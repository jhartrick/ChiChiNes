{"version":3,"sources":["webpack:///webpack/bootstrap 5d302073f61e63d7ae2c","webpack:///./workers/emulator.webworker.ts","webpack:///./src/app/emu/bridge.js","webpack:///(webpack)/buildin/global.js","webpack:///./src/app/emu","webpack:///./src/app/emu/ChiChiCore.js","webpack:///(webpack)/buildin/system.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;;;AC7DA,uBAAoC;AACpC,uBAAwC;AAExC,SAAS,GAAG,UAAC,KAAkB;IAC3B,UAAU,CAAC;QACP,IAAI,CAAC,GAAG,IAAI,KAAK,EAAE,CAAC;QACpB,WAAW,CAAC,aAAa,CAAC,CAAC;IAC/B,CAAC,EAAE,IAAI,CAAC,CAAC;AACZ,CAAC;AAED;IACG,6BAA6B;IAC7B,yCAAyC;IACzC,iCAAiC;IAGjC;QACI,0DAA0D;QAC1D,kDAAkD;QAClD,4BAA4B;QAE5B,+DAA+D;QAC/D,yDAAyD;QACzD,sCAAsC;QACtC,6JAA6J;QAC7J,oCAAoC;QACpC,8CAA8C;QAC9C,iCAAiC;IACrC,CAAC;IACL,YAAC;AAAD,CAAC;AAnBa,sBAAK;;;;;;;gFCVnB;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,8BAA8B,EAAE;;AAEhC;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,+BAA+B,cAAc;AAC7C;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA,SAAS;;AAET;AACA,wCAAwC;AACxC;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,+BAA+B,cAAc;AAC7C;AACA;;AAEA;AACA;;AAEA,yBAAyB;AACzB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA,SAAS;;AAET;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,2BAA2B,wBAAwB;AACnD;AACA;AACA,qCAAqC;AACrC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;;AAEA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,sCAAsC;AACtC;;AAEA,6DAA6D,OAAO;AACpE;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB,oBAAoB;AAC3C;AACA;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,+BAA+B,cAAc;AAC7C;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,2BAA2B,kBAAkB;AAC7C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;;AAEA;AACA,SAAS;;AAET;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;;AAEA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;;AAEA,uBAAuB,kBAAkB;AACzC;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,2BAA2B,iBAAiB;AAC5C;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,gEAAgE,QAAQ;AACxE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,yBAAyB;AACzB;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,yBAAyB;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,6BAA6B;AAC7B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA,qDAAqD,SAAS;AAC9D;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA,mBAAmB,cAAc;AACjC;AACA;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA,SAAS;;AAET;AACA;;AAEA;AACA,SAAS;;AAET;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;;AAEA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA,mCAAmC,uBAAuB;AAC1D;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;;AAEA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA,yBAAyB;AACzB;;AAEA;AACA;AACA,6BAA6B;AAC7B;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;;AAEA;AACA,qBAAqB;AACrB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA,iBAAiB;;AAEjB;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,+BAA+B,qBAAqB;AACpD;AACA;AACA;;AAEA;AACA;;AAEA;AACA,sD;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,2BAA2B,kBAAkB;AAC7C;;AAEA,8CAA8C,QAAQ;AACtD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,uCAAuC,gBAAgB;AACvD;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;;AAEA;AACA,+BAA+B,gBAAgB;AAC/C;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uCAAuC,wBAAwB;AAC/D;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,+BAA+B,yBAAyB;AACxD;AACA;AACA,4DAA4D,QAAQ;AACpE;AACA;AACA;AACA;AACA;;AAEA;AACA,uCAAuC,gBAAgB;AACvD;;AAEA;AACA;AACA,8CAA8C,uCAAuC;AACrF,6BAA6B;AAC7B;;AAEA;AACA;AACA;;AAEA;AACA,8CAA8C,yBAAyB;AACvE;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA,2BAA2B;AAC3B;AACA;AACA;;AAEA,+BAA+B,iBAAiB;AAChD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,+BAA+B;AAC/B;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb,0BAA0B;AAC1B;;AAEA;;AAEA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,6FAA6F,qBAAqB;;AAElH;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mCAAmC,mBAAmB;AACtD;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qCAAqC,+BAA+B;AACpE;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,2BAA2B,sBAAsB;AACjD;AACA;;AAEA;;AAEA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,4CAA4C;AAC5C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA,uBAAuB,iBAAiB;AACxC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,+CAA+C,0BAA0B;AACzE;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB;AACrB;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA,+BAA+B,mBAAmB;AAClD;AACA;AACA;AACA;;AAEA;AACA,uCAAuC,4BAA4B;AACnE;AACA;AACA;;AAEA;AACA,uCAAuC,wBAAwB;AAC/D;AACA;AACA;;AAEA;AACA,uCAAuC,kBAAkB;AACzD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA,wBAAwB;AACxB;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wDAAwD,QAAQ;AAChE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;;AAEA,2BAA2B,mBAAmB;AAC9C;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,mCAAmC,kCAAkC;AACrE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,2BAA2B,gBAAgB;AAC3C;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB,mBAAmB;AAC1C;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,mCAAmC,kBAAkB;AACrD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,6BAA6B;AACpD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iCAAiC;;AAEjC;AACA;AACA,iCAAiC;;AAEjC;;AAEA;AACA,6BAA6B;AAC7B,yBAAyB;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,yBAAyB;;AAEzB;AACA;AACA,yBAAyB;;AAEzB;;AAEA;AACA,qBAAqB;AACrB,iBAAiB;AACjB,aAAa;AACb;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;;AAET;AACA;;AAEA,2BAA2B,0BAA0B;AACrD;;AAEA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,SAAS;AAChC;;AAEA;AACA;;AAEA,+BAA+B,qBAAqB;AACpD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,2BAA2B,kBAAkB;AAC7C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,SAAS;AACT,2CAA2C;AAC3C;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,+BAA+B,uBAAuB;AACtD;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,uCAAuC,mBAAmB;AAC1D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,iBAAiB;AAC5C;AACA;;AAEA;AACA,SAAS;;AAET;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kFAAkF,oCAAoC,EAAE;AACxH;AACA;;AAEA;AACA;;AAEA;AACA;AACA,0CAA0C,GAAG;AAC7C;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;;AAEA,wCAAwC,GAAG;;AAE3C;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA,+DAA+D,kCAAkC;AACjG;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;;AAEA,2BAA2B,cAAc;AACzC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;;AAEA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,2BAA2B,uBAAuB;AAClD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA,sBAAsB,EAAE;AACxB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,8BAA8B,EAAE;AAChC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mCAAmC,kBAAkB;AACrD;;AAEA;AACA;;AAEA,2CAA2C,mBAAmB;AAC9D;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,+BAA+B,cAAc;AAC7C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,2BAA2B,uBAAuB;AAClD;;AAEA;AACA;AACA;;AAEA;AACA,2DAA2D,QAAQ;AACnE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,2CAA2C,mBAAmB;AAC9D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,+BAA+B,sBAAsB;AACrD;;AAEA;;AAEA,mCAAmC,OAAO;AAC1C;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mCAAmC,mBAAmB;AACtD;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;;AAEA;AACA,sCAAsC,sCAAsC;AAC5E,aAAa;AACb,uCAAuC,mCAAmC;AAC1E,aAAa;AACb;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;;AAEA,0CAA0C,gIAAgI;AAC1K;;AAEA;AACA;;AAEA,0CAA0C,8EAA8E;AACxH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,+BAA+B,gCAAgC;AAC/D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wFAAwF,iDAAiD,EAAE;AAC3I;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,4EAA4E,4CAA4C,EAAE;AAC1H;;AAEA;AACA;;AAEA;AACA,mCAAmC,kBAAkB;AACrD;;AAEA;AACA,sFAAsF,4CAA4C,EAAE;AACpI;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA,kDAAkD,QAAQ;AAC1D;AACA;;AAEA,uCAAuC,kBAAkB;AACzD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,2EAA2E,4CAA4C,EAAE;AACzH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,+BAA+B,kBAAkB;AACjD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;;AAEA,2BAA2B,kBAAkB;AAC7C,4BAA4B,0CAA0C;AACtE;;AAEA;AACA;AACA,aAAa;AACb,SAAS;;AAET;AACA;;AAEA;AACA;AACA;;AAEA,2BAA2B,kBAAkB;AAC7C;AACA;;AAEA;AACA;AACA,aAAa;AACb,SAAS;;AAET;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb,SAAS;;AAET;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,2BAA2B,kBAAkB;AAC7C;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,2BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA,2BAA2B,sBAAsB;AACjD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;;AAEA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,sCAAsC,WAAW;;AAEjD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA,0CAA0C,WAAW;AACrD;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,wB;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,a;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,+DAA+D,gDAAgD,EAAE;AACjH;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;;AAEA,2BAA2B,WAAW;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wB;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,WAAW;AAC1C;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;;AAEA,2BAA2B,kBAAkB;AAC7C;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;;AAEjB;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA,2BAA2B,kBAAkB;AAC7C;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,SAAS;;AAET;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,qCAAqC;AACrC;AACA,qCAAqC;AACrC;AACA,qCAAqC;AACrC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;;AAEA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;;AAEA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA,wCAAwC;;AAExC;AACA;AACA;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB;AACA;;AAEA,2DAA2D,+BAA+B,EAAE;;AAE5F;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,yBAAyB;AACzB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iBAAiB;AACjB;;AAEA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA,2BAA2B,mBAAmB;AAC9C;;AAEA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB;AACA;;AAEA,8DAA8D,+BAA+B,EAAE;;AAE/F;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,2BAA2B,mBAAmB;AAC9C;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;;AAEA;AACA;AACA,yBAAyB;AACzB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,iCAAiC;AACjC;AACA;;AAEA;AACA,6BAA6B;AAC7B;AACA;;AAEA;;AAEA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA,sDAAsD,YAAY;AAClE;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;;AAEb;AACA,2BAA2B;;AAE3B;;AAEA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mCAAmC,cAAc;AACjD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;;AAEA,+BAA+B,cAAc;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;;AAEA;AACA;AACA,yBAAyB,kBAAkB,mBAAmB,sBAAsB,gBAAgB,oCAAoC,mBAAmB,UAAU,SAAS,UAAU,mDAAmD,oCAAoC,kBAAkB,OAAO,QAAQ,sDAAsD,8BAA8B,kBAAkB,WAAW;AACja,uDAAuD,SAAS,qBAAqB,uBAAuB,OAAO,uBAAuB,2BAA2B;AACrK;AACA,KAAK,sBAAsB,wBAAwB;AACnD,wDAAwD,yFAAyF,mDAAmD,aAAa,gDAAgD,OAAO,8DAA8D,mDAAmD,gBAAgB,uBAAuB,cAAc;AAC9a,sFAAsF;AACtF;AACA,SAAS,gBAAgB;AACzB,KAAK,gBAAgB,yHAAyH,oBAAoB,cAAc,mDAAmD,8CAA8C,EAAE,cAAc,WAAW,SAAS,eAAe,kBAAkB,gBAAgB,kBAAkB,kBAAkB,iBAAiB,uEAAuE,YAAY,kBAAkB,aAAa,cAAc,WAAW;AACtiB,aAAa,YAAY,eAAe,eAAe,+BAA+B,iBAAiB,uBAAuB,0BAA0B,+BAA+B,iBAAiB,iBAAiB,wBAAwB,oDAAoD,2BAA2B,wHAAwH;AACxb,oBAAoB,gDAAgD,+BAA+B;AACnG;AACA;AACA,8DAA8D;AAC9D,aAAa;AACb,SAAS,0DAA0D,EAAE,GAAG,0EAA0E,8BAA8B,OAAO,cAAc,cAAc;AACnN,MAAM,8BAA8B,oBAAoB,sCAAsC,0BAA0B,6BAA6B,mBAAmB;AACxK;AACA;AACA,MAAM,gCAAgC,4EAA4E,4DAA4D,6BAA6B,MAAM,0CAA0C,yBAAyB,4CAA4C,6BAA6B,0CAA0C,6BAA6B,0CAA0C,wBAAwB,+BAA+B,yBAAyB,+BAA+B;AAC7jB,2BAA2B;AAC3B;AACA,MAAM,iBAAiB,6BAA6B,sBAAsB,qBAAqB,4BAA4B,2BAA2B,mBAAmB,mCAAmC,4BAA4B,2BAA2B,+BAA+B,2BAA2B,sBAAsB,sCAAsC,4BAA4B,8BAA8B;AACnb,2BAA2B;AAC3B,sDAAsD;AACtD,MAAM,oBAAoB,yBAAyB,+DAA+D,kBAAkB;AACpI,2BAA2B,kIAAkI,gDAAgD,oBAAoB,YAAY,oBAAoB,YAAY;AAC7Q,uBAAuB,yBAAyB;AAChD,MAAM,4BAA4B,oBAAoB,4BAA4B,oBAAoB;AACtG,oCAAoC,oBAAoB,0BAA0B,0CAA0C,0CAA0C,kGAAkG,oDAAoD;AAC5T,qCAAqC,qJAAqJ,mBAAmB,gBAAgB,eAAe,oBAAoB,YAAY,oBAAoB,yBAAyB,eAAe,YAAY,YAAY,oBAAoB,yBAAyB,eAAe,YAAY,YAAY,eAAe,YAAY,iDAAiD;AAChgB,MAAM,oBAAoB;AAC1B,2BAA2B,iDAAiD;AAC5E,sBAAsB,aAAa,uDAAuD,OAAO,kBAAkB,kCAAkC,uBAAuB,+BAA+B,4CAA4C,wBAAwB,6BAA6B,2CAA2C,kGAAkG,qDAAqD,qBAAqB,0BAA0B,kCAAkC,QAAQ;AACvkB,kBAAkB,eAAe,WAAW,GAAG,0DAA0D,yGAAyG,4BAA4B,gDAAgD,uBAAuB,cAAc,eAAe;AAClV,MAAM,kBAAkB,0BAA0B,oBAAoB,uCAAuC,kBAAkB,sBAAsB,kDAAkD;AACvM,2BAA2B;AAC3B;AACA,MAAM,sBAAsB,oBAAoB,iEAAiE,uBAAuB,oBAAoB,iEAAiE,6BAA6B,yBAAyB,4JAA4J,qBAAqB;AACpc,gCAAgC;AAChC;AACA,MAAM,sBAAsB,sCAAsC,yBAAyB,SAAS,0BAA0B,mBAAmB,mJAAmJ,+BAA+B,2BAA2B,4DAA4D,6BAA6B;AACvb,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,2CAA2C,SAAS;AACpD;AACA;;AAEA;AACA;AACA,cAAc,qBAAqB;AACnC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,2CAA2C,SAAS;AACpD;AACA;;AAEA;AACA;AACA,cAAc,qBAAqB;AACnC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,2CAA2C,SAAS;AACpD;AACA;;AAEA;AACA;AACA,cAAc,qBAAqB;AACnC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,2CAA2C,SAAS;AACpD;AACA;;AAEA;AACA;AACA,cAAc,qBAAqB;AACnC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,mBAAmB,cAAc,gBAAgB,iDAAiD,aAAa,oBAAoB,OAAO,iEAAiE,4DAA4D,8BAA8B,OAAO,cAAc,UAAU,eAAe,sBAAsB,uDAAuD,yBAAyB,gBAAgB,eAAe,SAAS,aAAa,yrBAAyrB,sBAAsB,6CAA6C,OAAO,GAAG,mBAAmB,KAAK,YAAY,+CAA+C,cAAc,oGAAoG,qBAAqB,mBAAmB,0BAA0B,qKAAqK,gBAAgB,KAAK,GAAG,oBAAoB,2CAA2C,6BAA6B,yBAAyB,kDAAkD,oBAAoB,2BAA2B,sBAAsB,SAAS,cAAc,wFAAwF,8DAA8D,iBAAiB,OAAO,UAAU,YAAY,4CAA4C,OAAO,0BAA0B,SAAS,cAAc,0EAA0E,mZAAmZ,wJAAwJ,EAAE,GAAG,cAAc,sBAAsB,SAAS,cAAc,2BAA2B,SAAS,cAAc,6CAA6C,QAAQ,kCAAkC,oBAAoB,mBAAmB,cAAc,WAAW,kGAAkG,sBAAsB,gCAAgC,0CAA0C,kcAAkc,mBAAmB,0BAA0B,SAAS,cAAc,wBAAwB,sBAAsB,8DAA8D,gCAAgC,sBAAsB,6BAA6B,gCAAgC,gBAAgB,sCAAsC,gBAAgB,OAAO,aAAa,cAAc,eAAe,SAAS,eAAe,WAAW,gBAAgB,iBAAiB,KAAK,WAAW,WAAW,yBAAyB,gDAAgD,cAAc,EAAE,GAAG,gFAAgF,mDAAmD,QAAQ,4BAA4B,oBAAoB,gBAAgB,iCAAiC,sBAAsB,oCAAoC,gBAAgB,GAAG,6BAA6B,OAAO,QAAQ,qBAAqB,WAAW,mBAAmB,kGAAkG,qHAAqH,+DAA+D,UAAU,yBAAyB,oGAAoG,EAAE,GAAG,wHAAwH,YAAY,KAAK,0BAA0B,0CAA0C,+EAA+E,0DAA0D,QAAQ,EAAE,mBAAmB,wHAAwH,kIAAkI,2QAA2Q,OAAO,8CAA8C,mDAAmD,wKAAwK,EAAE,GAAG,6GAA6G,4IAA4I,oEAAoE,wGAAwG,gBAAgB,EAAE,gBAAgB,+BAA+B,mBAAmB,aAAa,yLAAyL,yBAAyB,MAAM,mBAAmB,6BAA6B,MAAM,yBAAyB,0FAA0F,6CAA6C,OAAO,iCAAiC,oCAAoC,aAAa,OAAO,KAAK,WAAW,8HAA8H,yBAAyB,WAAW,mBAAmB,+BAA+B,yFAAyF,6CAA6C,4BAA4B,OAAO,sCAAsC,QAAQ,mRAAmR,YAAY,cAAc,kLAAkL,mBAAmB,uBAAuB,iCAAiC,kGAAkG,yDAAyD,KAAK,oEAAoE,WAAW,4BAA4B,+DAA+D,6CAA6C,EAAE,GAAG,gKAAgK,YAAY,0BAA0B,EAAE,qBAAqB,kCAAkC,wCAAwC,mBAAmB,+DAA+D,qDAAqD,mDAAmD,OAAO,oFAAoF,oCAAoC,0BAA0B,yBAAyB,oEAAoE,uHAAuH,8PAA8P,aAAa,UAAU,YAAY,uVAAuV,kBAAkB,qCAAqC,mBAAmB,WAAW,MAAM,oBAAoB,OAAO,2BAA2B,SAAS,oCAAoC,+BAA+B,OAAO,eAAe,mCAAmC,WAAW,MAAM,sBAAsB,OAAO,4BAA4B,yCAAyC,mCAAmC,kBAAkB,OAAO,KAAK,cAAc,eAAe,+BAA+B,KAAK,WAAW,uDAAuD,2BAA2B,gEAAgE,eAAe,+BAA+B,mBAAmB,oDAAoD,gBAAgB,2BAA2B,gBAAgB,4BAA4B,gBAAgB,6BAA6B,mBAAmB,6BAA6B,gBAAgB,4BAA4B,gBAAgB,6BAA6B,gBAAgB,4BAA4B,gBAAgB,6BAA6B,mBAAmB,kCAAkC,yDAAyD,qdAAqd,gBAAgB,4BAA4B,gBAAgB,wCAAwC,gBAAgB,qEAAqE,+IAA+I,YAAY,cAAc,4CAA4C,sFAAsF,cAAc,wCAAwC,gFAAgF,SAAS,gHAAgH,eAAe,oBAAoB,cAAc,gBAAgB,2BAA2B,gBAAgB,4BAA4B,gBAAgB,gBAAgB,uBAAuB,wCAAwC,4GAA4G,oCAAoC,yEAAyE,kEAAkE,mBAAmB,SAAS,cAAc,mCAAmC,6FAA6F,yCAAyC,uGAAuG,aAAa,6sBAA6sB,4GAA4G,cAAc,mDAAmD,wBAAwB,mBAAmB,4BAA4B,gBAAgB,2BAA2B,gBAAgB,wCAAwC,eAAe,2BAA2B,qBAAqB,sBAAsB,yEAAyE,OAAO,0CAA0C,QAAQ,2BAA2B,gBAAgB,0BAA0B,mBAAmB,4BAA4B,gBAAgB,4BAA4B,gBAAgB,6BAA6B,eAAe,kCAAkC,eAAe,kCAAkC,mBAAmB,4BAA4B,mBAAmB,4BAA4B,mBAAmB,4BAA4B,iBAAiB,gDAAgD,2KAA2K,OAAO,iGAAiG,OAAO,0CAA0C,sCAAsC,OAAO,sJAAsJ,YAAY,YAAY,OAAO,mCAAmC,mFAAmF,YAAY,cAAc,2BAA2B,OAAO,aAAa,YAAY,oBAAoB,sBAAsB,SAAS,cAAc,0BAA0B,6BAA6B,iBAAiB,oDAAoD,iBAAiB,oEAAoE,iBAAiB,2BAA2B,iBAAiB,4BAA4B,iBAAiB,4BAA4B,oBAAoB,4BAA4B,iBAAiB,2BAA2B,iBAAiB,4BAA4B,iBAAiB,wCAAwC,2lEAA2lE,qGAAqG,qdAAqd,0CAA0C,oCAAoC,oCAAoC,yBAAyB,sDAAsD,yCAAyC,uFAAuF,qFAAqF,qDAAqD,uBAAuB,oDAAoD,2DAA2D,OAAO,6DAA6D,8CAA8C,oCAAoC,uCAAuC,mPAAmP,uCAAuC,+DAA+D,kDAAkD,kaAAka,EAAE,wJAAwJ,oEAAoE,iGAAiG,QAAQ,yDAAyD,OAAO,QAAQ,gBAAgB,yCAAyC,0CAA0C,4BAA4B,SAAS,uEAAuE,aAAa,cAAc,mBAAmB,WAAW,wCAAwC,2CAA2C,sDAAsD,iCAAiC,8DAA8D,oCAAoC,2BAA2B,0BAA0B,sDAAsD,yCAAyC,yBAAyB,mDAAmD,qBAAqB,2BAA2B,+CAA+C,8DAA8D,oDAAoD,0BAA0B,qQAAqQ,kCAAkC,KAAK,4DAA4D,mDAAmD,6CAA6C,6CAA6C,kDAAkD,gJAAgJ,OAAO,sGAAsG,yDAAyD,KAAK,oEAAoE,yDAAyD,gDAAgD,uCAAuC,6LAA6L,4CAA4C,yFAAyF,sPAAsP,uDAAuD,uCAAuC,qRAAqR,qDAAqD,uCAAuC,iQAAiQ,wDAAwD,6CAA6C,0XAA0X,0CAA0C,6CAA6C,yTAAyT,6CAA6C,6FAA6F,oBAAoB,iCAAiC,uFAAuF,OAAO,6BAA6B,qEAAqE,wFAAwF,GAAG,mDAAmD,iFAAiF,UAAU,2HAA2H,0BAA0B,EAAE,4FAA4F,6BAA6B,kBAAkB,yCAAyC,yDAAyD,0BAA0B,iBAAiB,0CAA0C,oBAAoB,0CAA0C,oBAAoB,2BAA2B,qCAAqC,sCAAsC,yBAAyB,gDAAgD,yBAAyB,wCAAwC,iGAAiG,sCAAsC,OAAO,iFAAiF,eAAe,oHAAoH,iCAAiC,OAAO,eAAe,cAAc,UAAU,cAAc,kMAAkM,kEAAkE,QAAQ,4BAA4B,6BAA6B,oCAAoC,qEAAqE,oIAAoI,8CAA8C,yEAAyE,sBAAsB,OAAO,2CAA2C,eAAe,6BAA6B,oEAAoE,8KAA8K,KAAK,YAAY,cAAc,OAAO,iEAAiE,OAAO,yBAAyB,iBAAiB,QAAQ,QAAQ,6EAA6E,OAAO,iBAAiB,mBAAmB,OAAO,GAAG,qBAAqB,YAAY,mBAAmB,gBAAgB,qBAAqB,eAAe,OAAO,cAAc,UAAU,OAAO,YAAY,eAAe,wFAAwF,qCAAqC,oCAAoC,8QAA8Q,gDAAgD,iBAAiB,6CAA6C,iBAAiB,qCAAqC,oCAAoC,0BAA0B,mCAAmC,+DAA+D,0HAA0H,+CAA+C,2HAA2H,oEAAoE,2KAA2K,KAAK,YAAY,cAAc,mFAAmF,GAAG,sDAAsD,6CAA6C,aAAa,UAAU,qDAAqD,uCAAuC,iBAAiB,0EAA0E,4EAA4E,0BAA0B,iCAAiC,0CAA0C,kCAAkC,uCAAuC,oPAAoP,yCAAyC,8EAA8E,6FAA6F,qUAAqU,EAAE,yGAAyG,oEAAoE,wFAAwF,QAAQ,gDAAgD,OAAO,QAAQ,gBAAgB,yCAAyC,qCAAqC,uCAAuC,oSAAoS,oCAAoC,2FAA2F,0IAA0I,iJAAiJ,KAAK,YAAY,YAAY,UAAU,GAAG,uBAAuB,OAAO,0EAA0E,6BAA6B,OAAO,SAAS,UAAU,wCAAwC,SAAS,UAAU,wEAAwE,iCAAiC,0BAA0B,kDAAkD,iCAAiC,0HAA0H,sCAAsC,oCAAoC,yLAAyL,gCAAgC,uCAAuC,iMAAiM,gCAAgC,8EAA8E,yBAAyB,+JAA+J,OAAO,8DAA8D,kCAAkC,qFAAqF,+DAA+D,4FAA4F,kOAAkO,iDAAiD,2BAA2B,kCAAkC,iCAAiC,+BAA+B,oBAAoB,+BAA+B,OAAO,wEAAwE,yCAAyC,mIAAmI,6BAA6B,eAAe,gCAAgC,0BAA0B,sCAAsC,2EAA2E,gEAAgE,qCAAqC,iEAAiE,oEAAoE,mGAAmG,mCAAmC,8hBAA8hB,oCAAoC,oCAAoC,gPAAgP,sDAAsD,iCAAiC,yIAAyI,6BAA6B,mFAAmF,gDAAgD,yCAAyC,sDAAsD,wCAAwC,mFAAmF,kCAAkC,uBAAuB,sBAAsB,4BAA4B,qBAAqB,KAAK,oDAAoD,8BAA8B,yBAAyB,UAAU,gCAAgC,qBAAqB,OAAO,yBAAyB,0BAA0B,QAAQ,WAAW,yBAAyB,gBAAgB,KAAK,iEAAiE,OAAO,uBAAuB,aAAa,qCAAqC,8HAA8H,sIAAsI,kJAAkJ,sBAAsB,MAAM,8IAA8I,OAAO,wCAAwC,2BAA2B,qBAAqB,+DAA+D,iBAAiB,OAAO,4IAA4I,OAAO,aAAa,6DAA6D,mhBAAmhB,6CAA6C,sBAAsB,oBAAoB,6BAA6B,OAAO,sBAAsB,SAAS,cAAc,uDAAuD,WAAW,EAAE,GAAG,4HAAqI,YAAY;AAAA,gWAA6P,4BAA4B,uBAAuB;;AAEtyuC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,uBAAuB,yBAAyB;AAChD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,+CAA+C,SAAS;AACxD;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,+CAA+C,SAAS;AACxD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,SAAS;AAC3B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,uDAAuD,WAAW;AAClE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,2BAA2B,cAAc;AACzC;AACA;AACA;AACA;AACA,a;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,2BAA2B,cAAc;AACzC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,4BAA4B,gBAAgB;;AAE5C;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA,+BAA+B,+HAA+H,EAAE;AAChK;AACA;AACA;AACA,SAAS;AACT;AACA,mCAAmC,aAAa;AAChD,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;;AAEA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA;;AAEA,mCAAmC,wCAAwC,OAAO;;AAElF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,0CAA0C,mDAAmD,OAAO;;AAEpG;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;;AAEA,sDAAsD,IAAI,GAAG,IAAI,mCAAmC,IAAI,GAAG,IAAI,KAAK,IAAI;AACxH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;;AAEA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,iCAAiC;AACjC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,sCAAsC,gCAAgC;AACtE;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,iCAAiC;AACjC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA,qBAAqB;AACrB;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,2BAA2B,mBAAmB;AAC9C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,6BAA6B;AAC7B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;;AAEA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,iCAAiC;AACjC;AACA;AACA;;AAEA,uCAAuC,kBAAkB;AACzD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,yBAAyB;AACzB;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,yBAAyB;AACzB;;AAEA,uCAAuC,kBAAkB;AACzD;;AAEA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB;AACzB;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,yBAAyB;AACzB;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,yBAAyB;AACzB;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,yBAAyB;AACzB;;AAEA;AACA;AACA;;AAEA;AACA,yBAAyB;AACzB;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,yBAAyB;AACzB;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,yBAAyB,yBAAyB,IAAI;AACtD;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,yBAAyB,yBAAyB,IAAI;AACtD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,6BAA6B;AAC7B;AACA,6BAA6B;AAC7B;;AAEA;AACA;;AAEA;AACA,yBAAyB;AACzB;AACA;AACA,6BAA6B;AAC7B;AACA,6BAA6B;AAC7B;;AAEA;AACA;;AAEA;AACA,yBAAyB;AACzB;;AAEA;AACA;AACA,6BAA6B;AAC7B;AACA,6BAA6B;AAC7B;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,yBAAyB;AACzB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,6BAA6B;AAC7B;AACA,6BAA6B;AAC7B;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,yBAAyB;AACzB;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,yBAAyB;AACzB;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;;AAEA,6BAA6B,UAAU;AACvC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,aAAa;;AAEb;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;;AAEA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;;AAEA;;AAEA;AACA,aAAa;;AAEb;AACA;;AAEA;;AAEA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yFAAyF,IAAI;AAC7F;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,gFAAgF;;AAEhF;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA,kBAAkB,6BAA6B;AAC/C;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA,kBAAkB,6BAA6B;AAC/C;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA,a;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,2BAA2B,mBAAmB;AAC9C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;;AAEA,2BAA2B,gBAAgB;AAC3C;AACA;AACA;AACA;;AAEA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,2BAA2B,sBAAsB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,2BAA2B,YAAY;AACvC;AACA;;AAEA;AACA,2BAA2B,gBAAgB;AAC3C;AACA;;AAEA,+CAA+C,QAAQ;AACvD;AACA;AACA;AACA;;AAEA;;AAEA,iCAAiC,sBAAsB;AACvD;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,2BAA2B,YAAY;AACvC;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;;AAEA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;;AAEA;;AAEA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb,+BAA+B,SAAS;AACxC;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oCAAoC,cAAc;AAClD;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;;AAEA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;;AAEA;AACA,SAAS;;AAET;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;;AAEA;AACA,SAAS;;AAET;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA,SAAS;;AAET;AACA;;AAEA;;AAEA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;;AAEA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA,iCAAiC,aAAa;AAC9C;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;;AAEA;;AAEA,mCAAmC,uBAAuB;AAC1D;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA,2BAA2B,SAAS;AACpC;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;;AAEA,2BAA2B,SAAS;AACpC;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,2BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,2BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,oCAAoC,cAAc;AAClD;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,0CAA0C,QAAQ;AAClD;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,oCAAoC,cAAc;AAClD;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,2BAA2B,kBAAkB;AAC7C;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,oCAAoC,eAAe;AACnD;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,2BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,2BAA2B,sBAAsB;AACjD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,+CAA+C,gBAAgB;AAC/D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,a;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET,+BAA+B,aAAa;AAC5C,KAAK;;AAEL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;;AAET;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA,mCAAmC,kBAAkB;AACrD;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;;AAEA,mCAAmC,sBAAsB;AACzD;AACA;;AAEA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,+BAA+B,oBAAoB;AACnD;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;AACA;;AAEA,mCAAmC,oBAAoB;AACvD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,2BAA2B,oBAAoB;AAC/C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB,aAAa;;AAEb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA,2BAA2B,uBAAuB;AAClD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA,gFAAgF;AAChF;AACA;AACA;AACA;AACA,8CAA8C,gEAAgE;AAC9G;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA,kCAAkC,EAAE;AACpC;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,EAAE;;AAER;;AAEA,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,6FAA6F;AAC7F;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,mCAAmC,gBAAgB;AACnD;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,oCAAoC,iBAAiB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA,+BAA+B,gBAAgB;AAC/C;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA,+BAA+B,gBAAgB;AAC/C;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA,+BAA+B,gBAAgB;AAC/C;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wCAAwC,cAAc;AACtD;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA,kDAAkD,QAAQ;AAC1D;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,wCAAwC,cAAc;AACtD;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;;AAEA,+BAA+B,gBAAgB;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,uCAAuC;AACvC;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uCAAuC;AACvC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA,kCAAkC;;AAElC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA,+BAA+B,gBAAgB;AAC/C;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM,EAAE;;AAER;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA,2BAA2B,uBAAuB;AAClD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,uFAAuF;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mCAAmC,WAAW;AAC9C;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,MAAM,EAAE;;AAER;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA,a;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,a;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,2BAA2B,YAAY;AACvC;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;;AAEA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,oCAAoC,eAAe;AACnD;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA,gCAAgC,0EAA0E,SAAS,MAAM,MAAM;AAC/H;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa;AACb,SAAS;;AAET;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,2BAA2B,kBAAkB;AAC7C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,oCAAoC,yBAAyB;AAC7D;AACA;;AAEA;AACA,SAAS;;AAET;AACA,2CAA2C,EAAE;AAC7C,SAAS;;AAET;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;;AAEA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA,2BAA2B,iBAAiB;AAC5C;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,+BAA+B,WAAW;AAC1C;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;;AAEjB;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,iBAAiB;;AAEjB;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,2BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,iCAAiC;AACjC;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,2BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA,iBAAiB;;AAEjB;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb,SAAS;;AAET;AACA;;AAEA;AACA,+BAA+B,yBAAyB;AACxD;AACA;;AAEA;AACA,aAAa;AACb,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET,+BAA+B;;AAE/B;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,2BAA2B,cAAc;AACzC;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,+BAA+B,uBAAuB;AACtD;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;;AAEA;;AAEA,+BAA+B,sBAAsB;AACrD;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA,SAAS;;AAET;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA,wEAAwE,EAAE,sBAAsB,IAAI,WAAW,IAAI;;AAEnH;AACA,SAAS;;AAET;AACA,6EAA6E,IAAI,EAAE,EAAE,YAAY,IAAI,EAAE,EAAE,mCAAmC,IAAI,EAAE,EAAE,gDAAgD,IAAI,oBAAoB,EAAE,oLAAoL,GAAG,aAAa,IAAI;AACta;AACA,SAAS;;AAET;AACA;;AAEA;AACA,SAAS;;AAET;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA2B,EAAE,QAAQ,EAAE,QAAQ,EAAE,QAAQ,EAAE;AAC3D,aAAa;AACb;AACA,gCAAgC,EAAE,QAAQ,EAAE,QAAQ,EAAE,QAAQ,EAAE;AAChE,aAAa;AACb;AACA,mCAAmC,EAAE,QAAQ,EAAE,QAAQ,EAAE;AACzD,aAAa;AACb;AACA,gCAAgC,GAAG;AACnC,aAAa;AACb;AACA,mCAAmC,GAAG,WAAW,GAAG;AACpD,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,8CAA8C,mBAAmB;AACjE;AACA;;AAEA;AACA,4CAA4C,kBAAkB;AAC9D;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,+BAA+B,qGAAqG,EAAE;AACtI;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,iCAAiC,EAAE,WAAW,EAAE,WAAW,EAAE,cAAc;;AAE3E;AACA;;AAEA;AACA;;AAEA,2HAA2H,+BAA+B,GAAG;AAC7J;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,yBAAyB;AACzB;AACA;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA,8CAA8C,2CAA2C;AACzF;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,8CAA8C,wBAAwB,EAAE;AACxE,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;;AAEA;AACA,uCAAuC;;AAEvC;AACA;;AAEA;AACA;AACA,qBAAqB;AACrB;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;;AAEA;AACA;;AAEA,2BAA2B,yBAAyB;AACpD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oCAAoC,gBAAgB;AACpD;;AAEA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;;AAEA,oCAAoC,gBAAgB;AACpD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;;AAEA;AACA,iCAAiC;AACjC;AACA;;AAEA,2BAA2B,2BAA2B;AACtD;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA,mCAAmC;;AAEnC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mCAAmC;;AAEnC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iDAAiD;;AAEjD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB;AACzB;AACA;AACA;;AAEA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB;AACzB;;AAEA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,iDAAiD;;AAEjD,wDAAwD;;AAExD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,uCAAuC;AACvC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,4BAA4B,gBAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;;AAEA;AACA;AACA;AACA,sDAAsD;AACtD,sDAAsD;AACtD;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;;AAEb;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,2BAA2B,kBAAkB;AAC7C;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;;AAEA,2BAA2B,kBAAkB;AAC7C;;AAEA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oCAAoC;AACpC;;AAEA;;AAEA;AACA,mCAAmC,iBAAiB;AACpD;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,mCAAmC,qBAAqB;AACxD;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA,SAAS;;AAET;AACA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;;AAEA,mCAAmC,WAAW;AAC9C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,aAAa;AACb;AACA;;AAEA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;;AAEA,uCAAuC,wBAAwB;AAC/D;AACA;;AAEA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,iBAAiB;;AAEjB;;AAEA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;;AAEA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gCAAgC,UAAU,EAAE;AAC5C,2BAA2B,aAAa,EAAE;AAC1C,4BAA4B;AAC5B;;AAEA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,sCAAsC;AACtC;;AAEA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mCAAmC,gBAAgB;AACnD;AACA,uCAAuC,OAAO;AAC9C;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA,2BAA2B;AAC3B;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;;AAEA;AACA,kCAAkC,2CAA2C;;AAE7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;AACA,uCAAuC,gBAAgB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,0BAA0B;;AAE1B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,4DAA4D;AAC5D;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA,6BAA6B,cAAc,EAAE;AAC7C;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,0CAA0C,EAAE;AAC7E;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,kCAAkC,EAAE;AACzE;AACA;AACA;;AAEA;AACA,yBAAyB;AACzB;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,0BAA0B,EAAE;AACjE;AACA;AACA;;AAEA;AACA,yBAAyB;AACzB;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wCAAwC,yBAAyB;AACjE;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6BAA6B,oCAAoC,EAAE;AACnE;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,6BAA6B,sBAAsB,EAAE;AACrD;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,6BAA6B,sBAAsB,EAAE;AACrD;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,6BAA6B,sBAAsB,EAAE;AACrD;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA,6BAA6B,sBAAsB,EAAE;AACrD;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6BAA6B,kCAAkC,EAAE;AACjE;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,6BAA6B,yBAAyB,EAAE;AACxD,6BAA6B,kCAAkC,EAAE;AACjE;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6BAA6B,iCAAiC,EAAE;AAChE;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6BAA6B,sBAAsB,EAAE;AACrD,6BAA6B,wCAAwC,EAAE;AACvE;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6BAA6B,sBAAsB,EAAE;AACrD,6BAA6B,wCAAwC,EAAE;AACvE;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA,6BAA6B,mEAAmE,EAAE;AAClG;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB,SAAS;AACT;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B,qCAAqC,EAAE;AACpE;AACA;AACA;AACA;AACA;AACA;;AAEA,oFAAoF,gBAAgB,EAAE;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,6BAA6B,2BAA2B,EAAE;AAC1D,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,6BAA6B,qCAAqC,EAAE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,+EAA+E,aAAa,EAAE;AAC9F;AACA,iBAAiB;AACjB,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,6BAA6B,qCAAqC,EAAE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,6BAA6B,2BAA2B,EAAE;AAC1D,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B,qCAAqC,EAAE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB,6BAA6B,2BAA2B,EAAE;AAC1D,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iCAAiC,qCAAqC,EAAE;AACxE;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iCAAiC,2BAA2B,EAAE;AAC9D,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,UAAU;AAChF;;AAEA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B,qCAAqC,EAAE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iCAAiC,qCAAqC,EAAE;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iCAAiC,2BAA2B,EAAE;AAC9D,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,6BAA6B,qCAAqC,EAAE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,6BAA6B,2BAA2B,EAAE;AAC1D,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,KAAK;AACL,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,8CAA8C,2BAA2B;AACzE;AACA;AACA,iBAAiB;AACjB;AACA,sDAAsD,sBAAsB;AAC5E;AACA,kDAAkD,kBAAkB,EAAE;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,8CAA8C,2BAA2B;AACzE;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB,SAAS;AACT;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,iBAAiB;AACjB,6BAA6B,gCAAgC,EAAE;AAC/D,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,6BAA6B,2BAA2B,EAAE;AAC1D,SAAS;AACT;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,oEAAoE;;AAEpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,6BAA6B,0CAA0C,EAAE;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,kDAAkD,2BAA2B;AAC7E;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB,aAAa;AACb;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iHAAiH;AACjH;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wDAAwD;AACxD;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,6BAA6B,qCAAqC,EAAE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,6BAA6B,2BAA2B,EAAE;AAC1D,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,6BAA6B,2BAA2B,EAAE;AAC1D,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oEAAoE,8BAA8B,eAAe,EAAE,EAAE;AACrH,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,6BAA6B,2BAA2B,EAAE;AAC1D,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oEAAoE,8BAA8B,eAAe,EAAE,EAAE;AACrH;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,6BAA6B,2BAA2B,EAAE;AAC1D,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,SAAS;AACT;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,6BAA6B,2BAA2B,EAAE;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yDAAyD;;AAEzD;AACA,oCAAoC;AACpC,yBAAyB;AACzB;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,6BAA6B,2BAA2B,EAAE;AAC1D,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,iCAAiC;AACrF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iBAAiB;AACjB,6BAA6B,2BAA2B,EAAE;AAC1D,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,6BAA6B,qCAAqC,EAAE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,6BAA6B,2BAA2B,EAAE;AAC1D,SAAS;AACT;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;;AAET;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB,6BAA6B,2BAA2B,EAAE;AAC1D,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B,qCAAqC,EAAE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB,6BAA6B,2BAA2B,EAAE;AAC1D,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,6BAA6B,qCAAqC,EAAE;AACpE;AACA;AACA;AACA;AACA,iBAAiB;AACjB,6BAA6B,2BAA2B;AACxD;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,6BAA6B,qCAAqC,EAAE;AACpE;AACA;AACA;AACA;AACA,iBAAiB;AACjB,6BAA6B,2BAA2B,EAAE;AAC1D,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,0DAA0D;;AAE1D;AACA;;AAEA;AACA,6BAA6B,qCAAqC,EAAE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,6BAA6B,2BAA2B,EAAE;AAC1D,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B,2CAA2C,EAAE;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,6BAA6B,2BAA2B,EAAE;AAC1D,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,mCAAmC,eAAe,EAAE;AACpD;AACA;;AAEA;AACA;AACA,mCAAmC,eAAe,EAAE;AACpD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,6BAA6B,qCAAqC,EAAE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,6BAA6B,2BAA2B,EAAE;AAC1D,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB,6BAA6B,2BAA2B,EAAE;AAC1D,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,6BAA6B,qCAAqC,EAAE;AACpE;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,iBAAiB;AACjB,6BAA6B,2BAA2B,EAAE;AAC1D,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,6BAA6B,qCAAqC,EAAE;AACpE;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,iBAAiB;AACjB,SAAS;AACT;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA,8CAA8C,kCAAkC,EAAE;AAClF,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAuB,SAAS;AAChC;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,sCAAsC,eAAe;AACrD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,6BAA6B,iCAAiC,EAAE;AAChE;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,uCAAuC;AACvC;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kDAAkD,yCAAyC;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB,qCAAqC,EAAE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,yBAAyB,2BAA2B,EAAE;AACtD;;AAEA;AACA;AACA,uCAAuC;AACvC,qCAAqC;AACrC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iDAAiD,kCAAkC;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB,qCAAqC,EAAE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,yBAAyB,2BAA2B,EAAE;AACtD;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,2DAA2D;AAC3D,0CAA0C,mBAAmB,EAAE;AAC/D,KAAK,gEAAgE;AACrE;AACA,KAAK;AACL;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;AACA,+BAA+B,iGAAiG,EAAE;AAClI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,wEAAwE,EAAE;AAC1E,0FAA0F,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,GAAG;AAC7I,oFAAoF,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,GAAG;AAC/G,uFAAuF,aAAa,EAAE,aAAa,EAAE,aAAa,EAAE,aAAa,EAAE,aAAa,GAAG,IAAI;AACvK;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB,8CAA8C,0BAA0B;AACxE;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,uCAAuC,+BAA+B;AACtE;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,4CAA4C,iCAAiC;AAC7E;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB;;AAEA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA,+BAA+B,+BAA+B;AAC9D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,+BAA+B,QAAQ;AACvC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,mCAAmC,aAAa;AAChD;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA,iCAAiC;;AAEjC;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,qGAAqG,+BAA+B,GAAG;;AAEvI,2CAA2C,kBAAkB;AAC7D,4HAA4H,+BAA+B,GAAG;;AAE9J,+CAA+C,kBAAkB;AACjE;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA,6BAA6B;;AAE7B;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;;AAEA,2BAA2B,SAAS;AACpC;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,2BAA2B,SAAS;AACpC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uBAAuB,iBAAiB;AACxC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,iB;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uCAAuC,oBAAoB;AAC3D;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,wBAAwB;AACnD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uCAAuC,WAAW;AAClD;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,2BAA2B,uBAAuB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA,uBAAuB,cAAc;AACrC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,2BAA2B,kBAAkB;AAC7C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,SAAS;;AAET;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;;AAEL;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uCAAuC,WAAW;AAClD;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,aAAa;;AAEb;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,KAAK;;AAEL;;AAEA;AACA,mBAAmB;;AAEnB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,4BAA4B;AAC5B;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,2BAA2B;AAClD;;AAEA;AACA;AACA;AACA;AACA;;AAEA,2BAA2B,6BAA6B;AACxD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,2FAA2F;AAC3F;AACA;AACA;AACA,8FAA8F,MAAM;AACpG;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,kBAAkB;AACzC;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,qBAAqB;;AAErB;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qBAAqB;;AAErB;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA,+EAA+E;AAC/E;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA,sCAAsC;AACtC,8BAA8B;;AAE9B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA,+CAA+C,EAAE,MAAM;;AAEvD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA,wFAAwF;AACxF;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA,yEAAyE;AACzE;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA,sCAAsC;AACtC,8BAA8B;AAC9B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA,mBAAmB,6CAA6C;AAChE;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;;AAEA;AACA,kBAAkB,gEAAgE;AAClF;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,8BAA8B,2BAA2B;AACzD;;AAEA;AACA;AACA;;AAEA;AACA,+BAA+B,yBAAyB;AACxD;AACA;;AAEA,iGAAiG;AACjG;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,yBAAyB;;AAEzB;AACA;AACA;AACA,qBAAqB;AACrB;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,yBAAyB;;AAEzB;;AAEA;AACA;AACA;;AAEA;AACA,+CAA+C,QAAQ;AACvD;AACA;AACA;;AAEA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,+BAA+B;AAC/B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,uCAAuC,sBAAsB;AAC7D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB;AACrB;;AAEA,+BAA+B;AAC/B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,uCAAuC,sBAAsB;AAC7D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,yBAAyB;AAChD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qBAAqB;;AAErB;AACA;AACA;;AAEA;AACA,2CAA2C,QAAQ;AACnD;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA,uBAAuB,wBAAwB;AAC/C;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA,uCAAuC,QAAQ;AAC/C;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,2BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA;AACA;;AAEA;AACA,+BAA+B,sBAAsB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,2BAA2B,sBAAsB;AACjD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA,2BAA2B,uBAAuB;AAClD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iDAAiD;AACjD;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,8DAA8D;;AAE9D;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA,0DAA0D;;AAE1D;AACA;AACA;AACA;;AAEA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,2BAA2B,oBAAoB;AAC/C;AACA;AACA;AACA;AACA,aAAa;AACb,2BAA2B,oBAAoB;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,OAAO;AAC9B;AACA,2BAA2B,mBAAmB;AAC9C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA,2BAA2B,kBAAkB;AAC7C;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA,8BAA8B,2FAA2F;AACzH,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8CAA8C;;AAE9C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,SAAS;AAChC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uBAAuB,SAAS;AAChC;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,4CAA4C,mBAAmB;;AAE/D;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,mBAAmB;AAC9C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;;AAEA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;;AAEA;AACA,uDAAuD;AACvD;AACA;;AAEA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,2BAA2B,mBAAmB;AAC9C;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,2BAA2B,mBAAmB;AAC9C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC;AACrC;;AAEA,yCAAyC;AACzC;;AAEA;AACA,2BAA2B,mBAAmB;AAC9C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,qBAAqB;AACrB;;AAEA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA2B,OAAO;AAClC,+BAA+B,mBAAmB;AAClD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,mBAAmB;AAC9C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,8DAA8D;AAC9D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kEAAkE;AAClE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;;AAEA;AACA,2BAA2B,kCAAkC;AAC7D;AACA;AACA;AACA;;AAEA,8DAA8D;AAC9D;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA,iEAAiE;;AAEjE;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B,mBAAmB;AAClD;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,+EAA+E;AAC/E;AACA;AACA;;AAEA,+BAA+B,mBAAmB;AAClD;;AAEA;AACA;AACA,yBAAyB;AACzB;AACA,yBAAyB;AACzB;AACA,yBAAyB;AACzB;AACA,yBAAyB;AACzB;AACA,yBAAyB;AACzB;AACA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;;AAEA;AACA,2BAA2B,mBAAmB;AAC9C;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,2BAA2B,mBAAmB;AAC9C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,mBAAmB;AAC9C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA,2BAA2B,mBAAmB;AAC9C;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB;AACrB;AACA,qBAAqB;AACrB;AACA,qBAAqB;AACrB;AACA,qBAAqB;AACrB;AACA,qBAAqB;AACrB;AACA,qBAAqB;AACrB;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,wGAAwG;AACxG,6IAA6I;AAC7I,+CAA+C;AAC/C;AACA;;AAEA;AACA;AACA,0FAA0F;AAC1F;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0JAA0J;AAC1J,yDAAyD;AACzD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;;AAEA;AACA;AACA,aAAa;;AAEb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,gIAAgI;AAChI,sCAAsC;AACtC;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gGAAgG;AAChG,sCAAsC;AACtC;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qGAAqG;AACrG,0CAA0C;AAC1C;AACA;;AAEA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA,oGAAoG;AACpG,sCAAsC;AACtC;AACA;;AAEA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kCAAkC;AAClC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yFAAyF,GAAG;AAC5F,wFAAwF;AACxF,8EAA8E,EAAE;AAChF;;AAEA;;AAEA;AACA,4IAA4I,QAAQ,KAAK,SAAS,KAAK;AACvK;;AAEA;AACA,yIAAyI,QAAQ,KAAK,SAAS,KAAK;AACpK;;AAEA;AACA;;AAEA,6FAA6F;AAC7F;;AAEA;AACA;AACA,8FAA8F;AAC9F,kCAAkC;AAClC;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yCAAyC;AACzC,yCAAyC;AACzC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,2BAA2B,mBAAmB;AAC9C;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA,qCAAqC,aAAa;AAClD;AACA;;AAEA;AACA,+BAA+B,mBAAmB;AAClD;AACA;AACA;AACA;;AAEA,yCAAyC,aAAa;AACtD;;AAEA;AACA,2BAA2B,mBAAmB;AAC9C;;AAEA;AACA,mCAAmC,mBAAmB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB,mFAAmF;AACnF;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iCAAiC;AACjC,qBAAqB;AACrB;AACA,qBAAqB;AACrB;AACA,qBAAqB;AACrB;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mCAAmC,oBAAoB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,kCAAkC;AAClC,iBAAiB,mBAAmB;AACpC;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qFAAqF,IAAI;AACzF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oCAAoC;AACpC,yBAAyB;AACzB,oCAAoC;AACpC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;;AAEA,2BAA2B,mBAAmB;AAC9C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,4BAA4B;;AAE5B;AACA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,oCAAoC;AACpC;AACA,aAAa;AACb;AACA,oCAAoC;AACpC;AACA;AACA,aAAa;AACb;AACA,oCAAoC;AACpC;AACA;AACA,aAAa;AACb;AACA,6BAA6B;AAC7B;AACA,aAAa;AACb;AACA,6BAA6B;AAC7B;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;;AAEA,+BAA+B,gBAAgB;AAC/C;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,+BAA+B,cAAc;AAC7C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA,sBAAsB,qBAAqB;AAC3C;;AAEA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;;AAEjB;AACA;AACA;;AAEA;AACA;AACA;;AAEA,+BAA+B,cAAc;AAC7C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,0CAA0C;;AAE1C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;;AAEjB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;;AAEjB;AACA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,yBAAyB;AACzB;AACA;;AAEA;;AAEA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB,+BAA+B,gBAAgB;AAC/C;;AAEA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,qBAAqB;AACrB;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;;AAEA;AACA,+BAA+B,0BAA0B;AACzD;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;;AAEjB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;;AAEA,qEAAqE,UAAU,EAAE;AACjF;;AAEA,+HAA+H,yDAAyD;;AAExL;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,mCAAmC,gBAAgB;AACnD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,mCAAmC,cAAc;AACjD;AACA;AACA;AACA;;AAEA;AACA,kFAAkF,mBAAmB,6BAA6B,sBAAsB;AACxJ,aAAa;AACb;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA,2BAA2B,gBAAgB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,+BAA+B,SAAS;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA,mCAAmC,SAAS;AAC5C;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,+BAA+B,cAAc;AAC7C;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA,qBAAqB;AACrB;AACA,qBAAqB;AACrB;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,qBAAqB;AAC3C;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB;AACrB;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,yBAAyB;AACzB;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mCAAmC,eAAe;AAClD;AACA;;AAEA;;AAEA,iBAAiB;;AAEjB;AACA,aAAa;AACb;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA,gDAAgD,wBAAwB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kHAAkH;AAClH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,+EAA+E;AAC/E;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL,8DAA8D;AAC9D;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,MAAM,EAAE;;AAER;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,6CAA6C,EAAE;AAC/C;;AAEA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,mDAAmD;AACnD,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb,6CAA6C,EAAE;AAC/C;AACA;AACA,aAAa;AACb,gCAAgC,EAAE;AAClC,uCAAuC,EAAE;AACzC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,WAAW;AAC1C;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,qCAAqC,UAAU;AAC/C;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,qCAAqC,UAAU;AAC/C;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;;;AAGA;AACA;AACA;AACA,aAAa;AACb;;;AAGA;AACA;AACA;AACA,aAAa;AACb;;;AAGA;AACA;AACA;AACA,aAAa;AACb;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;;;AAGA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;;;AAGA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;;AAEA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;;;AAGA;AACA;AACA;AACA,aAAa;AACb;;AAEA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,aAAa;AACb;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,0BAA0B;AAC1B,yBAAyB;;AAEzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,8BAA8B;AAC9B;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;;AAGA;AACA;;AAEA;;;AAGA,iBAAiB,OAAO;;AAExB;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,aAAa;AACb;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,iBAAiB,OAAO;;AAExB;AACA;;AAEA;AACA,aAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,yDAAyD;AACzD;AACA;AACA,+GAA+G,EAAE,mBAAmB,EAAE;AACtI;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,gCAAgC,EAAE;AAClC;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,mCAAmC,yBAAyB;AAC5D;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb,gCAAgC,EAAE;AAClC;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA,wEAAwE;AACxE;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB,uCAAuC;AACvC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb,gCAAgC,EAAE;AAClC;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,qDAAqD,EAAE;AACvD,yCAAyC,EAAE;AAC3C;AACA;AACA,aAAa;AACb,0CAA0C;AAC1C;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yCAAyC;AACzC,qBAAqB;AACrB;AACA,sEAAsE;AACtE;AACA,iBAAiB;;AAEjB;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,6DAA6D;AAC7D,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,sDAAsD,EAAE;AACxD,wCAAwC,EAAE;AAC1C,oCAAoC,EAAE;AACtC,4CAA4C,EAAE;AAC9C,2CAA2C;AAC3C;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,QAAQ,mBAAmB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,OAAO;AACtC,oCAAoC,SAAS;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gFAAgF;AAChF;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,+BAA+B,mBAAmB;AAClD;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;;AAEA;;AAEA;AACA,iBAAiB;AACjB;AACA;;AAEA;;AAEA;;AAEA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;;AAEA;;AAEA;;AAEA;AACA,iBAAiB;AACjB;AACA;;AAEA;;AAEA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA,yFAAyF;AACzF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,+BAA+B,mBAAmB;AAClD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA,2CAA2C,YAAY;AACvD,gDAAgD,gBAAgB;AAChE;AACA;AACA;;AAEA;;AAEA;AACA,qDAAqD,QAAQ;AAC7D;AACA;AACA,qBAAqB;AACrB,wCAAwC,YAAY;AACpD;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA,2CAA2C,YAAY;AACvD,gDAAgD,gBAAgB;AAChE;AACA;AACA;;AAEA;AACA,qDAAqD,QAAQ;AAC7D;AACA;AACA,qBAAqB;AACrB,wCAAwC,YAAY;AACpD;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,iCAAiC;AACjC,gCAAgC;AAChC;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,8CAA8C,qBAAqB;AACnE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,2CAA2C,2BAA2B;AACtE;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,+BAA+B,yBAAyB;AACxD;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sIAAsI,EAAE;AACxI;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,+BAA+B,mBAAmB;AAClD;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sIAAsI,EAAE;AACxI;;AAEA;AACA;;AAEA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA,mCAAmC,iBAAiB;AACpD,mMAAmM;AACnM;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA,oCAAoC,oBAAoB;AACxD;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA,+BAA+B,UAAU;AACzC;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,+BAA+B,UAAU;AACzC;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,+BAA+B,UAAU;AACzC;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,+BAA+B,UAAU;AACzC;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA,+BAA+B,UAAU;AACzC;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,wFAAwF;AACxF;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA,wFAAwF;AACxF;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,mCAAmC;AACnC;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA,6BAA6B;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA,wFAAwF;AACxF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,KAAK;;AAEL;;AAEA,wEAAwE;AACxE;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,yBAAyB;AACzB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,mCAAmC,qBAAqB;AACxD;AACA;;AAEA,oCAAoC,2BAA2B;AAC/D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,yDAAyD,EAAE;AAC3D;AACA;AACA;AACA,6HAA6H,QAAQ;AACrI;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,0CAA0C;AACzE;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,oGAAoG,QAAQ;AAC5G;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,+BAA+B,qBAAqB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,mCAAmC,qBAAqB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA,mCAAmC,qBAAqB;AACxD;AACA;AACA;AACA;AACA,oCAAoC,sBAAsB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,sBAAsB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,gGAAgG,QAAQ;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA,+BAA+B,qBAAqB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB,eAAe,uBAAuB;AACvD;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,yHAAyH,QAAQ;AACjI;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB,eAAe,uBAAuB;AACvD;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,gGAAgG,QAAQ;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,EAAE;;AAER;;AAEA,qFAAqF;AACrF;AACA;AACA;AACA,8CAA8C,qEAAqE;AACnH;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,EAAE;;AAER;;AAEA,mFAAmF;AACnF;AACA;AACA;AACA;AACA,8CAA8C,mEAAmE;AACjH;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA,kCAAkC,EAAE;AACpC;AACA;AACA;AACA,wFAAwF;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,wFAAwF;AACxF;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,EAAE;;AAER;;AAEA,6EAA6E;AAC7E;AACA;AACA;AACA,8CAA8C,6DAA6D;AAC3G;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,EAAE;;AAER;;AAEA,sEAAsE;AACtE;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,EAAE;;AAER;;AAEA,iFAAiF;AACjF;AACA;AACA;AACA;AACA,8CAA8C,iEAAiE;AAC/G;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,wFAAwF;AACxF;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA,wFAAwF;AACxF;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,EAAE;;AAER;;AAEA,sEAAsE;AACtE;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,yFAAyF;AACzF;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,mCAAmC,gBAAgB;AACnD;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,qGAAqG;AACrG;AACA,aAAa;AACb;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,EAAE;;AAER;;AAEA,iFAAiF;AACjF;AACA;AACA;AACA;AACA,8CAA8C,iEAAiE;AAC/G;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,wFAAwF;AACxF;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,wFAAwF;AACxF;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,EAAE;;AAER;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,6CAA6C,kBAAkB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,mCAAmC,kDAAkD;AACrF;AACA;AACA;AACA;AACA;AACA,4CAA4C,iBAAiB;AAC7D;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA,0FAA0C,eAAe,EAAE;AAAA;AAC3D,KAAK;AACL;AACA;AACA;;AAEA;;AAEA,CAAC;;;;;;;;ACjqlCD;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;;AAEA;AACA;AACA,4CAA4C;;AAE5C;;;;;;;ACpBA;AACA;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA,2B;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;;AAEA;;AAEA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6EAA6E;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;;AAEA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,mCAAmC;AACnC,8EAA8E;;AAE9E;AACA;AACA;AACA;;AAEA;AACA;;AAEA,+BAA+B,OAAO;AACtC;AACA;AACA;;AAEA,aAAa;AACb;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA,sBAAsB,uBAAuB;AAC7C;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sBAAsB,uBAAuB;AAC7C;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;;;;AAIA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uBAAuB;AAC7C;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,uBAAuB;AAC7C;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;;AAEA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,8CAA8C,EAAE,GAAG,EAAE;AACrD;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,aAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,qBAAqB,IAAI,EAAE,IAAI,EAAE,IAAI;AACrC;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,OAAO;AAChC,yBAAyB;AACzB;AACA;AACA;;AAEA;AACA;AACA;;AAEA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8CAA8C;AAC9C;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B,UAAU;AACzC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,UAAU;AACzC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,UAAU;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,8CAA8C,EAAE;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA,iBAAiB;;AAEjB;AACA;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;;AAEA;;AAEA;;AAEA,aAAa;AACb;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;;AAGA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;;;AAGA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;;AAEA,aAAa;AACb;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA,yF;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,uDAAuD;AACvD,aAAa;AACb;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,qE;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,uDAAuD;AACvD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yF;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA,qE;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,aAAa;AACb;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,OAAO;AAChC,yBAAyB,OAAO;AAChC,yBAAyB;AACzB;AACA;AACA;AACA,+BAA+B,4BAA4B;AAC3D;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,aAAa;AACb;AACA,qFAAqF,EAAE;AACvF,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;;;;AAIA;;AAEA;;;AAGA;AACA;;;AAGA;AACA;AACA;;;AAGA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;;AAEA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa;AACb;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa;AACb;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA,aAAa;AACb;AACA;AACA;AACA,uCAAuC,EAAE;AACzC;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,8CAA8C,kCAAkC;AAChF;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,+CAA+C,KAAK,aAAa,KAAK,KAAK,EAAE,GAAG,EAAE;AAClF;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wEAAwE;AACxE;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA,gCAAgC,QAAQ;AACxC;AACA,mCAAmC,QAAQ;AAC3C;AACA,uCAAuC,QAAQ;AAC/C;AACA;;AAEA;AACA;;AAEA;AACA,+BAA+B,QAAQ;AACvC;AACA,mCAAmC,QAAQ;AAC3C;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;;AAEA,+BAA+B,OAAO;AACtC;;AAEA;;AAEA;;AAEA,qCAAqC,SAAS;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;;AAGA,+BAA+B,OAAO;AACtC;AACA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA,yCAAyC,UAAU;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,0CAA0C,UAAU;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,OAAO;AACtC;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA,yCAAyC,UAAU;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,0CAA0C,UAAU;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,aAAa;AACtC,yBAAyB,OAAO;AAChC,yBAAyB,OAAO;AAChC,yBAAyB,OAAO;AAChC,yBAAyB,OAAO;AAChC,yBAAyB,OAAO;AAChC,yBAAyB;AACzB;AACA;AACA;AACA;;AAEA;AACA;;AAEA,iCAAiC,SAAS;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA,+BAA+B,YAAY;AAC3C,mCAAmC,WAAW;;AAE9C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;;AAEA,+BAA+B,YAAY;AAC3C,mCAAmC,WAAW;;AAE9C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA,+BAA+B,YAAY;AAC3C,mCAAmC,WAAW;;AAE9C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,QAAQ;AACvC,mCAAmC,QAAQ;AAC3C;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,OAAO;AAChC,yBAAyB,OAAO;AAChC,yBAAyB;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;AAGA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,aAAa;AACb;AACA,gCAAgC,QAAQ;;AAExC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,OAAO;AAChC,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gCAAgC;AAChC;AACA,+BAA+B,QAAQ;AACvC,mCAAmC,QAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,OAAO;AAChC,yBAAyB;AACzB;AACA;AACA;;AAEA,8BAA8B;;AAE9B,+BAA+B,QAAQ;AACvC,mCAAmC,QAAQ;;AAE3C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA,+BAA+B,OAAO;AACtC,mCAAmC,OAAO;;AAE1C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB,uCAAuC;AACvC,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;;AAGA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;;AAGA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb,yCAAyC,EAAE;AAC3C;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,6CAA6C,EAAE;AAC/C;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA,8CAA8C,EAAE,IAAI,EAAE,KAAK,EAAE,aAAa,EAAE;AAC5E;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA,8CAA8C,EAAE,IAAI,EAAE,cAAc,EAAE;AACtE;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;;;AAGA,aAAa;AACb;AACA;AACA,aAAa;AACb;;AAEA;;AAEA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,uCAAuC;AACvC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,EAAE;AACpC;AACA;AACA,aAAa;AACb,6CAA6C,EAAE;AAC/C,kCAAkC;AAClC;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,mCAAmC,QAAQ;AAC3C;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA,mCAAmC,QAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;;AAEA;;AAEA,iCAAiC,SAAS;AAC1C;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;;AAGA,+BAA+B,WAAW;;AAE1C;AACA;AACA;;AAEA,gCAAgC,UAAU;;AAE1C;AACA;;AAEA,gCAAgC,yCAAyC;;AAEzE;AACA;;AAEA,gCAAgC,2BAA2B;;AAE3D;AACA;;AAEA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,+BAA+B,WAAW;AAC1C;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,gCAAgC,UAAU;AAC1C;AACA;AACA;AACA;AACA;AACA;;AAEA,gCAAgC,yCAAyC;AACzE;AACA;AACA;AACA;AACA;AACA;;AAEA,gCAAgC,2BAA2B;AAC3D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,aAAa;AACb;AACA;AACA;;AAEA;;AAEA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,aAAa;AACtC,yBAAyB;AACzB;AACA;AACA,+BAA+B,QAAQ;AACvC,iEAAiE;AACjE;;AAEA,gCAAgC,sBAAsB;AACtD;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,OAAO;AAChC,yBAAyB;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,+BAA+B,aAAa;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,mDAAmD;AACnD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,wEAAwE;AACxE,wEAAwE;AACxE,2EAA2E,aAAa;;AAExF;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,aAAa;AACb;;;AAGA,aAAa;AACb;;AAEA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;;AAEA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+B;AACA;AACA;;AAEA;AACA;;AAEA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,2EAA2E;AAC3E;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,2GAA2G,MAAM;AACjH;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,aAAa;AACb;;AAEA,aAAa;AACb;;;;;AAKA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;;AAGA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,+BAA+B,SAAS;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB,+BAA+B,iCAAiC;AAChE;AACA;;AAEA;AACA;AACA,iBAAiB;;AAEjB,gCAAgC,SAAS;AACzC;AACA;;AAEA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,gCAAgC;AAC/D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,OAAO;AAChC,yBAAyB;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uCAAuC,iBAAiB;AACxD;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa;AACb;AACA;AACA;AACA,+BAA+B,SAAS;AACxC;AACA;AACA;AACA;AACA,wCAAwC,0CAA0C;AAClF;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;;AAGA;;;AAGA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;;AAEA,mCAAmC,WAAW;AAC9C;AACA;;AAEA,gCAAgC,SAAS;AACzC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;;AAEA;;AAEA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;;;AAGA,mCAAmC;;AAEnC;;AAEA,aAAa;AACb,gDAAgD,EAAE;AAClD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,+BAA+B,UAAU;;AAEzC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,+BAA+B,UAAU;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb,2CAA2C,EAAE;AAC7C,0CAA0C,EAAE;AAC5C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA,qIAAqI;AACrI;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wJAAwJ,EAAE;AAC1J;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA,uDAAuD,EAAE;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA,+BAA+B,OAAO;AACtC;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,+BAA+B,0CAA0C;AACzE;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;;;;AAMA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,0CAA0C;AAC7E;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA,iBAAiB;AACjB;AACA;;;AAGA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,mCAAmC,qBAAqB;AACxD;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE;AACvE,kEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;;AAEA;AACA,iBAAiB;AACjB;AACA;;AAEA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL,CAAC;;;;;;;;ACx5RD;AACA;AACA;AACA;AACA;AACA;AACA","file":"emulator.worker.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 5d302073f61e63d7ae2c","import './../src/app/emu/bridge.js';\nimport './../src/app/emu/ChiChiCore.js';\n\nonmessage = (event:MessageEvent) => {\n    setTimeout(() => {\n        let p = new bgEmu();\n        postMessage('hello there');\n    }, 1000);\n }\n\n export class bgEmu {\n    // public tileDoodler: Tiler;\n    // private machine: ChiChiNES.NESMachine;\n    // public controlPad: ControlPad;\n\n\n    constructor() {\n        // const wavsharer = new ChiChiNES.BeepsBoops.WavSharer();\n        // const whizzler = new ChiChiNES.PixelWhizzler();\n        // whizzler.FillRGB = false;\n\n        // const soundbop = new ChiChiNES.BeepsBoops.Bopper(wavsharer);\n        // const cpu = new ChiChiNES.CPU2A03(whizzler, soundbop);\n        // this.controlPad = new ControlPad();\n        // this.machine = new ChiChiNES.NESMachine(cpu, whizzler, new ChiChiNES.TileDoodler(whizzler), wavsharer, soundbop, new ChiChiNES.Sound.SoundThreader(null));\n        // machine.PadOne = this.controlPad;\n        // this.tileDoodler = new Tiler(this.machine);\n        // machine.Cpu.Debugging = false;\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./workers/emulator.webworker.ts","/**\n * @version   : 16.3.2 - Bridge.NET\n * @author    : Object.NET, Inc. http://bridge.net/\n * @copyright : Copyright 2008-2017 Object.NET, Inc. http://object.net/\n * @license   : See license.txt and https://github.com/bridgedotnet/Bridge/blob/master/LICENSE.md\n */\n\n    // @source Init.js\n\n(function (globals) {\n    \"use strict\";\n\n    if (typeof module !== \"undefined\" && module.exports) {\n        globals = global;\n    }\n\n    // @source Core.js\n\n    var core = {\n        global: globals,\n\n        isNode: Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]',\n\n        emptyFn: function () { },\n\n        identity: function (x) {\n            return x;\n        },\n\n        geti: function (scope, name1, name2) {\n            if (Bridge.hasValue(scope[name1])) {\n                return name1;\n            }\n\n            if (name2 && Bridge.hasValue(scope[name2])) {\n                return name2;\n            }\n\n            var name = name2 || name1;\n            var idx = name.lastIndexOf(\"$\");\n\n            if (/\\$\\d+$/g.test(name)) {\n                idx = name.lastIndexOf(\"$\", idx - 1);\n            }\n\n            return name.substr(idx + 1);\n        },\n\n        box: function (v, T, toStr, hashCode) {\n            if (v && v.$boxed) {\n                return v;\n            }\n\n            if (v == null) {\n                return v;\n            }\n\n            if (v.$clone) {\n                v = v.$clone();\n            }\n\n            return {\n                $boxed: true,\n                fn: {\n                    toString: toStr,\n                    getHashCode: hashCode\n                },\n                v: v,\n                type: T,\n                constructor: T,\n                getHashCode: function() {\n                    return this.fn.getHashCode ? this.fn.getHashCode(this.v) : Bridge.getHashCode(this.v);\n                },\n                equals: function (o) {\n                    var eq = this.equals;\n                    this.equals = null;\n                    var r = Bridge.equals(this.v, o);\n                    this.equals = eq;\n                    return r;\n                },\n                valueOf: function() {\n                    return this.v;\n                },\n                toString: function () {\n                    return this.fn.toString ? this.fn.toString(this.v) : this.v.toString();\n                }\n            };\n        },\n\n        unbox: function (o, noclone) {\n            if (o && o.$boxed) {\n                var v = o.v;\n                if (!noclone && v && v.$clone) {\n                    v = v.$clone();\n                }\n\n                return v;\n            }\n\n            if (Bridge.isArray(o)) {\n                var arr = [];\n                for (var i = 0; i < o.length; i++) {\n                    var item = o[i];\n\n                    if (item && item.$boxed) {\n                        item = item.v;\n\n                        if (item.$clone) {\n                            item = item.$clone();\n                        }\n                    }\n                    else if (!noclone && item && item.$clone) {\n                        item = item.$clone();\n                    }\n\n                    arr[i] = item;\n                }\n                o = arr;\n            }\n\n            if (o && !noclone && o.$clone) {\n                o = o.$clone();\n            }\n\n            return o;\n        },\n\n        virtualc: function (name) {\n            return Bridge.virtual(name, true);\n        },\n\n        virtual: function (name, isClass) {\n            var type = Bridge.unroll(name);\n\n            if (!type || !Bridge.isFunction(type)) {\n                var old = Bridge.Class.staticInitAllow;\n                type = isClass ? Bridge.define(name) : Bridge.definei(name);\n                Bridge.Class.staticInitAllow = true;\n                if (type.$staticInit) {\n                    type.$staticInit();\n                }\n                Bridge.Class.staticInitAllow = old;\n            }\n\n            return type;\n        },\n\n        safe: function (fn) {\n            try {\n                return fn();\n            } catch (ex) {\n            }\n\n            return false;\n        },\n\n        literal: function (type, obj) {\n            obj.$getType = function () { return type };\n            return obj;\n        },\n\n        isJSObject: function(value) {\n            return Object.prototype.toString.call(value) === '[object Object]';\n        },\n\n        isPlainObject: function (obj) {\n            if (typeof obj == 'object' && obj !== null) {\n                if (typeof Object.getPrototypeOf == 'function') {\n                    var proto = Object.getPrototypeOf(obj);\n\n                    return proto === Object.prototype || proto === null;\n                }\n\n                return Object.prototype.toString.call(obj) === '[object Object]';\n            }\n\n            return false;\n        },\n\n        toPlain: function (o) {\n            if (!o || Bridge.isPlainObject(o) || typeof o != \"object\") {\n                return o;\n            }\n\n            if (typeof o.toJSON == 'function') {\n                return o.toJSON();\n            }\n\n            if (Bridge.isArray(o)) {\n                var arr = [];\n\n                for (var i = 0; i < o.length; i++) {\n                    arr.push(Bridge.toPlain(o[i]));\n                }\n\n                return arr;\n            }\n\n            var newo = {},\n                m;\n\n            for (var key in o) {\n                m = o[key];\n\n                if (!Bridge.isFunction(m)) {\n                    newo[key] = m;\n                }\n            }\n\n            return newo;\n        },\n\n        ref: function (o, n) {\n            if (Bridge.isArray(n)) {\n                n = System.Array.toIndex(o, n);\n            }\n\n            var proxy = {};\n\n            Object.defineProperty(proxy, \"v\", {\n                get: function () {\n                    if (n == null) {\n                        return o;\n                    }\n\n                    return o[n];\n                },\n\n                set: function (value) {\n                    if (n == null) {\n                        if (value && value.$clone) {\n                            value.$clone(o);\n                        } else {\n                            o = value;\n                        }\n                    }\n                    o[n] = value;\n                }\n            });\n\n            return proxy;\n        },\n\n        ensureBaseProperty: function (scope, name) {\n            var scopeType = Bridge.getType(scope),\n                descriptors = scopeType.$descriptors || [];\n\n            scope.$propMap = scope.$propMap || {};\n\n            if (scope.$propMap[name]) {\n                return scope;\n            }\n\n            for (var j = 0; j < descriptors.length; j++) {\n                var d = descriptors[j];\n                if (d.name === name) {\n                    var aliasCfg = {},\n                        aliasName = \"$\" + Bridge.getTypeAlias(d.cls) + \"$\" + name;\n\n                    if (d.get) {\n                        aliasCfg.get = d.get;\n                    }\n\n                    if (d.set) {\n                        aliasCfg.set = d.set;\n                    }\n                    Bridge.property(scope, aliasName, aliasCfg, false, scopeType, true);\n                }\n            }\n\n            scope.$propMap[name] = true;\n\n            return scope;\n        },\n\n        property: function (scope, name, v, statics, cls, alias) {\n            var cfg = {\n                enumerable: alias ? false : true,\n                configurable: true\n            };\n\n            if (v && v.get) {\n                cfg.get = v.get;\n            }\n\n            if (v && v.set) {\n                cfg.set = v.set;\n            }\n\n            if (!v || !(v.get || v.set)) {\n                var backingField = Bridge.getTypeAlias(cls) + \"$\" + name;\n\n                cls.$init = cls.$init || {};\n                if (statics) {\n                    cls.$init[backingField] = v;\n                }\n\n                (function (cfg, scope, backingField, v) {\n                    cfg.get = function () {\n                        var o = this.$init[backingField];\n                        return o === undefined ? v : o;\n                    };\n\n                    cfg.set = function (value) {\n                        this.$init[backingField] = value;\n                    };\n                })(cfg, scope, backingField, v);\n            }\n\n            Object.defineProperty(scope, name, cfg);\n\n            return cfg;\n        },\n\n        event: function (scope, name, v, statics) {\n            scope[name] = v;\n\n            var rs = name.charAt(0) === \"$\",\n                cap = rs ? name.slice(1) : name,\n                addName = \"add\" + cap,\n                removeName = \"remove\" + cap,\n                lastSep = name.lastIndexOf(\"$\"),\n                endsNum = lastSep > 0 && ((name.length - lastSep - 1) > 0) && !isNaN(parseInt(name.substr(lastSep + 1)));\n\n            if (endsNum) {\n                lastSep = name.substring(0, lastSep - 1).lastIndexOf(\"$\");\n            }\n\n            if (lastSep > 0 && lastSep !== (name.length - 1)) {\n                addName = name.substring(0, lastSep) + \"add\" + name.substr(lastSep + 1);\n                removeName = name.substring(0, lastSep) + \"remove\" + name.substr(lastSep + 1);\n            }\n\n            scope[addName] = (function (name, scope, statics) {\n                return statics ? function (value) {\n                    scope[name] = Bridge.fn.combine(scope[name], value);\n                } : function (value) {\n                    this[name] = Bridge.fn.combine(this[name], value);\n                };\n            })(name, scope, statics);\n\n            scope[removeName] = (function (name, scope, statics) {\n                return statics ? function (value) {\n                    scope[name] = Bridge.fn.remove(scope[name], value);\n                } : function (value) {\n                    this[name] = Bridge.fn.remove(this[name], value);\n                };\n            })(name, scope, statics);\n        },\n\n        createInstance: function (type, args) {\n            if (type === System.Decimal) {\n                return System.Decimal.Zero;\n            }\n\n            if (type === System.Int64) {\n                return System.Int64.Zero;\n            }\n\n            if (type === System.UInt64) {\n                return System.UInt64.Zero;\n            }\n\n            if (type === System.Double ||\n                type === System.Single ||\n                type === System.Byte ||\n                type === System.SByte ||\n                type === System.Int16 ||\n                type === System.UInt16 ||\n                type === System.Int32 ||\n                type === System.UInt32 ||\n                type === Bridge.Int) {\n                return 0;\n            }\n\n            if (typeof (type.createInstance) === 'function') {\n                return type.createInstance();\n            } else if (typeof (type.getDefaultValue) === 'function') {\n                return type.getDefaultValue();\n            } else if (type === Boolean || type === System.Boolean) {\n                return false;\n            } else if (type === System.DateTime) {\n                return System.DateTime.getDefaultValue();\n            } else if (type === Date) {\n                return new Date();\n            } else if (type === Number) {\n                return 0;\n            } else if (type === String || type === System.String) {\n                return '';\n            } else if (type && type.$literal) {\n                return type.ctor();\n            } else if (args && args.length > 0) {\n                return Bridge.Reflection.applyConstructor(type, args);\n            } else {\n                return new type();\n            }\n        },\n\n        clone: function (obj) {\n            if (obj == null) {\n                return obj;\n            }\n\n            if (Bridge.isArray(obj)) {\n                return System.Array.clone(obj);\n            }\n\n            if (Bridge.isString(obj)) {\n                return obj;\n            }\n\n            var name;\n\n            if (Bridge.isFunction(obj[name = \"System$ICloneable$clone\"])) {\n                return obj[name]();\n            }\n\n            if (Bridge.is(obj, System.ICloneable)) {\n                return obj.clone();\n            }\n\n            if (Bridge.isFunction(obj.$clone)) {\n                return obj.$clone();\n            }\n\n            return null;\n        },\n\n        copy: function (to, from, keys, toIf) {\n            if (typeof keys === \"string\") {\n                keys = keys.split(/[,;\\s]+/);\n            }\n\n            for (var name, i = 0, n = keys ? keys.length : 0; i < n; i++) {\n                name = keys[i];\n\n                if (toIf !== true || to[name] == undefined) {\n                    if (Bridge.is(from[name], System.ICloneable)) {\n                        to[name] = Bridge.clone(from[name]);\n                    } else {\n                        to[name] = from[name];\n                    }\n                }\n            }\n\n            return to;\n        },\n\n        get: function (t) {\n            if (t && t.$staticInit !== null) {\n                t.$staticInit();\n            }\n\n            return t;\n        },\n\n        ns: function (ns, scope) {\n            var nsParts = ns.split(\".\"),\n                i = 0;\n\n            if (!scope) {\n                scope = Bridge.global;\n            }\n\n            for (i = 0; i < nsParts.length; i++) {\n                if (typeof scope[nsParts[i]] === \"undefined\") {\n                    scope[nsParts[i]] = {};\n                }\n\n                scope = scope[nsParts[i]];\n            }\n\n            return scope;\n        },\n\n        ready: function (fn, scope) {\n            var delayfn = function () {\n                if (scope) {\n                    fn.apply(scope);\n                } else {\n                    fn();\n                }\n            };\n\n            if (typeof Bridge.global.jQuery !== \"undefined\") {\n                Bridge.global.jQuery(delayfn);\n            } else {\n                if (typeof Bridge.global.document === \"undefined\" || Bridge.global.document.readyState === \"complete\" || Bridge.global.document.readyState === \"loaded\") {\n                    delayfn();\n                } else {\n                    Bridge.on(\"DOMContentLoaded\", Bridge.global.document, delayfn);\n                }\n            }\n        },\n\n        on: function (event, elem, fn, scope) {\n            var listenHandler = function (e) {\n                var ret = fn.apply(scope || this, arguments);\n\n                if (ret === false) {\n                    e.stopPropagation();\n                    e.preventDefault();\n                }\n\n                return (ret);\n            };\n\n            var attachHandler = function () {\n                var ret = fn.call(scope || elem, Bridge.global.event);\n\n                if (ret === false) {\n                    Bridge.global.event.returnValue = false;\n                    Bridge.global.event.cancelBubble = true;\n                }\n\n                return (ret);\n            };\n\n            if (elem.addEventListener) {\n                elem.addEventListener(event, listenHandler, false);\n            } else {\n                elem.attachEvent(\"on\" + event, attachHandler);\n            }\n        },\n\n        addHash: function (v, r, m) {\n            if (isNaN(r)) {\n                r = 17;\n            }\n\n            if (isNaN(m)) {\n                m = 23;\n            }\n\n            if (Bridge.isArray(v)) {\n                for (var i = 0; i < v.length; i++) {\n                    r = r + ((r * m | 0) + (v[i] == null ? 0 : Bridge.getHashCode(v[i]))) | 0;\n                }\n\n                return r;\n            }\n\n            return r = r + ((r * m | 0) + (v == null ? 0 : Bridge.getHashCode(v))) | 0;\n        },\n\n        getHashCode: function (value, safe, deep) {\n            // In CLR: mutable object should keep on returning same value\n            // Bridge.NET goals: make it deterministic (to make testing easier) without breaking CLR contracts\n            //     for value types it returns deterministic values (f.e. for int 3 it returns 3)\n            //     for reference types it returns random value\n\n            if (value && value.$boxed && value.type.getHashCode) {\n                return value.type.getHashCode(Bridge.unbox(value, true));\n            }\n\n            value = Bridge.unbox(value, true);\n\n            if (Bridge.isEmpty(value, true)) {\n                if (safe) {\n                    return 0;\n                }\n\n                throw new System.InvalidOperationException(\"HashCode cannot be calculated for empty value\");\n            }\n\n            if (deep !== false && value.hasOwnProperty(\"item1\") && Bridge.isPlainObject(value)) {\n                deep = true;\n            }\n\n            if (value.getHashCode && Bridge.isFunction(value.getHashCode) && !value.__insideHashCode && value.getHashCode.length === 0) {\n                value.__insideHashCode = true;\n                var r = value.getHashCode();\n\n                delete value.__insideHashCode;\n\n                return r;\n            }\n\n            if (Bridge.isBoolean(value)) {\n                return value ? 1 : 0;\n            }\n\n            if (Bridge.isDate(value)) {\n                return value.valueOf() & 0xFFFFFFFF;\n            }\n\n            if (value === Number.POSITIVE_INFINITY) {\n                return 0x7FF00000;\n            }\n\n            if (value === Number.NEGATIVE_INFINITY) {\n                return 0xFFF00000;\n            }\n\n            if (Bridge.isNumber(value)) {\n                if (Math.floor(value) === value) {\n                    return value;\n                }\n\n                value = value.toExponential();\n            }\n\n            if (Bridge.isString(value)) {\n                var hash = 0,\n                    i;\n\n                for (i = 0; i < value.length; i++) {\n                    hash = (((hash << 5) - hash) + value.charCodeAt(i)) & 0xFFFFFFFF;\n                }\n\n                return hash;\n            }\n\n            if (value.$$hashCode) {\n                return value.$$hashCode;\n            }\n\n            if (deep && typeof value == \"object\") {\n                var result = 0,\n                    temp;\n\n                for (var property in value) {\n                    if (value.hasOwnProperty(property)) {\n                        temp = Bridge.isEmpty(value[property], true) ? 0 : Bridge.getHashCode(value[property]);\n                        result = 29 * result + temp;\n                    }\n                }\n\n                if (result !== 0) {\n                    value.$$hashCode = result;\n\n                    return result;\n                }\n            }\n\n            value.$$hashCode = (Math.random() * 0x100000000) | 0;\n\n            return value.$$hashCode;\n        },\n\n        getDefaultValue: function (type) {\n            if (type == null) {\n                throw new System.ArgumentNullException(\"type\");\n            } else if ((type.getDefaultValue) && type.getDefaultValue.length === 0) {\n                return type.getDefaultValue();\n            } else if (Bridge.Reflection.isEnum(type)) {\n                return System.Enum.parse(type, 0);\n            } else if (type === Boolean || type === System.Boolean) {\n                return false;\n            } else if (type === System.DateTime) {\n                return System.DateTime.getDefaultValue();\n            } else if (type === Date) {\n                return new Date();\n            } else if (type === Number) {\n                return 0;\n            }\n\n            return null;\n        },\n\n        $$aliasCache: [],\n\n        getTypeAlias: function (obj) {\n            if (obj.$$alias) {\n                return obj.$$alias;\n            }\n\n            var type = (obj.$$name || typeof obj === \"function\") ? obj : Bridge.getType(obj),\n                alias;\n\n            if (type.$$alias) {\n                return type.$$alias;\n            }\n\n            alias = Bridge.$$aliasCache[type];\n            if (alias) {\n                return alias;\n            }\n\n            if (type.$isArray) {\n                var elementName = Bridge.getTypeAlias(type.$elementType);\n                alias = elementName + \"$Array\" + (type.$rank > 1 ? (\"$\" + type.$rank) : \"\");\n                if (type.$$name) {\n                    type.$$alias = alias;\n                } else {\n                    Bridge.$$aliasCache[type] = alias;\n                }\n                return alias;\n            }\n\n            var name = obj.$$name || Bridge.getTypeName(obj);\n\n            alias = name.replace(/[\\.\\(\\)\\,]/g, \"$\");\n            if (type.$$name) {\n                type.$$alias = alias;\n            } else {\n                Bridge.$$aliasCache[type] = alias;\n            }\n            return alias;\n        },\n\n        getTypeName: function (obj) {\n            return Bridge.Reflection.getTypeFullName(obj);\n        },\n\n        hasValue: function (obj) {\n            return Bridge.unbox(obj, true) != null;\n        },\n\n        hasValue$1: function () {\n            if (arguments.length === 0) {\n                return false;\n            }\n\n            var i = 0;\n\n            for (i; i < arguments.length; i++) {\n                if (Bridge.unbox(arguments[i], true) == null) {\n                    return false;\n                }\n            }\n\n            return true;\n        },\n\n        isObject: function(type) {\n            return type === Object || type === System.Object;\n        },\n\n        is: function (obj, type, ignoreFn, allowNull) {\n            if (obj == null) {\n                return !!allowNull;\n            }\n\n            if (type === System.Object) {\n                type = Object;\n            }\n\n            var tt = typeof type;\n\n            if (tt === \"boolean\") {\n                return type;\n            }\n\n            if (obj.$boxed) {\n                if (obj.type.$kind === \"enum\" && (obj.type.prototype.$utype === type || type === System.Enum || type === System.IFormattable || type === System.IComparable)) {\n                    return true;\n                }\n                else if (type.$kind !== \"interface\" && !type.$nullable) {\n                    return obj.type === type || Bridge.isObject(type);\n                }\n\n                if (ignoreFn !== true && type.$is) {\n                    return type.$is(Bridge.unbox(obj, true));\n                }\n\n                if (Bridge.Reflection.isAssignableFrom(type, obj.type)) {\n                    return true;\n                }\n\n                obj = Bridge.unbox(obj, true);\n            }\n\n            var ctor = Bridge.Reflection.convertType(obj.constructor);\n            if (type.constructor === Function && obj instanceof type || ctor === type || Bridge.isObject(type)) {\n                return true;\n            }\n\n            var hasObjKind = ctor.$kind || ctor.$$inherits,\n                hasTypeKind = type.$kind;\n            if (hasObjKind || hasTypeKind) {\n                var isInterface = type.$isInterface;\n\n                if (isInterface) {\n                    if (hasObjKind) {\n                        if (ctor.$isArrayEnumerator) {\n                            return System.Array.is(obj, type);\n                        }\n\n                        return type.isAssignableFrom ? type.isAssignableFrom(ctor) : Bridge.Reflection.getInterfaces(ctor).indexOf(type) >= 0;\n                    }\n\n                    if (Bridge.isArray(obj, ctor)) {\n                        return System.Array.is(obj, type);\n                    }\n                }\n\n                if (ignoreFn !== true && type.$is) {\n                    return type.$is(obj);\n                }\n\n                if (type.$literal) {\n                    if (Bridge.isPlainObject(obj)) {\n                        if (obj.$getType) {\n                            return Bridge.Reflection.isAssignableFrom(type, obj.$getType());\n                        }\n\n                        return true;\n                    }\n                }\n\n                return false;\n            }\n\n            if (tt === \"string\") {\n                type = Bridge.unroll(type);\n            }\n\n            if (tt === \"function\" && (Bridge.getType(obj).prototype instanceof type)) {\n                return true;\n            }\n\n            if (ignoreFn !== true) {\n                if (typeof (type.$is) === \"function\") {\n                    return type.$is(obj);\n                }\n\n                if (typeof (type.isAssignableFrom) === \"function\") {\n                    return type.isAssignableFrom(Bridge.getType(obj));\n                }\n            }\n\n            if (Bridge.isArray(obj)) {\n                return System.Array.is(obj, type);\n            }\n\n            return tt === \"object\" && ((ctor === type) || (obj instanceof type));\n        },\n\n        as: function (obj, type, allowNull) {\n            if (Bridge.is(obj, type, false, allowNull)) {\n                return obj != null && obj.$boxed && type !== Object && type !== System.Object ? obj.v : obj;\n            }\n            return null;\n        },\n\n        cast: function (obj, type, allowNull) {\n            if (obj == null) {\n                return obj;\n            }\n\n            var result = Bridge.is(obj, type, false, allowNull) ? obj : null;\n\n            if (result === null) {\n                throw new System.InvalidCastException(\"Unable to cast type \" + (obj ? Bridge.getTypeName(obj) : \"'null'\") + \" to type \" + Bridge.getTypeName(type));\n            }\n\n            if (obj.$boxed && type !== Object && type !== System.Object) {\n                return obj.v;\n            }\n\n            return result;\n        },\n\n        apply: function (obj, values, callback) {\n            var names = Bridge.getPropertyNames(values, true),\n                i;\n\n            for (i = 0; i < names.length; i++) {\n                var name = names[i];\n\n                if (typeof obj[name] === \"function\" && typeof values[name] !== \"function\") {\n                    obj[name](values[name]);\n                } else {\n                    obj[name] = values[name];\n                }\n            }\n\n            if (callback) {\n                callback.call(obj, obj);\n            }\n\n            return obj;\n        },\n\n        merge: function (to, from, callback, elemFactory) {\n            if (to == null) {\n                return from;\n            }\n\n            // Maps instance of plain JS value or Object into Bridge object.\n            // Used for deserialization. Proper deserialization requires reflection that is currently not supported in Bridge.\n            // It currently is only capable to deserialize:\n            // -instance of single class or primitive\n            // -array of primitives\n            // -array of single class\n            if (to instanceof System.Decimal && typeof from === \"number\") {\n                return new System.Decimal(from);\n            }\n\n            if (to instanceof System.Int64 && Bridge.isNumber(from)) {\n                return new System.Int64(from);\n            }\n\n            if (to instanceof System.UInt64 && Bridge.isNumber(from)) {\n                return new System.UInt64(from);\n            }\n\n            if (to instanceof Boolean || Bridge.isBoolean(to) ||\n                typeof to === \"number\" ||\n                to instanceof String || Bridge.isString(to) ||\n                to instanceof Function || Bridge.isFunction(to) ||\n                to instanceof Date || Bridge.isDate(to) ||\n                Bridge.getType(to).$number) {\n                return from;\n            }\n\n            var key,\n                i,\n                value,\n                toValue,\n                fn;\n\n            if (Bridge.isArray(from) && Bridge.isFunction(to.add || to.push)) {\n                fn = Bridge.isArray(to) ? to.push : to.add;\n\n                for (i = 0; i < from.length; i++) {\n                    var item = from[i];\n\n                    if (!Bridge.isArray(item)) {\n                        item = [typeof elemFactory === 'undefined' ? item : Bridge.merge(elemFactory(), item)];\n                    }\n\n                    fn.apply(to, item);\n                }\n            } else {\n                var t = Bridge.getType(to),\n\t\t\t\t\tdescriptors = t && t.$descriptors;\n\n                if (from) {\n                    for (key in from) {\n                        value = from[key];\n\n                        var descriptor = null;\n                        if (descriptors) {\n                            for (var i = descriptors.length - 1; i >= 0; i--) {\n                                if (descriptors[i].name === key) {\n                                    descriptor = descriptors[i];\n                                    break;\n                                }\n                            }\n                        }\n\n                        if (descriptor != null) {\n                            if (descriptor.set) {\n                                to[key] = Bridge.merge(to[key], value);\n                            } else {\n                                Bridge.merge(to[key], value);\n                            }\n                        } else if (typeof to[key] === \"function\") {\n                            if (key.match(/^\\s*get[A-Z]/)) {\n                                Bridge.merge(to[key](), value);\n                            } else {\n                                to[key](value);\n                            }\n                        } else {\n                            var setter1 = \"set\" + key.charAt(0).toUpperCase() + key.slice(1),\n                                setter2 = \"set\" + key,\n                                getter;\n\n                            if (typeof to[setter1] === \"function\" && typeof value !== \"function\") {\n                                getter = \"g\" + setter1.slice(1);\n                                if (typeof to[getter] === \"function\") {\n                                    to[setter1](Bridge.merge(to[getter](), value));\n                                } else {\n                                    to[setter1](value);\n                                }\n                            } else if (typeof to[setter2] === \"function\" && typeof value !== \"function\") {\n                                getter = \"g\" + setter2.slice(1);\n                                if (typeof to[getter] === \"function\") {\n                                    to[setter2](Bridge.merge(to[getter](), value));\n                                } else {\n                                    to[setter2](value);\n                                }\n                            } else if (value && value.constructor === Object && to[key]) {\n                                toValue = to[key];\n                                Bridge.merge(toValue, value);\n                            } else {\n                                var isNumber = Bridge.isNumber(from);\n\n                                if (to[key] instanceof System.Decimal && isNumber) {\n                                    return new System.Decimal(from);\n                                }\n\n                                if (to[key] instanceof System.Int64 && isNumber) {\n                                    return new System.Int64(from);\n                                }\n\n                                if (to[key] instanceof System.UInt64 && isNumber) {\n                                    return new System.UInt64(from);\n                                }\n\n                                to[key] = value;\n                            }\n                        }\n                    }\n                } else {\n                    if (callback) {\n                        callback.call(to, to);\n                    }\n                    return from;\n                }\n            }\n\n            if (callback) {\n                callback.call(to, to);\n            }\n\n            return to;\n        },\n\n        getEnumerator: function (obj, fnName, T) {\n            if (typeof obj === \"string\") {\n                obj = System.String.toCharArray(obj);\n            }\n\n            if (arguments.length === 2 && Bridge.isFunction(fnName)) {\n                T = fnName;\n                fnName = null;\n            }\n\n            if (fnName && obj && obj[fnName]) {\n                return obj[fnName].call(obj);\n            }\n\n            if (!T && obj && obj.getEnumerator) {\n                return obj.getEnumerator();\n            }\n\n            var name;\n\n            if (T && Bridge.isFunction(obj[name = \"System$Collections$Generic$IEnumerable$1$\" + Bridge.getTypeAlias(T) + \"$getEnumerator\"])) {\n                return obj[name]();\n            }\n\n            if (T && Bridge.isFunction(obj[name = \"System$Collections$Generic$IEnumerable$1$getEnumerator\"])) {\n                return obj[name]();\n            }\n\n            if (Bridge.isFunction(obj[name = \"System$Collections$IEnumerable$getEnumerator\"])) {\n                return obj[name]();\n            }\n\n            if (T && obj && obj.getEnumerator) {\n                return obj.getEnumerator();\n            }\n\n            if ((Object.prototype.toString.call(obj) === \"[object Array]\") ||\n                (obj && Bridge.isDefined(obj.length))) {\n                return new Bridge.ArrayEnumerator(obj, T);\n            }\n\n            throw new System.InvalidOperationException(\"Cannot create enumerator\");\n        },\n\n        getPropertyNames: function (obj, includeFunctions) {\n            var names = [],\n                name;\n\n            for (name in obj) {\n                if (includeFunctions || typeof obj[name] !== \"function\") {\n                    names.push(name);\n                }\n            }\n\n            return names;\n        },\n\n        isDefined: function (value, noNull) {\n            return typeof value !== \"undefined\" && (noNull ? value !== null : true);\n        },\n\n        isEmpty: function (value, allowEmpty) {\n            return (typeof value === \"undefined\" || value === null) || (!allowEmpty ? value === \"\" : false) || ((!allowEmpty && Bridge.isArray(value)) ? value.length === 0 : false);\n        },\n\n        toArray: function (ienumerable) {\n            var i,\n                item,\n                len,\n                result = [];\n\n            if (Bridge.isArray(ienumerable)) {\n                for (i = 0, len = ienumerable.length; i < len; ++i) {\n                    result.push(ienumerable[i]);\n                }\n            } else {\n                i = Bridge.getEnumerator(ienumerable);\n\n                while (i.moveNext()) {\n                    item = i.Current;\n                    result.push(item);\n                }\n            }\n\n            return result;\n        },\n\n        toList: function (ienumerable, T) {\n            return new (System.Collections.Generic.List$1(T || System.Object).$ctor1)(ienumerable);\n        },\n\n        arrayTypes: [globals.Array, globals.Uint8Array, globals.Int8Array, globals.Int16Array, globals.Uint16Array, globals.Int32Array, globals.Uint32Array, globals.Float32Array, globals.Float64Array, globals.Uint8ClampedArray],\n\n        isArray: function (obj, ctor) {\n            var c = ctor || (obj != null ? obj.constructor : null);\n\n            if (!c) {\n                return false;\n            }\n\n            return Bridge.arrayTypes.indexOf(c) >= 0 || c.$isArray || Array.isArray(obj);\n        },\n\n        isFunction: function (obj) {\n            return typeof (obj) === \"function\";\n        },\n\n        isDate: function (obj) {\n            return Object.prototype.toString.call(obj) === \"[object Date]\";\n        },\n\n        isNull: function (value) {\n            return (value === null) || (value === undefined);\n        },\n\n        isBoolean: function (value) {\n            return typeof value === \"boolean\";\n        },\n\n        isNumber: function (value) {\n            return typeof value === \"number\" && isFinite(value);\n        },\n\n        isString: function (value) {\n            return typeof value === \"string\";\n        },\n\n        unroll: function (value) {\n            var d = value.split(\".\"),\n                o = Bridge.global[d[0]],\n                i = 1;\n\n            for (i; i < d.length; i++) {\n                if (!o) {\n                    return null;\n                }\n\n                o = o[d[i]];\n            }\n\n            return o;\n        },\n\n        referenceEquals: function (a, b) {\n            return Bridge.hasValue(a) ? a === b : !Bridge.hasValue(b);\n        },\n\n        staticEquals: function (a, b) {\n            if (!Bridge.hasValue(a)) {\n                return !Bridge.hasValue(b);\n            }\n\n            return Bridge.hasValue(b) ? Bridge.equals(a, b) : false;\n        },\n\n        equals: function (a, b) {\n            if (a == null && b == null) {\n                return true;\n            }\n\n            if (a && a.$boxed && a.type.equals && a.type.equals.length === 2) {\n                return a.type.equals(a, b);\n            }\n\n            if (b && b.$boxed && b.type.equals && b.type.equals.length === 2) {\n                return b.type.equals(b, a);\n            }\n\n            if (a && Bridge.isFunction(a.equals) && a.equals.length === 1) {\n                return a.equals(b);\n            }\n\n            if (b && Bridge.isFunction(b.equals) && b.equals.length === 1) {\n                return b.equals(a);\n            } if (Bridge.isFunction(a) && Bridge.isFunction(b)) {\n                return Bridge.fn.equals.call(a, b);\n            } else if (Bridge.isDate(a) && Bridge.isDate(b)) {\n                if (a.kind !== undefined && a.ticks !== undefined && b.kind !== undefined && b.ticks !== undefined) {\n                    return a.ticks.equals(b.ticks);\n                }\n\n                return a.valueOf() === b.valueOf();\n            } else if (Bridge.isNull(a) && Bridge.isNull(b)) {\n                return true;\n            } else if (Bridge.isNull(a) !== Bridge.isNull(b)) {\n                return false;\n            }\n\n            var eq = a === b;\n\n            if (!eq && typeof a === \"object\" && typeof b === \"object\" && a !== null && b !== null && a.$kind === \"struct\" && b.$kind === \"struct\" && a.$$name === b.$$name) {\n                return Bridge.getHashCode(a) === Bridge.getHashCode(b) && Bridge.objectEquals(a, b);\n            }\n\n            if (!eq && a && b && a.hasOwnProperty(\"item1\") && Bridge.isPlainObject(a) && b.hasOwnProperty(\"item1\") && Bridge.isPlainObject(b)) {\n                return Bridge.objectEquals(a, b);\n            }\n\n            return eq;\n        },\n\n        objectEquals: function (a, b) {\n            Bridge.$$leftChain = [];\n            Bridge.$$rightChain = [];\n\n            var result = Bridge.deepEquals(a, b);\n\n            delete Bridge.$$leftChain;\n            delete Bridge.$$rightChain;\n\n            return result;\n        },\n\n        deepEquals: function (a, b) {\n            if (typeof a === \"object\" && typeof b === \"object\") {\n                if (a === b) {\n                    return true;\n                }\n\n                if (Bridge.$$leftChain.indexOf(a) > -1 || Bridge.$$rightChain.indexOf(b) > -1) {\n                    return false;\n                }\n\n                var p;\n\n                for (p in b) {\n                    if (b.hasOwnProperty(p) !== a.hasOwnProperty(p)) {\n                        return false;\n                    } else if (typeof b[p] !== typeof a[p]) {\n                        return false;\n                    }\n                }\n\n                for (p in a) {\n                    if (b.hasOwnProperty(p) !== a.hasOwnProperty(p)) {\n                        return false;\n                    } else if (typeof a[p] !== typeof b[p]) {\n                        return false;\n                    }\n\n                    if (a[p] === b[p]) {\n                        continue;\n                    } else if (typeof (a[p]) === \"object\") {\n                        Bridge.$$leftChain.push(a);\n                        Bridge.$$rightChain.push(b);\n\n                        if (!Bridge.deepEquals(a[p], b[p])) {\n                            return false;\n                        }\n\n                        Bridge.$$leftChain.pop();\n                        Bridge.$$rightChain.pop();\n                    } else {\n                        if (!Bridge.equals(a[p], b[p])) {\n                            return false;\n                        }\n                    }\n                }\n\n                return true;\n            } else {\n                return Bridge.equals(a, b);\n            }\n        },\n\n        numberCompare : function (a, b) {\n            if (a < b) {\n                return -1;\n            }\n            if (a > b) {\n                return 1;\n            }\n            if (a == b) {\n                return 0;\n            }\n            if (!isNaN(a)) {\n                return 1;\n            }\n            if (!isNaN(b)) {\n                return -1;\n            }\n            return 0;\n        },\n\n        compare: function (a, b, safe, T) {\n            if (a && a.$boxed) {\n                a = Bridge.unbox(a, true);\n            }\n\n            if (b && b.$boxed) {\n                b = Bridge.unbox(b, true);\n            }\n\n            if (typeof a === \"number\" && typeof b === \"number\") {\n                return Bridge.numberCompare(a, b);\n            }\n\n            if (!Bridge.isDefined(a, true)) {\n                if (safe) {\n                    return 0;\n                }\n\n                throw new System.NullReferenceException();\n            } else if (Bridge.isNumber(a) || Bridge.isString(a) || Bridge.isBoolean(a)) {\n                if (Bridge.isString(a) && !Bridge.hasValue(b)) {\n                    return 1;\n                }\n\n                return a < b ? -1 : (a > b ? 1 : 0);\n            } else if (Bridge.isDate(a)) {\n                if (a.kind !== undefined && a.ticks !== undefined) {\n                    return Bridge.compare(a.ticks, b.ticks);\n                }\n\n                return Bridge.compare(a.valueOf(), b.valueOf());\n            }\n\n            var name;\n\n            if (T && Bridge.isFunction(a[name = \"System$IComparable$1$\" + Bridge.getTypeAlias(T) + \"$compareTo\"])) {\n                return a[name](b);\n            }\n\n            if (T && Bridge.isFunction(a[name = \"System$IComparable$1$compareTo\"])) {\n                return a[name](b);\n            }\n\n            if (Bridge.isFunction(a[name = \"System$IComparable$compareTo\"])) {\n                return a[name](b);\n            }\n\n            if (Bridge.isFunction(a.compareTo)) {\n                return a.compareTo(b);\n            }\n\n            if (T && Bridge.isFunction(b[name = \"System$IComparable$1$\" + Bridge.getTypeAlias(T) + \"$compareTo\"])) {\n                return -b[name](a);\n            }\n\n            if (T && Bridge.isFunction(b[name = \"System$IComparable$1$compareTo\"])) {\n                return -b[name](a);\n            }\n\n            if (Bridge.isFunction(b[name = \"System$IComparable$compareTo\"])) {\n                return -b[name](a);\n            }\n\n            if (Bridge.isFunction(b.compareTo)) {\n                return -b.compareTo(a);\n            }\n\n            if (safe) {\n                return 0;\n            }\n\n            throw new System.Exception(\"Cannot compare items\");\n        },\n\n        equalsT: function (a, b, T) {\n            if (a && a.$boxed && a.type.equalsT && a.type.equalsT.length === 2) {\n                return a.type.equalsT(a, b);\n            }\n\n            if (b && b.$boxed && b.type.equalsT && b.type.equalsT.length === 2) {\n                return b.type.equalsT(b, a);\n            }\n\n            if (!Bridge.isDefined(a, true)) {\n                throw new System.NullReferenceException();\n            } else if (Bridge.isNumber(a) || Bridge.isString(a) || Bridge.isBoolean(a)) {\n                return a === b;\n            } else if (Bridge.isDate(a)) {\n                if (a.kind !== undefined && a.ticks !== undefined) {\n                    return a.ticks.equals(b.ticks);\n                }\n\n                return a.valueOf() === b.valueOf();\n            }\n\n            var name;\n\n            if (T && a != null && Bridge.isFunction(a[name = \"System$IEquatable$1$\" + Bridge.getTypeAlias(T) + \"$equalsT\"])) {\n                return a[name](b);\n            }\n\n            if (T && b != null && Bridge.isFunction(b[name = \"System$IEquatable$1$\" + Bridge.getTypeAlias(T) + \"$equalsT\"])) {\n                return b[name](a);\n            }\n\n            if (Bridge.isFunction(a) && Bridge.isFunction(b)) {\n                return Bridge.fn.equals.call(a, b);\n            }\n\n            return a.equalsT ? a.equalsT(b) : b.equalsT(a);\n        },\n\n        format: function (obj, formatString, provider) {\n            if (obj && obj.$boxed) {\n                if (obj.type.$kind === \"enum\") {\n                    return System.Enum.format(obj.type, obj.v, formatString);\n                } else if (obj.type === System.Char) {\n                    return System.Char.format(Bridge.unbox(obj, true), formatString, provider);\n                } else if (obj.type.format) {\n                    return obj.type.format(Bridge.unbox(obj, true), formatString, provider);\n                }\n            }\n\n            if (Bridge.isNumber(obj)) {\n                return Bridge.Int.format(obj, formatString, provider);\n            } else if (Bridge.isDate(obj)) {\n                return System.DateTime.format(obj, formatString, provider);\n            }\n\n            var name;\n\n            if (Bridge.isFunction(obj[name = \"System$IFormattable$format\"])) {\n                return obj[name](formatString, provider);\n            }\n\n            return obj.format(formatString, provider);\n        },\n\n        getType: function (instance, T) {\n            if (instance && instance.$boxed) {\n                return instance.type;\n            }\n\n            if (instance == null) {\n                throw new System.NullReferenceException(\"instance is null\");\n            }\n\n            if (T) {\n                var type = Bridge.getType(instance);\n                return Bridge.Reflection.isAssignableFrom(T, type) ? type : T;\n            }\n\n            if (typeof (instance) === \"number\") {\n                if (!isNaN(instance) && isFinite(instance) && Math.floor(instance, 0) === instance) {\n                    return System.Int32;\n                } else {\n                    return System.Double;\n                }\n            }\n\n            if (instance.$type) {\n                return instance.$type;\n            }\n\n            if (instance.$getType) {\n                return instance.$getType();\n            }\n\n            var result = null;\n            try {\n                result = instance.constructor;\n            } catch (ex) {\n                result = Object;\n            }\n\n            return Bridge.Reflection.convertType(result);\n        },\n\n        isLower: function (c) {\n            var s = String.fromCharCode(c);\n\n            return s === s.toLowerCase() && s !== s.toUpperCase();\n        },\n\n        isUpper: function (c) {\n            var s = String.fromCharCode(c);\n\n            return s !== s.toLowerCase() && s === s.toUpperCase();\n        },\n\n        coalesce: function (a, b) {\n            return Bridge.hasValue(a) ? a : b;\n        },\n\n        fn: {\n            equals: function (fn) {\n                if (this === fn) {\n                    return true;\n                }\n\n                if (fn == null || (this.constructor !== fn.constructor)) {\n                    return false;\n                }\n\n                return this.equals && (this.equals === fn.equals) && this.$method && (this.$method === fn.$method) && this.$scope && (this.$scope === fn.$scope);\n            },\n\n            call: function (obj, fnName) {\n                var args = Array.prototype.slice.call(arguments, 2);\n\n                obj = obj || Bridge.global;\n\n                return obj[fnName].apply(obj, args);\n            },\n\n            makeFn: function (fn, length) {\n                switch (length) {\n                    case 0:\n                        return function () {\n                            return fn.apply(this, arguments);\n                        };\n                    case 1:\n                        return function (a) {\n                            return fn.apply(this, arguments);\n                        };\n                    case 2:\n                        return function (a, b) {\n                            return fn.apply(this, arguments);\n                        };\n                    case 3:\n                        return function (a, b, c) {\n                            return fn.apply(this, arguments);\n                        };\n                    case 4:\n                        return function (a, b, c, d) {\n                            return fn.apply(this, arguments);\n                        };\n                    case 5:\n                        return function (a, b, c, d, e) {\n                            return fn.apply(this, arguments);\n                        };\n                    case 6:\n                        return function (a, b, c, d, e, f) {\n                            return fn.apply(this, arguments);\n                        };\n                    case 7:\n                        return function (a, b, c, d, e, f, g) {\n                            return fn.apply(this, arguments);\n                        };\n                    case 8:\n                        return function (a, b, c, d, e, f, g, h) {\n                            return fn.apply(this, arguments);\n                        };\n                    case 9:\n                        return function (a, b, c, d, e, f, g, h, i) {\n                            return fn.apply(this, arguments);\n                        };\n                    case 10:\n                        return function (a, b, c, d, e, f, g, h, i, j) {\n                            return fn.apply(this, arguments);\n                        };\n                    case 11:\n                        return function (a, b, c, d, e, f, g, h, i, j, k) {\n                            return fn.apply(this, arguments);\n                        };\n                    case 12:\n                        return function (a, b, c, d, e, f, g, h, i, j, k, l) {\n                            return fn.apply(this, arguments);\n                        };\n                    case 13:\n                        return function (a, b, c, d, e, f, g, h, i, j, k, l, m) {\n                            return fn.apply(this, arguments);\n                        };\n                    case 14:\n                        return function (a, b, c, d, e, f, g, h, i, j, k, l, m, n) {\n                            return fn.apply(this, arguments);\n                        };\n                    case 15:\n                        return function (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o) {\n                            return fn.apply(this, arguments);\n                        };\n                    case 16:\n                        return function (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) {\n                            return fn.apply(this, arguments);\n                        };\n                    case 17:\n                        return function (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q) {\n                            return fn.apply(this, arguments);\n                        };\n                    case 18:\n                        return function (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r) {\n                            return fn.apply(this, arguments);\n                        };\n                    case 19:\n                        return function (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s) {\n                            return fn.apply(this, arguments);\n                        };\n                    default:\n                        return function (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t) {\n                            return fn.apply(this, arguments);\n                        };\n                }\n            },\n\n            cacheBind: function (obj, method, args, appendArgs) {\n                return Bridge.fn.bind(obj, method, args, appendArgs, true);\n            },\n\n            bind: function (obj, method, args, appendArgs, cache) {\n                if (method && method.$method === method && method.$scope === obj) {\n                    return method;\n                }\n\n                if (obj && cache && obj.$$bind) {\n                    for (var i = 0; i < obj.$$bind.length; i++) {\n                        if (obj.$$bind[i].$method === method) {\n                            return obj.$$bind[i];\n                        }\n                    }\n                }\n\n                var fn;\n\n                if (arguments.length === 2) {\n                    fn = Bridge.fn.makeFn(function () {\n                        Bridge.caller.unshift(this);\n\n                        var result = null;\n                        try {\n                            result = method.apply(obj, arguments);\n                        } finally {\n                            Bridge.caller.shift(this);\n                        }\n\n                        return result;\n                    }, method.length);\n                } else {\n                    fn = Bridge.fn.makeFn(function () {\n                        var callArgs = args || arguments;\n\n                        if (appendArgs === true) {\n                            callArgs = Array.prototype.slice.call(arguments, 0);\n                            callArgs = callArgs.concat(args);\n                        } else if (typeof appendArgs === \"number\") {\n                            callArgs = Array.prototype.slice.call(arguments, 0);\n\n                            if (appendArgs === 0) {\n                                callArgs.unshift.apply(callArgs, args);\n                            } else if (appendArgs < callArgs.length) {\n                                callArgs.splice.apply(callArgs, [appendArgs, 0].concat(args));\n                            } else {\n                                callArgs.push.apply(callArgs, args);\n                            }\n                        }\n                        Bridge.caller.unshift(this);\n\n                        var result = null;\n                        try {\n                            result = method.apply(obj, callArgs);\n                        } finally {\n                            Bridge.caller.shift(this);\n                        }\n\n                        return result;\n                    }, method.length);\n                }\n\n                if (obj && cache) {\n                    obj.$$bind = obj.$$bind || [];\n                    obj.$$bind.push(fn);\n                }\n\n                fn.$method = method;\n                fn.$scope = obj;\n                fn.equals = Bridge.fn.equals;\n\n                return fn;\n            },\n\n            bindScope: function (obj, method) {\n                var fn = Bridge.fn.makeFn(function () {\n                    var callArgs = Array.prototype.slice.call(arguments, 0);\n\n                    callArgs.unshift.apply(callArgs, [obj]);\n\n                    Bridge.caller.unshift(this);\n\n                    var result = null;\n                    try {\n                        result = method.apply(obj, callArgs);\n                    } finally {\n                        Bridge.caller.shift(this);\n                    }\n\n                    return result;\n                }, method.length);\n\n                fn.$method = method;\n                fn.$scope = obj;\n                fn.equals = Bridge.fn.equals;\n\n                return fn;\n            },\n\n            $build: function (handlers) {\n                if (!handlers || handlers.length === 0) {\n                    return null;\n                }\n\n                var fn = function () {\n                    var result = null,\n                        i,\n                        handler;\n\n                    for (i = 0; i < handlers.length; i++) {\n                        handler = handlers[i];\n                        result = handler.apply(null, arguments);\n                    }\n\n                    return result;\n                };\n\n                fn.$invocationList = handlers ? Array.prototype.slice.call(handlers, 0) : [];\n                handlers = fn.$invocationList.slice();               \n\n                return fn;\n            },\n\n            combine: function (fn1, fn2) {\n                if (!fn1 || !fn2) {\n                    var fn = fn1 || fn2;\n                    return fn ? Bridge.fn.$build([fn]) : fn;\n                }\n\n                var list1 = fn1.$invocationList ? fn1.$invocationList : [fn1],\n                    list2 = fn2.$invocationList ? fn2.$invocationList : [fn2];\n\n                return Bridge.fn.$build(list1.concat(list2));\n            },\n\n            getInvocationList: function (fn) {\n                if (fn == null) {\n                    throw new System.ArgumentNullException();\n                }\n\n                if(!fn.$invocationList) {\n                    fn.$invocationList = [fn];\n                }\n\n                return fn.$invocationList;\n            },\n\n            remove: function (fn1, fn2) {\n                if (!fn1 || !fn2) {\n                    return fn1 || null;\n                }\n\n                var list1 = fn1.$invocationList ? fn1.$invocationList : [fn1],\n                    list2 = fn2.$invocationList ? fn2.$invocationList : [fn2],\n                    result = [],\n                    exclude,\n                    i, j;\n\n                for (j = 0; j < list2.length; j++) {\n                    exclude = -1;\n\n                    for (i = list1.length - 1; i >= 0; i--) {\n                        if (list1[i] === list2[j] ||\n                            ((list1[i].$method && (list1[i].$method === list2[j].$method)) && (list1[i].$scope && (list1[i].$scope === list2[j].$scope)))) {\n                            exclude = i;\n                            break;\n                        }\n                    }\n\n                    if (exclude > -1) {\n                        list1.splice(exclude, 1);\n                    }\n                }\n\n                return Bridge.fn.$build(list1);\n            }\n        },\n\n        sleep: function (ms, timeout) {\n            if (Bridge.hasValue(timeout)) {\n                ms = timeout.getTotalMilliseconds();\n            }\n\n            if (isNaN(ms) || ms < -1 || ms > 2147483647) {\n                throw new System.ArgumentOutOfRangeException(\"timeout\", \"Number must be either non-negative and less than or equal to Int32.MaxValue or -1\");\n            }\n\n            if (ms == -1) {\n                ms = 2147483647;\n            }\n\n            var start = new Date().getTime();\n\n            while ((new Date().getTime() - start) < ms) {\n                if ((new Date().getTime() - start) > 2147483647) {\n                    break;\n                }\n            }\n        },\n\n        getMetadata: function (t) {\n            var m = t.$getMetadata ? t.$getMetadata() : t.$metadata;\n\n            return m;\n        },\n\n        loadModule: function (config, callback) {\n            var amd = config.amd,\n                cjs = config.cjs,\n                fnName = config.fn;\n\n            var tcs = new System.Threading.Tasks.TaskCompletionSource(),\n                fn = Bridge.global[fnName || \"require\"];\n\n            if (amd && amd.length > 0) {\n                fn(amd, function() {\n                    var loads = Array.prototype.slice.call(arguments, 0);\n                    if (cjs && cjs.length > 0) {\n                        for (var i = 0; i < cjs.length; i++) {\n                            loads.push(fn(cjs[i]));\n                        }\n                    }\n\n                    callback.apply(Bridge.global, loads);\n                    tcs.setResult();\n                });\n            } else if (cjs && cjs.length > 0) {\n                var t = new System.Threading.Tasks.Task();\n                t.status = System.Threading.Tasks.TaskStatus.ranToCompletion;\n\n                var loads = [];\n                for (var j = 0; j < cjs.length; j++) {\n                    loads.push(fn(cjs[j]));\n                }\n\n                callback.apply(Bridge.global, loads);\n                return t;\n            } else {\n                var t = new System.Threading.Tasks.Task();\n                t.status = System.Threading.Tasks.TaskStatus.ranToCompletion;\n                return t;\n            }\n\n            return tcs.task;\n        }\n    };\n\n    globals.Bridge = core;\n    globals.Bridge.caller = [];\n\n    if (globals.console) {\n        globals.Bridge.Console = globals.console;\n    }\n\n    globals.System = {};\n    globals.System.Diagnostics = {};\n    globals.System.Diagnostics.Contracts = {};\n    globals.System.Threading = {};\n\n    // @source Browser.js\n\n    var check = function (regex) {\n        return Bridge.global.navigator && regex.test(Bridge.global.navigator.userAgent.toLowerCase());\n    },\n\n    isStrict = Bridge.global.document && Bridge.global.document.compatMode === \"CSS1Compat\",\n\n    version = function (is, regex) {\n        var m;\n\n        return Bridge.global.navigator && (is && (m = regex.exec(navigator.userAgent.toLowerCase()))) ? parseFloat(m[1]) : 0;\n    },\n\n    docMode = Bridge.global.document ? Bridge.global.document.documentMode : null,\n    isOpera = check(/opera/),\n    isOpera10_5 = isOpera && check(/version\\/10\\.5/),\n    isChrome = check(/\\bchrome\\b/),\n    isWebKit = check(/webkit/),\n    isSafari = !isChrome && check(/safari/),\n    isSafari2 = isSafari && check(/applewebkit\\/4/),\n    isSafari3 = isSafari && check(/version\\/3/),\n    isSafari4 = isSafari && check(/version\\/4/),\n    isSafari5_0 = isSafari && check(/version\\/5\\.0/),\n    isSafari5 = isSafari && check(/version\\/5/),\n    isIE = !isOpera && (check(/msie/) || check(/trident/)),\n    isIE7 = isIE && ((check(/msie 7/) && docMode !== 8 && docMode !== 9 && docMode !== 10) || docMode === 7),\n    isIE8 = isIE && ((check(/msie 8/) && docMode !== 7 && docMode !== 9 && docMode !== 10) || docMode === 8),\n    isIE9 = isIE && ((check(/msie 9/) && docMode !== 7 && docMode !== 8 && docMode !== 10) || docMode === 9),\n    isIE10 = isIE && ((check(/msie 10/) && docMode !== 7 && docMode !== 8 && docMode !== 9) || docMode === 10),\n    isIE11 = isIE && ((check(/trident\\/7\\.0/) && docMode !== 7 && docMode !== 8 && docMode !== 9 && docMode !== 10) || docMode === 11),\n    isIE6 = isIE && check(/msie 6/),\n    isGecko = !isWebKit && !isIE && check(/gecko/),\n    isGecko3 = isGecko && check(/rv:1\\.9/),\n    isGecko4 = isGecko && check(/rv:2\\.0/),\n    isGecko5 = isGecko && check(/rv:5\\./),\n    isGecko10 = isGecko && check(/rv:10\\./),\n    isFF3_0 = isGecko3 && check(/rv:1\\.9\\.0/),\n    isFF3_5 = isGecko3 && check(/rv:1\\.9\\.1/),\n    isFF3_6 = isGecko3 && check(/rv:1\\.9\\.2/),\n    isWindows = check(/windows|win32/),\n    isMac = check(/macintosh|mac os x/),\n    isLinux = check(/linux/),\n    scrollbarSize = null,\n    chromeVersion = version(true, /\\bchrome\\/(\\d+\\.\\d+)/),\n    firefoxVersion = version(true, /\\bfirefox\\/(\\d+\\.\\d+)/),\n    ieVersion = version(isIE, /msie (\\d+\\.\\d+)/),\n    operaVersion = version(isOpera, /version\\/(\\d+\\.\\d+)/),\n    safariVersion = version(isSafari, /version\\/(\\d+\\.\\d+)/),\n    webKitVersion = version(isWebKit, /webkit\\/(\\d+\\.\\d+)/),\n    isSecure = Bridge.global.location ? /^https/i.test(Bridge.global.location.protocol) : false,\n    isiPhone = Bridge.global.navigator && /iPhone/i.test(Bridge.global.navigator.platform),\n    isiPod = Bridge.global.navigator && /iPod/i.test(Bridge.global.navigator.platform),\n    isiPad = Bridge.global.navigator && /iPad/i.test(Bridge.global.navigator.userAgent),\n    isBlackberry = Bridge.global.navigator && /Blackberry/i.test(Bridge.global.navigator.userAgent),\n    isAndroid = Bridge.global.navigator && /Android/i.test(Bridge.global.navigator.userAgent),\n    isDesktop = isMac || isWindows || (isLinux && !isAndroid),\n    isTablet = isiPad,\n    isPhone = !isDesktop && !isTablet;\n\n    var browser = {\n        isStrict: isStrict,\n        isIEQuirks: isIE && (!isStrict && (isIE6 || isIE7 || isIE8 || isIE9)),\n        isOpera: isOpera,\n        isOpera10_5: isOpera10_5,\n        isWebKit: isWebKit,\n        isChrome: isChrome,\n        isSafari: isSafari,\n        isSafari3: isSafari3,\n        isSafari4: isSafari4,\n        isSafari5: isSafari5,\n        isSafari5_0: isSafari5_0,\n        isSafari2: isSafari2,\n        isIE: isIE,\n        isIE6: isIE6,\n        isIE7: isIE7,\n        isIE7m: isIE6 || isIE7,\n        isIE7p: isIE && !isIE6,\n        isIE8: isIE8,\n        isIE8m: isIE6 || isIE7 || isIE8,\n        isIE8p: isIE && !(isIE6 || isIE7),\n        isIE9: isIE9,\n        isIE9m: isIE6 || isIE7 || isIE8 || isIE9,\n        isIE9p: isIE && !(isIE6 || isIE7 || isIE8),\n        isIE10: isIE10,\n        isIE10m: isIE6 || isIE7 || isIE8 || isIE9 || isIE10,\n        isIE10p: isIE && !(isIE6 || isIE7 || isIE8 || isIE9),\n        isIE11: isIE11,\n        isIE11m: isIE6 || isIE7 || isIE8 || isIE9 || isIE10 || isIE11,\n        isIE11p: isIE && !(isIE6 || isIE7 || isIE8 || isIE9 || isIE10),\n        isGecko: isGecko,\n        isGecko3: isGecko3,\n        isGecko4: isGecko4,\n        isGecko5: isGecko5,\n        isGecko10: isGecko10,\n        isFF3_0: isFF3_0,\n        isFF3_5: isFF3_5,\n        isFF3_6: isFF3_6,\n        isFF4: 4 <= firefoxVersion && firefoxVersion < 5,\n        isFF5: 5 <= firefoxVersion && firefoxVersion < 6,\n        isFF10: 10 <= firefoxVersion && firefoxVersion < 11,\n        isLinux: isLinux,\n        isWindows: isWindows,\n        isMac: isMac,\n        chromeVersion: chromeVersion,\n        firefoxVersion: firefoxVersion,\n        ieVersion: ieVersion,\n        operaVersion: operaVersion,\n        safariVersion: safariVersion,\n        webKitVersion: webKitVersion,\n        isSecure: isSecure,\n        isiPhone: isiPhone,\n        isiPod: isiPod,\n        isiPad: isiPad,\n        isBlackberry: isBlackberry,\n        isAndroid: isAndroid,\n        isDesktop: isDesktop,\n        isTablet: isTablet,\n        isPhone: isPhone,\n        iOS: isiPhone || isiPad || isiPod,\n        standalone: Bridge.global.navigator ? !!Bridge.global.navigator.standalone : false\n    };\n\n    Bridge.Browser = browser;\n    // @source Class.js\n\n        var base = {\n        _initialize: function () {\n            if (this.$init) {\n                return;\n            }\n\n            this.$init = {};\n\n            if (this.$staticInit) {\n                this.$staticInit();\n            }\n\n            if (this.$initMembers) {\n                this.$initMembers();\n            }\n        },\n\n        initConfig: function (extend, base, config, statics, scope, prototype) {\n            var initFn,\n                name,\n                cls = (statics ? scope : scope.ctor),\n                descriptors = cls.$descriptors,\n                aliases = cls.$aliases;\n\n            if (config.fields) {\n                for (name in config.fields) {\n                    scope[name] = config.fields[name];\n                }\n            }\n\n            var props = config.properties;\n            if (props) {\n                for (name in props) {\n                    var v = props[name],\n                        d,\n                        cfg;\n\n                    if (v != null && Bridge.isPlainObject(v) && (!v.get || !v.set)) {\n                        for (var k = 0; k < descriptors.length; k++) {\n                            if (descriptors[k].name === name) {\n                                d = descriptors[k];\n                            }\n                        }\n\n                        if (d && d.get && !v.get) {\n                            v.get = d.get;\n                        }\n\n                        if (d && d.set && !v.set) {\n                            v.set = d.set;\n                        }\n                    }\n\n                    cfg = Bridge.property(statics ? scope : prototype, name, v, statics, cls);\n                    cfg.name = name;\n                    cfg.cls = cls;\n\n                    descriptors.push(cfg);\n                }\n            }\n\n            if (config.events) {\n                for (name in config.events) {\n                    Bridge.event(scope, name, config.events[name], statics);\n                }\n            }\n\n            if (config.alias) {\n                for (var i = 0; i < config.alias.length; i++) {\n                    (function (obj, name, alias, cls) {\n                        var descriptor = null;\n                        for (var i = descriptors.length - 1; i >= 0; i--) {\n                            if (descriptors[i].name === name) {\n                                descriptor = descriptors[i];\n                                break;\n                            }\n                        }\n\n                        var arr = Array.isArray(alias) ? alias : [alias];\n                        for (var j = 0; j < arr.length; j++) {\n                            alias = arr[j];\n\n                            if (descriptor != null) {\n                                Object.defineProperty(obj, alias, descriptor);\n                                aliases.push({ alias: alias, descriptor: descriptor });\n                            } else {\n                                var m = scope[name];\n\n                                if (m === undefined && prototype) {\n                                    m = prototype[name];\n                                }\n\n                                scope[alias] = m;\n                                aliases.push({ fn: name, alias: alias });\n                            }\n                        }\n                    })(statics ? scope : prototype, config.alias[i], config.alias[i + 1], cls);\n\n                    i++;\n                }\n            }\n\n            if (config.init) {\n                initFn = config.init;\n            }\n\n            if (initFn || (extend && !statics && base.$initMembers)) {\n                scope.$initMembers = function () {\n                    if (extend && !statics && base.$initMembers) {\n                        base.$initMembers.call(this);\n                    }\n\n                    if (initFn) {\n                        initFn.call(this);\n                    }\n                };\n            }\n        },\n\n        convertScheme: function(obj) {\n            var result = {},\n            copy = function (obj, to) {\n                var reserved = [\"fields\", \"methods\", \"events\", \"props\", \"properties\", \"alias\", \"ctors\"],\n                    keys = Object.keys(obj);\n\n                for (var i = 0; i < keys.length; i++) {\n                    var name = keys[i];\n\n                    if (reserved.indexOf(name) === -1) {\n                        to[name] = obj[name];\n                    }\n                }\n\n                if (obj.fields) {\n                    Bridge.apply(to, obj.fields);\n                }\n\n                if (obj.methods) {\n                    Bridge.apply(to, obj.methods);\n                }\n\n                var config = {},\n                    write = false;\n\n                if (obj.props) {\n                    config.properties = obj.props;\n                    write = true;\n                } else if (obj.properties) {\n                    config.properties = obj.properties;\n                    write = true;\n                }\n\n                if (obj.events) {\n                    config.events = obj.events;\n                    write = true;\n                }\n\n                if (obj.alias) {\n                    config.alias = obj.alias;\n                    write = true;\n                }\n\n                if (obj.ctors) {\n                    if (obj.ctors.init) {\n                        config.init = obj.ctors.init;\n                        write = true;\n                        delete obj.ctors.init;\n                    }\n\n                    Bridge.apply(to, obj.ctors);\n                }\n\n                if (write) {\n                    to.$config = config;\n                }\n            };\n\n            if (obj.main) {\n                result.$main = obj.main;\n                delete obj.main;\n            }\n\n            copy(obj, result);\n\n            if (obj.statics || obj.$statics) {\n                result.$statics = {};\n                copy(obj.statics || obj.$statics, result.$statics);\n            }\n\n            return result;\n        },\n\n        definei: function (className, gscope, prop) {\n            if ((prop === true || !prop) && gscope) {\n                gscope.$kind = \"interface\";\n            } else if (prop) {\n                prop.$kind = \"interface\";\n            } else {\n                gscope = { $kind: \"interface\" };\n            }\n\n            var c = Bridge.define(className, gscope, prop);\n\n            c.$kind = \"interface\";\n            c.$isInterface = true;\n\n            return c;\n        },\n\n        // Create a new Class that inherits from this class\n        define: function (className, gscope, prop, gCfg) {\n            var isGenericInstance = false;\n\n            if (prop === true) {\n                isGenericInstance = true;\n                prop = gscope;\n                gscope = Bridge.global;\n            } else if (!prop) {\n                prop = gscope;\n                gscope = Bridge.global;\n            }\n\n            var fn;\n\n            if (Bridge.isFunction(prop)) {\n                fn = function () {\n                    var args,\n                        key,\n                        obj,\n                        c;\n\n                    key = Bridge.Class.getCachedType(fn, arguments);\n\n                    if (key) {\n                        return key.type;\n                    }\n\n                    args = Array.prototype.slice.call(arguments);\n                    obj = prop.apply(null, args);\n                    c = Bridge.define(Bridge.Class.genericName(className, args), obj, true, { fn: fn, args: args });\n\n                    if (!Bridge.Class.staticInitAllow && !Bridge.Class.queueIsBlocked) {\n                        Bridge.Class.$queue.push(c);\n                    }\n\n                    return Bridge.get(c);\n                };\n\n                fn.$cache = [];\n\n                return Bridge.Class.generic(className, gscope, fn, prop);\n            }\n\n            if (!isGenericInstance) {\n                Bridge.Class.staticInitAllow = false;\n            }\n\n            prop = prop || {};\n\n            if (prop.$kind === \"enum\" && !prop.inherits) {\n                prop.inherits = [System.IComparable, System.IFormattable];\n            }\n\n            var rNames = [\"fields\", \"events\", \"props\", \"ctors\", \"methods\"],\n                defaultScheme = Bridge.isFunction(prop.main) ? 0 : 1,\n                check = function (scope) {\n                    if (scope.config && Bridge.isPlainObject(scope.config) ||\n                        scope.$main && Bridge.isFunction(scope.$main) ||\n                        scope.hasOwnProperty(\"ctor\") && Bridge.isFunction(scope.ctor)) {\n                        defaultScheme = 1;\n                        return false;\n                    }\n\n                    if (scope.alias && Bridge.isArray(scope.alias) && scope.alias.length > 0 && scope.alias.length % 2 === 0) {\n                        return true;\n                    }\n\n                    for (var j = 0; j < rNames.length; j++) {\n                        if (scope[rNames[j]] && Bridge.isPlainObject(scope[rNames[j]])) {\n                            return true;\n                        }\n                    }\n                    return false;\n                },\n                alternateScheme = check(prop);\n\n            if (!alternateScheme && prop.statics) {\n                alternateScheme = check(prop.statics);\n            }\n\n            if (!alternateScheme) {\n                alternateScheme = defaultScheme == 0;\n            }\n\n            if (alternateScheme) {\n                prop = Bridge.Class.convertScheme(prop);\n            }\n\n            var extend = prop.$inherits || prop.inherits,\n                statics = prop.$statics || prop.statics,\n                isEntryPoint = prop.$entryPoint,\n                base,\n                prototype,\n                scope = prop.$scope || gscope || Bridge.global,\n                objectType = Bridge.global.System && Bridge.global.System.Object || Object,\n                i,\n                v,\n                isCtor,\n                ctorName,\n                name,\n                registerT = true;\n\n            prop.$kind = prop.$kind || \"class\";\n\n            if (prop.$kind === \"enum\") {\n                extend = [System.Enum];\n            }\n\n            if (prop.$noRegister === true) {\n                registerT = false;\n                delete prop.$noRegister;\n            }\n\n            if (prop.$inherits) {\n                delete prop.$inherits;\n            } else {\n                delete prop.inherits;\n            }\n\n            if (isEntryPoint) {\n                delete prop.$entryPoint;\n            }\n\n            if (Bridge.isFunction(statics)) {\n                statics = null;\n            } else if (prop.$statics) {\n                delete prop.$statics;\n            } else {\n                delete prop.statics;\n            }\n\n            var Class,\n                cls = prop.hasOwnProperty(\"ctor\") && prop.ctor;\n\n            if (!cls) {\n                if (prop.$literal) {\n                    Class = function (obj) {\n                        obj = obj || {};\n                        obj.$getType = function () { return Class };\n                        return obj;\n                    };\n                } else {\n                    Class = function () {\n                        this.$initialize();\n                        if (Class.$base) {\n                            if (Class.$$inherits && Class.$$inherits.length > 0 && Class.$$inherits[0].$staticInit) {\n                                Class.$$inherits[0].$staticInit();\n                            }\n\n                            if (Class.$base.ctor) {\n                                Class.$base.ctor.call(this);\n                            }\n                        }\n                    };\n                }\n\n                prop.ctor = Class;\n            } else {\n                Class = cls;\n            }\n\n            if (prop.$literal) {\n                if ((!statics || !statics.createInstance)) {\n                    Class.createInstance = function () {\n                        var obj = {};\n                        obj.$getType = function() { return Class };\n                        return obj;\n                    };\n                }\n\n                Class.$literal = true;\n                delete prop.$literal;\n            }\n\n            if (!isGenericInstance && registerT) {\n                scope = Bridge.Class.set(scope, className, Class);\n            }\n\n            if (gCfg) {\n                gCfg.fn.$cache.push({ type: Class, args: gCfg.args });\n            }\n\n            Class.$$name = className;\n            Class.$kind = prop.$kind;\n\n            if (gCfg && isGenericInstance) {\n                Class.$genericTypeDefinition = gCfg.fn;\n                Class.$typeArguments = gCfg.args;\n                Class.$assembly = gCfg.fn.$assembly || Bridge.$currentAssembly;\n\n                var result = Bridge.Reflection.getTypeFullName(gCfg.fn);\n\n                for (i = 0; i < gCfg.args.length; i++) {\n                    result += (i === 0 ? '[' : ',') + '[' + Bridge.Reflection.getTypeQName(gCfg.args[i]) + ']';\n                }\n\n                result += ']';\n\n                Class.$$fullname = result;\n            } else {\n                Class.$$fullname = Class.$$name;\n            }\n\n            if (extend && Bridge.isFunction(extend)) {\n                extend = extend();\n            }\n\n            Bridge.Class.createInheritors(Class, extend);\n\n            var noBase = extend ? extend[0].$kind === \"interface\" : true;\n\n            if (noBase) {\n                extend = null;\n            }\n\n            base = extend ? extend[0].prototype : this.prototype;\n            Class.$base = base;\n            prototype = extend ? (extend[0].$$initCtor ? new extend[0].$$initCtor() : new extend[0]()) : (objectType.$$initCtor ? new objectType.$$initCtor() : new objectType());\n\n            Class.$$initCtor = function () { };\n            Class.$$initCtor.prototype = prototype;\n            Class.$$initCtor.prototype.constructor = Class;\n            Class.$$initCtor.prototype.$$fullname = gCfg && isGenericInstance ? Class.$$fullname : Class.$$name;\n\n            if (statics) {\n                var staticsConfig = statics.$config || statics.config;\n\n                if (staticsConfig && !Bridge.isFunction(staticsConfig)) {\n                    Bridge.Class.initConfig(extend, base, staticsConfig, true, Class);\n\n                    if (statics.$config) {\n                        delete statics.$config;\n                    } else {\n                        delete statics.config;\n                    }\n                }\n            }\n\n            var instanceConfig = prop.$config || prop.config;\n\n            if (instanceConfig && !Bridge.isFunction(instanceConfig)) {\n                Bridge.Class.initConfig(extend, base, instanceConfig, false, prop, prototype);\n\n                if (prop.$config) {\n                    delete prop.$config;\n                } else {\n                    delete prop.config;\n                }\n            } else if (extend && base.$initMembers) {\n                prop.$initMembers = function () {\n                    base.$initMembers.call(this);\n                };\n            }\n\n            prop.$initialize = Bridge.Class._initialize;\n\n            var keys = [];\n\n            for (name in prop) {\n                keys.push(name);\n            }\n\n            for (i = 0; i < keys.length; i++) {\n                name = keys[i];\n\n                v = prop[name];\n                isCtor = name === \"ctor\";\n                ctorName = name;\n\n                if (Bridge.isFunction(v) && (isCtor || name.match(\"^\\\\$ctor\") !== null)) {\n                    isCtor = true;\n                }\n\n                var member = prop[name];\n                if (isCtor) {\n                    Class[ctorName] = member;\n                    Class[ctorName].prototype = prototype;\n                    Class[ctorName].prototype.constructor = Class;\n                    prototype[ctorName] = member;\n                } else {\n                    prototype[ctorName] = member;\n                }\n            }\n\n            prototype.$$name = className;\n\n            if (!prototype.toJSON) {\n                prototype.toJSON = Bridge.Class.toJSON;\n            }\n\n            if (statics) {\n                for (name in statics) {\n                    var member = statics[name];\n                    if (name === \"ctor\") {\n                        Class[\"$ctor\"] = member;\n                    } else {\n                        if (prop.$kind === \"enum\" && !Bridge.isFunction(member) && name.charAt(0) !== \"$\") {\n                            Class.$names = Class.$names || [];\n                            Class.$names.push({name: name, value: member});\n                        }\n\n                        Class[name] = member;\n                    }\n                }\n\n                if (prop.$kind === \"enum\" && Class.$names) {\n                    Class.$names = Class.$names.sort(function (i1, i2) {\n                        if (Bridge.isFunction(i1.value.eq)) {\n                            return i1.value.sub(i2.value).sign();\n                        }\n\n                        return i1.value - i2.value;\n                    }).map(function(i) {\n                        return i.name;\n                    });\n                }\n            }\n\n            if (!extend) {\n                extend = [objectType].concat(Class.$interfaces);\n            }\n\n            Bridge.Class.setInheritors(Class, extend);\n\n            fn = function () {\n                if (Bridge.Class.staticInitAllow && !Class.$isGenericTypeDefinition) {\n                    Class.$staticInit = null;\n\n                    if (Class.$initMembers) {\n                        Class.$initMembers();\n                    }\n\n                    if (Class.$ctor) {\n                        Class.$ctor();\n                    }\n                }\n            };\n\n            if (isEntryPoint || Bridge.isFunction(prototype.$main)) {\n                if (prototype.$main) {\n                    var entryName = prototype.$main.name || \"Main\";\n                    if (!Class[entryName]) {\n                        Class[entryName] = prototype.$main;\n                    }\n                }\n\n                Bridge.Class.$queueEntry.push(Class);\n            }\n\n            Class.$staticInit = fn;\n\n            if (!isGenericInstance && registerT) {\n                Bridge.Class.registerType(className, Class);\n            }\n\n            if (Bridge.Reflection) {\n                Class.$getMetadata = Bridge.Reflection.getMetadata;\n            }\n\n            if (Class.$kind === \"enum\") {\n                if (!Class.prototype.$utype) {\n                    Class.prototype.$utype = System.Int32;\n                }\n                Class.$is = function (instance) {\n                    var utype = Class.prototype.$utype;\n\n                    if (utype === String) {\n                        return typeof (instance) == \"string\";\n                    }\n\n                    if (utype && utype.$is) {\n                        return utype.$is(instance);\n                    }\n\n                    return typeof (instance) == \"number\";\n                };\n\n                Class.getDefaultValue = function () {\n                    var utype = Class.prototype.$utype;\n\n                    if (utype === String || utype === System.String) {\n                        return null;\n                    }\n\n                    return 0;\n                };\n            }\n\n            if (Class.$kind === \"interface\") {\n                if (Class.prototype.$variance) {\n                    Class.isAssignableFrom = Bridge.Class.varianceAssignable;\n                }\n\n                Class.$isInterface = true;\n            }\n\n            return Class;\n        },\n\n        toCtorString: function() {\n            return Bridge.Reflection.getTypeName(this);\n        },\n\n        createInheritors: function(cls, extend) {\n            var interfaces = [],\n                baseInterfaces = [],\n                descriptors = [],\n                aliases = [];\n\n            if (extend) {\n                for (var j = 0; j < extend.length; j++) {\n                    var baseType = extend[j],\n                        baseI = (baseType.$interfaces || []).concat(baseType.$baseInterfaces || []),\n                        baseDescriptors = baseType.$descriptors,\n                        baseAliases = baseType.$aliases;\n\n                    if (baseDescriptors && baseDescriptors.length > 0) {\n                        for (var d = 0; d < baseDescriptors.length; d++) {\n                            descriptors.push(baseDescriptors[d]);\n                        }\n                    }\n\n                    if (baseAliases && baseAliases.length > 0) {\n                        for (var d = 0; d < baseAliases.length; d++) {\n                            aliases.push(baseAliases[d]);\n                        }\n                    }\n\n                    if (baseI.length > 0) {\n                        for (var k = 0; k < baseI.length; k++) {\n                            if (baseInterfaces.indexOf(baseI[k]) < 0) {\n                                baseInterfaces.push(baseI[k]);\n                            }\n                        }\n                    }\n\n                    if (baseType.$kind === \"interface\") {\n                        interfaces.push(baseType);\n                    }\n                }\n            }\n\n            cls.$descriptors = descriptors;\n            cls.$aliases = aliases;\n            cls.$baseInterfaces = baseInterfaces;\n            cls.$interfaces = interfaces;\n            cls.$allInterfaces = interfaces.concat(baseInterfaces);\n        },\n\n        toJSON: function () {\n            var obj = {},\n                t = Bridge.getType(this),\n                descriptors = t.$descriptors || [];\n\n            for (var key in this) {\n                var own = this.hasOwnProperty(key),\n                    descriptor = null;\n\n                if (!own) {\n                    for (var i = descriptors.length - 1; i >= 0; i--) {\n                        if (descriptors[i].name === key) {\n                            descriptor = descriptors[i];\n                            break;\n                        }\n                    }\n                }\n\n                var dcount = key.split(\"$\").length;\n                if ((own || descriptor != null) && (dcount === 1 || dcount === 2 && key.match(\"\\$\\d+$\"))) {\n                    obj[key] = this[key];\n                }\n            }\n\n            return obj;\n        },\n\n        setInheritors: function(cls, extend) {\n            cls.$$inherits = extend;\n\n            for (var i = 0; i < extend.length; i++) {\n                var scope = extend[i];\n\n                if (!scope.$$inheritors) {\n                    scope.$$inheritors = [];\n                }\n\n                scope.$$inheritors.push(cls);\n            }\n        },\n\n        varianceAssignable: function (source) {\n            var check = function (target, type) {\n                if (type.$genericTypeDefinition === target.$genericTypeDefinition && type.$typeArguments.length === target.$typeArguments.length) {\n                    for (var i = 0; i < target.$typeArguments.length; i++) {\n                        var v = target.prototype.$variance[i], t = target.$typeArguments[i], s = type.$typeArguments[i];\n\n                        switch (v) {\n                            case 1: if (!Bridge.Reflection.isAssignableFrom(t, s))\n                                return false;\n                                break;\n                            case 2: if (!Bridge.Reflection.isAssignableFrom(s, t))\n                                return false;\n                                break;\n                            default: if (s !== t)\n                                return false;\n                        }\n                    }\n\n                    return true;\n                }\n\n                return false;\n            };\n\n            if (source.$kind === \"interface\" && check(this, source)) {\n                return true;\n            }\n\n            var ifs = Bridge.Reflection.getInterfaces(source);\n\n            for (var i = 0; i < ifs.length; i++) {\n                if (ifs[i] === this || check(this, ifs[i])) {\n                    return true;\n                }\n            }\n            return false;\n        },\n\n        registerType: function (className, cls) {\n            if (Bridge.$currentAssembly) {\n                Bridge.$currentAssembly.$types[className] = cls;\n                cls.$assembly = Bridge.$currentAssembly;\n            }\n        },\n\n        addExtend: function (cls, extend) {\n            var i,\n                scope;\n\n            Array.prototype.push.apply(cls.$$inherits, extend);\n            cls.$interfaces = cls.$interfaces || [];\n            cls.$baseInterfaces = cls.$baseInterfaces || [];\n\n            for (i = 0; i < extend.length; i++) {\n                scope = extend[i];\n\n                if (!scope.$$inheritors) {\n                    scope.$$inheritors = [];\n                }\n\n                scope.$$inheritors.push(cls);\n\n                var baseI = (scope.$interfaces || []).concat(scope.$baseInterfaces || []);\n\n                if (baseI.length > 0) {\n                    for (var k = 0; k < baseI.length; k++) {\n                        if (cls.$baseInterfaces.indexOf(baseI[k]) < 0) {\n                            cls.$baseInterfaces.push(baseI[k]);\n                        }\n                    }\n                }\n\n                if (scope.$kind === \"interface\") {\n                    cls.$interfaces.push(scope);\n                }\n            }\n\n            cls.$allInterfaces = cls.$interfaces.concat(cls.$baseInterfaces);\n        },\n\n        set: function (scope, className, cls, noDefineProp) {\n            var nameParts = className.split(\".\"),\n                name,\n                key,\n                exists,\n                i;\n\n            for (i = 0; i < (nameParts.length - 1) ; i++) {\n                if (typeof scope[nameParts[i]] == \"undefined\") {\n                    scope[nameParts[i]] = {};\n                }\n\n                scope = scope[nameParts[i]];\n            }\n\n            name = nameParts[nameParts.length - 1];\n            exists = scope[name];\n\n            if (exists) {\n                if (exists.$$name === className) {\n                    throw \"Class '\" + className + \"' is already defined\";\n                }\n\n                for (key in exists) {\n                    var o = exists[key];\n\n                    if (typeof o === \"function\" && o.$$name) {\n                        (function (cls, key, o) {\n                            Object.defineProperty(cls, key, {\n                                get: function () {\n                                    if (Bridge.Class.staticInitAllow) {\n                                        if (o.$staticInit) {\n                                            o.$staticInit();\n                                        }\n\n                                        Bridge.Class.defineProperty(cls, key, o);\n                                    }\n\n                                    return o;\n                                },\n\n                                set: function (newValue) {\n                                    o = newValue;\n                                },\n\n                                enumerable: true,\n\n                                configurable: true\n                            });\n                        })(cls, key, o);\n                    }\n                }\n            }\n\n            if (noDefineProp !== true) {\n                (function (scope, name, cls) {\n                    Object.defineProperty(scope, name, {\n                        get: function () {\n                            if (Bridge.Class.staticInitAllow) {\n                                if (cls.$staticInit) {\n                                    cls.$staticInit();\n                                }\n\n                                Bridge.Class.defineProperty(scope, name, cls);\n                            }\n\n                            return cls;\n                        },\n\n                        set: function (newValue) {\n                            cls = newValue;\n                        },\n\n                        enumerable: true,\n\n                        configurable: true\n                    });\n                })(scope, name, cls);\n            } else {\n                scope[name] = cls;\n            }\n\n            return scope;\n        },\n\n        defineProperty: function (scope, name, cls) {\n            Object.defineProperty(scope, name, {\n                value: cls,\n                enumerable: true,\n                configurable: true\n            });\n        },\n\n        genericName: function (name, typeArguments) {\n            var gName = name;\n\n            for (var i = 0; i < typeArguments.length; i++) {\n                var ta = typeArguments[i];\n\n                gName += \"$\" + (ta.$$name || Bridge.getTypeName(ta));\n            }\n\n            return gName;\n        },\n\n        getCachedType: function (fn, args) {\n            var arr = fn.$cache,\n                len = arr.length,\n                key,\n                found,\n                i, g;\n\n            for (i = 0; i < len; i++) {\n                key = arr[i];\n\n                if (key.args.length === args.length) {\n                    found = true;\n\n                    for (g = 0; g < key.args.length; g++) {\n                        if (key.args[g] !== args[g]) {\n                            found = false;\n\n                            break;\n                        }\n                    }\n\n                    if (found) {\n                        return key;\n                    }\n                }\n            }\n\n            return null;\n        },\n\n        generic: function (className, scope, fn, prop) {\n            fn.$$name = className;\n            fn.$kind = \"class\";\n\n            Bridge.Class.set(scope, className, fn, true);\n            Bridge.Class.registerType(className, fn);\n\n            fn.$typeArgumentCount = prop.length;\n            fn.$isGenericTypeDefinition = true;\n            fn.$getMetadata = Bridge.Reflection.getMetadata;\n\n            fn.$staticInit = function() {\n                fn.$typeArguments = Bridge.Reflection.createTypeParams(prop);\n\n                var old = Bridge.Class.staticInitAllow,\n                    oldIsBlocked = Bridge.Class.queueIsBlocked;\n                Bridge.Class.staticInitAllow = false;\n                Bridge.Class.queueIsBlocked = true;\n\n                var cfg = prop.apply(null, fn.$typeArguments),\n                    extend = cfg.$inherits || cfg.inherits;\n\n                Bridge.Class.staticInitAllow = old;\n                Bridge.Class.queueIsBlocked = oldIsBlocked;\n\n                if (extend && Bridge.isFunction(extend)) {\n                    extend = extend();\n                }\n\n                Bridge.Class.createInheritors(fn, extend);\n                var objectType = Bridge.global.System && Bridge.global.System.Object || Object;\n                if (!extend) {\n                    extend = [objectType].concat(fn.$interfaces);\n                }\n\n                Bridge.Class.setInheritors(fn, extend);\n\n                var prototype = extend ? (extend[0].$$initCtor ? new extend[0].$$initCtor() : new extend[0]()) : new objectType();\n                fn.prototype = prototype;\n                fn.prototype.constructor = fn;\n            };\n\n            Bridge.Class.$queue.push(fn);\n\n            return fn;\n        },\n\n        init: function (fn) {\n            if (fn) {\n                var old = Bridge.Class.staticInitAllow;\n                Bridge.Class.staticInitAllow = true;\n                fn();\n                Bridge.Class.staticInitAllow = old;\n                return;\n            }\n\n            Bridge.Class.staticInitAllow = true;\n\n            var queue = Bridge.Class.$queue.concat(Bridge.Class.$queueEntry);\n            Bridge.Class.$queue.length = 0;\n            Bridge.Class.$queueEntry.length = 0;\n\n            for (var i = 0; i < queue.length; i++) {\n                var t = queue[i];\n\n                if (t.$staticInit) {\n                    t.$staticInit();\n                }\n\n                if (t.prototype.$main) {\n                    (function(cls, name) {\n                        Bridge.ready(function () {\n                             cls[name]();\n                        });\n                    })(t, t.prototype.$main.name || \"Main\");\n\n                    t.prototype.$main = null;\n                }\n            }\n        }\n    };\n\n    Bridge.Class = base;\n    Bridge.Class.$queue = [];\n    Bridge.Class.$queueEntry = [];\n    Bridge.define = Bridge.Class.define;\n    Bridge.definei = Bridge.Class.definei;\n    Bridge.init = Bridge.Class.init;\n\n    // @source ReflectionAssembly.js\n\n    Bridge.assembly = function (assemblyName, res, callback) {\n        if (!callback) {\n            callback = res;\n            res = {};\n        }\n\n        assemblyName = assemblyName || \"Bridge.$Unknown\";\n\n        var asm = System.Reflection.Assembly.assemblies[assemblyName];\n\n        if (!asm) {\n            asm = new System.Reflection.Assembly(assemblyName, res);\n        } else {\n            Bridge.apply(asm.res, res || {});\n        }\n\n        Bridge.$currentAssembly = asm;\n\n        if (callback) {\n            var old = Bridge.Class.staticInitAllow;\n            Bridge.Class.staticInitAllow = false;\n\n            callback.call(Bridge.global, asm, Bridge.global);\n\n            Bridge.Class.staticInitAllow = old;\n        }\n\n        Bridge.init();\n    };\n\n    Bridge.define(\"System.Reflection.Assembly\", {\n        statics: {\n            assemblies: {}\n        },\n\n        ctor: function (name, res) {\n            this.$initialize();\n            this.name = name;\n            this.res = res || {};\n            this.$types = {};\n            this.$ = {};\n\n            System.Reflection.Assembly.assemblies[name] = this;\n        },\n\n        toString: function () {\n            return this.name;\n        },\n\n        getManifestResourceNames: function () {\n            return Object.keys(this.res);\n        },\n\n        getManifestResourceDataAsBase64: function (type, name) {\n            if (arguments.length === 1) {\n                name = type;\n                type = null;\n            }\n\n            if (type) {\n                name = Bridge.Reflection.getTypeNamespace(type) + \".\" + name;\n            }\n\n            return this.res[name] || null;\n        },\n\n        getManifestResourceData: function (type, name) {\n            if (arguments.length === 1) {\n                name = type;\n                type = null;\n            }\n\n            if (type) {\n                name = Bridge.Reflection.getTypeNamespace(type) + '.' + name;\n            }\n\n            var r = this.res[name];\n\n            return r ? System.Convert.fromBase64String(r) : null;\n        },\n\n        getCustomAttributes: function (attributeType) {\n            if (attributeType && !Bridge.isBoolean(attributeType)) {\n                return this.attr.filter(function (a) {\n                    return Bridge.is(a, attributeType);\n                });\n            }\n\n            return this.attr;\n        }\n    });\n\n    Bridge.$currentAssembly = new System.Reflection.Assembly(\"mscorlib\");\n    Bridge.SystemAssembly = Bridge.$currentAssembly;\n    Bridge.SystemAssembly.$types[\"System.Reflection.Assembly\"] = System.Reflection.Assembly;\n    System.Reflection.Assembly.$assembly = Bridge.SystemAssembly;\n    var $asm = Bridge.$currentAssembly;\n\n    // @source Object.js\n\n    Bridge.define(\"System.Object\", {\n        \n    });\n\n    Bridge.define(\"System.Void\", {\n        $kind: \"struct\"\n    });\n    // @source systemAssemblyVersion.js\n\n    Bridge.init(function () {\n        Bridge.SystemAssembly.version = \"16.3.2\";\n        Bridge.SystemAssembly.compiler = \"16.3.2\";\n    });\n\n    Bridge.define(\"Bridge.Utils.SystemAssemblyVersion\");\n\n    // @source Reflection.js\n\n    Bridge.Reflection = {\n        setMetadata: function (type, metadata) {\n            type.$getMetadata = Bridge.Reflection.getMetadata;\n            type.$metadata = metadata;\n        },\n\n        initMetaData: function (type, metadata) {\n            if (metadata.m) {\n                for (var i = 0; i < metadata.m.length; i++) {\n                    var m = metadata.m[i];\n\n                    m.td = type;\n\n                    if (m.ad) {\n                        m.ad.td = type;\n                    }\n\n                    if (m.r) {\n                        m.r.td = type;\n                    }\n\n                    if (m.g) {\n                        m.g.td = type;\n                    }\n\n                    if (m.s) {\n                        m.s.td = type;\n                    }\n\n                    if (m.tprm && Bridge.isArray(m.tprm)) {\n                        for (var j = 0; j < m.tprm.length; j++) {\n                            m.tprm[j] = Bridge.Reflection.createTypeParam(m.tprm[j], type);\n                        }\n                    }\n                }\n            }\n\n            type.$metadata = metadata;\n            type.$initMetaData = true;\n        },\n\n        getMetadata: function () {\n            if (!this.$metadata && this.$genericTypeDefinition) {\n                this.$metadata = this.$genericTypeDefinition.$factoryMetadata || this.$genericTypeDefinition.$metadata;\n            }\n\n            var metadata = this.$metadata;\n\n            if (typeof (metadata) === \"function\") {\n                if (this.$isGenericTypeDefinition && !this.$factoryMetadata) {\n                    this.$factoryMetadata = this.$metadata;\n                }\n\n                if (this.$typeArguments) {\n                    metadata = this.$metadata.apply(null, this.$typeArguments);\n                } else if (this.$isGenericTypeDefinition) {\n                    var arr = Bridge.Reflection.createTypeParams(this.$metadata);\n                    this.$typeArguments = arr;\n                    metadata = this.$metadata.apply(null, arr);\n                } else {\n                    metadata = this.$metadata();\n                }\n            }\n\n            if (!this.$initMetaData && metadata) {\n                Bridge.Reflection.initMetaData(this, metadata);\n            }\n\n            return metadata;\n        },\n\n        createTypeParams: function (fn, t) {\n            var args,\n                names = [],\n                fnStr = fn.toString();\n\n            args = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(/([^\\s,]+)/g) || [];\n            for (var i = 0; i < args.length; i++) {\n                names.push(Bridge.Reflection.createTypeParam(args[i], t));\n            }\n\n            return names;\n        },\n\n        createTypeParam: function (name, t) {\n            var fn = function TypeParameter() { };\n            fn.$$name = name;\n            fn.$isTypeParameter = true;\n            if (t) {\n                fn.td = t;\n            }\n            return fn;\n        },\n\n        load: function (name) {\n            return System.Reflection.Assembly.assemblies[name] || require(name);\n        },\n\n        getGenericTypeDefinition: function (type) {\n            if (type.$isGenericTypeDefinition) {\n                return type;\n            }\n\n            if (!type.$genericTypeDefinition) {\n                throw new System.InvalidOperationException(\"This operation is only valid on generic types.\");\n            }\n\n            return type.$genericTypeDefinition;\n        },\n\n        getGenericParameterCount: function (type) {\n            return type.$typeArgumentCount || 0;\n        },\n\n        getGenericArguments: function (type) {\n            return type.$typeArguments || [];\n        },\n\n        getMethodGenericArguments: function (m) {\n            return m.tprm || [];\n        },\n\n        isGenericTypeDefinition: function (type) {\n            return type.$isGenericTypeDefinition || false;\n        },\n\n        isGenericType: function (type) {\n            return type.$genericTypeDefinition != null || Bridge.Reflection.isGenericTypeDefinition(type);\n        },\n\n        convertType: function(type) {\n            if (type === Boolean) {\n                return System.Boolean;\n            }\n\n            if (type === String) {\n                return System.String;\n            }\n\n            if (type === Object) {\n                return System.Object;\n            }\n\n            if (type === Date) {\n                return System.DateTime;\n            }\n\n            return type;\n        },\n\n        getBaseType: function (type) {\n            if (Bridge.isObject(type) || type.$kind === \"interface\" || type.prototype == null) {\n                return null;\n            } else if (Object.getPrototypeOf) {\n                return Bridge.Reflection.convertType(Object.getPrototypeOf(type.prototype).constructor);\n            } else {\n                var p = type.prototype;\n\n                if (Object.prototype.hasOwnProperty.call(p, \"constructor\")) {\n                    var ownValue;\n\n                    try {\n                        ownValue = p.constructor;\n                        delete p.constructor;\n                        return Bridge.Reflection.convertType(p.constructor);\n                    }\n                    finally {\n                        p.constructor = ownValue;\n                    }\n                }\n\n                return Bridge.Reflection.convertType(p.constructor);\n            }\n        },\n\n        getTypeFullName: function (obj) {\n            var str;\n\n            if (obj.$$fullname) {\n                str = obj.$$fullname;\n            } else if (obj.$$name) {\n                str = obj.$$name;\n            }\n\n            if (str) {\n                var ns = Bridge.Reflection.getTypeNamespace(obj, str);\n\n                if (ns) {\n                    var idx = str.indexOf(\"[\");\n                    var name = str.substring(ns.length + 1, idx === -1 ? str.length : idx);\n\n                    if (new RegExp(/[\\.\\$]/).test(name)) {\n                        str = ns + \".\" + name.replace(/\\.|\\$/g, function (match) { return (match === \".\") ? \"+\" : \"`\"; }) + (idx === -1 ? \"\" : str.substring(idx));\n                    }\n                }\n\n                return str;\n            }\n\n            if (obj.constructor === Object) {\n                str = obj.toString();\n                var match = (/\\[object (.{1,})\\]/).exec(str);\n                return (match && match.length > 1) ? match[1] : \"Object\";\n            } else if (obj.constructor === Function) {\n                str = obj.toString();\n            } else {\n                str = obj.constructor.toString();\n            }\n\n            var results = (/function (.{1,})\\(/).exec(str);\n\n            return (results && results.length > 1) ? results[1] : \"System.Object\";\n        },\n\n        _makeQName: function (name, asm) {\n            return name + (asm ? ', ' + asm.name : '');\n        },\n\n        getTypeQName: function (type) {\n            return Bridge.Reflection._makeQName(Bridge.Reflection.getTypeFullName(type), type.$assembly);\n        },\n\n        getTypeName: function (type) {\n            var fullName = Bridge.Reflection.getTypeFullName(type),\n                bIndex = fullName.indexOf('['),\n                pIndex = fullName.lastIndexOf('+', bIndex >= 0 ? bIndex : fullName.length),\n                nsIndex = pIndex > -1 ? pIndex : fullName.lastIndexOf('.', bIndex >= 0 ? bIndex : fullName.length);\n\n            return nsIndex > 0 ? (bIndex >= 0 ? fullName.substring(nsIndex + 1, bIndex) : fullName.substr(nsIndex + 1)) : fullName;\n        },\n\n        getTypeNamespace: function (type, name) {\n            var fullName = name || Bridge.Reflection.getTypeFullName(type),\n                bIndex = fullName.indexOf('['),\n                nsIndex = fullName.lastIndexOf('.', bIndex >= 0 ? bIndex : fullName.length),\n                ns = nsIndex > 0 ? fullName.substr(0, nsIndex) : '';\n\n            if (type.$assembly) {\n                var parentType = Bridge.Reflection._getAssemblyType(type.$assembly, ns);\n\n                if (parentType) {\n                    ns = Bridge.Reflection.getTypeNamespace(parentType);\n                }\n            }\n\n            return ns;\n        },\n\n        getTypeAssembly: function (type) {\n            if (System.Array.contains([Date, Number, Boolean, String, Function, Array], type) || type.$isArray) {\n                return Bridge.SystemAssembly;\n            } else {\n                return type.$assembly || Bridge.SystemAssembly;\n            }\n        },\n\n        _extractArrayRank: function (name) {\n            var rank = -1,\n                m = (/<(\\d+)>$/g).exec(name);\n\n            if (m) {\n                name = name.substring(0, m.index);\n                rank = parseInt(m[1]);\n            }\n\n            m = (/\\[(,*)\\]$/g).exec(name);\n            if (m) {\n                name = name.substring(0, m.index);\n                rank = m[1].length + 1;\n            }\n\n            return {\n                rank: rank,\n                name: name\n            };\n        },\n\n        _getAssemblyType: function (asm, name) {\n            var noAsm = false,\n                rank = -1;\n\n            if (new RegExp(/[\\+\\`]/).test(name)) {\n                name = name.replace(/\\+|\\`/g, function(match) { return match === \"+\" ? \".\" : \"$\"});\n            }\n\n            if (!asm) {\n                asm = Bridge.SystemAssembly;\n                noAsm = true;\n            }\n\n            var rankInfo = Bridge.Reflection._extractArrayRank(name);\n            rank = rankInfo.rank;\n            name = rankInfo.name;\n\n            if (asm.$types) {\n                var t = asm.$types[name] || null;\n\n                if (t) {\n                    return rank > -1 ? System.Array.type(t, rank) : t;\n                }\n\n                if (asm.name === \"mscorlib\") {\n                    asm = Bridge.global;\n                } else {\n                    return null;\n                }\n            }\n\n            var a = name.split('.'),\n                scope = asm;\n\n            for (var i = 0; i < a.length; i++) {\n                scope = scope[a[i]];\n\n                if (!scope) {\n                    return null;\n                }\n            }\n\n            if (typeof scope !== 'function' || !noAsm && scope.$assembly && asm.name !== scope.$assembly.name) {\n                return null;\n            }\n\n            return rank > -1 ? System.Array.type(scope, rank) : scope;\n        },\n\n        getAssemblyTypes: function (asm) {\n            var result = [];\n\n            if (asm.$types) {\n                for (var t in asm.$types) {\n                    if (asm.$types.hasOwnProperty(t)) {\n                        result.push(asm.$types[t]);\n                    }\n                }\n            } else {\n                var traverse = function (s, n) {\n                    for (var c in s) {\n                        if (s.hasOwnProperty(c)) {\n                            traverse(s[c], c);\n                        }\n                    }\n\n                    if (typeof (s) === 'function' && Bridge.isUpper(n.charCodeAt(0))) {\n                        result.push(s);\n                    }\n                };\n\n                traverse(asm, '');\n            }\n\n            return result;\n        },\n\n        createAssemblyInstance: function (asm, typeName) {\n            var t = Bridge.Reflection.getType(typeName, asm);\n\n            return t ? Bridge.createInstance(t) : null;\n        },\n\n        getInterfaces: function (type) {\n            var t;\n\n            if (type.$allInterfaces) {\n                return type.$allInterfaces;\n            } else if (type === Date) {\n                return [System.IComparable$1(Date), System.IEquatable$1(Date), System.IComparable, System.IFormattable];\n            } else if (type === Number) {\n                return [System.IComparable$1(Bridge.Int), System.IEquatable$1(Bridge.Int), System.IComparable, System.IFormattable];\n            } else if (type === Boolean) {\n                return [System.IComparable$1(Boolean), System.IEquatable$1(Boolean), System.IComparable];\n            } else if (type === String) {\n                return [System.IComparable$1(String), System.IEquatable$1(String), System.IComparable, System.ICloneable, System.Collections.IEnumerable, System.Collections.Generic.IEnumerable$1(System.Char)];\n            } else if (type === Array || type.$isArray || (t = System.Array._typedArrays[Bridge.getTypeName(type)])) {\n                t = t || type.$elementType || System.Object;\n                return [System.Collections.IEnumerable, System.Collections.ICollection, System.ICloneable, System.Collections.IList, System.Collections.Generic.IEnumerable$1(t), System.Collections.Generic.ICollection$1(t), System.Collections.Generic.IList$1(t)];\n            } else {\n                return [];\n            }\n        },\n\n        isInstanceOfType: function (instance, type) {\n            return Bridge.is(instance, type);\n        },\n\n        isAssignableFrom: function (baseType, type) {\n            if (baseType == null) {\n                throw new System.NullReferenceException();\n            }\n\n            if (type == null) {\n                return false;\n            }\n\n            if (baseType === type || Bridge.isObject(baseType)) {\n                return true;\n            }\n\n            if (Bridge.isFunction(baseType.isAssignableFrom)) {\n                return baseType.isAssignableFrom(type);\n            }\n\n            if (type === Array) {\n                return System.Array.is([], baseType);\n            }\n\n            if (Bridge.Reflection.isInterface(baseType) && System.Array.contains(Bridge.Reflection.getInterfaces(type), baseType)) {\n                return true;\n            }\n\n            var inheritors = type.$$inherits,\n                i,\n                r;\n\n            if (inheritors) {\n                for (i = 0; i < inheritors.length; i++) {\n                    r = Bridge.Reflection.isAssignableFrom(baseType, inheritors[i]);\n\n                    if (r) {\n                        return true;\n                    }\n                }\n            }\n\n            return false;\n        },\n\n        isClass: function (type) {\n            return (type.$kind === \"class\" || type === Array || type === Function || type === RegExp || type === String || type === Error || type === Object);\n        },\n\n        isEnum: function (type) {\n            return type.$kind === \"enum\";\n        },\n\n        isFlags: function (type) {\n            return !!(type.prototype && type.prototype.$flags);\n        },\n\n        isInterface: function (type) {\n            return type.$kind === \"interface\";\n        },\n\n        _getType: function (typeName, asm, re, noinit) {\n            var outer = !re;\n\n            if (outer) {\n                typeName = typeName.replace(/\\[(,*)\\]/g, function (match, g1) {\n                    return \"<\" + (g1.length + 1) + \">\"\n                });\n            }\n\n            var next = function () {\n                for (; ;) {\n                    var m = re.exec(typeName);\n\n                    if (m && m[0] == \"[\" && (typeName[m.index + 1] === ']' || typeName[m.index + 1] === ',')) {\n                        continue;\n                    }\n\n                    if (m && m[0] == \"]\" && (typeName[m.index - 1] === '[' || typeName[m.index - 1] === ',')) {\n                        continue;\n                    }\n\n                    if (m && m[0] == \",\" && (typeName[m.index + 1] === ']' || typeName[m.index + 1] === ',')) {\n                        continue;\n                    }\n\n                    return m;\n                }\n            };\n\n            re = re || /[[,\\]]/g;\n\n            var last = re.lastIndex,\n                m = next(),\n                tname,\n                targs = [],\n                t,\n                noasm = !asm;\n\n            //asm = asm || Bridge.$currentAssembly;\n\n            if (m) {\n                tname = typeName.substring(last, m.index);\n\n                switch (m[0]) {\n                    case '[':\n                        if (typeName[m.index + 1] !== '[') {\n                            return null;\n                        }\n\n                        for (; ;) {\n                            next();\n                            t = Bridge.Reflection._getType(typeName, null, re);\n\n                            if (!t) {\n                                return null;\n                            }\n\n                            targs.push(t);\n                            m = next();\n\n                            if (m[0] === ']') {\n                                break;\n                            } else if (m[0] !== ',') {\n                                return null;\n                            }\n                        }\n\n                        var arrMatch = (/^\\s*<(\\d+)>/g).exec(typeName.substring(m.index+1));\n                        if (arrMatch) {\n                            tname = tname + \"<\" + parseInt(arrMatch[1]) + \">\";\n                        }\n\n                        m = next();\n\n                        if (m && m[0] === ',') {\n                            next();\n\n                            if (!(asm = System.Reflection.Assembly.assemblies[(re.lastIndex > 0 ? typeName.substring(m.index + 1, re.lastIndex - 1) : typeName.substring(m.index + 1)).trim()])) {\n                                return null;\n                            }\n                        }\n                        break;\n\n                    case ']':\n                        break;\n\n                    case ',':\n                        next();\n\n                        if (!(asm = System.Reflection.Assembly.assemblies[(re.lastIndex > 0 ? typeName.substring(m.index + 1, re.lastIndex - 1) : typeName.substring(m.index + 1)).trim()])) {\n                            return null;\n                        }\n\n                        break;\n                }\n            } else {\n                tname = typeName.substring(last);\n            }\n\n            if (outer && re.lastIndex) {\n                return null;\n            }\n\n            tname = tname.trim();\n            var rankInfo = Bridge.Reflection._extractArrayRank(tname);\n            var rank = rankInfo.rank;\n            tname = rankInfo.name;\n\n            t = Bridge.Reflection._getAssemblyType(asm, tname);\n\n            if (noinit) {\n                return t;\n            }\n\n            if (!t && noasm) {\n                for (var asmName in System.Reflection.Assembly.assemblies) {\n                    if (System.Reflection.Assembly.assemblies.hasOwnProperty(asmName) && System.Reflection.Assembly.assemblies[asmName] !== asm) {\n                        t = Bridge.Reflection._getType(typeName, System.Reflection.Assembly.assemblies[asmName], null,true);\n\n                        if (t) {\n                            break;\n                        }\n                    }\n                }\n            }\n\n            t = targs.length ? t.apply(null, targs) : t;\n\n            if (t && t.$staticInit) {\n                t.$staticInit();\n            }\n\n            if (rank > -1) {\n                t = System.Array.type(t, rank);\n            }\n\n            return t;\n        },\n\n        getType: function (typeName, asm) {\n            if (typeName == null) {\n                throw new System.ArgumentNullException(\"typeName\");\n            }\n            return typeName ? Bridge.Reflection._getType(typeName, asm) : null;\n        },\n\n        canAcceptNull: function (type) {\n            if (type.$kind === \"struct\" ||\n                type === System.Decimal ||\n                type === System.Int64 ||\n                type === System.UInt64 ||\n                type === System.Double ||\n                type === System.Single ||\n                type === System.Byte ||\n                type === System.SByte ||\n                type === System.Int16 ||\n                type === System.UInt16 ||\n                type === System.Int32 ||\n                type === System.UInt32 ||\n                type === Bridge.Int ||\n                type === Boolean ||\n                type === Date ||\n                type === Number) {\n                return false;\n            }\n\n            return true;\n        },\n\n        applyConstructor: function (constructor, args) {\n            if (!args || args.length === 0) {\n                return new constructor();\n            }\n\n            if (constructor.$$initCtor && constructor.$kind !== \"anonymous\") {\n                var md = Bridge.getMetadata(constructor),\n                    count = 0;\n\n                if (md) {\n                    var ctors = Bridge.Reflection.getMembers(constructor, 1, 28),\n                        found;\n\n                    for (var j = 0; j < ctors.length; j++) {\n                        var ctor = ctors[j];\n\n                        if (ctor.p && ctor.p.length === args.length) {\n                            found = true;\n\n                            for (var k = 0; k < ctor.p.length; k++) {\n                                var p = ctor.p[k];\n\n                                if (!Bridge.is(args[k], p) || args[k] == null && !Bridge.Reflection.canAcceptNull(p)) {\n                                    found = false;\n                                    break;\n                                }\n                            }\n\n                            if (found) {\n                                constructor = constructor[ctor.sn];\n                                count++;\n                            }\n                        }\n                    }\n                } else {\n                    if (Bridge.isFunction(constructor.ctor) && constructor.ctor.length === args.length) {\n                        constructor = constructor.ctor;\n                    } else {\n                        var name = \"$ctor\",\n                            i = 1;\n\n                        while (Bridge.isFunction(constructor[name + i])) {\n                            if (constructor[name + i].length === args.length) {\n                                constructor = constructor[name + i];\n                                count++;\n                            }\n\n                            i++;\n                        }\n                    }\n                }\n\n                if (count > 1) {\n                    throw new System.Exception(\"The ambiguous constructor call\");\n                }\n            }\n\n            var f = function () {\n                constructor.apply(this, args);\n            };\n\n            f.prototype = constructor.prototype;\n\n            return new f();\n        },\n\n        getAttributes: function (type, attrType, inherit) {\n            var result = [],\n                i,\n                t,\n                a,\n                md,\n                type_md;\n\n            if (inherit) {\n                var b = Bridge.Reflection.getBaseType(type);\n\n                if (b) {\n                    a = Bridge.Reflection.getAttributes(b, attrType, true);\n\n                    for (i = 0; i < a.length; i++) {\n                        t = Bridge.getType(a[i]);\n                        md = Bridge.getMetadata(t);\n\n                        if (!md || !md.ni) {\n                            result.push(a[i]);\n                        }\n                    }\n                }\n            }\n\n            type_md = Bridge.getMetadata(type);\n\n            if (type_md && type_md.at) {\n                for (i = 0; i < type_md.at.length; i++) {\n                    a = type_md.at[i];\n\n                    if (attrType == null || Bridge.Reflection.isInstanceOfType(a, attrType)) {\n                        t = Bridge.getType(a);\n                        md = Bridge.getMetadata(t);\n\n                        if (!md || !md.am) {\n                            for (var j = result.length - 1; j >= 0; j--) {\n                                if (Bridge.Reflection.isInstanceOfType(result[j], t)) {\n                                    result.splice(j, 1);\n                                }\n                            }\n                        }\n\n                        result.push(a);\n                    }\n                }\n            }\n\n            return result;\n        },\n\n        getMembers: function (type, memberTypes, bindingAttr, name, params) {\n            var result = [];\n\n            if ((bindingAttr & 72) === 72 || (bindingAttr & 6) === 4) {\n                var b = Bridge.Reflection.getBaseType(type);\n\n                if (b) {\n                    result = Bridge.Reflection.getMembers(b, memberTypes & ~1, bindingAttr & (bindingAttr & 64 ? 255 : 247) & (bindingAttr & 2 ? 251 : 255), name, params);\n                }\n            }\n\n            var f = function (m) {\n                if ((memberTypes & m.t) && (((bindingAttr & 4) && !m.is) || ((bindingAttr & 8) && m.is)) && (!name || ((bindingAttr & 1) === 1 ? (m.n.toUpperCase() === name.toUpperCase()) : (m.n === name)))) {\n                    if ((bindingAttr & 16) === 16 && m.a === 2 ||\n                        (bindingAttr & 32) === 32 && m.a !== 2) {\n                        if (params) {\n                            if ((m.p || []).length !== params.length) {\n                                return;\n                            }\n\n                            for (var i = 0; i < params.length; i++) {\n                                if (params[i] !== m.p[i]) {\n                                    return;\n                                }\n                            }\n                        }\n\n                        result.push(m);\n                    }\n                }\n            };\n\n            var type_md = Bridge.getMetadata(type);\n\n            if (type_md && type_md.m) {\n                var mNames = ['g', 's', 'ad', 'r'];\n\n                for (var i = 0; i < type_md.m.length; i++) {\n                    var m = type_md.m[i];\n\n                    f(m);\n\n                    for (var j = 0; j < 4; j++) {\n                        var a = mNames[j];\n\n                        if (m[a]) {\n                            f(m[a]);\n                        }\n                    }\n                }\n            }\n\n            if (bindingAttr & 256) {\n                while (type) {\n                    var r = [];\n\n                    for (var i = 0; i < result.length; i++) {\n                        if (result[i].td === type) {\n                            r.push(result[i]);\n                        }\n                    }\n\n                    if (r.length > 1) {\n                        throw new System.Reflection.AmbiguousMatchException('Ambiguous match');\n                    } else if (r.length === 1) {\n                        return r[0];\n                    }\n\n                    type = Bridge.Reflection.getBaseType(type);\n                }\n\n                return null;\n            }\n\n            return result;\n        },\n\n        createDelegate: function(mi, firstArgument) {\n            var isStatic = mi.is || mi.sm,\n                bind = firstArgument != null && !isStatic,\n                method = Bridge.Reflection.midel(mi, firstArgument, null, bind);\n\n            if (!bind) {\n                if (isStatic) {\n                    return function () {\n                        var args = firstArgument != null ? [firstArgument] : [];\n                        return method.apply(mi.td, args.concat(Array.prototype.slice.call(arguments, 0)));\n                    };\n                }\n                else {\n                    return function (target) {\n                        return method.apply(target, Array.prototype.slice.call(arguments, 1));\n                    };\n                }\n            }\n\n            return method;\n        },\n\n        midel: function (mi, target, typeArguments, bind) {\n            if (bind !== false) {\n                if (mi.is && !!target) {\n                    throw new System.ArgumentException('Cannot specify target for static method');\n                } else if (!mi.is && !target) {\n                    throw new System.ArgumentException('Must specify target for instance method');\n                }\n            }\n\n            var method;\n\n            if (mi.fg) {\n                method = function () { return (mi.is ? mi.td : this)[mi.fg]; };\n            } else if (mi.fs) {\n                method = function (v) { (mi.is ? mi.td : this)[mi.fs] = v; };\n            } else {\n                method = mi.def || (mi.is || mi.sm ? mi.td[mi.sn] : (target ? target[mi.sn] : mi.td.prototype[mi.sn]));\n\n                if (mi.tpc) {\n                    if (!typeArguments || typeArguments.length !== mi.tpc) {\n                        throw new System.ArgumentException('Wrong number of type arguments');\n                    }\n\n                    var gMethod = method;\n\n                    method = function () {\n                        return gMethod.apply(this, typeArguments.concat(Array.prototype.slice.call(arguments)));\n                    }\n                } else {\n                    if (typeArguments && typeArguments.length) {\n                        throw new System.ArgumentException('Cannot specify type arguments for non-generic method');\n                    }\n                }\n\n                if (mi.exp) {\n                    var _m1 = method;\n\n                    method = function () { return _m1.apply(this, Array.prototype.slice.call(arguments, 0, arguments.length - 1).concat(arguments[arguments.length - 1])); };\n                }\n\n                if (mi.sm) {\n                    var _m2 = method;\n\n                    method = function () { return _m2.apply(null, [this].concat(Array.prototype.slice.call(arguments))); };\n                }\n            }\n\n            if (mi.box) {\n                var unboxed = method;\n                method = function() {\n                    var v = unboxed.apply(this, arguments);\n                    return v != null ? mi.box(v) : v;\n                };\n            }\n\n            return bind !== false ? Bridge.fn.bind(target, method) : method;\n        },\n\n        invokeCI: function (ci, args) {\n            if (ci.exp) {\n                args = args.slice(0, args.length - 1).concat(args[args.length - 1]);\n            }\n\n            if (ci.def) {\n                return ci.def.apply(null, args);\n            } else if (ci.sm) {\n                return ci.td[ci.sn].apply(null, args);\n            } else {\n                return Bridge.Reflection.applyConstructor(ci.sn ? ci.td[ci.sn] : ci.td, args);\n            }\n        },\n\n        fieldAccess: function (fi, obj) {\n            if (fi.is && !!obj) {\n                throw new System.ArgumentException('Cannot specify target for static field');\n            } else if (!fi.is && !obj) {\n                throw new System.ArgumentException('Must specify target for instance field');\n            }\n\n            obj = fi.is ? fi.td : obj;\n\n            if (arguments.length === 3) {\n                obj[fi.sn] = arguments[2];\n            } else {\n                return fi.box ? fi.box(obj[fi.sn]) : obj[fi.sn];\n            }\n        },\n\n        getMetaValue: function (type, name, dv) {\n            var md = type.$isTypeParameter ? type : Bridge.getMetadata(type);\n            return md ? (md[name] || dv) : dv;\n        },\n\n        isArray: function (type) {\n            return Bridge.arrayTypes.indexOf(type) >= 0;\n        },\n\n        hasGenericParameters: function (type) {\n            if (type.$typeArguments) {\n                for (var i = 0; i < type.$typeArguments.length; i++) {\n                    if (type.$typeArguments[i].$isTypeParameter) {\n                        return true;\n                    }\n                }\n            }\n\n            return false;\n        }\n    };\n\n    Bridge.setMetadata = Bridge.Reflection.setMetadata;\n\n    System.Reflection.ConstructorInfo = {\n        $is: function (obj) {\n            return obj != null && obj.t === 1;\n        }\n    };\n\n    System.Reflection.EventInfo = {\n        $is: function (obj) {\n            return obj != null && obj.t === 2;\n        }\n    };\n\n    System.Reflection.FieldInfo = {\n        $is: function (obj) {\n            return obj != null && obj.t === 4;\n        }\n    };\n\n    System.Reflection.MethodBase = {\n        $is: function (obj) {\n            return obj != null && (obj.t === 1 || obj.t === 8);\n        }\n    };\n\n    System.Reflection.MethodInfo = {\n        $is: function (obj) {\n            return obj != null && obj.t === 8;\n        }\n    };\n\n    System.Reflection.PropertyInfo = {\n        $is: function (obj) {\n            return obj != null && obj.t === 16;\n        }\n    };\n\n    System.AppDomain = {\n        getAssemblies: function () {\n            return Object.keys(System.Reflection.Assembly.assemblies).map(function (n) { return System.Reflection.Assembly.assemblies[n]; });\n        }\n    };\n\n    // @source Interfaces.js\n\n    Bridge.define(\"System.IFormattable\", {\n        $kind: \"interface\",\n        statics: {\n            $is: function (obj) {\n                if (Bridge.isNumber(obj) || Bridge.isDate(obj)) {\n                    return true;\n                }\n\n                return Bridge.is(obj, System.IFormattable, true);\n            }\n        }\n    });\n\n    Bridge.define(\"System.IComparable\", {\n        $kind: \"interface\",\n\n        statics: {\n            $is: function (obj) {\n                if (Bridge.isNumber(obj) || Bridge.isDate(obj) || Bridge.isBoolean(obj) || Bridge.isString(obj)) {\n                    return true;\n                }\n\n                return Bridge.is(obj, System.IComparable, true);\n            }\n        }\n    });\n\n    Bridge.define(\"System.IFormatProvider\", {\n        $kind: \"interface\"\n    });\n\n    Bridge.define(\"System.ICloneable\", {\n        $kind: \"interface\"\n    });\n\n    Bridge.define('System.IComparable$1', function (T) {\n        return {\n            $kind: \"interface\",\n\n            statics: {\n                $is: function (obj) {\n                    if (Bridge.isNumber(obj) && T.$number && T.$is(obj) || Bridge.isDate(obj) && (T === Date || T === System.DateTime) || Bridge.isBoolean(obj) && (T === Boolean || T === System.Boolean) || Bridge.isString(obj) && (T === String || T === System.String)) {\n                        return true;\n                    }\n\n                    return Bridge.is(obj, System.IComparable$1(T), true);\n                },\n\n                isAssignableFrom: function (type) {\n                    if (type === System.DateTime && T === Date) {\n                        return true;\n                    }\n\n                    return Bridge.Reflection.getInterfaces(type).indexOf(System.IComparable$1(T)) >= 0;\n                }\n            }\n        };\n    });\n\n    Bridge.define('System.IEquatable$1', function (T) {\n        return {\n            $kind: \"interface\",\n\n            statics: {\n                $is: function (obj) {\n                    if (Bridge.isNumber(obj) && T.$number && T.$is(obj) || Bridge.isDate(obj) && (T === Date || T === System.DateTime) || Bridge.isBoolean(obj) && (T === Boolean || T === System.Boolean) || Bridge.isString(obj) && (T === String || T === System.String)) {\n                        return true;\n                    }\n\n                    return Bridge.is(obj, System.IEquatable$1(T), true);\n                },\n\n                isAssignableFrom: function (type) {\n                    if (type === System.DateTime && T === Date) {\n                        return true;\n                    }\n\n                    return Bridge.Reflection.getInterfaces(type).indexOf(System.IEquatable$1(T)) >= 0;\n                }\n            }\n        };\n    });\n\n    Bridge.define(\"Bridge.IPromise\", {\n        $kind: \"interface\"\n    });\n\n    Bridge.define(\"System.IDisposable\", {\n        $kind: \"interface\"\n    });\n\n    Bridge.define(\"System.IAsyncResult\", {\n        $kind: \"interface\"\n    });\n\n    // @source Enum.js\n\n    var enumMethods = {\n        nameEquals: function (n1, n2, ignoreCase) {\n            if (ignoreCase) {\n                return n1.toLowerCase() === n2.toLowerCase();\n            }\n\n            return (n1.charAt(0).toLowerCase() + n1.slice(1)) === (n2.charAt(0).toLowerCase() + n2.slice(1));\n        },\n\n        checkEnumType: function (enumType) {\n            if (!enumType) {\n                throw new System.ArgumentNullException(\"enumType\");\n            }\n\n            if (enumType.prototype && enumType.$kind !== \"enum\") {\n                throw new System.ArgumentException(\"\", \"enumType\");\n            }\n        },\n\n        getUnderlyingType: function (type) {\n            System.Enum.checkEnumType(type);\n            return type.prototype.$utype || System.Int32;\n        },\n\n        toName: function (name) {\n            return name;\n        },\n\n        parse: function (enumType, s, ignoreCase, silent) {\n            System.Enum.checkEnumType(enumType);\n\n            if (s != null) {\n                if (enumType === Number || enumType === System.String || enumType.$number) {\n                    return s;\n                }\n\n                var intValue = {};\n\n                if (System.Int32.tryParse(s, intValue)) {\n                    return Bridge.box(intValue.v, enumType, function (obj) { return System.Enum.toString(enumType, obj); });\n                }\n\n                var names = System.Enum.getNames(enumType),\n                    values = enumType;\n\n                if (!enumType.prototype || !enumType.prototype.$flags) {\n                    for (var i = 0; i < names.length; i++) {\n                        var name = names[i];\n\n                        if (enumMethods.nameEquals(name, s, ignoreCase)) {\n                            return Bridge.box(values[name], enumType, function (obj) { return System.Enum.toString(enumType, obj); });\n                        }\n                    }\n                } else {\n                    var parts = s.split(','),\n                        value = 0,\n                        parsed = true;\n\n                    for (var i = parts.length - 1; i >= 0; i--) {\n                        var part = parts[i].trim(),\n                            found = false;\n\n                        for (var n = 0; n < names.length; n++) {\n                            var name = names[n];\n\n                            if (enumMethods.nameEquals(name, part, ignoreCase)) {\n                                value |= values[name];\n                                found = true;\n\n                                break;\n                            }\n                        }\n\n                        if (!found) {\n                            parsed = false;\n\n                            break;\n                        }\n                    }\n\n                    if (parsed) {\n                        return Bridge.box(value, enumType, function (obj) { return System.Enum.toString(enumType, obj); });\n                    }\n                }\n            }\n\n            if (silent !== true) {\n                throw new System.ArgumentException('Invalid Enumeration Value');\n            }\n\n            return null;\n        },\n\n        toStringFn: function(type) {\n            return function(value) {\n                return System.Enum.toString(type, value);\n            };\n        },\n\n        toString: function (enumType, value, forceFlags) {\n            if (arguments.length === 0) {\n                return \"System.Enum\";\n            }\n\n            if (value && value.$boxed && enumType === System.Enum) {\n                enumType = value.type;\n            }\n\n            value = Bridge.unbox(value, true);\n\n            if (enumType === Number || enumType === System.String || enumType.$number) {\n                return value.toString();\n            }\n\n            System.Enum.checkEnumType(enumType);\n\n            var values = enumType,\n                names = System.Enum.getNames(enumType),\n                isLong = System.Int64.is64Bit(value);\n\n            if (((!enumType.prototype || !enumType.prototype.$flags) && forceFlags !== true) || (value === 0)) {\n                for (var i = 0; i < names.length; i++) {\n                    var name = names[i];\n\n                    if (isLong && System.Int64.is64Bit(values[name]) ? (values[name].eq(value)) : (values[name] === value)) {\n                        return enumMethods.toName(name);\n                    }\n                }\n\n                //throw new System.ArgumentException('Invalid Enumeration Value');\n                return value.toString();\n            } else {\n                var parts = [],\n                    entries = System.Enum.getValuesAndNames(enumType),\n                    index = entries.length - 1,\n                    saveResult = value;\n\n                while (index >= 0) {\n                    var entry = entries[index],\n                        long = isLong && System.Int64.is64Bit(entry.value);\n\n                    if ((index == 0) && (long ? entry.value.isZero() : entry.value == 0)) {\n                        break;\n                    }\n\n                    if (long ? (value.and(entry.value).eq(entry.value)) : ((value & entry.value) == entry.value)) {\n                        if (long) {\n                            value = value.sub(entry.value);\n                        } else {\n                            value -= entry.value;\n                        }\n\n                        parts.unshift(entry.name);\n                    }\n\n                    index--;\n                }\n\n                if (isLong ? !value.isZero() : value !== 0) {\n                    return saveResult.toString();\n                }\n\n                if (isLong ? saveResult.isZero() : saveResult === 0) {\n                    var entry = entries[0];\n                    if (entry && (System.Int64.is64Bit(entry.value) ? entry.value.isZero() : (entry.value == 0))) {\n                        return entry.name;\n                    }\n\n                    return \"0\";\n                }\n\n                return parts.join(', ');\n            }\n        },\n\n        getValuesAndNames: function (enumType) {\n            System.Enum.checkEnumType(enumType);\n\n            var parts = [],\n                names = System.Enum.getNames(enumType),\n                values = enumType;\n\n            for (var i = 0; i < names.length; i++) {\n                parts.push({ name: names[i], value: values[names[i]] });\n            }\n\n            return parts.sort(function (i1, i2) {\n                return System.Int64.is64Bit(i1.value) ? i1.value.sub(i2.value).sign() : (i1.value - i2.value);\n            });\n        },\n\n        getValues: function (enumType) {\n            System.Enum.checkEnumType(enumType);\n\n            var parts = [],\n                names = System.Enum.getNames(enumType),\n                values = enumType;\n\n            for (var i = 0; i < names.length; i++) {\n                parts.push(values[names[i]]);\n            }\n\n            return parts.sort(function (i1, i2) {\n                return System.Int64.is64Bit(i1) ? i1.sub(i2).sign() : (i1 - i2);\n            });\n        },\n\n        format: function (enumType, value, format) {\n            System.Enum.checkEnumType(enumType);\n\n            var name;\n\n            if (!Bridge.hasValue(value) && (name = \"value\") || !Bridge.hasValue(format) && (name = \"format\")) {\n                throw new System.ArgumentNullException(name);\n            }\n\n            value = Bridge.unbox(value, true);\n\n            switch (format) {\n                case \"G\":\n                case \"g\":\n                    return System.Enum.toString(enumType, value);\n                case \"x\":\n                case \"X\":\n                    return value.toString(16);\n                case \"d\":\n                case \"D\":\n                    return value.toString();\n                case \"f\":\n                case \"F\":\n                    return System.Enum.toString(enumType, value, true);\n                default:\n                    throw new System.FormatException();\n            }\n        },\n\n        getNames: function (enumType) {\n            System.Enum.checkEnumType(enumType);\n\n            var parts = [],\n                values = enumType;\n\n            if (enumType.$names) {\n                return enumType.$names.slice(0);\n            }\n\n            for (var i in values) {\n                if (values.hasOwnProperty(i) && i.indexOf(\"$\") < 0 && typeof values[i] !== \"function\") {\n                    parts.push([enumMethods.toName(i), values[i]]);\n                }\n            }\n\n            return parts.sort(function (i1, i2) {\n                return System.Int64.is64Bit(i1[1]) ? i1[1].sub(i2[1]).sign() : (i1[1] - i2[1]);\n            }).map(function (i) {\n                return i[0];\n            });\n        },\n\n        getName: function (enumType, value) {\n            value = Bridge.unbox(value, true);\n\n            if (value == null) {\n                throw new System.ArgumentNullException(\"value\");\n            }\n\n            var isLong = System.Int64.is64Bit(value);\n\n            if (!isLong && !(typeof (value) === \"number\" && Math.floor(value, 0) === value)) {\n                throw new System.ArgumentException(\"Argument must be integer\", \"value\");\n            }\n\n            System.Enum.checkEnumType(enumType);\n\n            var names = System.Enum.getNames(enumType),\n                values = enumType;\n\n            for (var i = 0; i < names.length; i++) {\n                var name = names[i];\n\n                if (isLong ? value.eq(values[name]) : (values[name] === value)) {\n                    return name;\n                }\n            }\n\n            return null;\n        },\n\n        hasFlag: function (value, flag) {\n            flag = Bridge.unbox(flag, true);\n            var isLong = System.Int64.is64Bit(value);\n            return flag === 0 || (isLong ? !value.and(flag).isZero() : !!(value & flag));\n        },\n\n        isDefined: function (enumType, value) {\n            value = Bridge.unbox(value, true);\n\n            System.Enum.checkEnumType(enumType);\n\n            var values = enumType,\n                names = System.Enum.getNames(enumType),\n                isString = Bridge.isString(value),\n                isLong = System.Int64.is64Bit(value);\n\n            for (var i = 0; i < names.length; i++) {\n                var name = names[i];\n                if (isString ? enumMethods.nameEquals(name, value, false) : (isLong ? value.eq(values[name]) : (values[name] === value))) {\n                    return true;\n                }\n            }\n\n            return false;\n        },\n\n        tryParse: function (enumType, value, result, ignoreCase) {\n            result.v = 0;\n            result.v = Bridge.unbox(enumMethods.parse(enumType, value, ignoreCase, true), true);\n\n            if (result.v == null) {\n                return false;\n            }\n\n            return true;\n        },\n\n        equals: function (v1, v2, T) {\n            if (v2 && v2.$boxed && (v1 && v1.$boxed || T)) {\n                if (v2.type !== (v1.type || T)) {\n                    return false;\n                }\n            }\n\n            return System.Enum.equalsT(v1, v2);\n        },\n\n        equalsT: function (v1, v2) {\n            return Bridge.equals(Bridge.unbox(v1, true), Bridge.unbox(v2, true));\n        }\n    };\n\n    Bridge.define(\"System.Enum\", {\n        inherits: [System.IComparable, System.IFormattable],\n        statics: {\n            methods: enumMethods\n        }\n    });\n\n    // @source Nullable.js\n\n    var nullable = {\n        hasValue: Bridge.hasValue,\n\n        getValue: function (obj) {\n            obj = Bridge.unbox(obj, true);\n            if (!Bridge.hasValue(obj)) {\n                throw new System.InvalidOperationException(\"Nullable instance doesn't have a value.\");\n            }\n\n            return obj;\n        },\n\n        getValueOrDefault: function (obj, defValue) {\n            return Bridge.hasValue(obj) ? obj : defValue;\n        },\n\n        add: function (a, b) {\n            return Bridge.hasValue$1(a, b) ? a + b : null;\n        },\n\n        band: function (a, b) {\n            return Bridge.hasValue$1(a, b) ? a & b : null;\n        },\n\n        bor: function (a, b) {\n            return Bridge.hasValue$1(a, b) ? a | b : null;\n        },\n\n        and: function (a, b) {\n            if (a === true && b === true) {\n                return true;\n            } else if (a === false || b === false) {\n                return false;\n            }\n\n            return null;\n        },\n\n        or: function (a, b) {\n            if (a === true || b === true) {\n                return true;\n            } else if (a === false && b === false) {\n                return false;\n            }\n\n            return null;\n        },\n\n        div: function (a, b) {\n            return Bridge.hasValue$1(a, b) ? a / b : null;\n        },\n\n        eq: function (a, b) {\n            return !Bridge.hasValue(a) ? !Bridge.hasValue(b) : (a === b);\n        },\n\n        equals: function (a, b, fn) {\n            return !Bridge.hasValue(a) ? !Bridge.hasValue(b) : (fn ? fn(a, b) : Bridge.equals(a, b));\n        },\n\n        toString: function (a, fn) {\n            return !Bridge.hasValue(a) ? \"\" : (fn ? fn(a) : a.toString());\n        },\n\n        toStringFn: function (fn) {\n            return function(v) {\n                return System.Nullable.toString(v, fn);\n            };\n        },\n\n        getHashCode: function (a, fn) {\n            return !Bridge.hasValue(a) ? 0 : (fn ? fn(a) : Bridge.getHashCode(a));\n        },\n\n        getHashCodeFn: function (fn) {\n            return function (v) {\n                return System.Nullable.getHashCode(v, fn);\n            };\n        },\n\n        xor: function (a, b) {\n            return Bridge.hasValue$1(a, b) ? a ^ b : null;\n        },\n\n        gt: function (a, b) {\n            return Bridge.hasValue$1(a, b) && a > b;\n        },\n\n        gte: function (a, b) {\n            return Bridge.hasValue$1(a, b) && a >= b;\n        },\n\n        neq: function (a, b) {\n            return !Bridge.hasValue(a) ? Bridge.hasValue(b) : (a !== b);\n        },\n\n        lt: function (a, b) {\n            return Bridge.hasValue$1(a, b) && a < b;\n        },\n\n        lte: function (a, b) {\n            return Bridge.hasValue$1(a, b) && a <= b;\n        },\n\n        mod: function (a, b) {\n            return Bridge.hasValue$1(a, b) ? a % b : null;\n        },\n\n        mul: function (a, b) {\n            return Bridge.hasValue$1(a, b) ? a * b : null;\n        },\n\n        imul: function (a, b) {\n            return Bridge.hasValue$1(a, b) ? Bridge.Int.mul(a, b) : null;\n        },\n\n        sl: function (a, b) {\n            return Bridge.hasValue$1(a, b) ? a << b : null;\n        },\n\n        sr: function (a, b) {\n            return Bridge.hasValue$1(a, b) ? a >> b : null;\n        },\n\n        srr: function (a, b) {\n            return Bridge.hasValue$1(a, b) ? a >>> b : null;\n        },\n\n        sub: function (a, b) {\n            return Bridge.hasValue$1(a, b) ? a - b : null;\n        },\n\n        bnot: function (a) {\n            return Bridge.hasValue(a) ? ~a : null;\n        },\n\n        neg: function (a) {\n            return Bridge.hasValue(a) ? -a : null;\n        },\n\n        not: function (a) {\n            return Bridge.hasValue(a) ? !a : null;\n        },\n\n        pos: function (a) {\n            return Bridge.hasValue(a) ? +a : null;\n        },\n\n        lift: function () {\n            for (var i = 1; i < arguments.length; i++) {\n                if (!Bridge.hasValue(arguments[i])) {\n                    return null;\n                }\n            }\n\n            if (arguments[0] == null) {\n                return null;\n            }\n\n            if (arguments[0].apply == undefined) {\n                return arguments[0];\n            }\n\n            return arguments[0].apply(null, Array.prototype.slice.call(arguments, 1));\n        },\n\n        lift1: function (f, o) {\n            return Bridge.hasValue(o) ? (typeof f === \"function\" ? f.apply(null, Array.prototype.slice.call(arguments, 1)) : o[f].apply(o, Array.prototype.slice.call(arguments, 2))) : null;\n        },\n\n        lift2: function (f, a, b) {\n            return Bridge.hasValue$1(a, b) ? (typeof f === \"function\" ? f.apply(null, Array.prototype.slice.call(arguments, 1)) : a[f].apply(a, Array.prototype.slice.call(arguments, 2))) : null;\n        },\n\n        liftcmp: function (f, a, b) {\n            return Bridge.hasValue$1(a, b) ? (typeof f === \"function\" ? f.apply(null, Array.prototype.slice.call(arguments, 1)) : a[f].apply(a, Array.prototype.slice.call(arguments, 2))) : false;\n        },\n\n        lifteq: function (f, a, b) {\n            var va = Bridge.hasValue(a),\n                vb = Bridge.hasValue(b);\n\n            return (!va && !vb) || (va && vb && (typeof f === \"function\" ? f.apply(null, Array.prototype.slice.call(arguments, 1)) : a[f].apply(a, Array.prototype.slice.call(arguments, 2))));\n        },\n\n        liftne: function (f, a, b) {\n            var va = Bridge.hasValue(a),\n                vb = Bridge.hasValue(b);\n\n            return (va !== vb) || (va && (typeof f === \"function\" ? f.apply(null, Array.prototype.slice.call(arguments, 1)) : a[f].apply(a, Array.prototype.slice.call(arguments, 2))));\n        },\n\n        getUnderlyingType: function (nullableType) {\n            if (!nullableType) {\n                throw new System.ArgumentNullException(\"nullableType\");\n            }\n\n            if (Bridge.Reflection.isGenericType(nullableType) &&\n                !Bridge.Reflection.isGenericTypeDefinition(nullableType)) {\n                var genericType = Bridge.Reflection.getGenericTypeDefinition(nullableType);\n\n                if (genericType === System.Nullable$1) {\n                    return Bridge.Reflection.getGenericArguments(nullableType)[0];\n                }\n            }\n\n            return null;\n        },\n\n        compare: function (n1, n2) {\n            return System.Collections.Generic.Comparer$1.$default.compare(n1, n2);\n        }\n    };\n\n    System.Nullable = nullable;\n\n    Bridge.define('System.Nullable$1', function (T) {\n        return {\n            $kind: \"struct\",\n\n            statics: {\n                $nullable: true,\n                $nullableType: T,\n                getDefaultValue: function () {\n                    return null;\n                },\n\n                $is: function(obj) {\n                    return Bridge.is(obj, T);\n                }\n            }\n        };\n    });\n    // @source Char.js\n\n    Bridge.define(\"System.Char\", {\n        inherits: [System.IComparable, System.IFormattable],\n        $kind: \"struct\",\n        statics: {\n            min: 0,\n\n            max: 65535,\n\n            $is: function (instance) {\n                return typeof (instance) === \"number\" && Math.round(instance, 0) == instance && instance >= System.Char.min && instance <= System.Char.max;\n            },\n\n            getDefaultValue: function () {\n                return 0;\n            },\n\n            parse: function (s) {\n                if (!Bridge.hasValue(s)) {\n                    throw new System.ArgumentNullException(\"s\");\n                }\n\n                if (s.length !== 1) {\n                    throw new System.FormatException();\n                }\n\n                return s.charCodeAt(0);\n            },\n\n            tryParse: function (s, result) {\n                var b = s && s.length === 1;\n\n                result.v = b ? s.charCodeAt(0) : 0;\n\n                return b;\n            },\n\n            format: function (number, format, provider) {\n                return Bridge.Int.format(number, format, provider);\n            },\n\n            charCodeAt: function (str, index) {\n                if (str == null) {\n                    throw new System.ArgumentNullException();\n                }\n\n                if (str.length != 1) {\n                    throw new System.FormatException(\"String must be exactly one character long\");\n                }\n\n                return str.charCodeAt(index);\n            },\n\n            isWhiteSpace: function (s) {\n                return !/[^\\s\\x09-\\x0D\\x85\\xA0]/.test(s);\n            },\n\n            isDigit: function (value) {\n                if (value < 256) {\n                    return (value >= 48 && value <= 57);\n                }\n\n                return new RegExp(/[0-9\\u0030-\\u0039\\u0660-\\u0669\\u06F0-\\u06F9\\u07C0-\\u07C9\\u0966-\\u096F\\u09E6-\\u09EF\\u0A66-\\u0A6F\\u0AE6-\\u0AEF\\u0B66-\\u0B6F\\u0BE6-\\u0BEF\\u0C66-\\u0C6F\\u0CE6-\\u0CEF\\u0D66-\\u0D6F\\u0E50-\\u0E59\\u0ED0-\\u0ED9\\u0F20-\\u0F29\\u1040-\\u1049\\u1090-\\u1099\\u17E0-\\u17E9\\u1810-\\u1819\\u1946-\\u194F\\u19D0-\\u19D9\\u1A80-\\u1A89\\u1A90-\\u1A99\\u1B50-\\u1B59\\u1BB0-\\u1BB9\\u1C40-\\u1C49\\u1C50-\\u1C59\\uA620-\\uA629\\uA8D0-\\uA8D9\\uA900-\\uA909\\uA9D0-\\uA9D9\\uAA50-\\uAA59\\uABF0-\\uABF9\\uFF10-\\uFF19]/).test(String.fromCharCode(value));\n            },\n\n            isLetter: function (value) {\n                if (value < 256) {\n                    return (value >= 65 && value <= 90) || (value >= 97 && value <= 122);\n                }\n\n                return new RegExp(/[A-Za-z\\u0061-\\u007A\\u00B5\\u00DF-\\u00F6\\u00F8-\\u00FF\\u0101\\u0103\\u0105\\u0107\\u0109\\u010B\\u010D\\u010F\\u0111\\u0113\\u0115\\u0117\\u0119\\u011B\\u011D\\u011F\\u0121\\u0123\\u0125\\u0127\\u0129\\u012B\\u012D\\u012F\\u0131\\u0133\\u0135\\u0137\\u0138\\u013A\\u013C\\u013E\\u0140\\u0142\\u0144\\u0146\\u0148\\u0149\\u014B\\u014D\\u014F\\u0151\\u0153\\u0155\\u0157\\u0159\\u015B\\u015D\\u015F\\u0161\\u0163\\u0165\\u0167\\u0169\\u016B\\u016D\\u016F\\u0171\\u0173\\u0175\\u0177\\u017A\\u017C\\u017E-\\u0180\\u0183\\u0185\\u0188\\u018C\\u018D\\u0192\\u0195\\u0199-\\u019B\\u019E\\u01A1\\u01A3\\u01A5\\u01A8\\u01AA\\u01AB\\u01AD\\u01B0\\u01B4\\u01B6\\u01B9\\u01BA\\u01BD-\\u01BF\\u01C6\\u01C9\\u01CC\\u01CE\\u01D0\\u01D2\\u01D4\\u01D6\\u01D8\\u01DA\\u01DC\\u01DD\\u01DF\\u01E1\\u01E3\\u01E5\\u01E7\\u01E9\\u01EB\\u01ED\\u01EF\\u01F0\\u01F3\\u01F5\\u01F9\\u01FB\\u01FD\\u01FF\\u0201\\u0203\\u0205\\u0207\\u0209\\u020B\\u020D\\u020F\\u0211\\u0213\\u0215\\u0217\\u0219\\u021B\\u021D\\u021F\\u0221\\u0223\\u0225\\u0227\\u0229\\u022B\\u022D\\u022F\\u0231\\u0233-\\u0239\\u023C\\u023F\\u0240\\u0242\\u0247\\u0249\\u024B\\u024D\\u024F-\\u0293\\u0295-\\u02AF\\u0371\\u0373\\u0377\\u037B-\\u037D\\u0390\\u03AC-\\u03CE\\u03D0\\u03D1\\u03D5-\\u03D7\\u03D9\\u03DB\\u03DD\\u03DF\\u03E1\\u03E3\\u03E5\\u03E7\\u03E9\\u03EB\\u03ED\\u03EF-\\u03F3\\u03F5\\u03F8\\u03FB\\u03FC\\u0430-\\u045F\\u0461\\u0463\\u0465\\u0467\\u0469\\u046B\\u046D\\u046F\\u0471\\u0473\\u0475\\u0477\\u0479\\u047B\\u047D\\u047F\\u0481\\u048B\\u048D\\u048F\\u0491\\u0493\\u0495\\u0497\\u0499\\u049B\\u049D\\u049F\\u04A1\\u04A3\\u04A5\\u04A7\\u04A9\\u04AB\\u04AD\\u04AF\\u04B1\\u04B3\\u04B5\\u04B7\\u04B9\\u04BB\\u04BD\\u04BF\\u04C2\\u04C4\\u04C6\\u04C8\\u04CA\\u04CC\\u04CE\\u04CF\\u04D1\\u04D3\\u04D5\\u04D7\\u04D9\\u04DB\\u04DD\\u04DF\\u04E1\\u04E3\\u04E5\\u04E7\\u04E9\\u04EB\\u04ED\\u04EF\\u04F1\\u04F3\\u04F5\\u04F7\\u04F9\\u04FB\\u04FD\\u04FF\\u0501\\u0503\\u0505\\u0507\\u0509\\u050B\\u050D\\u050F\\u0511\\u0513\\u0515\\u0517\\u0519\\u051B\\u051D\\u051F\\u0521\\u0523\\u0525\\u0527\\u0561-\\u0587\\u1D00-\\u1D2B\\u1D6B-\\u1D77\\u1D79-\\u1D9A\\u1E01\\u1E03\\u1E05\\u1E07\\u1E09\\u1E0B\\u1E0D\\u1E0F\\u1E11\\u1E13\\u1E15\\u1E17\\u1E19\\u1E1B\\u1E1D\\u1E1F\\u1E21\\u1E23\\u1E25\\u1E27\\u1E29\\u1E2B\\u1E2D\\u1E2F\\u1E31\\u1E33\\u1E35\\u1E37\\u1E39\\u1E3B\\u1E3D\\u1E3F\\u1E41\\u1E43\\u1E45\\u1E47\\u1E49\\u1E4B\\u1E4D\\u1E4F\\u1E51\\u1E53\\u1E55\\u1E57\\u1E59\\u1E5B\\u1E5D\\u1E5F\\u1E61\\u1E63\\u1E65\\u1E67\\u1E69\\u1E6B\\u1E6D\\u1E6F\\u1E71\\u1E73\\u1E75\\u1E77\\u1E79\\u1E7B\\u1E7D\\u1E7F\\u1E81\\u1E83\\u1E85\\u1E87\\u1E89\\u1E8B\\u1E8D\\u1E8F\\u1E91\\u1E93\\u1E95-\\u1E9D\\u1E9F\\u1EA1\\u1EA3\\u1EA5\\u1EA7\\u1EA9\\u1EAB\\u1EAD\\u1EAF\\u1EB1\\u1EB3\\u1EB5\\u1EB7\\u1EB9\\u1EBB\\u1EBD\\u1EBF\\u1EC1\\u1EC3\\u1EC5\\u1EC7\\u1EC9\\u1ECB\\u1ECD\\u1ECF\\u1ED1\\u1ED3\\u1ED5\\u1ED7\\u1ED9\\u1EDB\\u1EDD\\u1EDF\\u1EE1\\u1EE3\\u1EE5\\u1EE7\\u1EE9\\u1EEB\\u1EED\\u1EEF\\u1EF1\\u1EF3\\u1EF5\\u1EF7\\u1EF9\\u1EFB\\u1EFD\\u1EFF-\\u1F07\\u1F10-\\u1F15\\u1F20-\\u1F27\\u1F30-\\u1F37\\u1F40-\\u1F45\\u1F50-\\u1F57\\u1F60-\\u1F67\\u1F70-\\u1F7D\\u1F80-\\u1F87\\u1F90-\\u1F97\\u1FA0-\\u1FA7\\u1FB0-\\u1FB4\\u1FB6\\u1FB7\\u1FBE\\u1FC2-\\u1FC4\\u1FC6\\u1FC7\\u1FD0-\\u1FD3\\u1FD6\\u1FD7\\u1FE0-\\u1FE7\\u1FF2-\\u1FF4\\u1FF6\\u1FF7\\u210A\\u210E\\u210F\\u2113\\u212F\\u2134\\u2139\\u213C\\u213D\\u2146-\\u2149\\u214E\\u2184\\u2C30-\\u2C5E\\u2C61\\u2C65\\u2C66\\u2C68\\u2C6A\\u2C6C\\u2C71\\u2C73\\u2C74\\u2C76-\\u2C7B\\u2C81\\u2C83\\u2C85\\u2C87\\u2C89\\u2C8B\\u2C8D\\u2C8F\\u2C91\\u2C93\\u2C95\\u2C97\\u2C99\\u2C9B\\u2C9D\\u2C9F\\u2CA1\\u2CA3\\u2CA5\\u2CA7\\u2CA9\\u2CAB\\u2CAD\\u2CAF\\u2CB1\\u2CB3\\u2CB5\\u2CB7\\u2CB9\\u2CBB\\u2CBD\\u2CBF\\u2CC1\\u2CC3\\u2CC5\\u2CC7\\u2CC9\\u2CCB\\u2CCD\\u2CCF\\u2CD1\\u2CD3\\u2CD5\\u2CD7\\u2CD9\\u2CDB\\u2CDD\\u2CDF\\u2CE1\\u2CE3\\u2CE4\\u2CEC\\u2CEE\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\uA641\\uA643\\uA645\\uA647\\uA649\\uA64B\\uA64D\\uA64F\\uA651\\uA653\\uA655\\uA657\\uA659\\uA65B\\uA65D\\uA65F\\uA661\\uA663\\uA665\\uA667\\uA669\\uA66B\\uA66D\\uA681\\uA683\\uA685\\uA687\\uA689\\uA68B\\uA68D\\uA68F\\uA691\\uA693\\uA695\\uA697\\uA723\\uA725\\uA727\\uA729\\uA72B\\uA72D\\uA72F-\\uA731\\uA733\\uA735\\uA737\\uA739\\uA73B\\uA73D\\uA73F\\uA741\\uA743\\uA745\\uA747\\uA749\\uA74B\\uA74D\\uA74F\\uA751\\uA753\\uA755\\uA757\\uA759\\uA75B\\uA75D\\uA75F\\uA761\\uA763\\uA765\\uA767\\uA769\\uA76B\\uA76D\\uA76F\\uA771-\\uA778\\uA77A\\uA77C\\uA77F\\uA781\\uA783\\uA785\\uA787\\uA78C\\uA78E\\uA791\\uA793\\uA7A1\\uA7A3\\uA7A5\\uA7A7\\uA7A9\\uA7FA\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFF41-\\uFF5A\\u0041-\\u005A\\u00C0-\\u00D6\\u00D8-\\u00DE\\u0100\\u0102\\u0104\\u0106\\u0108\\u010A\\u010C\\u010E\\u0110\\u0112\\u0114\\u0116\\u0118\\u011A\\u011C\\u011E\\u0120\\u0122\\u0124\\u0126\\u0128\\u012A\\u012C\\u012E\\u0130\\u0132\\u0134\\u0136\\u0139\\u013B\\u013D\\u013F\\u0141\\u0143\\u0145\\u0147\\u014A\\u014C\\u014E\\u0150\\u0152\\u0154\\u0156\\u0158\\u015A\\u015C\\u015E\\u0160\\u0162\\u0164\\u0166\\u0168\\u016A\\u016C\\u016E\\u0170\\u0172\\u0174\\u0176\\u0178\\u0179\\u017B\\u017D\\u0181\\u0182\\u0184\\u0186\\u0187\\u0189-\\u018B\\u018E-\\u0191\\u0193\\u0194\\u0196-\\u0198\\u019C\\u019D\\u019F\\u01A0\\u01A2\\u01A4\\u01A6\\u01A7\\u01A9\\u01AC\\u01AE\\u01AF\\u01B1-\\u01B3\\u01B5\\u01B7\\u01B8\\u01BC\\u01C4\\u01C7\\u01CA\\u01CD\\u01CF\\u01D1\\u01D3\\u01D5\\u01D7\\u01D9\\u01DB\\u01DE\\u01E0\\u01E2\\u01E4\\u01E6\\u01E8\\u01EA\\u01EC\\u01EE\\u01F1\\u01F4\\u01F6-\\u01F8\\u01FA\\u01FC\\u01FE\\u0200\\u0202\\u0204\\u0206\\u0208\\u020A\\u020C\\u020E\\u0210\\u0212\\u0214\\u0216\\u0218\\u021A\\u021C\\u021E\\u0220\\u0222\\u0224\\u0226\\u0228\\u022A\\u022C\\u022E\\u0230\\u0232\\u023A\\u023B\\u023D\\u023E\\u0241\\u0243-\\u0246\\u0248\\u024A\\u024C\\u024E\\u0370\\u0372\\u0376\\u0386\\u0388-\\u038A\\u038C\\u038E\\u038F\\u0391-\\u03A1\\u03A3-\\u03AB\\u03CF\\u03D2-\\u03D4\\u03D8\\u03DA\\u03DC\\u03DE\\u03E0\\u03E2\\u03E4\\u03E6\\u03E8\\u03EA\\u03EC\\u03EE\\u03F4\\u03F7\\u03F9\\u03FA\\u03FD-\\u042F\\u0460\\u0462\\u0464\\u0466\\u0468\\u046A\\u046C\\u046E\\u0470\\u0472\\u0474\\u0476\\u0478\\u047A\\u047C\\u047E\\u0480\\u048A\\u048C\\u048E\\u0490\\u0492\\u0494\\u0496\\u0498\\u049A\\u049C\\u049E\\u04A0\\u04A2\\u04A4\\u04A6\\u04A8\\u04AA\\u04AC\\u04AE\\u04B0\\u04B2\\u04B4\\u04B6\\u04B8\\u04BA\\u04BC\\u04BE\\u04C0\\u04C1\\u04C3\\u04C5\\u04C7\\u04C9\\u04CB\\u04CD\\u04D0\\u04D2\\u04D4\\u04D6\\u04D8\\u04DA\\u04DC\\u04DE\\u04E0\\u04E2\\u04E4\\u04E6\\u04E8\\u04EA\\u04EC\\u04EE\\u04F0\\u04F2\\u04F4\\u04F6\\u04F8\\u04FA\\u04FC\\u04FE\\u0500\\u0502\\u0504\\u0506\\u0508\\u050A\\u050C\\u050E\\u0510\\u0512\\u0514\\u0516\\u0518\\u051A\\u051C\\u051E\\u0520\\u0522\\u0524\\u0526\\u0531-\\u0556\\u10A0-\\u10C5\\u10C7\\u10CD\\u1E00\\u1E02\\u1E04\\u1E06\\u1E08\\u1E0A\\u1E0C\\u1E0E\\u1E10\\u1E12\\u1E14\\u1E16\\u1E18\\u1E1A\\u1E1C\\u1E1E\\u1E20\\u1E22\\u1E24\\u1E26\\u1E28\\u1E2A\\u1E2C\\u1E2E\\u1E30\\u1E32\\u1E34\\u1E36\\u1E38\\u1E3A\\u1E3C\\u1E3E\\u1E40\\u1E42\\u1E44\\u1E46\\u1E48\\u1E4A\\u1E4C\\u1E4E\\u1E50\\u1E52\\u1E54\\u1E56\\u1E58\\u1E5A\\u1E5C\\u1E5E\\u1E60\\u1E62\\u1E64\\u1E66\\u1E68\\u1E6A\\u1E6C\\u1E6E\\u1E70\\u1E72\\u1E74\\u1E76\\u1E78\\u1E7A\\u1E7C\\u1E7E\\u1E80\\u1E82\\u1E84\\u1E86\\u1E88\\u1E8A\\u1E8C\\u1E8E\\u1E90\\u1E92\\u1E94\\u1E9E\\u1EA0\\u1EA2\\u1EA4\\u1EA6\\u1EA8\\u1EAA\\u1EAC\\u1EAE\\u1EB0\\u1EB2\\u1EB4\\u1EB6\\u1EB8\\u1EBA\\u1EBC\\u1EBE\\u1EC0\\u1EC2\\u1EC4\\u1EC6\\u1EC8\\u1ECA\\u1ECC\\u1ECE\\u1ED0\\u1ED2\\u1ED4\\u1ED6\\u1ED8\\u1EDA\\u1EDC\\u1EDE\\u1EE0\\u1EE2\\u1EE4\\u1EE6\\u1EE8\\u1EEA\\u1EEC\\u1EEE\\u1EF0\\u1EF2\\u1EF4\\u1EF6\\u1EF8\\u1EFA\\u1EFC\\u1EFE\\u1F08-\\u1F0F\\u1F18-\\u1F1D\\u1F28-\\u1F2F\\u1F38-\\u1F3F\\u1F48-\\u1F4D\\u1F59\\u1F5B\\u1F5D\\u1F5F\\u1F68-\\u1F6F\\u1FB8-\\u1FBB\\u1FC8-\\u1FCB\\u1FD8-\\u1FDB\\u1FE8-\\u1FEC\\u1FF8-\\u1FFB\\u2102\\u2107\\u210B-\\u210D\\u2110-\\u2112\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u2130-\\u2133\\u213E\\u213F\\u2145\\u2183\\u2C00-\\u2C2E\\u2C60\\u2C62-\\u2C64\\u2C67\\u2C69\\u2C6B\\u2C6D-\\u2C70\\u2C72\\u2C75\\u2C7E-\\u2C80\\u2C82\\u2C84\\u2C86\\u2C88\\u2C8A\\u2C8C\\u2C8E\\u2C90\\u2C92\\u2C94\\u2C96\\u2C98\\u2C9A\\u2C9C\\u2C9E\\u2CA0\\u2CA2\\u2CA4\\u2CA6\\u2CA8\\u2CAA\\u2CAC\\u2CAE\\u2CB0\\u2CB2\\u2CB4\\u2CB6\\u2CB8\\u2CBA\\u2CBC\\u2CBE\\u2CC0\\u2CC2\\u2CC4\\u2CC6\\u2CC8\\u2CCA\\u2CCC\\u2CCE\\u2CD0\\u2CD2\\u2CD4\\u2CD6\\u2CD8\\u2CDA\\u2CDC\\u2CDE\\u2CE0\\u2CE2\\u2CEB\\u2CED\\u2CF2\\uA640\\uA642\\uA644\\uA646\\uA648\\uA64A\\uA64C\\uA64E\\uA650\\uA652\\uA654\\uA656\\uA658\\uA65A\\uA65C\\uA65E\\uA660\\uA662\\uA664\\uA666\\uA668\\uA66A\\uA66C\\uA680\\uA682\\uA684\\uA686\\uA688\\uA68A\\uA68C\\uA68E\\uA690\\uA692\\uA694\\uA696\\uA722\\uA724\\uA726\\uA728\\uA72A\\uA72C\\uA72E\\uA732\\uA734\\uA736\\uA738\\uA73A\\uA73C\\uA73E\\uA740\\uA742\\uA744\\uA746\\uA748\\uA74A\\uA74C\\uA74E\\uA750\\uA752\\uA754\\uA756\\uA758\\uA75A\\uA75C\\uA75E\\uA760\\uA762\\uA764\\uA766\\uA768\\uA76A\\uA76C\\uA76E\\uA779\\uA77B\\uA77D\\uA77E\\uA780\\uA782\\uA784\\uA786\\uA78B\\uA78D\\uA790\\uA792\\uA7A0\\uA7A2\\uA7A4\\uA7A6\\uA7A8\\uA7AA\\uFF21-\\uFF3A\\u01C5\\u01C8\\u01CB\\u01F2\\u1F88-\\u1F8F\\u1F98-\\u1F9F\\u1FA8-\\u1FAF\\u1FBC\\u1FCC\\u1FFC\\u02B0-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0374\\u037A\\u0559\\u0640\\u06E5\\u06E6\\u07F4\\u07F5\\u07FA\\u081A\\u0824\\u0828\\u0971\\u0E46\\u0EC6\\u10FC\\u17D7\\u1843\\u1AA7\\u1C78-\\u1C7D\\u1D2C-\\u1D6A\\u1D78\\u1D9B-\\u1DBF\\u2071\\u207F\\u2090-\\u209C\\u2C7C\\u2C7D\\u2D6F\\u2E2F\\u3005\\u3031-\\u3035\\u303B\\u309D\\u309E\\u30FC-\\u30FE\\uA015\\uA4F8-\\uA4FD\\uA60C\\uA67F\\uA717-\\uA71F\\uA770\\uA788\\uA7F8\\uA7F9\\uA9CF\\uAA70\\uAADD\\uAAF3\\uAAF4\\uFF70\\uFF9E\\uFF9F\\u00AA\\u00BA\\u01BB\\u01C0-\\u01C3\\u0294\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u063F\\u0641-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u0800-\\u0815\\u0840-\\u0858\\u08A0\\u08A2-\\u08AC\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0972-\\u0977\\u0979-\\u097F\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C33\\u0C35-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E45\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10D0-\\u10FA\\u10FD-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17DC\\u1820-\\u1842\\u1844-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191C\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C77\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u2135-\\u2138\\u2D30-\\u2D67\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u3006\\u303C\\u3041-\\u3096\\u309F\\u30A1-\\u30FA\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA014\\uA016-\\uA48C\\uA4D0-\\uA4F7\\uA500-\\uA60B\\uA610-\\uA61F\\uA62A\\uA62B\\uA66E\\uA6A0-\\uA6E5\\uA7FB-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA6F\\uAA71-\\uAA76\\uAA7A\\uAA80-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB\\uAADC\\uAAE0-\\uAAEA\\uAAF2\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF66-\\uFF6F\\uFF71-\\uFF9D\\uFFA0-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]/).test(String.fromCharCode(value));\n            },\n\n            isHighSurrogate: function (value) {\n                return new RegExp(/[\\uD800-\\uDBFF]/).test(String.fromCharCode(value));\n            },\n\n            isLowSurrogate: function (value) {\n                return new RegExp(/[\\uDC00-\\uDFFF]/).test(String.fromCharCode(value));\n            },\n\n            isSurrogate: function (value) {\n                return new RegExp(/[\\uD800-\\uDFFF]/).test(String.fromCharCode(value));\n            },\n\n            isNull: function (value) {\n                return new RegExp(\"\\u0000\").test(String.fromCharCode(value));\n            },\n\n            isSymbol: function (value) {\n                if (value < 256) {\n                    return ([36, 43, 60, 61, 62, 94, 96, 124, 126, 162, 163, 164, 165, 166, 167, 168, 169, 172, 174, 175, 176, 177, 180, 182, 184, 215, 247].indexOf(value) != -1);\n                }\n\n                return new RegExp(/[\\u20A0-\\u20CF\\u20D0-\\u20FF\\u2100-\\u214F\\u2150-\\u218F\\u2190-\\u21FF\\u2200-\\u22FF\\u2300-\\u23FF\\u25A0-\\u25FF\\u2600-\\u26FF\\u2700-\\u27BF\\u27C0-\\u27EF\\u27F0-\\u27FF\\u2800-\\u28FF\\u2900-\\u297F\\u2980-\\u29FF\\u2A00-\\u2AFF\\u2B00-\\u2BFF]/).test(String.fromCharCode(value));\n            },\n\n            isSeparator: function (value) {\n                if (value < 256) {\n                    return (value == 32 || value == 160);\n                }\n\n                return new RegExp(/[\\u2028\\u2029\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u200A\\u202F\\u205F\\u3000]/).test(String.fromCharCode(value));\n            },\n\n            isPunctuation: function (value) {\n                if (value < 256) {\n                    return ([33, 34, 35, 37, 38, 39, 40, 41, 42, 44, 45, 46, 47, 58, 59, 63, 64, 91, 92, 93, 95, 123, 125, 161, 171, 173, 183, 187, 191].indexOf(value) != -1);\n                }\n\n                return new RegExp(/[\\u0021-\\u0023\\u0025-\\u002A\\u002C-\\u002F\\u003A\\u003B\\u003F\\u0040\\u005B-\\u005D\\u005F\\u007B\\u007D\\u00A1\\u00A7\\u00AB\\u00B6\\u00B7\\u00BB\\u00BF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0AF0\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E3B\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65\\u002D\\u058A\\u05BE\\u1400\\u1806\\u2010-\\u2015\\u2E17\\u2E1A\\u2E3A\\u2E3B\\u301C\\u3030\\u30A0\\uFE31\\uFE32\\uFE58\\uFE63\\uFF0D\\u0028\\u005B\\u007B\\u0F3A\\u0F3C\\u169B\\u201A\\u201E\\u2045\\u207D\\u208D\\u2329\\u2768\\u276A\\u276C\\u276E\\u2770\\u2772\\u2774\\u27C5\\u27E6\\u27E8\\u27EA\\u27EC\\u27EE\\u2983\\u2985\\u2987\\u2989\\u298B\\u298D\\u298F\\u2991\\u2993\\u2995\\u2997\\u29D8\\u29DA\\u29FC\\u2E22\\u2E24\\u2E26\\u2E28\\u3008\\u300A\\u300C\\u300E\\u3010\\u3014\\u3016\\u3018\\u301A\\u301D\\uFD3E\\uFE17\\uFE35\\uFE37\\uFE39\\uFE3B\\uFE3D\\uFE3F\\uFE41\\uFE43\\uFE47\\uFE59\\uFE5B\\uFE5D\\uFF08\\uFF3B\\uFF5B\\uFF5F\\uFF62\\u0029\\u005D\\u007D\\u0F3B\\u0F3D\\u169C\\u2046\\u207E\\u208E\\u232A\\u2769\\u276B\\u276D\\u276F\\u2771\\u2773\\u2775\\u27C6\\u27E7\\u27E9\\u27EB\\u27ED\\u27EF\\u2984\\u2986\\u2988\\u298A\\u298C\\u298E\\u2990\\u2992\\u2994\\u2996\\u2998\\u29D9\\u29DB\\u29FD\\u2E23\\u2E25\\u2E27\\u2E29\\u3009\\u300B\\u300D\\u300F\\u3011\\u3015\\u3017\\u3019\\u301B\\u301E\\u301F\\uFD3F\\uFE18\\uFE36\\uFE38\\uFE3A\\uFE3C\\uFE3E\\uFE40\\uFE42\\uFE44\\uFE48\\uFE5A\\uFE5C\\uFE5E\\uFF09\\uFF3D\\uFF5D\\uFF60\\uFF63\\u00AB\\u2018\\u201B\\u201C\\u201F\\u2039\\u2E02\\u2E04\\u2E09\\u2E0C\\u2E1C\\u2E20\\u00BB\\u2019\\u201D\\u203A\\u2E03\\u2E05\\u2E0A\\u2E0D\\u2E1D\\u2E21\\u005F\\u203F\\u2040\\u2054\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFF3F\\u0021-\\u0023\\u0025-\\u0027\\u002A\\u002C\\u002E\\u002F\\u003A\\u003B\\u003F\\u0040\\u005C\\u00A1\\u00A7\\u00B6\\u00B7\\u00BF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0AF0\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u166D\\u166E\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u1805\\u1807-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2016\\u2017\\u2020-\\u2027\\u2030-\\u2038\\u203B-\\u203E\\u2041-\\u2043\\u2047-\\u2051\\u2053\\u2055-\\u205E\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00\\u2E01\\u2E06-\\u2E08\\u2E0B\\u2E0E-\\u2E16\\u2E18\\u2E19\\u2E1B\\u2E1E\\u2E1F\\u2E2A-\\u2E2E\\u2E30-\\u2E39\\u3001-\\u3003\\u303D\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFE10-\\uFE16\\uFE19\\uFE30\\uFE45\\uFE46\\uFE49-\\uFE4C\\uFE50-\\uFE52\\uFE54-\\uFE57\\uFE5F-\\uFE61\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF07\\uFF0A\\uFF0C\\uFF0E\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3C\\uFF61\\uFF64\\uFF65]/).test(String.fromCharCode(value));\n            },\n\n            isNumber: function (value) {\n                if (value < 256) {\n                    return ([48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 178, 179, 185, 188, 189, 190].indexOf(value) != -1);\n                }\n\n                return new RegExp(/[\\u0030-\\u0039\\u00B2\\u00B3\\u00B9\\u00BC-\\u00BE\\u0660-\\u0669\\u06F0-\\u06F9\\u07C0-\\u07C9\\u0966-\\u096F\\u09E6-\\u09EF\\u09F4-\\u09F9\\u0A66-\\u0A6F\\u0AE6-\\u0AEF\\u0B66-\\u0B6F\\u0B72-\\u0B77\\u0BE6-\\u0BF2\\u0C66-\\u0C6F\\u0C78-\\u0C7E\\u0CE6-\\u0CEF\\u0D66-\\u0D75\\u0E50-\\u0E59\\u0ED0-\\u0ED9\\u0F20-\\u0F33\\u1040-\\u1049\\u1090-\\u1099\\u1369-\\u137C\\u16EE-\\u16F0\\u17E0-\\u17E9\\u17F0-\\u17F9\\u1810-\\u1819\\u1946-\\u194F\\u19D0-\\u19DA\\u1A80-\\u1A89\\u1A90-\\u1A99\\u1B50-\\u1B59\\u1BB0-\\u1BB9\\u1C40-\\u1C49\\u1C50-\\u1C59\\u2070\\u2074-\\u2079\\u2080-\\u2089\\u2150-\\u2182\\u2185-\\u2189\\u2460-\\u249B\\u24EA-\\u24FF\\u2776-\\u2793\\u2CFD\\u3007\\u3021-\\u3029\\u3038-\\u303A\\u3192-\\u3195\\u3220-\\u3229\\u3248-\\u324F\\u3251-\\u325F\\u3280-\\u3289\\u32B1-\\u32BF\\uA620-\\uA629\\uA6E6-\\uA6EF\\uA830-\\uA835\\uA8D0-\\uA8D9\\uA900-\\uA909\\uA9D0-\\uA9D9\\uAA50-\\uAA59\\uABF0-\\uABF9\\uFF10-\\uFF19\\u0030-\\u0039\\u0660-\\u0669\\u06F0-\\u06F9\\u07C0-\\u07C9\\u0966-\\u096F\\u09E6-\\u09EF\\u0A66-\\u0A6F\\u0AE6-\\u0AEF\\u0B66-\\u0B6F\\u0BE6-\\u0BEF\\u0C66-\\u0C6F\\u0CE6-\\u0CEF\\u0D66-\\u0D6F\\u0E50-\\u0E59\\u0ED0-\\u0ED9\\u0F20-\\u0F29\\u1040-\\u1049\\u1090-\\u1099\\u17E0-\\u17E9\\u1810-\\u1819\\u1946-\\u194F\\u19D0-\\u19D9\\u1A80-\\u1A89\\u1A90-\\u1A99\\u1B50-\\u1B59\\u1BB0-\\u1BB9\\u1C40-\\u1C49\\u1C50-\\u1C59\\uA620-\\uA629\\uA8D0-\\uA8D9\\uA900-\\uA909\\uA9D0-\\uA9D9\\uAA50-\\uAA59\\uABF0-\\uABF9\\uFF10-\\uFF19\\u16EE-\\u16F0\\u2160-\\u2182\\u2185-\\u2188\\u3007\\u3021-\\u3029\\u3038-\\u303A\\uA6E6-\\uA6EF\\u00B2\\u00B3\\u00B9\\u00BC-\\u00BE\\u09F4-\\u09F9\\u0B72-\\u0B77\\u0BF0-\\u0BF2\\u0C78-\\u0C7E\\u0D70-\\u0D75\\u0F2A-\\u0F33\\u1369-\\u137C\\u17F0-\\u17F9\\u19DA\\u2070\\u2074-\\u2079\\u2080-\\u2089\\u2150-\\u215F\\u2189\\u2460-\\u249B\\u24EA-\\u24FF\\u2776-\\u2793\\u2CFD\\u3192-\\u3195\\u3220-\\u3229\\u3248-\\u324F\\u3251-\\u325F\\u3280-\\u3289\\u32B1-\\u32BF\\uA830-\\uA835]/).test(String.fromCharCode(value));\n            },\n\n            isControl: function (value) {\n                if (value < 256) {\n                    return (value >= 0 && value <= 31) || (value >= 127 && value <= 159);\n                }\n\n                return new RegExp(/[\\u0000-\\u001F\\u007F\\u0080-\\u009F]/).test(String.fromCharCode(value));\n            },\n\n            isLatin1: function (ch) {\n                return (ch <= 255);\n            },\n\n            isAscii: function (ch) {\n                return (ch <= 127);\n            },\n\n            isUpper: function (s, index) {\n                if (s == null) {\n                    throw new System.ArgumentNullException(\"s\");\n                }\n\n                if ((index >>> 0) >= ((s.length) >>> 0)) {\n                    throw new System.ArgumentOutOfRangeException(\"index\");\n                }\n\n                var c = s.charCodeAt(index);\n\n                if (System.Char.isLatin1(c)) {\n                    if (System.Char.isAscii(c)) {\n                        return (c >= 65 && c <= 90);\n                    }\n                }\n\n                return Bridge.isUpper(c);\n            },\n\n            equals: function (v1, v2) {\n                if (Bridge.is(v1, System.Char) && Bridge.is(v2, System.Char)) {\n                    return Bridge.unbox(v1, true) === Bridge.unbox(v2, true);\n                }\n\n                return false;\n            },\n\n            equalsT: function (v1, v2) {\n                return Bridge.unbox(v1, true) === Bridge.unbox(v2, true);\n            },\n\n            getHashCode: function(v) {\n                return v | (v << 16);\n            }\n        }\n    });\n\n    Bridge.Class.addExtend(System.Char, [System.IComparable$1(System.Char), System.IEquatable$1(System.Char)]);\n\n    // @source formattableString.js\n\n    Bridge.define(\"System.FormattableString\", {\n        inherits: [System.IFormattable],\n        statics: {\n            methods: {\n                invariant: function (formattable) {\n                    return formattable.toString$1(System.Globalization.CultureInfo.invariantCulture);\n                }\n            }\n        },\n        methods: {\n            toString: function () {\n                return this.toString$1(System.Globalization.CultureInfo.getCurrentCulture());\n            },\n            System$IFormattable$format: function (format, formatProvider) {\n                return this.toString$1(formatProvider);\n            }\n        }\n    });\n\n    // @source formattableStringImpl.js\n\n    Bridge.define(\"System.FormattableStringImpl\", {\n        inherits: [System.FormattableString],\n        fields: {\n            args: null,\n            format: null\n        },\n        props: {\n            ArgumentCount: {\n                get: function () {\n                    return this.args.length;\n                }\n            },\n            Format: {\n                get: function () {\n                    return this.format;\n                }\n            }\n        },\n        ctors: {\n            ctor: function (format, args) {\n                if (args === void 0) { args = []; }\n\n                this.$initialize();\n                System.FormattableString.ctor.call(this);\n                this.format = format;\n                this.args = args;\n            }\n        },\n        methods: {\n            getArgument: function (index) {\n                return this.args[System.Array.index(index, this.args)];\n            },\n            getArguments: function () {\n                return this.args;\n            },\n            toString$1: function (formatProvider) {\n                return System.String.formatProvider.apply(System.String, [formatProvider, this.format].concat(this.args));\n            }\n        }\n    });\n\n    // @source formattableStringFactory.js\n\n    Bridge.define(\"System.Runtime.CompilerServices.FormattableStringFactory\", {\n        statics: {\n            methods: {\n                create: function (format, args) {\n                    if (args === void 0) { args = []; }\n                    return new System.FormattableStringImpl(format, args);\n                }\n            }\n        }\n    });\n\n    // @source Exception.js\n\nBridge.define(\"System.Exception\", {\n        config: {\n            properties: {\n                Message: {\n                    get: function() {\n                        return this.message;\n                    }\n                },\n\n                InnerException: {\n                    get: function () {\n                        return this.innerException;\n                    }\n                },\n\n                StackTrace: {\n                    get: function () {\n                        return this.errorStack.stack;\n                    }\n                },\n\n                Data: {\n                    get: function () {\n                        return this.data;\n                    }\n                }\n            }\n        },\n\n        ctor: function (message, innerException) {\n            this.$initialize();\n            this.message = message ? message : (\"Exception of type '\" + Bridge.getTypeName(this) + \"' was thrown.\");\n            this.innerException = innerException ? innerException : null;\n            this.errorStack = new Error(this.message);\n            this.data = new (System.Collections.Generic.Dictionary$2(System.Object, System.Object))();\n        },\n\n        getBaseException: function() {\n            var inner = this.innerException;\n            var back = this;\n            \n            while (inner != null) {\n                back = inner;\n                inner = inner.innerException;\n            }\n            \n            return back;  \n        },\n\n        toString: function () {\n            var builder = Bridge.getTypeName(this);\n\n            if (this.Message != null) {\n                builder += \": \" + this.Message + \"\\n\";\n            } else {\n                builder += \"\\n\";\n            }\n                \n            if (this.StackTrace != null) {\n                builder += this.StackTrace + \"\\n\";\n            }\n                \n            return builder;\n        },\n\n        statics: {\n            create: function (error) {\n                if (Bridge.is(error, System.Exception)) {\n                    return error;\n                }\n\n                var ex;\n\n                if (error instanceof TypeError) {\n                    ex = new System.NullReferenceException(error.message, new Bridge.ErrorException(error));\n                } else if (error instanceof RangeError) {\n                    ex = new System.ArgumentOutOfRangeException(null, error.message, new Bridge.ErrorException(error));\n                } else if (error instanceof Error) {\n                    return new Bridge.ErrorException(error);\n                } else if (error && error.error && error.error.stack) {\n                    ex = new System.Exception(error.error.stack);\n                } else {\n                    ex = new System.Exception(error ? error.message ? error.message : error.toString() : null);\n                }\n\n                ex.errorStack = error;\n\n                return ex;\n            }\n        }\n    });\n\n    Bridge.define(\"System.SystemException\", {\n        inherits: [System.Exception],\n\n        ctor: function (message, innerException) {\n            this.$initialize();\n            System.Exception.ctor.call(this, message || \"System error.\", innerException);\n        }\n    });\n\n    Bridge.define(\"System.OutOfMemoryException\", {\n        inherits: [System.SystemException],\n\n        ctor: function (message, innerException) {\n            this.$initialize();\n\n            if (!message) {\n                message = \"Insufficient memory to continue the execution of the program.\";\n            }\n\n            System.SystemException.ctor.call(this, message, innerException);\n        }\n    });\n\n    Bridge.define(\"System.IndexOutOfRangeException\", {\n        inherits: [System.SystemException],\n\n        ctor: function (message, innerException) {\n            this.$initialize();\n\n            if (!message) {\n                message = \"Index was outside the bounds of the array.\";\n            }\n\n            System.SystemException.ctor.call(this, message, innerException);\n        }\n    });\n\n    Bridge.define(\"System.TimeoutException\", {\n        inherits: [System.SystemException],\n\n        ctor: function (message, innerException) {\n            this.$initialize();\n\n            if (!message) {\n                message = \"The operation has timed out.\";\n            }\n\n            System.SystemException.ctor.call(this, message, innerException);\n        }\n    });\n\n    Bridge.define(\"System.RegexMatchTimeoutException\", {\n        inherits: [System.TimeoutException],\n\n        _regexInput: \"\",\n\n        _regexPattern: \"\",\n\n        _matchTimeout: null,\n\n        config: {\n            init: function () {\n                this._matchTimeout = System.TimeSpan.fromTicks(-1);\n            }\n        },\n\n        ctor: function (message, innerException, matchTimeout) {\n            this.$initialize();\n\n            if (arguments.length == 3) {\n                this._regexInput = message;\n                this._regexPattern = innerException;\n                this._matchTimeout = matchTimeout;\n\n                message = \"The RegEx engine has timed out while trying to match a pattern to an input string. This can occur for many reasons, including very large inputs or excessive backtracking caused by nested quantifiers, back-references and other factors.\";\n                innerException = null;\n            }\n\n            System.TimeoutException.ctor.call(this, message, innerException);\n        },\n\n        getPattern: function () {\n            return this._regexPattern;\n        },\n\n        getInput: function () {\n            return this._regexInput;\n        },\n\n        getMatchTimeout: function () {\n            return this._matchTimeout;\n        }\n    });\n\n    Bridge.define(\"Bridge.ErrorException\", {\n        inherits: [System.Exception],\n\n        ctor: function (error) {\n            this.$initialize();\n            System.Exception.ctor.call(this, error.message);\n            this.errorStack = error;\n            this.error = error;\n        },\n\n        getError: function () {\n            return this.error;\n        }\n    });\n\n    Bridge.define(\"System.ArgumentException\", {\n        inherits: [System.Exception],\n\n        config: {\n            properties: {\n                ParamName: {\n                    get: function() {\n                        return this.paramName;\n                    }\n                }\n            }  \n        },\n\n        ctor: function (message, paramName, innerException) {\n            this.$initialize();\n            System.Exception.ctor.call(this, message || \"Value does not fall within the expected range.\", innerException);\n            this.paramName = paramName ? paramName : null;\n        }\n    });\n\n    Bridge.define(\"System.ArgumentNullException\", {\n        inherits: [System.ArgumentException],\n\n        ctor: function (paramName, message, innerException) {\n            this.$initialize();\n\n            if (!message) {\n                message = \"Value cannot be null.\";\n\n                if (paramName) {\n                    message += \"\\nParameter name: \" + paramName;\n                }\n            }\n\n            System.ArgumentException.ctor.call(this, message, paramName, innerException);\n        }\n    });\n\n    Bridge.define(\"System.ArgumentOutOfRangeException\", {\n        inherits: [System.ArgumentException],\n\n        config: {\n            properties: {\n                ActualValue: {\n                    get: function () {\n                        return this.actualValue;\n                    }\n                }\n            }\n        },\n\n        ctor: function (paramName, message, innerException, actualValue) {\n            this.$initialize();\n\n            if (!message) {\n                message = \"Value is out of range.\";\n\n                if (paramName) {\n                    message += \"\\nParameter name: \" + paramName;\n                }\n            }\n\n            System.ArgumentException.ctor.call(this, message, paramName, innerException);\n\n            this.actualValue = actualValue ? actualValue : null;\n        }\n    });\n\n    Bridge.define(\"System.Globalization.CultureNotFoundException\", {\n        inherits: [System.ArgumentException],\n\n        ctor: function (paramName, invalidCultureName, message, innerException, invalidCultureId) {\n            this.$initialize();\n\n            if (!message) {\n                message = \"Culture is not supported.\";\n\n                if (paramName) {\n                    message += \"\\nParameter name: \" + paramName;\n                }\n\n                if (invalidCultureName) {\n                    message += \"\\n\" + invalidCultureName + \" is an invalid culture identifier.\";\n                }\n            }\n\n            System.ArgumentException.ctor.call(this, message, paramName, innerException);\n\n            this.invalidCultureName = invalidCultureName ? invalidCultureName : null;\n            this.invalidCultureId = invalidCultureId ? invalidCultureId : null;\n        },\n\n        getInvalidCultureName: function () {\n            return this.invalidCultureName;\n        },\n\n        getInvalidCultureId: function () {\n            return this.invalidCultureId;\n        }\n    });\n\n    Bridge.define(\"System.Collections.Generic.KeyNotFoundException\", {\n        inherits: [System.Exception],\n\n        ctor: function (message, innerException) {\n            this.$initialize();\n            System.Exception.ctor.call(this, message || \"Key not found.\", innerException);\n        }\n    });\n\n    Bridge.define(\"System.ArithmeticException\", {\n        inherits: [System.Exception],\n\n        ctor: function (message, innerException) {\n            this.$initialize();\n            System.Exception.ctor.call(this, message || \"Overflow or underflow in the arithmetic operation.\", innerException);\n        }\n    });\n\n    Bridge.define(\"System.DivideByZeroException\", {\n        inherits: [System.ArithmeticException],\n\n        ctor: function (message, innerException) {\n            this.$initialize();\n            System.ArithmeticException.ctor.call(this, message || \"Attempted to divide by zero.\", innerException);\n        }\n    });\n\n    Bridge.define(\"System.OverflowException\", {\n        inherits: [System.ArithmeticException],\n\n        ctor: function (message, innerException) {\n            this.$initialize();\n            System.ArithmeticException.ctor.call(this, message || \"Arithmetic operation resulted in an overflow.\", innerException);\n        }\n    });\n\n    Bridge.define(\"System.FormatException\", {\n        inherits: [System.Exception],\n\n        ctor: function (message, innerException) {\n            this.$initialize();\n            System.Exception.ctor.call(this, message || \"Invalid format.\", innerException);\n        }\n    });\n\n    Bridge.define(\"System.InvalidCastException\", {\n        inherits: [System.Exception],\n\n        ctor: function (message, innerException) {\n            this.$initialize();\n            System.Exception.ctor.call(this, message || \"The cast is not valid.\", innerException);\n        }\n    });\n\n    Bridge.define(\"System.InvalidOperationException\", {\n        inherits: [System.Exception],\n\n        ctor: function (message, innerException) {\n            this.$initialize();\n            System.Exception.ctor.call(this, message || \"Operation is not valid due to the current state of the object.\", innerException);\n        }\n    });\n\n    Bridge.define(\"System.NotImplementedException\", {\n        inherits: [System.Exception],\n\n        ctor: function (message, innerException) {\n            this.$initialize();\n            System.Exception.ctor.call(this, message || \"The method or operation is not implemented.\", innerException);\n        }\n    });\n\n    Bridge.define(\"System.NotSupportedException\", {\n        inherits: [System.Exception],\n\n        ctor: function (message, innerException) {\n            this.$initialize();\n            System.Exception.ctor.call(this, message || \"Specified method is not supported.\", innerException);\n        }\n    });\n\n    Bridge.define(\"System.NullReferenceException\", {\n        inherits: [System.Exception],\n\n        ctor: function (message, innerException) {\n            this.$initialize();\n            System.Exception.ctor.call(this, message || \"Object is null.\", innerException);\n        }\n    });\n\n    Bridge.define(\"System.RankException\", {\n        inherits: [System.Exception],\n\n        ctor: function (message, innerException) {\n            this.$initialize();\n            System.Exception.ctor.call(this, message || \"Attempted to operate on an array with the incorrect number of dimensions.\", innerException);\n        }\n    });\n\n    Bridge.define(\"Bridge.PromiseException\", {\n        inherits: [System.Exception],\n\n        ctor: function (args, message, innerException) {\n            this.$initialize();\n            this.arguments = System.Array.clone(args);\n\n            if (message == null) {\n                message = \"Promise exception: [\";\n                message += this.arguments.map(function (item) { return item == null ? \"null\" : item.toString(); }).join(\", \");\n                message += \"]\";\n            }\n\n            System.Exception.ctor.call(this, message, innerException);\n        },\n\n        getArguments: function () {\n            return this.arguments;\n        }\n    });\n\n    Bridge.define(\"System.OperationCanceledException\", {\n        inherits: [System.Exception],\n\n        ctor: function (message, token, innerException) {\n            this.$initialize();\n            System.Exception.ctor.call(this, message || \"Operation was canceled.\", innerException);\n            this.cancellationToken = token || System.Threading.CancellationToken.none;\n        }\n    });\n\n    Bridge.define(\"System.Threading.Tasks.TaskCanceledException\", {\n        inherits: [System.OperationCanceledException],\n\n        ctor: function (message, task, innerException) {\n            this.$initialize();\n            System.OperationCanceledException.ctor.call(this, message || \"A task was canceled.\", null, innerException);\n            this.task = task || null;\n        }\n    });\n\n    Bridge.define(\"System.AggregateException\", {\n        inherits: [System.Exception],\n\n        ctor: function (message, innerExceptions) {\n            this.$initialize();\n            this.innerExceptions = new(System.Collections.ObjectModel.ReadOnlyCollection$1(System.Exception))(Bridge.hasValue(innerExceptions) ? Bridge.toArray(innerExceptions) : []);\n            System.Exception.ctor.call(this, message || 'One or more errors occurred.', this.innerExceptions.Count > 0 ? this.innerExceptions.getItem(0) : null);\n        },\n\n        handle: function (predicate) {\n            if (!Bridge.hasValue(predicate)) {\n                throw new System.ArgumentNullException(\"predicate\");\n            }\n\n            var count = this.innerExceptions.Count,\n                unhandledExceptions = [];\n\n            for (var i = 0; i < count; i++) {\n                if (!predicate(this.innerExceptions.get(i))) {\n                    unhandledExceptions.push(this.innerExceptions.getItem(i));\n                }\n            }\n\n            if (unhandledExceptions.length > 0) {\n                throw new System.AggregateException(this.Message, unhandledExceptions);\n            }\n        },\n\n        getBaseException: function() {\n            var back = this;\n            var backAsAggregate = this;\n            while (backAsAggregate != null && backAsAggregate.innerExceptions.Count === 1)\n            {\n                back = back.InnerException;\n                backAsAggregate = Bridge.as(back, System.AggregateException);\n            }\n            return back;  \n        },\n\n        flatten: function () {\n            // Initialize a collection to contain the flattened exceptions.\n            var flattenedExceptions = new(System.Collections.Generic.List$1(System.Exception))();\n\n            // Create a list to remember all aggregates to be flattened, this will be accessed like a FIFO queue\n            var exceptionsToFlatten = new(System.Collections.Generic.List$1(System.AggregateException))();\n            exceptionsToFlatten.add(this);\n            var nDequeueIndex = 0;\n\n            // Continue removing and recursively flattening exceptions, until there are no more.\n            while (exceptionsToFlatten.Count > nDequeueIndex) {\n                // dequeue one from exceptionsToFlatten\n                var currentInnerExceptions = exceptionsToFlatten.getItem(nDequeueIndex++).innerExceptions,\n                    count = currentInnerExceptions.Count;\n\n                for (var i = 0; i < count; i++) {\n                    var currentInnerException = currentInnerExceptions.getItem(i);\n\n                    if (!Bridge.hasValue(currentInnerException)) {\n                        continue;\n                    }\n\n                    var currentInnerAsAggregate = Bridge.as(currentInnerException, System.AggregateException);\n\n                    // If this exception is an aggregate, keep it around for later.  Otherwise,\n                    // simply add it to the list of flattened exceptions to be returned.\n                    if (Bridge.hasValue(currentInnerAsAggregate)) {\n                        exceptionsToFlatten.add(currentInnerAsAggregate);\n                    } else {\n                        flattenedExceptions.add(currentInnerException);\n                    }\n                }\n            }\n\n            return new System.AggregateException(this.Message, flattenedExceptions);\n        }\n    });\n\n    Bridge.define(\"System.Reflection.AmbiguousMatchException\", {\n        inherits: [System.Exception],\n\n        ctor: function (message, innerException) {\n            this.$initialize();\n            System.Exception.ctor.call(this, message || \"Ambiguous match.\", innerException);\n        }\n    });\n\n    // @source textInfo.js\n\n    Bridge.define(\"System.Globalization.TextInfo\", {\n        inherits: [System.ICloneable,System.Object],\n        fields: {\n            listSeparator: null\n        },\n        props: {\n            ANSICodePage: 0,\n            CultureName: null,\n            EBCDICCodePage: 0,\n            IsReadOnly: false,\n            IsRightToLeft: false,\n            LCID: 0,\n            ListSeparator: {\n                get: function () {\n                    return this.listSeparator;\n                },\n                set: function (value) {\n                    this.verifyWritable();\n\n                    this.listSeparator = value;\n                }\n            },\n            MacCodePage: 0,\n            OEMCodePage: 0\n        },\n        alias: [\"clone\", \"System$ICloneable$clone\"],\n        methods: {\n            clone: function () {\n                return Bridge.copy(new System.Globalization.TextInfo(), this, System.Array.init([\"ANSICodePage\", \"CultureName\", \"EBCDICCodePage\", \"IsRightToLeft\", \"LCID\", \"listSeparator\", \"MacCodePage\", \"OEMCodePage\", \"IsReadOnly\"], System.String));\n            },\n            verifyWritable: function () {\n                if (this.IsReadOnly) {\n                    throw new System.InvalidOperationException(\"Instance is read-only.\");\n                }\n            }\n        }\n    });\n\n    // @source Globalization.js\n\n    Bridge.define(\"System.Globalization.DateTimeFormatInfo\", {\n        inherits: [System.IFormatProvider, System.ICloneable],\n\n        config: {\n            alias: [\n                \"getFormat\", \"System$IFormatProvider$getFormat\"\n            ]\n        },\n\n        statics: {\n            $allStandardFormats: {\n                \"d\": \"shortDatePattern\",\n                \"D\": \"longDatePattern\",\n                \"f\": \"longDatePattern shortTimePattern\",\n                \"F\": \"longDatePattern longTimePattern\",\n                \"g\": \"shortDatePattern shortTimePattern\",\n                \"G\": \"shortDatePattern longTimePattern\",\n                \"m\": \"monthDayPattern\",\n                \"M\": \"monthDayPattern\",\n                \"o\": \"roundtripFormat\",\n                \"O\": \"roundtripFormat\",\n                \"r\": \"rfc1123\",\n                \"R\": \"rfc1123\",\n                \"s\": \"sortableDateTimePattern\",\n                \"S\": \"sortableDateTimePattern1\",\n                \"t\": \"shortTimePattern\",\n                \"T\": \"longTimePattern\",\n                \"u\": \"universalSortableDateTimePattern\",\n                \"U\": \"longDatePattern longTimePattern\",\n                \"y\": \"yearMonthPattern\",\n                \"Y\": \"yearMonthPattern\"\n            },\n\n            ctor: function () {\n                this.invariantInfo = Bridge.merge(new System.Globalization.DateTimeFormatInfo(), {\n                    abbreviatedDayNames: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n                    abbreviatedMonthGenitiveNames: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\", \"\"],\n                    abbreviatedMonthNames: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\", \"\"],\n                    amDesignator: \"AM\",\n                    dateSeparator: \"/\",\n                    dayNames: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n                    firstDayOfWeek: 0,\n                    fullDateTimePattern: \"dddd, dd MMMM yyyy HH:mm:ss\",\n                    longDatePattern: \"dddd, dd MMMM yyyy\",\n                    longTimePattern: \"HH:mm:ss\",\n                    monthDayPattern: \"MMMM dd\",\n                    monthGenitiveNames: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\", \"\"],\n                    monthNames: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\", \"\"],\n                    pmDesignator: \"PM\",\n                    rfc1123: \"ddd, dd MMM yyyy HH':'mm':'ss 'GMT'\",\n                    shortDatePattern: \"MM/dd/yyyy\",\n                    shortestDayNames: [\"Su\", \"Mo\", \"Tu\", \"We\", \"Th\", \"Fr\", \"Sa\"],\n                    shortTimePattern: \"HH:mm\",\n                    sortableDateTimePattern: \"yyyy'-'MM'-'dd'T'HH':'mm':'ss\",\n                    sortableDateTimePattern1: \"yyyy'-'MM'-'dd\",\n                    timeSeparator: \":\",\n                    universalSortableDateTimePattern: \"yyyy'-'MM'-'dd HH':'mm':'ss'Z'\",\n                    yearMonthPattern: \"yyyy MMMM\",\n                    roundtripFormat: \"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffzzz\"\n                });\n            }\n        },\n\n        getFormat: function (type) {\n            switch (type) {\n                case System.Globalization.DateTimeFormatInfo:\n                    return this;\n                default:\n                    return null;\n            }\n        },\n\n        getAbbreviatedDayName: function (dayofweek) {\n            if (dayofweek < 0 || dayofweek > 6) {\n                throw new System.ArgumentOutOfRangeException(\"dayofweek\");\n            }\n\n            return this.abbreviatedDayNames[dayofweek];\n        },\n\n        getAbbreviatedMonthName: function (month) {\n            if (month < 1 || month > 13) {\n                throw new System.ArgumentOutOfRangeException(\"month\");\n            }\n\n            return this.abbreviatedMonthNames[month - 1];\n        },\n\n        getAllDateTimePatterns: function (format, returnNull) {\n            var f = System.Globalization.DateTimeFormatInfo.$allStandardFormats,\n                formats,\n                names,\n                pattern,\n                i,\n                result = [];\n\n            if (format) {\n                if (!f[format]) {\n                    if (returnNull) {\n                        return null;\n                    }\n\n                    throw new System.ArgumentException(null, \"format\");\n                }\n\n                formats = {};\n                formats[format] = f[format];\n            } else {\n                formats = f;\n            }\n\n            for (f in formats) {\n                names = formats[f].split(\" \");\n                pattern = \"\";\n\n                for (i = 0; i < names.length; i++) {\n                    pattern = (i === 0 ? \"\" : (pattern + \" \")) + this[names[i]];\n                }\n\n                result.push(pattern);\n            }\n\n            return result;\n        },\n\n        getDayName: function (dayofweek) {\n            if (dayofweek < 0 || dayofweek > 6) {\n                throw new System.ArgumentOutOfRangeException(\"dayofweek\");\n            }\n\n            return this.dayNames[dayofweek];\n        },\n\n        getMonthName: function (month) {\n            if (month < 1 || month > 13) {\n                throw new System.ArgumentOutOfRangeException(\"month\");\n            }\n\n            return this.monthNames[month - 1];\n        },\n\n        getShortestDayName: function (dayOfWeek) {\n            if (dayOfWeek < 0 || dayOfWeek > 6) {\n                throw new System.ArgumentOutOfRangeException(\"dayOfWeek\");\n            }\n\n            return this.shortestDayNames[dayOfWeek];\n        },\n\n        clone: function () {\n            return Bridge.copy(new System.Globalization.DateTimeFormatInfo(), this, [\n                \"abbreviatedDayNames\",\n                \"abbreviatedMonthGenitiveNames\",\n                \"abbreviatedMonthNames\",\n                \"amDesignator\",\n                \"dateSeparator\",\n                \"dayNames\",\n                \"firstDayOfWeek\",\n                \"fullDateTimePattern\",\n                \"longDatePattern\",\n                \"longTimePattern\",\n                \"monthDayPattern\",\n                \"monthGenitiveNames\",\n                \"monthNames\",\n                \"pmDesignator\",\n                \"rfc1123\",\n                \"shortDatePattern\",\n                \"shortestDayNames\",\n                \"shortTimePattern\",\n                \"sortableDateTimePattern\",\n                \"timeSeparator\",\n                \"universalSortableDateTimePattern\",\n                \"yearMonthPattern\",\n                \"roundtripFormat\"\n            ]);\n        }\n    });\n\n    Bridge.define(\"System.Globalization.NumberFormatInfo\", {\n        inherits: [System.IFormatProvider, System.ICloneable],\n\n        config: {\n            alias: [\n                \"getFormat\", \"System$IFormatProvider$getFormat\"\n            ]\n        },\n\n        statics: {\n            ctor: function () {\n                this.numberNegativePatterns = [\"(n)\", \"-n\", \"- n\", \"n-\", \"n -\"];\n                this.currencyNegativePatterns = [\"($n)\", \"-$n\", \"$-n\", \"$n-\", \"(n$)\", \"-n$\", \"n-$\", \"n$-\", \"-n $\", \"-$ n\", \"n $-\", \"$ n-\", \"$ -n\", \"n- $\", \"($ n)\", \"(n $)\"];\n                this.currencyPositivePatterns = [\"$n\", \"n$\", \"$ n\", \"n $\"];\n                this.percentNegativePatterns = [\"-n %\", \"-n%\", \"-%n\", \"%-n\", \"%n-\", \"n-%\", \"n%-\", \"-% n\", \"n %-\", \"% n-\", \"% -n\", \"n- %\"];\n                this.percentPositivePatterns = [\"n %\", \"n%\", \"%n\", \"% n\"];\n\n                this.invariantInfo = Bridge.merge(new System.Globalization.NumberFormatInfo(), {\n                    nanSymbol: \"NaN\",\n                    negativeSign: \"-\",\n                    positiveSign: \"+\",\n                    negativeInfinitySymbol: \"-Infinity\",\n                    positiveInfinitySymbol: \"Infinity\",\n\n                    percentSymbol: \"%\",\n                    percentGroupSizes: [3],\n                    percentDecimalDigits: 2,\n                    percentDecimalSeparator: \".\",\n                    percentGroupSeparator: \",\",\n                    percentPositivePattern: 0,\n                    percentNegativePattern: 0,\n\n                    currencySymbol: \"¤\",\n                    currencyGroupSizes: [3],\n                    currencyDecimalDigits: 2,\n                    currencyDecimalSeparator: \".\",\n                    currencyGroupSeparator: \",\",\n                    currencyNegativePattern: 0,\n                    currencyPositivePattern: 0,\n\n                    numberGroupSizes: [3],\n                    numberDecimalDigits: 2,\n                    numberDecimalSeparator: \".\",\n                    numberGroupSeparator: \",\",\n                    numberNegativePattern: 1\n                });\n            }\n        },\n\n        getFormat: function (type) {\n            switch (type) {\n                case System.Globalization.NumberFormatInfo:\n                    return this;\n                default:\n                    return null;\n            }\n        },\n\n        clone: function () {\n            return Bridge.copy(new System.Globalization.NumberFormatInfo(), this, [\n                \"nanSymbol\",\n                \"negativeSign\",\n                \"positiveSign\",\n                \"negativeInfinitySymbol\",\n                \"positiveInfinitySymbol\",\n                \"percentSymbol\",\n                \"percentGroupSizes\",\n                \"percentDecimalDigits\",\n                \"percentDecimalSeparator\",\n                \"percentGroupSeparator\",\n                \"percentPositivePattern\",\n                \"percentNegativePattern\",\n                \"currencySymbol\",\n                \"currencyGroupSizes\",\n                \"currencyDecimalDigits\",\n                \"currencyDecimalSeparator\",\n                \"currencyGroupSeparator\",\n                \"currencyNegativePattern\",\n                \"currencyPositivePattern\",\n                \"numberGroupSizes\",\n                \"numberDecimalDigits\",\n                \"numberDecimalSeparator\",\n                \"numberGroupSeparator\",\n                \"numberNegativePattern\"\n            ]);\n        }\n    });\n\n    Bridge.define(\"System.Globalization.CultureInfo\", {\n        inherits: [System.IFormatProvider, System.ICloneable],\n\n        config: {\n            alias: [\n                \"getFormat\", \"System$IFormatProvider$getFormat\"\n            ]\n        },\n\n        $entryPoint: true,\n\n        statics: {\n            ctor: function () {\n                this.cultures = this.cultures || {};\n\n                this.invariantCulture = Bridge.merge(new System.Globalization.CultureInfo(\"iv\", true), {\n                    englishName: \"Invariant Language (Invariant Country)\",\n                    nativeName: \"Invariant Language (Invariant Country)\",\n                    numberFormat: System.Globalization.NumberFormatInfo.invariantInfo,\n                    dateTimeFormat: System.Globalization.DateTimeFormatInfo.invariantInfo,\n                    TextInfo: Bridge.merge(new System.Globalization.TextInfo(), {\n                        ANSICodePage: 1252,\n                        CultureName: \"\",\n                        EBCDICCodePage: 37,\n                        listSeparator: \",\",\n                        IsRightToLeft: false,\n                        LCID: 127,\n                        MacCodePage: 10000,\n                        OEMCodePage: 437,\n                        IsReadOnly: true\n                    })\n                });\n\n                this.setCurrentCulture(System.Globalization.CultureInfo.invariantCulture);\n            },\n\n            getCurrentCulture: function () {\n                return this.currentCulture;\n            },\n\n            setCurrentCulture: function (culture) {\n                this.currentCulture = culture;\n\n                System.Globalization.DateTimeFormatInfo.currentInfo = culture.dateTimeFormat;\n                System.Globalization.NumberFormatInfo.currentInfo = culture.numberFormat;\n            },\n\n            getCultureInfo: function (name) {\n                if (name == null) {\n                    throw new System.ArgumentNullException(\"name\");\n                } else if (name === \"\") {\n                    return System.Globalization.CultureInfo.invariantCulture;\n                }\n\n                var c = this.cultures[name];\n\n                if (c == null) {\n                    throw new System.Globalization.CultureNotFoundException(\"name\", name);\n                }\n\n                return c;\n            },\n\n            getCultures: function () {\n                var names = Bridge.getPropertyNames(this.cultures),\n                    result = [],\n                    i;\n\n                for (i = 0; i < names.length; i++) {\n                    result.push(this.cultures[names[i]]);\n                }\n\n                return result;\n            }\n        },\n\n        ctor: function (name, create) {\n            this.$initialize();\n            this.name = name;\n\n            if (!System.Globalization.CultureInfo.cultures) {\n                System.Globalization.CultureInfo.cultures = {};\n            }\n\n            if (name == null) {\n                throw new System.ArgumentNullException(\"name\");\n            }\n\n            var c;\n\n            if (name === \"\") {\n                c =  System.Globalization.CultureInfo.invariantCulture;\n            } else {\n                c = System.Globalization.CultureInfo.cultures[name];\n            }\n\n            if (c == null) {\n                if (!create) {\n                    throw new System.Globalization.CultureNotFoundException(\"name\", name);\n                }\n\n                System.Globalization.CultureInfo.cultures[name] = this;\n            } else {\n                Bridge.copy(this, c, [\n                            \"englishName\",\n                            \"nativeName\",\n                            \"numberFormat\",\n                            \"dateTimeFormat\",\n                            \"TextInfo\"\n                ]);\n\n                this.TextInfo.IsReadOnly = false;\n            }\n        },\n\n        getFormat: function (type) {\n            switch (type) {\n                case System.Globalization.NumberFormatInfo:\n                    return this.numberFormat;\n                case System.Globalization.DateTimeFormatInfo:\n                    return this.dateTimeFormat;\n                default:\n                    return null;\n            }\n        },\n\n        clone: function () {\n            return new System.Globalization.CultureInfo(this.name);\n        }\n    });\n\n    // @source Math.js\n\n    Bridge.Math = {\n        divRem: function (a, b, result) {\n            var remainder = a % b;\n\n            result.v = remainder;\n\n            return (a - remainder) / b;\n        },\n\n        round: function (n, d, rounding) {\n            var m = Math.pow(10, d || 0);\n\n            n *= m;\n\n            var sign = (n > 0) | -(n < 0);\n\n            if (n % 1 === 0.5 * sign) {\n                var f = Math.floor(n);\n\n                return (f + (rounding === 4 ? (sign > 0) : (f % 2 * sign))) / m;\n            }\n\n            return Math.round(n) / m;\n        },\n\n        log10: Math.log10 || function (x) {\n            return Math.log(x) / Math.LN10;\n        },\n\n        logWithBase: function (x, newBase) {\n            if (isNaN(x)) {\n                return x;\n            }\n\n            if (isNaN(newBase)) {\n                return newBase;\n            }\n\n            if (newBase === 1) {\n                return NaN\n            }\n\n            if (x !== 1 && (newBase === 0 || newBase === Number.POSITIVE_INFINITY)) {\n                return NaN;\n            }\n\n            return Bridge.Math.log10(x) / Bridge.Math.log10(newBase);\n        },\n\n        log: function (x) {\n            if (x === 0.0) {\n                return Number.NEGATIVE_INFINITY;\n            }\n\n            if (x < 0.0 || isNaN(x)) {\n                return NaN;\n            }\n\n            if (x === Number.POSITIVE_INFINITY) {\n                return Number.POSITIVE_INFINITY;\n            }\n\n            if (x === Number.NEGATIVE_INFINITY) {\n                return NaN;\n            }\n\n            return Math.log(x);\n        },\n\n        sinh: Math.sinh || function (x) {\n            return (Math.exp(x) - Math.exp(-x)) / 2;\n        },\n\n        cosh: Math.cosh || function (x) {\n            return (Math.exp(x) + Math.exp(-x)) / 2;\n        },\n\n        tanh: Math.tanh || function (x) {\n            if (x === Infinity) {\n                return 1;\n            } else if (x === -Infinity) {\n                return -1;\n            } else {\n                var y = Math.exp(2 * x);\n                return (y - 1) / (y + 1);\n            }\n        }\n    };\n\n    // @source Bool.js\n\nBridge.define(\"System.Boolean\", {\n    inherits: [System.IComparable],\n\n    statics: {\n        trueString: \"True\",\n        falseString: \"False\",\n\n        $is: function (instance) {\n            return typeof (instance) === \"boolean\";\n        },\n\n        getDefaultValue: function () {\n            return false;\n        },\n\n        createInstance: function () {\n            return false;\n        },\n\n        toString: function (v) {\n            return v ? System.Boolean.trueString : System.Boolean.falseString;\n        },\n\n        parse: function (value) {\n            if (!Bridge.hasValue(value)) {\n                throw new System.ArgumentNullException(\"value\");\n            }\n\n            var result = {\n                v: false\n            };\n\n            if (!System.Boolean.tryParse(value, result)) {\n                throw new System.FormatException(\"Bad format for Boolean value\");\n            }\n\n            return result.v;\n        },\n\n        tryParse: function (value, result) {\n            result.v = false;\n\n            if (!Bridge.hasValue(value)) {\n                return false;\n            }\n\n            if (System.String.equals(System.Boolean.trueString, value, 5)) {\n                result.v = true;\n                return true;\n            }\n\n            if (System.String.equals(System.Boolean.falseString, value, 5)) {\n                result.v = false;\n                return true;\n            }\n\n            var start = 0,\n                end = value.length - 1;\n\n            while (start < value.length) {\n                if (!System.Char.isWhiteSpace(value[start]) && !System.Char.isNull(value.charCodeAt(start))) {\n                    break;\n                }\n\n                start++;\n            }\n\n            while (end >= start) {\n                if (!System.Char.isWhiteSpace(value[end]) && !System.Char.isNull(value.charCodeAt(end))) {\n                    break;\n                }\n\n                end--;\n            }\n\n            value = value.substr(start, end - start + 1);\n\n            if (System.String.equals(System.Boolean.trueString, value, 5)) {\n                result.v = true;\n                return true;\n            }\n\n            if (System.String.equals(System.Boolean.falseString, value, 5)) {\n                result.v = false;\n                return true;\n            }\n\n            return false;\n        }\n    }\n});\n\nSystem.Boolean.$kind = \"\";\nBridge.Class.addExtend(System.Boolean, [System.IComparable$1(System.Boolean), System.IEquatable$1(System.Boolean)]);\n    // @source Integer.js\n\n    (function () {\n        var createIntType = function (name, min, max, precision) {\n            var type = Bridge.define(name, {\n                inherits: [System.IComparable, System.IFormattable],\n\n                statics: {\n                    $number: true,\n                    min: min,\n                    max: max,\n                    precision: precision,\n\n                    $is: function (instance) {\n                        return typeof (instance) === \"number\" && Math.floor(instance, 0) === instance && instance >= min && instance <= max;\n                    },\n                    getDefaultValue: function () {\n                        return 0;\n                    },\n                    parse: function (s, radix) {\n                        return Bridge.Int.parseInt(s, min, max, radix);\n                    },\n                    tryParse: function (s, result, radix) {\n                        return Bridge.Int.tryParseInt(s, result, min, max, radix);\n                    },\n                    format: function (number, format, provider) {\n                        return Bridge.Int.format(number, format, provider, type);\n                    },\n                    equals: function (v1, v2) {\n                        if (Bridge.is(v1, type) && Bridge.is(v2, type)) {\n                            return Bridge.unbox(v1, true) === Bridge.unbox(v2, true);\n                        }\n\n                        return false;\n                    },\n                    equalsT: function (v1, v2) {\n                        return Bridge.unbox(v1, true) === Bridge.unbox(v2, true);\n                    }\n                }\n            });\n\n            type.$kind = \"\";\n            Bridge.Class.addExtend(type, [System.IComparable$1(type), System.IEquatable$1(type)]);\n        };\n\n        createIntType(\"System.Byte\", 0, 255, 3);\n        createIntType(\"System.SByte\", -128, 127, 3);\n        createIntType(\"System.Int16\", -32768, 32767, 5);\n        createIntType(\"System.UInt16\", 0, 65535, 5);\n        createIntType(\"System.Int32\", -2147483648, 2147483647, 10);\n        createIntType(\"System.UInt32\", 0, 4294967295, 10);\n    })();\n\n    Bridge.define(\"Bridge.Int\", {\n        inherits: [System.IComparable, System.IFormattable],\n        statics: {\n            $number: true,\n\n            $is: function (instance) {\n                return typeof (instance) === \"number\" && isFinite(instance) && Math.floor(instance, 0) === instance;\n            },\n\n            getDefaultValue: function () {\n                return 0;\n            },\n\n            format: function (number, format, provider, T) {\n                var nf = (provider || System.Globalization.CultureInfo.getCurrentCulture()).getFormat(System.Globalization.NumberFormatInfo),\n                    decimalSeparator = nf.numberDecimalSeparator,\n                    groupSeparator = nf.numberGroupSeparator,\n                    isDecimal = number instanceof System.Decimal,\n                    isLong = number instanceof System.Int64 || number instanceof System.UInt64,\n                    isNeg = isDecimal || isLong ? (number.isZero() ? false : number.isNegative()) : number < 0,\n                    match,\n                    precision,\n                    groups,\n                    fs;\n\n                if (!isLong && (isDecimal ? !number.isFinite() : !isFinite(number))) {\n                    return Number.NEGATIVE_INFINITY === number || (isDecimal && isNeg) ? nf.negativeInfinitySymbol : (isNaN(number) ? nf.nanSymbol : nf.positiveInfinitySymbol);\n                }\n\n                if (!format) {\n                    format = \"G\";\n                }\n\n                match = format.match(/^([a-zA-Z])(\\d*)$/);\n\n                if (match) {\n                    fs = match[1].toUpperCase();\n                    precision = parseInt(match[2], 10);\n                    //precision = precision > 15 ? 15 : precision;\n\n                    switch (fs) {\n                        case \"D\":\n                            return this.defaultFormat(number, isNaN(precision) ? 1 : precision, 0, 0, nf, true);\n                        case \"F\":\n                        case \"N\":\n                            if (isNaN(precision)) {\n                                precision = nf.numberDecimalDigits;\n                            }\n\n                            return this.defaultFormat(number, 1, precision, precision, nf, fs === \"F\");\n                        case \"G\":\n                        case \"E\":\n                            var exponent = 0,\n                                coefficient = isDecimal || isLong ? (isLong && number.eq(System.Int64.MinValue) ? System.Int64(number.value.toUnsigned()) : number.abs()) : Math.abs(number),\n                                exponentPrefix = match[1],\n                                exponentPrecision = 3,\n                                minDecimals,\n                                maxDecimals;\n\n                            while (isDecimal || isLong ? coefficient.gte(10) : (coefficient >= 10)) {\n                                if (isDecimal || isLong) {\n                                    coefficient = coefficient.div(10);\n                                } else {\n                                    coefficient /= 10;\n                                }\n\n                                exponent++;\n                            }\n\n                            while (isDecimal || isLong ? (coefficient.ne(0) && coefficient.lt(1)) : (coefficient !== 0 && coefficient < 1)) {\n                                if (isDecimal || isLong) {\n                                    coefficient = coefficient.mul(10);\n                                } else {\n                                    coefficient *= 10;\n                                }\n                                exponent--;\n                            }\n\n                            if (fs === \"G\") {\n                                var noPrecision = isNaN(precision);\n\n                                if (noPrecision) {\n                                    if (isDecimal) {\n                                        precision = 29;\n                                    } else if (isLong) {\n                                        precision = number instanceof System.Int64 ? 19 : 20;\n                                    } else if (T && T.precision) {\n                                        precision = T.precision;\n                                    } else {\n                                        precision = 15;\n                                    }\n                                }\n\n                                if ((exponent > -5 && exponent < precision) || isDecimal && noPrecision) {\n                                    minDecimals = 0;\n                                    maxDecimals = precision - (exponent > 0 ? exponent + 1 : 1);\n                                    return this.defaultFormat(number, 1, minDecimals, maxDecimals, nf, true);\n                                }\n\n                                exponentPrefix = exponentPrefix === \"G\" ? \"E\" : \"e\";\n                                exponentPrecision = 2;\n                                minDecimals = 0;\n                                maxDecimals = (precision || 15) - 1;\n                            } else {\n                                minDecimals = maxDecimals = isNaN(precision) ? 6 : precision;\n                            }\n\n                            if (exponent >= 0) {\n                                exponentPrefix += nf.positiveSign;\n                            } else {\n                                exponentPrefix += nf.negativeSign;\n                                exponent = -exponent;\n                            }\n\n                            if (isNeg) {\n                                if (isDecimal || isLong) {\n                                    coefficient = coefficient.mul(-1);\n                                } else {\n                                    coefficient *= -1;\n                                }\n                            }\n\n                            return this.defaultFormat(coefficient, 1, minDecimals, maxDecimals, nf) + exponentPrefix + this.defaultFormat(exponent, exponentPrecision, 0, 0, nf, true);\n                        case \"P\":\n                            if (isNaN(precision)) {\n                                precision = nf.percentDecimalDigits;\n                            }\n\n                            return this.defaultFormat(number * 100, 1, precision, precision, nf, false, \"percent\");\n                        case \"X\":\n                            var result = isDecimal ? number.round().value.toHex().substr(2) : (isLong ? number.toString(16) : Math.round(number).toString(16));\n\n                            if (match[1] === \"X\") {\n                                result = result.toUpperCase();\n                            }\n\n                            precision -= result.length;\n\n                            while (precision-- > 0) {\n                                result = \"0\" + result;\n                            }\n\n                            return result;\n                        case \"C\":\n                            if (isNaN(precision)) {\n                                precision = nf.currencyDecimalDigits;\n                            }\n\n                            return this.defaultFormat(number, 1, precision, precision, nf, false, \"currency\");\n                        case \"R\":\n                            var r_result = isDecimal || isLong ? (number.toString()) : (\"\" + number);\n\n                            if (decimalSeparator !== \".\") {\n                                r_result = r_result.replace(\".\", decimalSeparator);\n                            }\n\n                            r_result = r_result.replace(\"e\", \"E\");\n\n                            return r_result;\n                    }\n                }\n\n                if (format.indexOf(\",.\") !== -1 || System.String.endsWith(format, \",\")) {\n                    var count = 0,\n                        index = format.indexOf(\",.\");\n\n                    if (index === -1) {\n                        index = format.length - 1;\n                    }\n\n                    while (index > -1 && format.charAt(index) === \",\") {\n                        count++;\n                        index--;\n                    }\n\n                    if (isDecimal || isLong) {\n                        number = number.div(Math.pow(1000, count));\n                    } else {\n                        number /= Math.pow(1000, count);\n                    }\n                }\n\n                if (format.indexOf(\"%\") !== -1) {\n                    if (isDecimal || isLong) {\n                        number = number.mul(100);\n                    } else {\n                        number *= 100;\n                    }\n                }\n\n                if (format.indexOf(\"‰\") !== -1) {\n                    if (isDecimal || isLong) {\n                        number = number.mul(1000);\n                    } else {\n                        number *= 1000;\n                    }\n                }\n\n                groups = format.split(\";\");\n\n                if ((isDecimal || isLong ? number.lt(0) : (number < 0)) && groups.length > 1) {\n                    if (isDecimal || isLong) {\n                        number = number.mul(-1);\n                    } else {\n                        number *= -1;\n                    }\n\n                    format = groups[1];\n                } else {\n                    format = groups[(isDecimal || isLong ? number.ne(0) : !number) && groups.length > 2 ? 2 : 0];\n                }\n\n                return this.customFormat(number, format, nf, !format.match(/^[^\\.]*[0#],[0#]/));\n            },\n\n            defaultFormat: function (number, minIntLen, minDecLen, maxDecLen, provider, noGroup, name) {\n                name = name || \"number\";\n\n                var nf = (provider || System.Globalization.CultureInfo.getCurrentCulture()).getFormat(System.Globalization.NumberFormatInfo),\n                    str,\n                    decimalIndex,\n                    pattern,\n                    roundingFactor,\n                    groupIndex,\n                    groupSize,\n                    groups = nf[name + \"GroupSizes\"],\n                    decimalPart,\n                    index,\n                    done,\n                    startIndex,\n                    length,\n                    part,\n                    sep,\n                    buffer = \"\",\n                    isDecimal = number instanceof System.Decimal,\n                    isLong = number instanceof System.Int64 || number instanceof System.UInt64,\n                    isNeg = isDecimal || isLong ? (number.isZero() ? false : number.isNegative()) : number < 0,\n                    isZero = false;\n\n                roundingFactor = Math.pow(10, maxDecLen);\n\n                if (isDecimal) {\n                    str = number.abs().toDecimalPlaces(maxDecLen).toFixed();\n                } else if (isLong) {\n                    str = number.eq(System.Int64.MinValue) ? number.value.toUnsigned().toString() : number.abs().toString();\n                } else {\n                    str = \"\" + (+Math.abs(number).toFixed(maxDecLen));\n                }\n\n                isZero = str.split('').every(function (s) { return s === '0' || s === '.'; });\n\n                decimalIndex = str.indexOf(\".\");\n\n                if (decimalIndex > 0) {\n                    decimalPart = nf[name + \"DecimalSeparator\"] + str.substr(decimalIndex + 1);\n                    str = str.substr(0, decimalIndex);\n                }\n\n                if (str.length < minIntLen) {\n                    str = Array(minIntLen - str.length + 1).join(\"0\") + str;\n                }\n\n                if (decimalPart) {\n                    if ((decimalPart.length - 1) < minDecLen) {\n                        decimalPart += Array(minDecLen - decimalPart.length + 2).join(\"0\");\n                    }\n\n                    if (maxDecLen === 0) {\n                        decimalPart = null;\n                    } else if ((decimalPart.length - 1) > maxDecLen) {\n                        decimalPart = decimalPart.substr(0, maxDecLen + 1);\n                    }\n                } else if (minDecLen > 0) {\n                    decimalPart = nf[name + \"DecimalSeparator\"] + Array(minDecLen + 1).join(\"0\");\n                }\n\n                groupIndex = 0;\n                groupSize = groups[groupIndex];\n\n                if (str.length < groupSize) {\n                    buffer = str;\n\n                    if (decimalPart) {\n                        buffer += decimalPart;\n                    }\n                } else {\n                    index = str.length;\n                    done = false;\n                    sep = noGroup ? \"\" : nf[name + \"GroupSeparator\"];\n\n                    while (!done) {\n                        length = groupSize;\n                        startIndex = index - length;\n\n                        if (startIndex < 0) {\n                            groupSize += startIndex;\n                            length += startIndex;\n                            startIndex = 0;\n                            done = true;\n                        }\n\n                        if (!length) {\n                            break;\n                        }\n\n                        part = str.substr(startIndex, length);\n\n                        if (buffer.length) {\n                            buffer = part + sep + buffer;\n                        } else {\n                            buffer = part;\n                        }\n\n                        index -= length;\n\n                        if (groupIndex < groups.length - 1) {\n                            groupIndex++;\n                            groupSize = groups[groupIndex];\n                        }\n                    }\n\n                    if (decimalPart) {\n                        buffer += decimalPart;\n                    }\n                }\n\n                if (isNeg && !isZero) {\n                    pattern = System.Globalization.NumberFormatInfo[name + \"NegativePatterns\"][nf[name + \"NegativePattern\"]];\n\n                    return pattern.replace(\"-\", nf.negativeSign).replace(\"%\", nf.percentSymbol).replace(\"$\", nf.currencySymbol).replace(\"n\", buffer);\n                } else if (System.Globalization.NumberFormatInfo[name + \"PositivePatterns\"]) {\n                    pattern = System.Globalization.NumberFormatInfo[name + \"PositivePatterns\"][nf[name + \"PositivePattern\"]];\n\n                    return pattern.replace(\"%\", nf.percentSymbol).replace(\"$\", nf.currencySymbol).replace(\"n\", buffer);\n                }\n\n                return buffer;\n            },\n\n            customFormat: function (number, format, nf, noGroup) {\n                var digits = 0,\n                    forcedDigits = -1,\n                    integralDigits = -1,\n                    decimals = 0,\n                    forcedDecimals = -1,\n                    atDecimals = 0,\n                    unused = 1,\n                    c, i, f,\n                    endIndex,\n                    roundingFactor,\n                    decimalIndex,\n                    isNegative = false,\n                    isZero = false,\n                    name,\n                    groupCfg,\n                    buffer = \"\",\n                    isZeroInt = false,\n                    wasSeparator = false,\n                    wasIntPart = false,\n                    isDecimal = number instanceof System.Decimal,\n                    isLong = number instanceof System.Int64 || number instanceof System.UInt64,\n                    isNeg = isDecimal || isLong ? (number.isZero() ? false : number.isNegative()) : number < 0;\n\n                name = \"number\";\n\n                if (format.indexOf(\"%\") !== -1) {\n                    name = \"percent\";\n                } else if (format.indexOf(\"$\") !== -1) {\n                    name = \"currency\";\n                }\n\n                for (i = 0; i < format.length; i++) {\n                    c = format.charAt(i);\n\n                    if (c === \"'\" || c === '\"') {\n                        i = format.indexOf(c, i + 1);\n\n                        if (i < 0) {\n                            break;\n                        }\n                    } else if (c === \"\\\\\") {\n                        i++;\n                    } else {\n                        if (c === \"0\" || c === \"#\") {\n                            decimals += atDecimals;\n\n                            if (c === \"0\") {\n                                if (atDecimals) {\n                                    forcedDecimals = decimals;\n                                } else if (forcedDigits < 0) {\n                                    forcedDigits = digits;\n                                }\n                            }\n\n                            digits += !atDecimals;\n                        }\n\n                        atDecimals = atDecimals || c === \".\";\n                    }\n                }\n                forcedDigits = forcedDigits < 0 ? 1 : digits - forcedDigits;\n\n                if (isNeg) {\n                    isNegative = true;\n                }\n\n                roundingFactor = Math.pow(10, decimals);\n\n                if (isDecimal) {\n                    number = System.Decimal.round(number.abs().mul(roundingFactor), 4).div(roundingFactor).toString();\n                } else if (isLong) {\n                    number = (number.eq(System.Int64.MinValue) ? System.Int64(number.value.toUnsigned()) : number.abs()).mul(roundingFactor).div(roundingFactor).toString();\n                } else {\n                    number = \"\" + (Math.round(Math.abs(number) * roundingFactor) / roundingFactor);\n                }\n\n                isZero = number.split('').every(function (s) { return s === '0' || s === '.'; });\n\n                decimalIndex = number.indexOf(\".\");\n                integralDigits = decimalIndex < 0 ? number.length : decimalIndex;\n                i = integralDigits - digits;\n\n                groupCfg = {\n                    groupIndex: Math.max(integralDigits, forcedDigits),\n                    sep: noGroup ? \"\" : nf[name + \"GroupSeparator\"]\n                };\n\n                if (integralDigits === 1 && number.charAt(0) === \"0\") {\n                    isZeroInt = true;\n                }\n\n                for (f = 0; f < format.length; f++) {\n                    c = format.charAt(f);\n\n                    if (c === \"'\" || c === '\"') {\n                        endIndex = format.indexOf(c, f + 1);\n\n                        buffer += format.substring(f + 1, endIndex < 0 ? format.length : endIndex);\n\n                        if (endIndex < 0) {\n                            break;\n                        }\n\n                        f = endIndex;\n                    } else if (c === \"\\\\\") {\n                        buffer += format.charAt(f + 1);\n                        f++;\n                    } else if (c === \"#\" || c === \"0\") {\n                        wasIntPart = true;\n\n                        if (!wasSeparator && isZeroInt && c === \"#\") {\n                            i++;\n                        } else {\n                            groupCfg.buffer = buffer;\n\n                            if (i < integralDigits) {\n                                if (i >= 0) {\n                                    if (unused) {\n                                        this.addGroup(number.substr(0, i), groupCfg);\n                                    }\n\n                                    this.addGroup(number.charAt(i), groupCfg);\n                                } else if (i >= integralDigits - forcedDigits) {\n                                    this.addGroup(\"0\", groupCfg);\n                                }\n\n                                unused = 0;\n                            } else if (forcedDecimals-- > 0 || i < number.length) {\n                                this.addGroup(i >= number.length ? \"0\" : number.charAt(i), groupCfg);\n                            }\n\n                            buffer = groupCfg.buffer;\n\n                            i++;\n                        }\n                    } else if (c === \".\") {\n                        if (!wasIntPart && !isZeroInt) {\n                            buffer += number.substr(0, integralDigits);\n                            wasIntPart = true;\n                        }\n\n                        if (number.length > ++i || forcedDecimals > 0) {\n                            wasSeparator = true;\n                            buffer += nf[name + \"DecimalSeparator\"];\n                        }\n                    } else if (c !== \",\") {\n                        buffer += c;\n                    }\n                }\n\n                if (isNegative && !isZero) {\n                    buffer = \"-\" + buffer;\n                }\n\n                return buffer;\n            },\n\n            addGroup: function (value, cfg) {\n                var buffer = cfg.buffer,\n                    sep = cfg.sep,\n                    groupIndex = cfg.groupIndex;\n\n                for (var i = 0, length = value.length; i < length; i++) {\n                    buffer += value.charAt(i);\n\n                    if (sep && groupIndex > 1 && groupIndex-- % 3 === 1) {\n                        buffer += sep;\n                    }\n                }\n\n                cfg.buffer = buffer;\n                cfg.groupIndex = groupIndex;\n            },\n\n            parseFloat: function (s, provider) {\n                var res = { };\n\n                Bridge.Int.tryParseFloat(s, provider, res, false);\n\n                return res.v;\n            },\n\n            tryParseFloat: function (s, provider, result, safe) {\n                result.v = 0;\n\n                if (safe == null) {\n                    safe = true;\n                }\n\n                if (s == null) {\n                    if (safe) {\n                        return false;\n                    }\n                    throw new System.ArgumentNullException(\"s\");\n                }\n\n                s = s.trim();\n\n                var nfInfo = (provider || System.Globalization.CultureInfo.getCurrentCulture()).getFormat(System.Globalization.NumberFormatInfo),\n                    point = nfInfo.numberDecimalSeparator,\n                    thousands = nfInfo.numberGroupSeparator;\n\n                var errMsg = \"Input string was not in a correct format.\";\n\n                var pointIndex = s.indexOf(point);\n                var thousandIndex = thousands ? s.indexOf(thousands) : -1;\n\n                if (pointIndex > -1) {\n                    // point before thousands is not allowed\n                    // \"10.2,5\" -> FormatException\n                    // \"1,0.2,5\" -> FormatException\n                    if (((pointIndex < thousandIndex) || ((thousandIndex > -1) && (pointIndex < s.indexOf(thousands, pointIndex))))\n                        // only one point is allowed\n                        || (s.indexOf(point, pointIndex + 1) > -1)) {\n                        if (safe) {\n                            return false;\n                        }\n                        throw new System.FormatException(errMsg);\n                    }\n                }\n\n                if ((point !== \".\") && (thousands !== \".\") && (s.indexOf(\".\") > -1)) {\n                    if (safe) {\n                        return false;\n                    }\n                    throw new System.FormatException(errMsg);\n                }\n\n                if (thousandIndex > -1) {\n                    // mutiple thousands are allowed, so we remove them before going further\n                    var tmpStr = \"\";\n\n                    for (var i = 0; i < s.length; i++) {\n                        if (s[i] !== thousands) {\n                            tmpStr += s[i];\n                        }\n                    }\n\n                    s = tmpStr;\n                }\n\n                if (s === nfInfo.negativeInfinitySymbol) {\n                    result.v = Number.NEGATIVE_INFINITY;\n                    return true;\n                } else if (s === nfInfo.positiveInfinitySymbol) {\n                    result.v = Number.POSITIVE_INFINITY;\n                    return true;\n                } else if (s === nfInfo.nanSymbol) {\n                    result.v = Number.NaN;\n                    return true;\n                }\n\n                var countExp = 0;\n\n                for (var i = 0; i < s.length; i++) {\n                    if (System.Char.isLetter(s[i].charCodeAt(0))) {\n                        if (s[i].toLowerCase() === \"e\") {\n                            countExp++;\n                            if (countExp > 1) {\n                                if (safe) {\n                                    return false;\n                                }\n                                throw new System.FormatException(errMsg);\n                            }\n                        }\n                        else {\n                            if (safe) {\n                                return false;\n                            }\n                            throw new System.FormatException(errMsg);\n                        }\n                    }\n                }\n\n                var r = parseFloat(s.replace(point, \".\"));\n\n                if (isNaN(r)) {\n                    if (safe) {\n                        return false;\n                    }\n                    throw new System.FormatException(errMsg);\n                }\n\n                result.v = r;\n                return true;\n            },\n\n            parseInt: function (str, min, max, radix) {\n                radix = radix || 10;\n\n                if (str == null) {\n                    throw new System.ArgumentNullException(\"str\");\n                }\n\n                if ((radix <= 10 && !/^[+-]?[0-9]+$/.test(str))\n                    || (radix == 16 && !/^[+-]?[0-9A-F]+$/gi.test(str))) {\n                    throw new System.FormatException(\"Input string was not in a correct format.\");\n                }\n\n                var result = parseInt(str, radix);\n\n                if (isNaN(result)) {\n                    throw new System.FormatException(\"Input string was not in a correct format.\");\n                }\n\n                if (result < min || result > max) {\n                    throw new System.OverflowException();\n                }\n\n                return result;\n            },\n\n            tryParseInt: function (str, result, min, max, radix) {\n                result.v = 0;\n                radix = radix || 10;\n\n                if ((radix <= 10 && !/^[+-]?[0-9]+$/.test(str))\n                    || (radix == 16 && !/^[+-]?[0-9A-F]+$/gi.test(str))) {\n                    return false;\n                }\n\n                result.v = parseInt(str, radix);\n\n                if (result.v < min || result.v > max) {\n                    result.v = 0;\n                    return false;\n                }\n\n                return true;\n            },\n\n            isInfinite: function (x) {\n                return x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY;\n            },\n\n            trunc: function (num) {\n                if (!Bridge.isNumber(num)) {\n                    return Bridge.Int.isInfinite(num) ? num : null;\n                }\n\n                return num > 0 ? Math.floor(num) : Math.ceil(num);\n            },\n\n            div: function (x, y) {\n                if (x == null || y == null) {\n                    return null;\n                }\n\n                if (y === 0) {\n                    throw new System.DivideByZeroException();\n                }\n\n                return this.trunc(x / y);\n            },\n\n            mod: function (x, y) {\n                if (x == null || y == null) {\n                    return null;\n                }\n\n                if (y === 0) {\n                    throw new System.DivideByZeroException();\n                }\n\n                return x % y;\n            },\n\n            check: function (x, type) {\n                if (System.Int64.is64Bit(x)) {\n                    return System.Int64.check(x, type);\n                } else if (x instanceof System.Decimal) {\n                    return System.Decimal.toInt(x, type);\n                }\n\n                if (Bridge.isNumber(x)) {\n                    if (System.Int64.is64BitType(type)) {\n                        if (type === System.UInt64 && x < 0) {\n                            throw new System.OverflowException();\n                        }\n\n                        return type === System.Int64 ? System.Int64(x) : System.UInt64(x);\n                    }\n                    else if (!type.$is(x)) {\n                        throw new System.OverflowException();\n                    }\n                }\n\n                if (Bridge.Int.isInfinite(x)) {\n                    if (System.Int64.is64BitType(type)) {\n                        return type.MinValue;\n                    }\n\n                    return type.min;\n                }\n\n                return x;\n            },\n\n            sxb: function (x) {\n                return Bridge.isNumber(x) ? (x | (x & 0x80 ? 0xffffff00 : 0)) : (Bridge.Int.isInfinite(x) ? System.SByte.min : null);\n            },\n\n            sxs: function (x) {\n                return Bridge.isNumber(x) ? (x | (x & 0x8000 ? 0xffff0000 : 0)) : (Bridge.Int.isInfinite(x) ? System.Int16.min : null);\n            },\n\n            clip8: function (x) {\n                return Bridge.isNumber(x) ? Bridge.Int.sxb(x & 0xff) : (Bridge.Int.isInfinite(x) ? System.SByte.min : null);\n            },\n\n            clipu8: function (x) {\n                return Bridge.isNumber(x) ? x & 0xff : (Bridge.Int.isInfinite(x) ? System.Byte.min : null);\n            },\n\n            clip16: function (x) {\n                return Bridge.isNumber(x) ? Bridge.Int.sxs(x & 0xffff) : (Bridge.Int.isInfinite(x) ? System.Int16.min : null);\n            },\n\n            clipu16: function (x) {\n                return Bridge.isNumber(x) ? x & 0xffff : (Bridge.Int.isInfinite(x) ? System.UInt16.min : null);\n            },\n\n            clip32: function (x) {\n                return Bridge.isNumber(x) ? x | 0 : (Bridge.Int.isInfinite(x) ? System.Int32.min : null);\n            },\n\n            clipu32: function (x) {\n                return Bridge.isNumber(x) ? x >>> 0 : (Bridge.Int.isInfinite(x) ? System.UInt32.min : null);\n            },\n\n            clip64: function (x) {\n                return Bridge.isNumber(x) ? System.Int64(Bridge.Int.trunc(x)) : (Bridge.Int.isInfinite(x) ? System.Int64.MinValue : null);\n            },\n\n            clipu64: function (x) {\n                return Bridge.isNumber(x) ? System.UInt64(Bridge.Int.trunc(x)) : (Bridge.Int.isInfinite(x) ? System.UInt64.MinValue : null);\n            },\n\n            sign: function (x) {\n                return Bridge.isNumber(x) ? (x === 0 ? 0 : (x < 0 ? -1 : 1)) : null;\n            },\n\n            $mul: Math.imul || function (a, b) {\n                var ah = (a >>> 16) & 0xffff,\n                    al = a & 0xffff,\n                    bh = (b >>> 16) & 0xffff,\n                    bl = b & 0xffff;\n                return ((al * bl) + (((ah * bl + al * bh) << 16) >>> 0) | 0);\n            },\n\n            mul: function (a, b, overflow) {\n                if (a == null || b == null) {\n                    return null;\n                }\n\n                if (overflow) {\n                    Bridge.Int.check(a * b, System.Int32)\n                }\n\n                return Bridge.Int.$mul(a, b);\n            },\n\n            umul: function (a, b, overflow) {\n                if (a == null || b == null) {\n                    return null;\n                }\n\n                if (overflow) {\n                    Bridge.Int.check(a * b, System.UInt32)\n                }\n\n                return Bridge.Int.$mul(a, b) >>> 0;\n            }\n        }\n    });\n\n    Bridge.Int.$kind = \"\";\n    Bridge.Class.addExtend(Bridge.Int, [System.IComparable$1(Bridge.Int), System.IEquatable$1(Bridge.Int)]);\n\n    // @source Double.js\n\n    Bridge.define(\"System.Double\", {\n        inherits: [System.IComparable, System.IFormattable],\n        statics: {\n            min: -Number.MAX_VALUE,\n\n            max: Number.MAX_VALUE,\n\n            precision: 15,\n\n            $number: true,\n\n            $is: function (instance) {\n                return typeof (instance) === \"number\";\n            },\n\n            getDefaultValue: function () {\n                return 0;\n            },\n\n            parse: function (s, provider) {\n                return Bridge.Int.parseFloat(s, provider);\n            },\n\n            tryParse: function (s, provider, result) {\n                return Bridge.Int.tryParseFloat(s, provider, result);\n            },\n\n            format: function (number, format, provider) {\n                return Bridge.Int.format(number, format || 'G', provider, System.Double);\n            },\n\n            equals: function (v1, v2) {\n                if (Bridge.is(v1, System.Double) && Bridge.is(v2, System.Double)) {\n                    return Bridge.unbox(v1, true) === Bridge.unbox(v2, true);\n                }\n\n                return false;\n            },\n\n            equalsT: function (v1, v2) {\n                return Bridge.unbox(v1, true) === Bridge.unbox(v2, true);\n            },\n\n            getHashCode: function (v) {\n                var value = Bridge.unbox(v, true);\n\n                if (value === 0) {\n                    return 0;\n                }\n\n                if (value === Number.POSITIVE_INFINITY) {\n                    return 0x7FF00000;\n                }\n\n                if (value === Number.NEGATIVE_INFINITY) {\n                    return 0xFFF00000;\n                }\n                return Bridge.getHashCode(value.toExponential());\n            }\n        }\n    });\n\n    System.Double.$kind = \"\";\n    Bridge.Class.addExtend(System.Double, [System.IComparable$1(System.Double), System.IEquatable$1(System.Double)]);\n\n    Bridge.define(\"System.Single\", {\n        inherits: [System.IComparable, System.IFormattable],\n        statics: {\n            min: -3.40282346638528859e+38,\n\n            max: 3.40282346638528859e+38,\n\n            precision: 7,\n\n            $number: true,\n\n            $is: System.Double.$is,\n\n            getDefaultValue: System.Double.getDefaultValue,\n\n            parse: System.Double.parse,\n\n            tryParse: System.Double.tryParse,\n\n            format: function (number, format, provider) {\n                return Bridge.Int.format(number, format || 'G', provider, System.Single);\n            },\n\n            equals: function (v1, v2) {\n                if (Bridge.is(v1, System.Single) && Bridge.is(v2, System.Single)) {\n                    return Bridge.unbox(v1, true) === Bridge.unbox(v2, true);\n                }\n\n                return false;\n            },\n\n            equalsT: function (v1, v2) {\n                return Bridge.unbox(v1, true) === Bridge.unbox(v2, true);\n            },\n\n            getHashCode: System.Double.getHashCode\n        }\n    });\n\n    System.Single.$kind = \"\";\n    Bridge.Class.addExtend(System.Single, [System.IComparable$1(System.Single), System.IEquatable$1(System.Single)]);\n\n    // @source Long.js\n\n/* long.js https://github.com/dcodeIO/long.js/blob/master/LICENSE */\n(function (b) {\n    function d(a, b, c) { this.low = a | 0; this.high = b | 0; this.unsigned = !!c } function g(a) { return !0 === (a && a.__isLong__) } function m(a, b) { var c, u; if (b) { a >>>= 0; if (u = 0 <= a && 256 > a) if (c = A[a]) return c; c = e(a, 0 > (a | 0) ? -1 : 0, !0); u && (A[a] = c) } else { a |= 0; if (u = -128 <= a && 128 > a) if (c = B[a]) return c; c = e(a, 0 > a ? -1 : 0, !1); u && (B[a] = c) } return c } function n(a, b) {\n        if (isNaN(a) || !isFinite(a)) return b ? p : k; if (b) { if (0 > a) return p; if (a >= C) return D } else { if (a <= -E) return l; if (a + 1 >= E) return F } return 0 > a ? n(-a, b).neg() : e(a % 4294967296 | 0, a / 4294967296 |\n        0, b)\n    } function e(a, b, c) { return new d(a, b, c) } function y(a, b, c) {\n        if (0 === a.length) throw Error(\"empty string\"); if (\"NaN\" === a || \"Infinity\" === a || \"+Infinity\" === a || \"-Infinity\" === a) return k; \"number\" === typeof b ? (c = b, b = !1) : b = !!b; c = c || 10; if (2 > c || 36 < c) throw RangeError(\"radix\"); var u; if (0 < (u = a.indexOf(\"-\"))) throw Error(\"interior hyphen\"); if (0 === u) return y(a.substring(1), b, c).neg(); u = n(w(c, 8)); for (var e = k, f = 0; f < a.length; f += 8) {\n            var d = Math.min(8, a.length - f), g = parseInt(a.substring(f, f + d), c); 8 > d ? (d = n(w(c, d)), e = e.mul(d).add(n(g))) :\n            (e = e.mul(u), e = e.add(n(g)))\n        } e.unsigned = b; return e\n    } function q(a) { return a instanceof d ? a : \"number\" === typeof a ? n(a) : \"string\" === typeof a ? y(a) : e(a.low, a.high, a.unsigned) } b.Bridge.$Long = d; d.__isLong__; Object.defineProperty(d.prototype, \"__isLong__\", { value: !0, enumerable: !1, configurable: !1 }); d.isLong = g; var B = {}, A = {}; d.fromInt = m; d.fromNumber = n; d.fromBits = e; var w = Math.pow; d.fromString = y; d.fromValue = q; var C = 4294967296 * 4294967296, E = C / 2, G = m(16777216), k = m(0); d.ZERO = k; var p = m(0, !0); d.UZERO = p; var r = m(1); d.ONE = r; var H =\n    m(1, !0); d.UONE = H; var z = m(-1); d.NEG_ONE = z; var F = e(-1, 2147483647, !1); d.MAX_VALUE = F; var D = e(-1, -1, !0); d.MAX_UNSIGNED_VALUE = D; var l = e(0, -2147483648, !1); d.MIN_VALUE = l; b = d.prototype; b.toInt = function () { return this.unsigned ? this.low >>> 0 : this.low }; b.toNumber = function () { return this.unsigned ? 4294967296 * (this.high >>> 0) + (this.low >>> 0) : 4294967296 * this.high + (this.low >>> 0) }; b.toString = function (a) {\n        a = a || 10; if (2 > a || 36 < a) throw RangeError(\"radix\"); if (this.isZero()) return \"0\"; if (this.isNegative()) {\n            if (this.eq(l)) {\n                var b =\n                n(a), c = this.div(b), b = c.mul(b).sub(this); return c.toString(a) + b.toInt().toString(a)\n            } return (\"undefined\" === typeof a || 10 === a ? \"-\" : \"\") + this.neg().toString(a)\n        } for (var c = n(w(a, 6), this.unsigned), b = this, e = \"\"; ;) { var d = b.div(c), f = (b.sub(d.mul(c)).toInt() >>> 0).toString(a), b = d; if (b.isZero()) return f + e; for (; 6 > f.length;) f = \"0\" + f; e = \"\" + f + e }\n    }; b.getHighBits = function () { return this.high }; b.getHighBitsUnsigned = function () { return this.high >>> 0 }; b.getLowBits = function () { return this.low }; b.getLowBitsUnsigned = function () {\n        return this.low >>>\n        0\n    }; b.getNumBitsAbs = function () { if (this.isNegative()) return this.eq(l) ? 64 : this.neg().getNumBitsAbs(); for (var a = 0 != this.high ? this.high : this.low, b = 31; 0 < b && 0 == (a & 1 << b) ; b--); return 0 != this.high ? b + 33 : b + 1 }; b.isZero = function () { return 0 === this.high && 0 === this.low }; b.isNegative = function () { return !this.unsigned && 0 > this.high }; b.isPositive = function () { return this.unsigned || 0 <= this.high }; b.isOdd = function () { return 1 === (this.low & 1) }; b.isEven = function () { return 0 === (this.low & 1) }; b.equals = function (a) {\n        g(a) || (a = q(a)); return this.unsigned !==\n        a.unsigned && 1 === this.high >>> 31 && 1 === a.high >>> 31 ? !1 : this.high === a.high && this.low === a.low\n    }; b.eq = b.equals; b.notEquals = function (a) { return !this.eq(a) }; b.neq = b.notEquals; b.lessThan = function (a) { return 0 > this.comp(a) }; b.lt = b.lessThan; b.lessThanOrEqual = function (a) { return 0 >= this.comp(a) }; b.lte = b.lessThanOrEqual; b.greaterThan = function (a) { return 0 < this.comp(a) }; b.gt = b.greaterThan; b.greaterThanOrEqual = function (a) { return 0 <= this.comp(a) }; b.gte = b.greaterThanOrEqual; b.compare = function (a) {\n        g(a) || (a = q(a)); if (this.eq(a)) return 0;\n        var b = this.isNegative(), c = a.isNegative(); return b && !c ? -1 : !b && c ? 1 : this.unsigned ? a.high >>> 0 > this.high >>> 0 || a.high === this.high && a.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(a).isNegative() ? -1 : 1\n    }; b.comp = b.compare; b.negate = function () { return !this.unsigned && this.eq(l) ? l : this.not().add(r) }; b.neg = b.negate; b.add = function (a) {\n        g(a) || (a = q(a)); var b = this.high >>> 16, c = this.high & 65535, d = this.low >>> 16, l = a.high >>> 16, f = a.high & 65535, n = a.low >>> 16, k; k = 0 + ((this.low & 65535) + (a.low & 65535)); a = 0 + (k >>> 16); a += d + n; d = 0 + (a >>> 16); d += c + f; c =\n        0 + (d >>> 16); c = c + (b + l) & 65535; return e((a & 65535) << 16 | k & 65535, c << 16 | d & 65535, this.unsigned)\n    }; b.subtract = function (a) { g(a) || (a = q(a)); return this.add(a.neg()) }; b.sub = b.subtract; b.multiply = function (a) {\n        if (this.isZero()) return k; g(a) || (a = q(a)); if (a.isZero()) return k; if (this.eq(l)) return a.isOdd() ? l : k; if (a.eq(l)) return this.isOdd() ? l : k; if (this.isNegative()) return a.isNegative() ? this.neg().mul(a.neg()) : this.neg().mul(a).neg(); if (a.isNegative()) return this.mul(a.neg()).neg(); if (this.lt(G) && a.lt(G)) return n(this.toNumber() *\n        a.toNumber(), this.unsigned); var b = this.high >>> 16, c = this.high & 65535, d = this.low >>> 16, x = this.low & 65535, f = a.high >>> 16, m = a.high & 65535, p = a.low >>> 16; a = a.low & 65535; var v, h, t, r; r = 0 + x * a; t = 0 + (r >>> 16); t += d * a; h = 0 + (t >>> 16); t = (t & 65535) + x * p; h += t >>> 16; t &= 65535; h += c * a; v = 0 + (h >>> 16); h = (h & 65535) + d * p; v += h >>> 16; h &= 65535; h += x * m; v += h >>> 16; h &= 65535; v = v + (b * a + c * p + d * m + x * f) & 65535; return e(t << 16 | r & 65535, v << 16 | h, this.unsigned)\n    }; b.mul = b.multiply; b.divide = function (a) {\n        g(a) || (a = q(a)); if (a.isZero()) throw Error(\"division by zero\"); if (this.isZero()) return this.unsigned ?\n                p : k; var b, c, d; if (this.unsigned) a.unsigned || (a = a.toUnsigned()); else { if (this.eq(l)) { if (a.eq(r) || a.eq(z)) return l; if (a.eq(l)) return r; b = this.shr(1).div(a).shl(1); if (b.eq(k)) return a.isNegative() ? r : z; c = this.sub(a.mul(b)); return d = b.add(c.div(a)) } if (a.eq(l)) return this.unsigned ? p : k; if (this.isNegative()) return a.isNegative() ? this.neg().div(a.neg()) : this.neg().div(a).neg(); if (a.isNegative()) return this.div(a.neg()).neg() } if (this.unsigned) { if (a.gt(this)) return p; if (a.gt(this.shru(1))) return H; d = p } else d =\n                k; for (c = this; c.gte(a) ;) { b = Math.max(1, Math.floor(c.toNumber() / a.toNumber())); for (var e = Math.ceil(Math.log(b) / Math.LN2), e = 48 >= e ? 1 : w(2, e - 48), f = n(b), m = f.mul(a) ; m.isNegative() || m.gt(c) ;) b -= e, f = n(b, this.unsigned), m = f.mul(a); f.isZero() && (f = r); d = d.add(f); c = c.sub(m) } return d\n    }; b.div = b.divide; b.modulo = function (a) { g(a) || (a = q(a)); return this.sub(this.div(a).mul(a)) }; b.mod = b.modulo; b.not = function () { return e(~this.low, ~this.high, this.unsigned) }; b.and = function (a) {\n        g(a) || (a = q(a)); return e(this.low & a.low, this.high &\n        a.high, this.unsigned)\n    }; b.or = function (a) { g(a) || (a = q(a)); return e(this.low | a.low, this.high | a.high, this.unsigned) }; b.xor = function (a) { g(a) || (a = q(a)); return e(this.low ^ a.low, this.high ^ a.high, this.unsigned) }; b.shiftLeft = function (a) { g(a) && (a = a.toInt()); return 0 === (a &= 63) ? this : 32 > a ? e(this.low << a, this.high << a | this.low >>> 32 - a, this.unsigned) : e(0, this.low << a - 32, this.unsigned) }; b.shl = b.shiftLeft; b.shiftRight = function (a) {\n        g(a) && (a = a.toInt()); return 0 === (a &= 63) ? this : 32 > a ? e(this.low >>> a | this.high << 32 - a, this.high >>\n        a, this.unsigned) : e(this.high >> a - 32, 0 <= this.high ? 0 : -1, this.unsigned)\n    }; b.shr = b.shiftRight; b.shiftRightUnsigned = function (a) { g(a) && (a = a.toInt()); a &= 63; if (0 === a) return this; var b = this.high; return 32 > a ? e(this.low >>> a | b << 32 - a, b >>> a, this.unsigned) : 32 === a ? e(b, 0, this.unsigned) : e(b >>> a - 32, 0, this.unsigned) }; b.shru = b.shiftRightUnsigned; b.toSigned = function () { return this.unsigned ? e(this.low, this.high, !1) : this }; b.toUnsigned = function () { return this.unsigned ? this : e(this.low, this.high, !0) }\n})(Bridge.global);\n\n    System.Int64 = function (l) {\n        if (this.constructor !== System.Int64) {\n            return new System.Int64(l);\n        }\n\n        if (!Bridge.hasValue(l)) {\n            l = 0;\n        }\n\n        this.T = System.Int64;\n        this.unsigned = false;\n        this.value = System.Int64.getValue(l);\n    }\n\n    System.Int64.$number = true;\n    System.Int64.TWO_PWR_16_DBL = 1 << 16;\n    System.Int64.TWO_PWR_32_DBL = System.Int64.TWO_PWR_16_DBL * System.Int64.TWO_PWR_16_DBL;\n    System.Int64.TWO_PWR_64_DBL = System.Int64.TWO_PWR_32_DBL * System.Int64.TWO_PWR_32_DBL;\n    System.Int64.TWO_PWR_63_DBL = System.Int64.TWO_PWR_64_DBL / 2;\n\n    System.Int64.$$name = \"System.Int64\";\n    System.Int64.prototype.$$name = \"System.Int64\";\n    System.Int64.$kind = \"struct\";\n    System.Int64.prototype.$kind = \"struct\";\n\n    System.Int64.$$inherits = [];\n    Bridge.Class.addExtend(System.Int64, [System.IComparable, System.IFormattable, System.IComparable$1(System.Int64), System.IEquatable$1(System.Int64)]);\n\n    System.Int64.$is = function (instance) {\n        return instance instanceof System.Int64;\n    };\n\n    System.Int64.is64Bit = function (instance) {\n        return instance instanceof System.Int64 || instance instanceof System.UInt64;\n    };\n\n    System.Int64.is64BitType = function (type) {\n        return type === System.Int64 || type === System.UInt64;\n    };\n\n    System.Int64.getDefaultValue = function () {\n        return System.Int64.Zero;\n    };\n\n    System.Int64.getValue = function (l) {\n        if (!Bridge.hasValue(l)) {\n            return null;\n        }\n\n        if (l instanceof Bridge.$Long) {\n            return l;\n        }\n\n        if (l instanceof System.Int64) {\n            return l.value;\n        }\n\n        if (l instanceof System.UInt64) {\n            return l.value.toSigned();\n        }\n\n        if (Bridge.isArray(l)) {\n            return new Bridge.$Long(l[0], l[1]);\n        }\n\n        if (Bridge.isString(l)) {\n            return Bridge.$Long.fromString(l);\n        }\n\n        if (Bridge.isNumber(l)) {\n            if (l + 1 >= System.Int64.TWO_PWR_63_DBL) {\n                return (new System.UInt64(l)).value.toSigned();\n            }\n            return Bridge.$Long.fromNumber(l);\n        }\n\n        if (l instanceof System.Decimal) {\n            return Bridge.$Long.fromString(l.toString());\n        }\n\n        return Bridge.$Long.fromValue(l);\n    };\n\n    System.Int64.create = function (l) {\n        if (!Bridge.hasValue(l)) {\n            return null;\n        }\n\n        if (l instanceof System.Int64) {\n            return l;\n        }\n\n        return new System.Int64(l);\n    };\n\n    System.Int64.lift = function (l) {\n        if (!Bridge.hasValue(l)) {\n            return null;\n        }\n        return System.Int64.create(l);\n    };\n\n    System.Int64.toNumber = function (value) {\n        if (!value) {\n            return null;\n        }\n\n        return value.toNumber();\n    };\n\n    System.Int64.prototype.toNumberDivided = function (divisor) {\n        var integral = this.div(divisor),\n            remainder = this.mod(divisor),\n            scaledRemainder = remainder.toNumber() / divisor;\n\n        return integral.toNumber() + scaledRemainder;\n    };\n\n    System.Int64.prototype.toJSON = function () {\n        return this.toNumber();\n    };\n\n    System.Int64.prototype.toString = function (format, provider) {\n        if (!format && !provider) {\n            return this.value.toString();\n        }\n\n        if (Bridge.isNumber(format) && !provider) {\n            return this.value.toString(format);\n        }\n\n        return Bridge.Int.format(this, format, provider);\n    };\n\n    System.Int64.prototype.format = function (format, provider) {\n        return Bridge.Int.format(this, format, provider);\n    };\n\n    System.Int64.prototype.isNegative = function () {\n        return this.value.isNegative();\n    };\n\n    System.Int64.prototype.abs = function () {\n        if (this.T === System.Int64 && this.eq(System.Int64.MinValue)) {\n            throw new System.OverflowException();\n        }\n        return new this.T(this.value.isNegative() ? this.value.neg() : this.value);\n    };\n\n    System.Int64.prototype.compareTo = function (l) {\n        return this.value.compare(this.T.getValue(l));\n    };\n\n    System.Int64.prototype.add = function (l, overflow) {\n        var addl = this.T.getValue(l),\n            r = new this.T(this.value.add(addl));\n\n        if (overflow) {\n            var neg1 = this.value.isNegative(),\n                neg2 = addl.isNegative(),\n                rneg = r.value.isNegative();\n\n            if ((neg1 && neg2 && !rneg) ||\n                (!neg1 && !neg2 && rneg) ||\n                (this.T === System.UInt64 && r.lt(System.UInt64.max(this, addl)))) {\n                throw new System.OverflowException();\n            }\n        }\n\n        return r;\n    };\n\n    System.Int64.prototype.sub = function (l, overflow) {\n        var subl = this.T.getValue(l),\n            r = new this.T(this.value.sub(subl));\n\n        if (overflow) {\n            var neg1 = this.value.isNegative(),\n                neg2 = subl.isNegative(),\n                rneg = r.value.isNegative();\n\n            if ((neg1 && !neg2 && !rneg) ||\n                (!neg1 && neg2 && rneg) ||\n                (this.T === System.UInt64 && this.value.lt(subl))) {\n                throw new System.OverflowException();\n            }\n        }\n\n        return r;\n    };\n\n    System.Int64.prototype.isZero = function () {\n        return this.value.isZero();\n    };\n\n    System.Int64.prototype.mul = function (l, overflow) {\n        var arg = this.T.getValue(l),\n            r = new this.T(this.value.mul(arg));\n\n        if (overflow) {\n            var s1 = this.sign(),\n                s2 = arg.isZero() ? 0 : (arg.isNegative() ? -1 : 1),\n                rs = r.sign();\n\n            if (this.T === System.Int64) {\n                if (this.eq(System.Int64.MinValue) || this.eq(System.Int64.MaxValue)) {\n                    if (arg.neq(1) && arg.neq(0)) {\n                        throw new System.OverflowException();\n                    }\n\n                    return r;\n                }\n\n                if (arg.eq(Bridge.$Long.MIN_VALUE) || arg.eq(Bridge.$Long.MAX_VALUE)) {\n                    if (this.neq(1) && this.neq(0)) {\n                        throw new System.OverflowException();\n                    }\n\n                    return r;\n                }\n\n                if ((s1 === -1 && s2 === -1 && rs !== 1) ||\n                    (s1 === 1 && s2 === 1 && rs !== 1) ||\n                    (s1 === -1 && s2 === 1 && rs !== -1) ||\n                    (s1 === 1 && s2 === -1 && rs !== -1)) {\n                    throw new System.OverflowException();\n                }\n\n                var r_abs = r.abs();\n\n                if (r_abs.lt(this.abs()) || r_abs.lt(System.Int64(arg).abs())) {\n                    throw new System.OverflowException();\n                }\n            } else {\n                if (this.eq(System.UInt64.MaxValue)) {\n                    if (arg.neq(1) && arg.neq(0)) {\n                        throw new System.OverflowException();\n                    }\n\n                    return r;\n                }\n\n                if (arg.eq(Bridge.$Long.MAX_UNSIGNED_VALUE)) {\n                    if (this.neq(1) && this.neq(0)) {\n                        throw new System.OverflowException();\n                    }\n\n                    return r;\n                }\n\n                var r_abs = r.abs();\n\n                if (r_abs.lt(this.abs()) || r_abs.lt(System.Int64(arg).abs())) {\n                    throw new System.OverflowException();\n                }\n            }\n        }\n\n        return r;\n    };\n\n    System.Int64.prototype.div = function (l) {\n        return new this.T(this.value.div(this.T.getValue(l)));\n    };\n\n    System.Int64.prototype.mod = function (l) {\n        return new this.T(this.value.mod(this.T.getValue(l)));\n    };\n\n    System.Int64.prototype.neg = function (overflow) {\n        if (overflow && this.T === System.Int64 && this.eq(System.Int64.MinValue)) {\n            throw new System.OverflowException();\n        }\n        return new this.T(this.value.neg());\n    };\n\n    System.Int64.prototype.inc = function (overflow) {\n        return this.add(1, overflow);\n    };\n\n    System.Int64.prototype.dec = function (overflow) {\n        return this.sub(1, overflow);\n    };\n\n    System.Int64.prototype.sign = function () {\n        return this.value.isZero() ? 0 : (this.value.isNegative() ? -1 : 1);\n    };\n\n    System.Int64.prototype.clone = function () {\n        return new this.T(this);\n    };\n\n    System.Int64.prototype.ne = function (l) {\n        return this.value.neq(this.T.getValue(l));\n    };\n\n    System.Int64.prototype.neq = function (l) {\n        return this.value.neq(this.T.getValue(l));\n    };\n\n    System.Int64.prototype.eq = function (l) {\n        return this.value.eq(this.T.getValue(l));\n    };\n\n    System.Int64.prototype.lt = function (l) {\n        return this.value.lt(this.T.getValue(l));\n    };\n\n    System.Int64.prototype.lte = function (l) {\n        return this.value.lte(this.T.getValue(l));\n    };\n\n    System.Int64.prototype.gt = function (l) {\n        return this.value.gt(this.T.getValue(l));\n    };\n\n    System.Int64.prototype.gte = function (l) {\n        return this.value.gte(this.T.getValue(l));\n    };\n\n    System.Int64.prototype.equals = function (l) {\n        return this.value.eq(this.T.getValue(l));\n    };\n\n    System.Int64.prototype.equalsT = function (l) {\n        return this.equals(l);\n    };\n\n    System.Int64.prototype.getHashCode = function () {\n        var n = (this.sign() * 397 + this.value.high) | 0;\n        n = (n * 397 + this.value.low) | 0;\n\n        return n;\n    };\n\n    System.Int64.prototype.toNumber = function () {\n        return this.value.toNumber();\n    };\n\n    System.Int64.parse = function (str) {\n        if (str == null) {\n            throw new System.ArgumentNullException(\"str\");\n        }\n\n        if (!/^[+-]?[0-9]+$/.test(str)) {\n            throw new System.FormatException(\"Input string was not in a correct format.\");\n        }\n\n        var result = new System.Int64(str);\n\n        if (System.String.trimStartZeros(str) !== result.toString()) {\n            throw new System.OverflowException();\n        }\n\n        return result;\n    };\n\n    System.Int64.tryParse = function (str, v) {\n        try {\n            if (str == null || !/^[+-]?[0-9]+$/.test(str)) {\n                v.v = System.Int64(Bridge.$Long.ZERO);\n                return false;\n            }\n\n            v.v = new System.Int64(str);\n\n            if (System.String.trimStartZeros(str) !== v.v.toString()) {\n                v.v = System.Int64(Bridge.$Long.ZERO);\n                return false;\n            }\n\n            return true;\n        } catch (e) {\n            v.v = System.Int64(Bridge.$Long.ZERO);\n            return false;\n        }\n    };\n\n    System.Int64.divRem = function (a, b, result) {\n        a = System.Int64(a);\n        b = System.Int64(b);\n        var remainder = a.mod(b);\n        result.v = remainder;\n        return a.sub(remainder).div(b);\n    };\n\n    System.Int64.min = function () {\n        var values = [],\n            min, i, len;\n\n        for (i = 0, len = arguments.length; i < len; i++) {\n            values.push(System.Int64.getValue(arguments[i]));\n        }\n\n        i = 0;\n        min = values[0];\n        for (; ++i < values.length;) {\n            if (values[i].lt(min)) {\n                min = values[i];\n            }\n        }\n\n        return new System.Int64(min);\n    };\n\n    System.Int64.max = function () {\n        var values = [],\n            max, i, len;\n\n        for (i = 0, len = arguments.length; i < len; i++) {\n            values.push(System.Int64.getValue(arguments[i]));\n        }\n\n        i = 0;\n        max = values[0];\n        for (; ++i < values.length;) {\n            if (values[i].gt(max)) {\n                max = values[i];\n            }\n        }\n\n        return new System.Int64(max);\n    };\n\n    System.Int64.prototype.and = function (l) {\n        return new this.T(this.value.and(this.T.getValue(l)));\n    };\n\n    System.Int64.prototype.not = function () {\n        return new this.T(this.value.not());\n    };\n\n    System.Int64.prototype.or = function (l) {\n        return new this.T(this.value.or(this.T.getValue(l)));\n    };\n\n    System.Int64.prototype.shl = function (l) {\n        return new this.T(this.value.shl(l));\n    };\n\n    System.Int64.prototype.shr = function (l) {\n        return new this.T(this.value.shr(l));\n    };\n\n    System.Int64.prototype.shru = function (l) {\n        return new this.T(this.value.shru(l));\n    };\n\n    System.Int64.prototype.xor = function (l) {\n        return new this.T(this.value.xor(this.T.getValue(l)));\n    };\n\n    System.Int64.check = function (v, tp) {\n        if (Bridge.Int.isInfinite(v)) {\n            if (tp === System.Int64 || tp === System.UInt64) {\n                return tp.MinValue;\n            }\n            return tp.min;\n        }\n\n        if (!v) {\n            return null;\n        }\n\n        var str, r;\n        if (tp === System.Int64) {\n            if (v instanceof System.Int64) {\n                return v;\n            }\n\n            str = v.value.toString();\n            r = new System.Int64(str);\n\n            if (str !== r.value.toString()) {\n                throw new System.OverflowException();\n            }\n\n            return r;\n        }\n\n        if (tp === System.UInt64) {\n            if (v instanceof System.UInt64) {\n                return v;\n            }\n\n            if (v.value.isNegative()) {\n                throw new System.OverflowException();\n            }\n            str = v.value.toString();\n            r = new System.UInt64(str);\n\n            if (str !== r.value.toString()) {\n                throw new System.OverflowException();\n            }\n\n            return r;\n        }\n\n        return Bridge.Int.check(v.toNumber(), tp);\n    };\n\n    System.Int64.clip8 = function (x) {\n        return x ? Bridge.Int.sxb(x.value.low & 0xff) : (Bridge.Int.isInfinite(x) ? System.SByte.min : null);\n    };\n\n    System.Int64.clipu8 = function (x) {\n        return x ? x.value.low & 0xff : (Bridge.Int.isInfinite(x) ? System.Byte.min : null);\n    };\n\n    System.Int64.clip16 = function (x) {\n        return x ? Bridge.Int.sxs(x.value.low & 0xffff) : (Bridge.Int.isInfinite(x) ? System.Int16.min : null);\n    };\n\n    System.Int64.clipu16 = function (x) {\n        return x ? x.value.low & 0xffff : (Bridge.Int.isInfinite(x) ? System.UInt16.min : null);\n    };\n\n    System.Int64.clip32 = function (x) {\n        return x ? x.value.low | 0 : (Bridge.Int.isInfinite(x) ? System.Int32.min : null);\n    };\n\n    System.Int64.clipu32 = function (x) {\n        return x ? x.value.low >>> 0 : (Bridge.Int.isInfinite(x) ? System.UInt32.min : null);\n    };\n\n    System.Int64.clip64 = function (x) {\n        return x ? new System.Int64(x.value.toSigned()) : (Bridge.Int.isInfinite(x) ? System.Int64.MinValue : null);\n    };\n\n    System.Int64.clipu64 = function (x) {\n        return x ? new System.UInt64(x.value.toUnsigned()) : (Bridge.Int.isInfinite(x) ? System.UInt64.MinValue : null);\n    };\n\n    System.Int64.Zero = System.Int64(Bridge.$Long.ZERO);\n    System.Int64.MinValue = System.Int64(Bridge.$Long.MIN_VALUE);\n    System.Int64.MaxValue = System.Int64(Bridge.$Long.MAX_VALUE);\n    System.Int64.precision = 19;\n\n    /* ULONG */\n\n    System.UInt64 = function (l) {\n        if (this.constructor !== System.UInt64) {\n            return new System.UInt64(l);\n        }\n\n        if (!Bridge.hasValue(l)) {\n            l = 0;\n        }\n\n        this.T = System.UInt64;\n        this.unsigned = true;\n        this.value = System.UInt64.getValue(l, true);\n    }\n\n    System.UInt64.$number = true;\n    System.UInt64.$$name = \"System.UInt64\";\n    System.UInt64.prototype.$$name = \"System.UInt64\";\n    System.UInt64.$kind = \"struct\";\n    System.UInt64.prototype.$kind = \"struct\";\n    System.UInt64.$$inherits = [];\n    Bridge.Class.addExtend(System.UInt64, [System.IComparable, System.IFormattable, System.IComparable$1(System.UInt64), System.IEquatable$1(System.UInt64)]);\n\n    System.UInt64.$is = function (instance) {\n        return instance instanceof System.UInt64;\n    };\n\n    System.UInt64.getDefaultValue = function () {\n        return System.UInt64.Zero;\n    };\n\n    System.UInt64.getValue = function (l) {\n        if (!Bridge.hasValue(l)) {\n            return null;\n        }\n\n        if (l instanceof Bridge.$Long) {\n            return l;\n        }\n\n        if (l instanceof System.UInt64) {\n            return l.value;\n        }\n\n        if (l instanceof System.Int64) {\n            return l.value.toUnsigned();\n        }\n\n        if (Bridge.isArray(l)) {\n            return new Bridge.$Long(l[0], l[1], true);\n        }\n\n        if (Bridge.isString(l)) {\n            return Bridge.$Long.fromString(l, true);\n        }\n\n        if (Bridge.isNumber(l)) {\n            if (l < 0) {\n                return (new System.Int64(l)).value.toUnsigned();\n            }\n\n            return Bridge.$Long.fromNumber(l, true);\n        }\n\n        if (l instanceof System.Decimal) {\n            return Bridge.$Long.fromString(l.toString(), true);\n        }\n\n        return Bridge.$Long.fromValue(l);\n    };\n\n    System.UInt64.create = function (l) {\n        if (!Bridge.hasValue(l)) {\n            return null;\n        }\n\n        if (l instanceof System.UInt64) {\n            return l;\n        }\n\n        return new System.UInt64(l);\n    };\n\n    System.UInt64.lift = function (l) {\n        if (!Bridge.hasValue(l)) {\n            return null;\n        }\n        return System.UInt64.create(l);\n    };\n\n    System.UInt64.prototype.toJSON = System.Int64.prototype.toJSON;\n    System.UInt64.prototype.toString = System.Int64.prototype.toString;\n    System.UInt64.prototype.format = System.Int64.prototype.format;\n    System.UInt64.prototype.isNegative = System.Int64.prototype.isNegative;\n    System.UInt64.prototype.abs = System.Int64.prototype.abs;\n    System.UInt64.prototype.compareTo = System.Int64.prototype.compareTo;\n    System.UInt64.prototype.add = System.Int64.prototype.add;\n    System.UInt64.prototype.sub = System.Int64.prototype.sub;\n    System.UInt64.prototype.isZero = System.Int64.prototype.isZero;\n    System.UInt64.prototype.mul = System.Int64.prototype.mul;\n    System.UInt64.prototype.div = System.Int64.prototype.div;\n    System.UInt64.prototype.toNumberDivided = System.Int64.prototype.toNumberDivided;\n    System.UInt64.prototype.mod = System.Int64.prototype.mod;\n    System.UInt64.prototype.neg = System.Int64.prototype.neg;\n    System.UInt64.prototype.inc = System.Int64.prototype.inc;\n    System.UInt64.prototype.dec = System.Int64.prototype.dec;\n    System.UInt64.prototype.sign = System.Int64.prototype.sign;\n    System.UInt64.prototype.clone = System.Int64.prototype.clone;\n    System.UInt64.prototype.ne = System.Int64.prototype.ne;\n    System.UInt64.prototype.neq = System.Int64.prototype.neq;\n    System.UInt64.prototype.eq = System.Int64.prototype.eq;\n    System.UInt64.prototype.lt = System.Int64.prototype.lt;\n    System.UInt64.prototype.lte = System.Int64.prototype.lte;\n    System.UInt64.prototype.gt = System.Int64.prototype.gt;\n    System.UInt64.prototype.gte = System.Int64.prototype.gte;\n    System.UInt64.prototype.equals = System.Int64.prototype.equals;\n    System.UInt64.prototype.equalsT = System.Int64.prototype.equalsT;\n    System.UInt64.prototype.getHashCode = System.Int64.prototype.getHashCode;\n    System.UInt64.prototype.toNumber = System.Int64.prototype.toNumber;\n\n    System.UInt64.parse = function (str) {\n        if (str == null) {\n            throw new System.ArgumentNullException(\"str\");\n        }\n\n        if (!/^[+-]?[0-9]+$/.test(str)) {\n            throw new System.FormatException(\"Input string was not in a correct format.\");\n        }\n\n        var result = new System.UInt64(str);\n\n        if (result.value.isNegative()) {\n            throw new System.OverflowException();\n        }\n\n        if (System.String.trimStartZeros(str) !== result.toString()) {\n            throw new System.OverflowException();\n        }\n\n        return result;\n    };\n\n    System.UInt64.tryParse = function (str, v) {\n        try {\n            if (str == null || !/^[+-]?[0-9]+$/.test(str)) {\n                v.v = System.UInt64(Bridge.$Long.UZERO);\n                return false;\n            }\n\n            v.v = new System.UInt64(str);\n\n            if (v.v.isNegative()) {\n                v.v = System.UInt64(Bridge.$Long.UZERO);\n                return false;\n            }\n\n            if (System.String.trimStartZeros(str) !== v.v.toString()) {\n                v.v = System.UInt64(Bridge.$Long.UZERO);\n                return false;\n            }\n\n            return true;\n        } catch (e) {\n            v.v = System.UInt64(Bridge.$Long.UZERO);\n            return false;\n        }\n    };\n\n    System.UInt64.min = function () {\n        var values = [],\n            min, i, len;\n\n        for (i = 0, len = arguments.length; i < len; i++) {\n            values.push(System.UInt64.getValue(arguments[i]));\n        }\n\n        i = 0;\n        min = values[0];\n        for (; ++i < values.length;) {\n            if (values[i].lt(min)) {\n                min = values[i];\n            }\n        }\n\n        return new System.UInt64(min);\n    };\n\n    System.UInt64.max = function () {\n        var values = [],\n            max, i, len;\n\n        for (i = 0, len = arguments.length; i < len; i++) {\n            values.push(System.UInt64.getValue(arguments[i]));\n        }\n\n        i = 0;\n        max = values[0];\n        for (; ++i < values.length;) {\n            if (values[i].gt(max)) {\n                max = values[i];\n            }\n        }\n\n        return new System.UInt64(max);\n    };\n\n    System.UInt64.divRem = function (a, b, result) {\n        a = System.UInt64(a);\n        b = System.UInt64(b);\n        var remainder = a.mod(b);\n        result.v = remainder;\n        return a.sub(remainder).div(b);\n    };\n\n    System.UInt64.prototype.and = System.Int64.prototype.and;\n    System.UInt64.prototype.not = System.Int64.prototype.not;\n    System.UInt64.prototype.or = System.Int64.prototype.or;\n    System.UInt64.prototype.shl = System.Int64.prototype.shl;\n    System.UInt64.prototype.shr = System.Int64.prototype.shr;\n    System.UInt64.prototype.shru = System.Int64.prototype.shru;\n    System.UInt64.prototype.xor = System.Int64.prototype.xor;\n\n    System.UInt64.Zero = System.UInt64(Bridge.$Long.UZERO);\n    System.UInt64.MinValue = System.UInt64.Zero;\n    System.UInt64.MaxValue = System.UInt64(Bridge.$Long.MAX_UNSIGNED_VALUE);\n    System.UInt64.precision = 20;\n\n    // @source Decimal.js\n\n    /* decimal.js v7.1.0 https://github.com/MikeMcl/decimal.js/LICENCE */\n    !function (n) { \"use strict\"; function e(n) { var e, i, t, r = n.length - 1, s = \"\", o = n[0]; if (r > 0) { for (s += o, e = 1; r > e; e++) t = n[e] + \"\", i = Rn - t.length, i && (s += l(i)), s += t; o = n[e], t = o + \"\", i = Rn - t.length, i && (s += l(i)) } else if (0 === o) return \"0\"; for (; o % 10 === 0;) o /= 10; return s + o } function i(n, e, i) { if (n !== ~~n || e > n || n > i) throw Error(En + n) } function t(n, e, i, t) { var r, s, o, u; for (s = n[0]; s >= 10; s /= 10)--e; return --e < 0 ? (e += Rn, r = 0) : (r = Math.ceil((e + 1) / Rn), e %= Rn), s = On(10, Rn - e), u = n[r] % s | 0, null == t ? 3 > e ? (0 == e ? u = u / 100 | 0 : 1 == e && (u = u / 10 | 0), o = 4 > i && 99999 == u || i > 3 && 49999 == u || 5e4 == u || 0 == u) : o = (4 > i && u + 1 == s || i > 3 && u + 1 == s / 2) && (n[r + 1] / s / 100 | 0) == On(10, e - 2) - 1 || (u == s / 2 || 0 == u) && 0 == (n[r + 1] / s / 100 | 0) : 4 > e ? (0 == e ? u = u / 1e3 | 0 : 1 == e ? u = u / 100 | 0 : 2 == e && (u = u / 10 | 0), o = (t || 4 > i) && 9999 == u || !t && i > 3 && 4999 == u) : o = ((t || 4 > i) && u + 1 == s || !t && i > 3 && u + 1 == s / 2) && (n[r + 1] / s / 1e3 | 0) == On(10, e - 3) - 1, o } function r(n, e, i) { for (var t, r, s = [0], o = 0, u = n.length; u > o;) { for (r = s.length; r--;) s[r] *= e; for (s[0] += wn.indexOf(n.charAt(o++)), t = 0; t < s.length; t++) s[t] > i - 1 && (void 0 === s[t + 1] && (s[t + 1] = 0), s[t + 1] += s[t] / i | 0, s[t] %= i) } return s.reverse() } function s(n, e) { var i, t, r = e.d.length; 32 > r ? (i = Math.ceil(r / 3), t = Math.pow(4, -i).toString()) : (i = 16, t = \"2.3283064365386962890625e-10\"), n.precision += i, e = E(n, 1, e.times(t), new n(1)); for (var s = i; s--;) { var o = e.times(e); e = o.times(o).minus(o).times(8).plus(1) } return n.precision -= i, e } function o(n, e, i, t) { var r, s, o, u, c, f, a, h, l, d = n.constructor; n: if (null != e) { if (h = n.d, !h) return n; for (r = 1, u = h[0]; u >= 10; u /= 10) r++; if (s = e - r, 0 > s) s += Rn, o = e, a = h[l = 0], c = a / On(10, r - o - 1) % 10 | 0; else if (l = Math.ceil((s + 1) / Rn), u = h.length, l >= u) { if (!t) break n; for (; u++ <= l;) h.push(0); a = c = 0, r = 1, s %= Rn, o = s - Rn + 1 } else { for (a = u = h[l], r = 1; u >= 10; u /= 10) r++; s %= Rn, o = s - Rn + r, c = 0 > o ? 0 : a / On(10, r - o - 1) % 10 | 0 } if (t = t || 0 > e || void 0 !== h[l + 1] || (0 > o ? a : a % On(10, r - o - 1)), f = 4 > i ? (c || t) && (0 == i || i == (n.s < 0 ? 3 : 2)) : c > 5 || 5 == c && (4 == i || t || 6 == i && (s > 0 ? o > 0 ? a / On(10, r - o) : 0 : h[l - 1]) % 10 & 1 || i == (n.s < 0 ? 8 : 7)), 1 > e || !h[0]) return h.length = 0, f ? (e -= n.e + 1, h[0] = On(10, (Rn - e % Rn) % Rn), n.e = -e || 0) : h[0] = n.e = 0, n; if (0 == s ? (h.length = l, u = 1, l--) : (h.length = l + 1, u = On(10, Rn - s), h[l] = o > 0 ? (a / On(10, r - o) % On(10, o) | 0) * u : 0), f) for (; ;) { if (0 == l) { for (s = 1, o = h[0]; o >= 10; o /= 10) s++; for (o = h[0] += u, u = 1; o >= 10; o /= 10) u++; s != u && (n.e++, h[0] == Pn && (h[0] = 1)); break } if (h[l] += u, h[l] != Pn) break; h[l--] = 0, u = 1 } for (s = h.length; 0 === h[--s];) h.pop() } return bn && (n.e > d.maxE ? (n.d = null, n.e = NaN) : n.e < d.minE && (n.e = 0, n.d = [0])), n } function u(n, i, t) { if (!n.isFinite()) return v(n); var r, s = n.e, o = e(n.d), u = o.length; return i ? (t && (r = t - u) > 0 ? o = o.charAt(0) + \".\" + o.slice(1) + l(r) : u > 1 && (o = o.charAt(0) + \".\" + o.slice(1)), o = o + (n.e < 0 ? \"e\" : \"e+\") + n.e) : 0 > s ? (o = \"0.\" + l(-s - 1) + o, t && (r = t - u) > 0 && (o += l(r))) : s >= u ? (o += l(s + 1 - u), t && (r = t - s - 1) > 0 && (o = o + \".\" + l(r))) : ((r = s + 1) < u && (o = o.slice(0, r) + \".\" + o.slice(r)), t && (r = t - u) > 0 && (s + 1 === u && (o += \".\"), o += l(r))), o } function c(n, e) { for (var i = 1, t = n[0]; t >= 10; t /= 10) i++; return i + e * Rn - 1 } function f(n, e, i) { if (e > Un) throw bn = !0, i && (n.precision = i), Error(Mn); return o(new n(mn), e, 1, !0) } function a(n, e, i) { if (e > _n) throw Error(Mn); return o(new n(vn), e, i, !0) } function h(n) { var e = n.length - 1, i = e * Rn + 1; if (e = n[e]) { for (; e % 10 == 0; e /= 10) i--; for (e = n[0]; e >= 10; e /= 10) i++ } return i } function l(n) { for (var e = \"\"; n--;) e += \"0\"; return e } function d(n, e, i, t) { var r, s = new n(1), o = Math.ceil(t / Rn + 4); for (bn = !1; ;) { if (i % 2 && (s = s.times(e), q(s.d, o) && (r = !0)), i = qn(i / 2), 0 === i) { i = s.d.length - 1, r && 0 === s.d[i] && ++s.d[i]; break } e = e.times(e), q(e.d, o) } return bn = !0, s } function p(n) { return 1 & n.d[n.d.length - 1] } function g(n, e, i) { for (var t, r = new n(e[0]), s = 0; ++s < e.length;) { if (t = new n(e[s]), !t.s) { r = t; break } r[i](t) && (r = t) } return r } function w(n, i) { var r, s, u, c, f, a, h, l = 0, d = 0, p = 0, g = n.constructor, w = g.rounding, m = g.precision; if (!n.d || !n.d[0] || n.e > 17) return new g(n.d ? n.d[0] ? n.s < 0 ? 0 : 1 / 0 : 1 : n.s ? n.s < 0 ? 0 : n : NaN); for (null == i ? (bn = !1, h = m) : h = i, a = new g(.03125) ; n.e > -2;) n = n.times(a), p += 5; for (s = Math.log(On(2, p)) / Math.LN10 * 2 + 5 | 0, h += s, r = c = f = new g(1), g.precision = h; ;) { if (c = o(c.times(n), h, 1), r = r.times(++d), a = f.plus(Sn(c, r, h, 1)), e(a.d).slice(0, h) === e(f.d).slice(0, h)) { for (u = p; u--;) f = o(f.times(f), h, 1); if (null != i) return g.precision = m, f; if (!(3 > l && t(f.d, h - s, w, l))) return o(f, g.precision = m, w, bn = !0); g.precision = h += 10, r = c = a = new g(1), d = 0, l++ } f = a } } function m(n, i) { var r, s, u, c, a, h, l, d, p, g, w, v = 1, N = 10, b = n, x = b.d, E = b.constructor, M = E.rounding, y = E.precision; if (b.s < 0 || !x || !x[0] || !b.e && 1 == x[0] && 1 == x.length) return new E(x && !x[0] ? -1 / 0 : 1 != b.s ? NaN : x ? 0 : b); if (null == i ? (bn = !1, p = y) : p = i, E.precision = p += N, r = e(x), s = r.charAt(0), !(Math.abs(c = b.e) < 15e14)) return d = f(E, p + 2, y).times(c + \"\"), b = m(new E(s + \".\" + r.slice(1)), p - N).plus(d), E.precision = y, null == i ? o(b, y, M, bn = !0) : b; for (; 7 > s && 1 != s || 1 == s && r.charAt(1) > 3;) b = b.times(n), r = e(b.d), s = r.charAt(0), v++; for (c = b.e, s > 1 ? (b = new E(\"0.\" + r), c++) : b = new E(s + \".\" + r.slice(1)), g = b, l = a = b = Sn(b.minus(1), b.plus(1), p, 1), w = o(b.times(b), p, 1), u = 3; ;) { if (a = o(a.times(w), p, 1), d = l.plus(Sn(a, new E(u), p, 1)), e(d.d).slice(0, p) === e(l.d).slice(0, p)) { if (l = l.times(2), 0 !== c && (l = l.plus(f(E, p + 2, y).times(c + \"\"))), l = Sn(l, new E(v), p, 1), null != i) return E.precision = y, l; if (!t(l.d, p - N, M, h)) return o(l, E.precision = y, M, bn = !0); E.precision = p += N, d = a = b = Sn(g.minus(1), g.plus(1), p, 1), w = o(b.times(b), p, 1), u = h = 1 } l = d, u += 2 } } function v(n) { return String(n.s * n.s / 0) } function N(n, e) { var i, t, r; for ((i = e.indexOf(\".\")) > -1 && (e = e.replace(\".\", \"\")), (t = e.search(/e/i)) > 0 ? (0 > i && (i = t), i += +e.slice(t + 1), e = e.substring(0, t)) : 0 > i && (i = e.length), t = 0; 48 === e.charCodeAt(t) ; t++); for (r = e.length; 48 === e.charCodeAt(r - 1) ; --r); if (e = e.slice(t, r)) { if (r -= t, n.e = i = i - t - 1, n.d = [], t = (i + 1) % Rn, 0 > i && (t += Rn), r > t) { for (t && n.d.push(+e.slice(0, t)), r -= Rn; r > t;) n.d.push(+e.slice(t, t += Rn)); e = e.slice(t), t = Rn - e.length } else t -= r; for (; t--;) e += \"0\"; n.d.push(+e), bn && (n.e > n.constructor.maxE ? (n.d = null, n.e = NaN) : n.e < n.constructor.minE && (n.e = 0, n.d = [0])) } else n.e = 0, n.d = [0]; return n } function b(n, e) { var i, t, s, o, u, f, a, h, l; if (\"Infinity\" === e || \"NaN\" === e) return +e || (n.s = NaN), n.e = NaN, n.d = null, n; if (An.test(e)) i = 16, e = e.toLowerCase(); else if (Fn.test(e)) i = 2; else { if (!Dn.test(e)) throw Error(En + e); i = 8 } for (o = e.search(/p/i), o > 0 ? (a = +e.slice(o + 1), e = e.substring(2, o)) : e = e.slice(2), o = e.indexOf(\".\"), u = o >= 0, t = n.constructor, u && (e = e.replace(\".\", \"\"), f = e.length, o = f - o, s = d(t, new t(i), o, 2 * o)), h = r(e, i, Pn), l = h.length - 1, o = l; 0 === h[o]; --o) h.pop(); return 0 > o ? new t(0 * n.s) : (n.e = c(h, l), n.d = h, bn = !1, u && (n = Sn(n, s, 4 * f)), a && (n = n.times(Math.abs(a) < 54 ? Math.pow(2, a) : Nn.pow(2, a))), bn = !0, n) } function x(n, e) { var i, t = e.d.length; if (3 > t) return E(n, 2, e, e); i = 1.4 * Math.sqrt(t), i = i > 16 ? 16 : 0 | i, e = e.times(Math.pow(5, -i)), e = E(n, 2, e, e); for (var r, s = new n(5), o = new n(16), u = new n(20) ; i--;) r = e.times(e), e = e.times(s.plus(r.times(o.times(r).minus(u)))); return e } function E(n, e, i, t, r) { var s, o, u, c, f = 1, a = n.precision, h = Math.ceil(a / Rn); for (bn = !1, c = i.times(i), u = new n(t) ; ;) { if (o = Sn(u.times(c), new n(e++ * e++), a, 1), u = r ? t.plus(o) : t.minus(o), t = Sn(o.times(c), new n(e++ * e++), a, 1), o = u.plus(t), void 0 !== o.d[h]) { for (s = h; o.d[s] === u.d[s] && s--;); if (-1 == s) break } s = u, u = t, t = o, o = s, f++ } return bn = !0, o.d.length = h + 1, o } function M(n, e) { var i, t = e.s < 0, r = a(n, n.precision, 1), s = r.times(.5); if (e = e.abs(), e.lte(s)) return dn = t ? 4 : 1, e; if (i = e.divToInt(r), i.isZero()) dn = t ? 3 : 2; else { if (e = e.minus(i.times(r)), e.lte(s)) return dn = p(i) ? t ? 2 : 3 : t ? 4 : 1, e; dn = p(i) ? t ? 1 : 4 : t ? 3 : 2 } return e.minus(r).abs() } function y(n, e, t, s) { var o, c, f, a, h, l, d, p, g, w = n.constructor, m = void 0 !== t; if (m ? (i(t, 1, gn), void 0 === s ? s = w.rounding : i(s, 0, 8)) : (t = w.precision, s = w.rounding), n.isFinite()) { for (d = u(n), f = d.indexOf(\".\"), m ? (o = 2, 16 == e ? t = 4 * t - 3 : 8 == e && (t = 3 * t - 2)) : o = e, f >= 0 && (d = d.replace(\".\", \"\"), g = new w(1), g.e = d.length - f, g.d = r(u(g), 10, o), g.e = g.d.length), p = r(d, 10, o), c = h = p.length; 0 == p[--h];) p.pop(); if (p[0]) { if (0 > f ? c-- : (n = new w(n), n.d = p, n.e = c, n = Sn(n, g, t, s, 0, o), p = n.d, c = n.e, l = hn), f = p[t], a = o / 2, l = l || void 0 !== p[t + 1], l = 4 > s ? (void 0 !== f || l) && (0 === s || s === (n.s < 0 ? 3 : 2)) : f > a || f === a && (4 === s || l || 6 === s && 1 & p[t - 1] || s === (n.s < 0 ? 8 : 7)), p.length = t, l) for (; ++p[--t] > o - 1;) p[t] = 0, t || (++c, p.unshift(1)); for (h = p.length; !p[h - 1]; --h); for (f = 0, d = \"\"; h > f; f++) d += wn.charAt(p[f]); if (m) { if (h > 1) if (16 == e || 8 == e) { for (f = 16 == e ? 4 : 3, --h; h % f; h++) d += \"0\"; for (p = r(d, o, e), h = p.length; !p[h - 1]; --h); for (f = 1, d = \"1.\"; h > f; f++) d += wn.charAt(p[f]) } else d = d.charAt(0) + \".\" + d.slice(1); d = d + (0 > c ? \"p\" : \"p+\") + c } else if (0 > c) { for (; ++c;) d = \"0\" + d; d = \"0.\" + d } else if (++c > h) for (c -= h; c--;) d += \"0\"; else h > c && (d = d.slice(0, c) + \".\" + d.slice(c)) } else d = m ? \"0p+0\" : \"0\"; d = (16 == e ? \"0x\" : 2 == e ? \"0b\" : 8 == e ? \"0o\" : \"\") + d } else d = v(n); return n.s < 0 ? \"-\" + d : d } function q(n, e) { return n.length > e ? (n.length = e, !0) : void 0 } function O(n) { return new this(n).abs() } function F(n) { return new this(n).acos() } function A(n) { return new this(n).acosh() } function D(n, e) { return new this(n).plus(e) } function Z(n) { return new this(n).asin() } function P(n) { return new this(n).asinh() } function R(n) { return new this(n).atan() } function L(n) { return new this(n).atanh() } function U(n, e) { n = new this(n), e = new this(e); var i, t = this.precision, r = this.rounding, s = t + 4; return n.s && e.s ? n.d || e.d ? !e.d || n.isZero() ? (i = e.s < 0 ? a(this, t, r) : new this(0), i.s = n.s) : !n.d || e.isZero() ? (i = a(this, s, 1).times(.5), i.s = n.s) : e.s < 0 ? (this.precision = s, this.rounding = 1, i = this.atan(Sn(n, e, s, 1)), e = a(this, s, 1), this.precision = t, this.rounding = r, i = n.s < 0 ? i.minus(e) : i.plus(e)) : i = this.atan(Sn(n, e, s, 1)) : (i = a(this, s, 1).times(e.s > 0 ? .25 : .75), i.s = n.s) : i = new this(NaN), i } function _(n) { return new this(n).cbrt() } function k(n) { return o(n = new this(n), n.e + 1, 2) } function S(n) { if (!n || \"object\" != typeof n) throw Error(xn + \"Object expected\"); var e, i, t, r = [\"precision\", 1, gn, \"rounding\", 0, 8, \"toExpNeg\", -pn, 0, \"toExpPos\", 0, pn, \"maxE\", 0, pn, \"minE\", -pn, 0, \"modulo\", 0, 9]; for (e = 0; e < r.length; e += 3) if (void 0 !== (t = n[i = r[e]])) { if (!(qn(t) === t && t >= r[e + 1] && t <= r[e + 2])) throw Error(En + i + \": \" + t); this[i] = t } if (void 0 !== (t = n[i = \"crypto\"])) { if (t !== !0 && t !== !1 && 0 !== t && 1 !== t) throw Error(En + i + \": \" + t); if (t) { if (\"undefined\" == typeof crypto || !crypto || !crypto.getRandomValues && !crypto.randomBytes) throw Error(yn); this[i] = !0 } else this[i] = !1 } return this } function T(n) { return new this(n).cos() } function C(n) { return new this(n).cosh() } function I(n) { function e(n) { var i, t, r, s = this; if (!(s instanceof e)) return new e(n); if (s.constructor = e, n instanceof e) return s.s = n.s, s.e = n.e, void (s.d = (n = n.d) ? n.slice() : n); if (r = typeof n, \"number\" === r) { if (0 === n) return s.s = 0 > 1 / n ? -1 : 1, s.e = 0, void (s.d = [0]); if (0 > n ? (n = -n, s.s = -1) : s.s = 1, n === ~~n && 1e7 > n) { for (i = 0, t = n; t >= 10; t /= 10) i++; return s.e = i, void (s.d = [n]) } return 0 * n !== 0 ? (n || (s.s = NaN), s.e = NaN, void (s.d = null)) : N(s, n.toString()) } if (\"string\" !== r) throw Error(En + n); return 45 === n.charCodeAt(0) ? (n = n.slice(1), s.s = -1) : s.s = 1, Zn.test(n) ? N(s, n) : b(s, n) } var i, t, r; if (e.prototype = kn, e.ROUND_UP = 0, e.ROUND_DOWN = 1, e.ROUND_CEIL = 2, e.ROUND_FLOOR = 3, e.ROUND_HALF_UP = 4, e.ROUND_HALF_DOWN = 5, e.ROUND_HALF_EVEN = 6, e.ROUND_HALF_CEIL = 7, e.ROUND_HALF_FLOOR = 8, e.EUCLID = 9, e.config = e.set = S, e.clone = I, e.abs = O, e.acos = F, e.acosh = A, e.add = D, e.asin = Z, e.asinh = P, e.atan = R, e.atanh = L, e.atan2 = U, e.cbrt = _, e.ceil = k, e.cos = T, e.cosh = C, e.div = H, e.exp = B, e.floor = V, e.hypot = $, e.ln = j, e.log = W, e.log10 = z, e.log2 = J, e.max = G, e.min = K, e.mod = Q, e.mul = X, e.pow = Y, e.random = nn, e.round = en, e.sign = tn, e.sin = rn, e.sinh = sn, e.sqrt = on, e.sub = un, e.tan = cn, e.tanh = fn, e.trunc = an, void 0 === n && (n = {}), n) for (r = [\"precision\", \"rounding\", \"toExpNeg\", \"toExpPos\", \"maxE\", \"minE\", \"modulo\", \"crypto\"], i = 0; i < r.length;) n.hasOwnProperty(t = r[i++]) || (n[t] = this[t]); return e.config(n), e } function H(n, e) { return new this(n).div(e) } function B(n) { return new this(n).exp() } function V(n) { return o(n = new this(n), n.e + 1, 3) } function $() { var n, e, i = new this(0); for (bn = !1, n = 0; n < arguments.length;) if (e = new this(arguments[n++]), e.d) i.d && (i = i.plus(e.times(e))); else { if (e.s) return bn = !0, new this(1 / 0); i = e } return bn = !0, i.sqrt() } function j(n) { return new this(n).ln() } function W(n, e) { return new this(n).log(e) } function J(n) { return new this(n).log(2) } function z(n) { return new this(n).log(10) } function G() { return g(this, arguments, \"lt\") } function K() { return g(this, arguments, \"gt\") } function Q(n, e) { return new this(n).mod(e) } function X(n, e) { return new this(n).mul(e) } function Y(n, e) { return new this(n).pow(e) } function nn(n) { var e, t, r, s, o = 0, u = new this(1), c = []; if (void 0 === n ? n = this.precision : i(n, 1, gn), r = Math.ceil(n / Rn), this.crypto) if (crypto.getRandomValues) for (e = crypto.getRandomValues(new Uint32Array(r)) ; r > o;) s = e[o], s >= 429e7 ? e[o] = crypto.getRandomValues(new Uint32Array(1))[0] : c[o++] = s % 1e7; else { if (!crypto.randomBytes) throw Error(yn); for (e = crypto.randomBytes(r *= 4) ; r > o;) s = e[o] + (e[o + 1] << 8) + (e[o + 2] << 16) + ((127 & e[o + 3]) << 24), s >= 214e7 ? crypto.randomBytes(4).copy(e, o) : (c.push(s % 1e7), o += 4); o = r / 4 } else for (; r > o;) c[o++] = 1e7 * Math.random() | 0; for (r = c[--o], n %= Rn, r && n && (s = On(10, Rn - n), c[o] = (r / s | 0) * s) ; 0 === c[o]; o--) c.pop(); if (0 > o) t = 0, c = [0]; else { for (t = -1; 0 === c[0]; t -= Rn) c.shift(); for (r = 1, s = c[0]; s >= 10; s /= 10) r++; Rn > r && (t -= Rn - r) } return u.e = t, u.d = c, u } function en(n) { return o(n = new this(n), n.e + 1, this.rounding) } function tn(n) { return n = new this(n), n.d ? n.d[0] ? n.s : 0 * n.s : n.s || NaN } function rn(n) { return new this(n).sin() } function sn(n) { return new this(n).sinh() } function on(n) { return new this(n).sqrt() } function un(n, e) { return new this(n).sub(e) } function cn(n) { return new this(n).tan() } function fn(n) { return new this(n).tanh() } function an(n) { return o(n = new this(n), n.e + 1, 1) } var hn, ln, dn, pn = 9e15, gn = 1e9, wn = \"0123456789abcdef\", mn = \"2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058\", vn = \"3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789\", Nn = { precision: 20, rounding: 4, modulo: 1, toExpNeg: -7, toExpPos: 21, minE: -pn, maxE: pn, crypto: !1 }, bn = !0, xn = \"[DecimalError] \", En = xn + \"Invalid argument: \", Mn = xn + \"Precision limit exceeded\", yn = xn + \"crypto unavailable\", qn = Math.floor, On = Math.pow, Fn = /^0b([01]+(\\.[01]*)?|\\.[01]+)(p[+-]?\\d+)?$/i, An = /^0x([0-9a-f]+(\\.[0-9a-f]*)?|\\.[0-9a-f]+)(p[+-]?\\d+)?$/i, Dn = /^0o([0-7]+(\\.[0-7]*)?|\\.[0-7]+)(p[+-]?\\d+)?$/i, Zn = /^(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i, Pn = 1e7, Rn = 7, Ln = 9007199254740991, Un = mn.length - 1, _n = vn.length - 1, kn = {}; kn.absoluteValue = kn.abs = function () { var n = new this.constructor(this); return n.s < 0 && (n.s = 1), o(n) }, kn.ceil = function () { return o(new this.constructor(this), this.e + 1, 2) }, kn.comparedTo = kn.cmp = function (n) { var e, i, t, r, s = this, o = s.d, u = (n = new s.constructor(n)).d, c = s.s, f = n.s; if (!o || !u) return c && f ? c !== f ? c : o === u ? 0 : !o ^ 0 > c ? 1 : -1 : NaN; if (!o[0] || !u[0]) return o[0] ? c : u[0] ? -f : 0; if (c !== f) return c; if (s.e !== n.e) return s.e > n.e ^ 0 > c ? 1 : -1; for (t = o.length, r = u.length, e = 0, i = r > t ? t : r; i > e; ++e) if (o[e] !== u[e]) return o[e] > u[e] ^ 0 > c ? 1 : -1; return t === r ? 0 : t > r ^ 0 > c ? 1 : -1 }, kn.cosine = kn.cos = function () { var n, e, i = this, t = i.constructor; return i.d ? i.d[0] ? (n = t.precision, e = t.rounding, t.precision = n + Math.max(i.e, i.sd()) + Rn, t.rounding = 1, i = s(t, M(t, i)), t.precision = n, t.rounding = e, o(2 == dn || 3 == dn ? i.neg() : i, n, e, !0)) : new t(1) : new t(NaN) }, kn.cubeRoot = kn.cbrt = function () { var n, i, t, r, s, u, c, f, a, h, l = this, d = l.constructor; if (!l.isFinite() || l.isZero()) return new d(l); for (bn = !1, u = l.s * Math.pow(l.s * l, 1 / 3), u && Math.abs(u) != 1 / 0 ? r = new d(u.toString()) : (t = e(l.d), n = l.e, (u = (n - t.length + 1) % 3) && (t += 1 == u || -2 == u ? \"0\" : \"00\"), u = Math.pow(t, 1 / 3), n = qn((n + 1) / 3) - (n % 3 == (0 > n ? -1 : 2)), u == 1 / 0 ? t = \"5e\" + n : (t = u.toExponential(), t = t.slice(0, t.indexOf(\"e\") + 1) + n), r = new d(t), r.s = l.s), c = (n = d.precision) + 3; ;) if (f = r, a = f.times(f).times(f), h = a.plus(l), r = Sn(h.plus(l).times(f), h.plus(a), c + 2, 1), e(f.d).slice(0, c) === (t = e(r.d)).slice(0, c)) { if (t = t.slice(c - 3, c + 1), \"9999\" != t && (s || \"4999\" != t)) { (!+t || !+t.slice(1) && \"5\" == t.charAt(0)) && (o(r, n + 1, 1), i = !r.times(r).times(r).eq(l)); break } if (!s && (o(f, n + 1, 0), f.times(f).times(f).eq(l))) { r = f; break } c += 4, s = 1 } return bn = !0, o(r, n, d.rounding, i) }, kn.decimalPlaces = kn.dp = function () { var n, e = this.d, i = NaN; if (e) { if (n = e.length - 1, i = (n - qn(this.e / Rn)) * Rn, n = e[n]) for (; n % 10 == 0; n /= 10) i--; 0 > i && (i = 0) } return i }, kn.dividedBy = kn.div = function (n) { return Sn(this, new this.constructor(n)) }, kn.dividedToIntegerBy = kn.divToInt = function (n) { var e = this, i = e.constructor; return o(Sn(e, new i(n), 0, 1, 1), i.precision, i.rounding) }, kn.equals = kn.eq = function (n) { return 0 === this.cmp(n) }, kn.floor = function () { return o(new this.constructor(this), this.e + 1, 3) }, kn.greaterThan = kn.gt = function (n) { return this.cmp(n) > 0 }, kn.greaterThanOrEqualTo = kn.gte = function (n) { var e = this.cmp(n); return 1 == e || 0 === e }, kn.hyperbolicCosine = kn.cosh = function () { var n, e, i, t, r, s = this, u = s.constructor, c = new u(1); if (!s.isFinite()) return new u(s.s ? 1 / 0 : NaN); if (s.isZero()) return c; i = u.precision, t = u.rounding, u.precision = i + Math.max(s.e, s.sd()) + 4, u.rounding = 1, r = s.d.length, 32 > r ? (n = Math.ceil(r / 3), e = Math.pow(4, -n).toString()) : (n = 16, e = \"2.3283064365386962890625e-10\"), s = E(u, 1, s.times(e), new u(1), !0); for (var f, a = n, h = new u(8) ; a--;) f = s.times(s), s = c.minus(f.times(h.minus(f.times(h)))); return o(s, u.precision = i, u.rounding = t, !0) }, kn.hyperbolicSine = kn.sinh = function () { var n, e, i, t, r = this, s = r.constructor; if (!r.isFinite() || r.isZero()) return new s(r); if (e = s.precision, i = s.rounding, s.precision = e + Math.max(r.e, r.sd()) + 4, s.rounding = 1, t = r.d.length, 3 > t) r = E(s, 2, r, r, !0); else { n = 1.4 * Math.sqrt(t), n = n > 16 ? 16 : 0 | n, r = r.times(Math.pow(5, -n)), r = E(s, 2, r, r, !0); for (var u, c = new s(5), f = new s(16), a = new s(20) ; n--;) u = r.times(r), r = r.times(c.plus(u.times(f.times(u).plus(a)))) } return s.precision = e, s.rounding = i, o(r, e, i, !0) }, kn.hyperbolicTangent = kn.tanh = function () { var n, e, i = this, t = i.constructor; return i.isFinite() ? i.isZero() ? new t(i) : (n = t.precision, e = t.rounding, t.precision = n + 7, t.rounding = 1, Sn(i.sinh(), i.cosh(), t.precision = n, t.rounding = e)) : new t(i.s) }, kn.inverseCosine = kn.acos = function () { var n, e = this, i = e.constructor, t = e.abs().cmp(1), r = i.precision, s = i.rounding; return -1 !== t ? 0 === t ? e.isNeg() ? a(i, r, s) : new i(0) : new i(NaN) : e.isZero() ? a(i, r + 4, s).times(.5) : (i.precision = r + 6, i.rounding = 1, e = e.asin(), n = a(i, r + 4, s).times(.5), i.precision = r, i.rounding = s, n.minus(e)) }, kn.inverseHyperbolicCosine = kn.acosh = function () { var n, e, i = this, t = i.constructor; return i.lte(1) ? new t(i.eq(1) ? 0 : NaN) : i.isFinite() ? (n = t.precision, e = t.rounding, t.precision = n + Math.max(Math.abs(i.e), i.sd()) + 4, t.rounding = 1, bn = !1, i = i.times(i).minus(1).sqrt().plus(i), bn = !0, t.precision = n, t.rounding = e, i.ln()) : new t(i) }, kn.inverseHyperbolicSine = kn.asinh = function () { var n, e, i = this, t = i.constructor; return !i.isFinite() || i.isZero() ? new t(i) : (n = t.precision, e = t.rounding, t.precision = n + 2 * Math.max(Math.abs(i.e), i.sd()) + 6, t.rounding = 1, bn = !1, i = i.times(i).plus(1).sqrt().plus(i), bn = !0, t.precision = n, t.rounding = e, i.ln()) }, kn.inverseHyperbolicTangent = kn.atanh = function () { var n, e, i, t, r = this, s = r.constructor; return r.isFinite() ? r.e >= 0 ? new s(r.abs().eq(1) ? r.s / 0 : r.isZero() ? r : NaN) : (n = s.precision, e = s.rounding, t = r.sd(), Math.max(t, n) < 2 * -r.e - 1 ? o(new s(r), n, e, !0) : (s.precision = i = t - r.e, r = Sn(r.plus(1), new s(1).minus(r), i + n, 1), s.precision = n + 4, s.rounding = 1, r = r.ln(), s.precision = n, s.rounding = e, r.times(.5))) : new s(NaN) }, kn.inverseSine = kn.asin = function () { var n, e, i, t, r = this, s = r.constructor; return r.isZero() ? new s(r) : (e = r.abs().cmp(1), i = s.precision, t = s.rounding, -1 !== e ? 0 === e ? (n = a(s, i + 4, t).times(.5), n.s = r.s, n) : new s(NaN) : (s.precision = i + 6, s.rounding = 1, r = r.div(new s(1).minus(r.times(r)).sqrt().plus(1)).atan(), s.precision = i, s.rounding = t, r.times(2))) }, kn.inverseTangent = kn.atan = function () { var n, e, i, t, r, s, u, c, f, h = this, l = h.constructor, d = l.precision, p = l.rounding; if (h.isFinite()) { if (h.isZero()) return new l(h); if (h.abs().eq(1) && _n >= d + 4) return u = a(l, d + 4, p).times(.25), u.s = h.s, u } else { if (!h.s) return new l(NaN); if (_n >= d + 4) return u = a(l, d + 4, p).times(.5), u.s = h.s, u } for (l.precision = c = d + 10, l.rounding = 1, i = Math.min(28, c / Rn + 2 | 0), n = i; n; --n) h = h.div(h.times(h).plus(1).sqrt().plus(1)); for (bn = !1, e = Math.ceil(c / Rn), t = 1, f = h.times(h), u = new l(h), r = h; -1 !== n;) if (r = r.times(f), s = u.minus(r.div(t += 2)), r = r.times(f), u = s.plus(r.div(t += 2)), void 0 !== u.d[e]) for (n = e; u.d[n] === s.d[n] && n--;); return i && (u = u.times(2 << i - 1)), bn = !0, o(u, l.precision = d, l.rounding = p, !0) }, kn.isFinite = function () { return !!this.d }, kn.isInteger = kn.isInt = function () { return !!this.d && qn(this.e / Rn) > this.d.length - 2 }, kn.isNaN = function () { return !this.s }, kn.isNegative = kn.isNeg = function () { return this.s < 0 }, kn.isPositive = kn.isPos = function () { return this.s > 0 }, kn.isZero = function () { return !!this.d && 0 === this.d[0] }, kn.lessThan = kn.lt = function (n) { return this.cmp(n) < 0 }, kn.lessThanOrEqualTo = kn.lte = function (n) { return this.cmp(n) < 1 }, kn.logarithm = kn.log = function (n) { var i, r, s, u, c, a, h, l, d = this, p = d.constructor, g = p.precision, w = p.rounding, v = 5; if (null == n) n = new p(10), i = !0; else { if (n = new p(n), r = n.d, n.s < 0 || !r || !r[0] || n.eq(1)) return new p(NaN); i = n.eq(10) } if (r = d.d, d.s < 0 || !r || !r[0] || d.eq(1)) return new p(r && !r[0] ? -1 / 0 : 1 != d.s ? NaN : r ? 0 : 1 / 0); if (i) if (r.length > 1) c = !0; else { for (u = r[0]; u % 10 === 0;) u /= 10; c = 1 !== u } if (bn = !1, h = g + v, a = m(d, h), s = i ? f(p, h + 10) : m(n, h), l = Sn(a, s, h, 1), t(l.d, u = g, w)) do if (h += 10, a = m(d, h), s = i ? f(p, h + 10) : m(n, h), l = Sn(a, s, h, 1), !c) { +e(l.d).slice(u + 1, u + 15) + 1 == 1e14 && (l = o(l, g + 1, 0)); break } while (t(l.d, u += 10, w)); return bn = !0, o(l, g, w) }, kn.minus = kn.sub = function (n) { var e, i, t, r, s, u, f, a, h, l, d, p, g = this, w = g.constructor; if (n = new w(n), !g.d || !n.d) return g.s && n.s ? g.d ? n.s = -n.s : n = new w(n.d || g.s !== n.s ? g : NaN) : n = new w(NaN), n; if (g.s != n.s) return n.s = -n.s, g.plus(n); if (h = g.d, p = n.d, f = w.precision, a = w.rounding, !h[0] || !p[0]) { if (p[0]) n.s = -n.s; else { if (!h[0]) return new w(3 === a ? -0 : 0); n = new w(g) } return bn ? o(n, f, a) : n } if (i = qn(n.e / Rn), l = qn(g.e / Rn), h = h.slice(), s = l - i) { for (d = 0 > s, d ? (e = h, s = -s, u = p.length) : (e = p, i = l, u = h.length), t = Math.max(Math.ceil(f / Rn), u) + 2, s > t && (s = t, e.length = 1), e.reverse(), t = s; t--;) e.push(0); e.reverse() } else { for (t = h.length, u = p.length, d = u > t, d && (u = t), t = 0; u > t; t++) if (h[t] != p[t]) { d = h[t] < p[t]; break } s = 0 } for (d && (e = h, h = p, p = e, n.s = -n.s), u = h.length, t = p.length - u; t > 0; --t) h[u++] = 0; for (t = p.length; t > s;) { if (h[--t] < p[t]) { for (r = t; r && 0 === h[--r];) h[r] = Pn - 1; --h[r], h[t] += Pn } h[t] -= p[t] } for (; 0 === h[--u];) h.pop(); for (; 0 === h[0]; h.shift())--i; return h[0] ? (n.d = h, n.e = c(h, i), bn ? o(n, f, a) : n) : new w(3 === a ? -0 : 0) }, kn.modulo = kn.mod = function (n) { var e, i = this, t = i.constructor; return n = new t(n), !i.d || !n.s || n.d && !n.d[0] ? new t(NaN) : !n.d || i.d && !i.d[0] ? o(new t(i), t.precision, t.rounding) : (bn = !1, 9 == t.modulo ? (e = Sn(i, n.abs(), 0, 3, 1), e.s *= n.s) : e = Sn(i, n, 0, t.modulo, 1), e = e.times(n), bn = !0, i.minus(e)) }, kn.naturalExponential = kn.exp = function () { return w(this) }, kn.naturalLogarithm = kn.ln = function () { return m(this) }, kn.negated = kn.neg = function () { var n = new this.constructor(this); return n.s = -n.s, o(n) }, kn.plus = kn.add = function (n) { var e, i, t, r, s, u, f, a, h, l, d = this, p = d.constructor; if (n = new p(n), !d.d || !n.d) return d.s && n.s ? d.d || (n = new p(n.d || d.s === n.s ? d : NaN)) : n = new p(NaN), n; if (d.s != n.s) return n.s = -n.s, d.minus(n); if (h = d.d, l = n.d, f = p.precision, a = p.rounding, !h[0] || !l[0]) return l[0] || (n = new p(d)), bn ? o(n, f, a) : n; if (s = qn(d.e / Rn), t = qn(n.e / Rn), h = h.slice(), r = s - t) { for (0 > r ? (i = h, r = -r, u = l.length) : (i = l, t = s, u = h.length), s = Math.ceil(f / Rn), u = s > u ? s + 1 : u + 1, r > u && (r = u, i.length = 1), i.reverse() ; r--;) i.push(0); i.reverse() } for (u = h.length, r = l.length, 0 > u - r && (r = u, i = l, l = h, h = i), e = 0; r;) e = (h[--r] = h[r] + l[r] + e) / Pn | 0, h[r] %= Pn; for (e && (h.unshift(e), ++t), u = h.length; 0 == h[--u];) h.pop(); return n.d = h, n.e = c(h, t), bn ? o(n, f, a) : n }, kn.precision = kn.sd = function (n) { var e, i = this; if (void 0 !== n && n !== !!n && 1 !== n && 0 !== n) throw Error(En + n); return i.d ? (e = h(i.d), n && i.e + 1 > e && (e = i.e + 1)) : e = NaN, e }, kn.round = function () { var n = this, e = n.constructor; return o(new e(n), n.e + 1, e.rounding) }, kn.sine = kn.sin = function () { var n, e, i = this, t = i.constructor; return i.isFinite() ? i.isZero() ? new t(i) : (n = t.precision, e = t.rounding, t.precision = n + Math.max(i.e, i.sd()) + Rn, t.rounding = 1, i = x(t, M(t, i)), t.precision = n, t.rounding = e, o(dn > 2 ? i.neg() : i, n, e, !0)) : new t(NaN) }, kn.squareRoot = kn.sqrt = function () { var n, i, t, r, s, u, c = this, f = c.d, a = c.e, h = c.s, l = c.constructor; if (1 !== h || !f || !f[0]) return new l(!h || 0 > h && (!f || f[0]) ? NaN : f ? c : 1 / 0); for (bn = !1, h = Math.sqrt(+c), 0 == h || h == 1 / 0 ? (i = e(f), (i.length + a) % 2 == 0 && (i += \"0\"), h = Math.sqrt(i), a = qn((a + 1) / 2) - (0 > a || a % 2), h == 1 / 0 ? i = \"1e\" + a : (i = h.toExponential(), i = i.slice(0, i.indexOf(\"e\") + 1) + a), r = new l(i)) : r = new l(h.toString()), t = (a = l.precision) + 3; ;) if (u = r, r = u.plus(Sn(c, u, t + 2, 1)).times(.5), e(u.d).slice(0, t) === (i = e(r.d)).slice(0, t)) { if (i = i.slice(t - 3, t + 1), \"9999\" != i && (s || \"4999\" != i)) { (!+i || !+i.slice(1) && \"5\" == i.charAt(0)) && (o(r, a + 1, 1), n = !r.times(r).eq(c)); break } if (!s && (o(u, a + 1, 0), u.times(u).eq(c))) { r = u; break } t += 4, s = 1 } return bn = !0, o(r, a, l.rounding, n) }, kn.tangent = kn.tan = function () { var n, e, i = this, t = i.constructor; return i.isFinite() ? i.isZero() ? new t(i) : (n = t.precision, e = t.rounding, t.precision = n + 10, t.rounding = 1, i = i.sin(), i.s = 1, i = Sn(i, new t(1).minus(i.times(i)).sqrt(), n + 10, 0), t.precision = n, t.rounding = e, o(2 == dn || 4 == dn ? i.neg() : i, n, e, !0)) : new t(NaN) }, kn.times = kn.mul = function (n) { var e, i, t, r, s, u, f, a, h, l = this, d = l.constructor, p = l.d, g = (n = new d(n)).d; if (n.s *= l.s, !(p && p[0] && g && g[0])) return new d(!n.s || p && !p[0] && !g || g && !g[0] && !p ? NaN : p && g ? 0 * n.s : n.s / 0); for (i = qn(l.e / Rn) + qn(n.e / Rn), a = p.length, h = g.length, h > a && (s = p, p = g, g = s, u = a, a = h, h = u), s = [], u = a + h, t = u; t--;) s.push(0); for (t = h; --t >= 0;) { for (e = 0, r = a + t; r > t;) f = s[r] + g[t] * p[r - t - 1] + e, s[r--] = f % Pn | 0, e = f / Pn | 0; s[r] = (s[r] + e) % Pn | 0 } for (; !s[--u];) s.pop(); for (e ? ++i : s.shift(), t = s.length; !s[--t];) s.pop(); return n.d = s, n.e = c(s, i), bn ? o(n, d.precision, d.rounding) : n }, kn.toBinary = function (n, e) { return y(this, 2, n, e) }, kn.toDecimalPlaces = kn.toDP = function (n, e) { var t = this, r = t.constructor; return t = new r(t), void 0 === n ? t : (i(n, 0, gn), void 0 === e ? e = r.rounding : i(e, 0, 8), o(t, n + t.e + 1, e)) }, kn.toExponential = function (n, e) { var t, r = this, s = r.constructor; return void 0 === n ? t = u(r, !0) : (i(n, 0, gn), void 0 === e ? e = s.rounding : i(e, 0, 8), r = o(new s(r), n + 1, e), t = u(r, !0, n + 1)), r.isNeg() && !r.isZero() ? \"-\" + t : t }, kn.toFixed = function (n, e) { var t, r, s = this, c = s.constructor; return void 0 === n ? t = u(s) : (i(n, 0, gn), void 0 === e ? e = c.rounding : i(e, 0, 8), r = o(new c(s), n + s.e + 1, e), t = u(r, !1, n + r.e + 1)), s.isNeg() && !s.isZero() ? \"-\" + t : t }, kn.toFraction = function (n) { var i, t, r, s, o, u, c, f, a, l, d, p, g = this, w = g.d, m = g.constructor; if (!w) return new m(g); if (a = t = new m(1), r = f = new m(0), i = new m(r), o = i.e = h(w) - g.e - 1, u = o % Rn, i.d[0] = On(10, 0 > u ? Rn + u : u), null == n) n = o > 0 ? i : a; else { if (c = new m(n), !c.isInt() || c.lt(a)) throw Error(En + c); n = c.gt(i) ? o > 0 ? i : a : c } for (bn = !1, c = new m(e(w)), l = m.precision, m.precision = o = w.length * Rn * 2; d = Sn(c, i, 0, 1, 1), s = t.plus(d.times(r)), 1 != s.cmp(n) ;) t = r, r = s, s = a, a = f.plus(d.times(s)), f = s, s = i, i = c.minus(d.times(s)), c = s; return s = Sn(n.minus(t), r, 0, 1, 1), f = f.plus(s.times(a)), t = t.plus(s.times(r)), f.s = a.s = g.s, p = Sn(a, r, o, 1).minus(g).abs().cmp(Sn(f, t, o, 1).minus(g).abs()) < 1 ? [a, r] : [f, t], m.precision = l, bn = !0, p }, kn.toHexadecimal = kn.toHex = function (n, e) { return y(this, 16, n, e) }, kn.toNearest = function (n, e) { var t = this, r = t.constructor; if (t = new r(t), null == n) { if (!t.d) return t; n = new r(1), e = r.rounding } else { if (n = new r(n), void 0 !== e && i(e, 0, 8), !t.d) return n.s ? t : n; if (!n.d) return n.s && (n.s = t.s), n } return n.d[0] ? (bn = !1, 4 > e && (e = [4, 5, 7, 8][e]), t = Sn(t, n, 0, e, 1).times(n), bn = !0, o(t)) : (n.s = t.s, t = n), t }, kn.toNumber = function () { return +this }, kn.toOctal = function (n, e) { return y(this, 8, n, e) }, kn.toPower = kn.pow = function (n) { var i, r, s, u, c, f, a, h = this, l = h.constructor, p = +(n = new l(n)); if (!(h.d && n.d && h.d[0] && n.d[0])) return new l(On(+h, p)); if (h = new l(h), h.eq(1)) return h; if (s = l.precision, c = l.rounding, n.eq(1)) return o(h, s, c); if (i = qn(n.e / Rn), r = n.d.length - 1, a = i >= r, f = h.s, a) { if ((r = 0 > p ? -p : p) <= Ln) return u = d(l, h, r, s), n.s < 0 ? new l(1).div(u) : o(u, s, c) } else if (0 > f) return new l(NaN); return f = 0 > f && 1 & n.d[Math.max(i, r)] ? -1 : 1, r = On(+h, p), i = 0 != r && isFinite(r) ? new l(r + \"\").e : qn(p * (Math.log(\"0.\" + e(h.d)) / Math.LN10 + h.e + 1)), i > l.maxE + 1 || i < l.minE - 1 ? new l(i > 0 ? f / 0 : 0) : (bn = !1, l.rounding = h.s = 1, r = Math.min(12, (i + \"\").length), u = w(n.times(m(h, s + r)), s), u = o(u, s + 5, 1), t(u.d, s, c) && (i = s + 10, u = o(w(n.times(m(h, i + r)), i), i + 5, 1), +e(u.d).slice(s + 1, s + 15) + 1 == 1e14 && (u = o(u, s + 1, 0))), u.s = f, bn = !0, l.rounding = c, o(u, s, c)) }, kn.toPrecision = function (n, e) { var t, r = this, s = r.constructor; return void 0 === n ? t = u(r, r.e <= s.toExpNeg || r.e >= s.toExpPos) : (i(n, 1, gn), void 0 === e ? e = s.rounding : i(e, 0, 8), r = o(new s(r), n, e), t = u(r, n <= r.e || r.e <= s.toExpNeg, n)), r.isNeg() && !r.isZero() ? \"-\" + t : t }, kn.toSignificantDigits = kn.toSD = function (n, e) { var t = this, r = t.constructor; return void 0 === n ? (n = r.precision, e = r.rounding) : (i(n, 1, gn), void 0 === e ? e = r.rounding : i(e, 0, 8)), o(new r(t), n, e) }, kn.toString = function () { var n = this, e = n.constructor, i = u(n, n.e <= e.toExpNeg || n.e >= e.toExpPos); return n.isNeg() && !n.isZero() ? \"-\" + i : i }, kn.truncated = kn.trunc = function () { return o(new this.constructor(this), this.e + 1, 1) }, kn.valueOf = kn.toJSON = function () { var n = this, e = n.constructor, i = u(n, n.e <= e.toExpNeg || n.e >= e.toExpPos); return n.isNeg() ? \"-\" + i : i }; var Sn = function () { function n(n, e, i) { var t, r = 0, s = n.length; for (n = n.slice() ; s--;) t = n[s] * e + r, n[s] = t % i | 0, r = t / i | 0; return r && n.unshift(r), n } function e(n, e, i, t) { var r, s; if (i != t) s = i > t ? 1 : -1; else for (r = s = 0; i > r; r++) if (n[r] != e[r]) { s = n[r] > e[r] ? 1 : -1; break } return s } function i(n, e, i, t) { for (var r = 0; i--;) n[i] -= r, r = n[i] < e[i] ? 1 : 0, n[i] = r * t + n[i] - e[i]; for (; !n[0] && n.length > 1;) n.shift() } return function (t, r, s, u, c, f) { var a, h, l, d, p, g, w, m, v, N, b, x, E, M, y, q, O, F, A, D, Z = t.constructor, P = t.s == r.s ? 1 : -1, R = t.d, L = r.d; if (!(R && R[0] && L && L[0])) return new Z(t.s && r.s && (R ? !L || R[0] != L[0] : L) ? R && 0 == R[0] || !L ? 0 * P : P / 0 : NaN); for (f ? (p = 1, h = t.e - r.e) : (f = Pn, p = Rn, h = qn(t.e / p) - qn(r.e / p)), A = L.length, O = R.length, v = new Z(P), N = v.d = [], l = 0; L[l] == (R[l] || 0) ; l++); if (L[l] > (R[l] || 0) && h--, null == s ? (M = s = Z.precision, u = Z.rounding) : M = c ? s + (t.e - r.e) + 1 : s, 0 > M) N.push(1), g = !0; else { if (M = M / p + 2 | 0, l = 0, 1 == A) { for (d = 0, L = L[0], M++; (O > l || d) && M--; l++) y = d * f + (R[l] || 0), N[l] = y / L | 0, d = y % L | 0; g = d || O > l } else { for (d = f / (L[0] + 1) | 0, d > 1 && (L = n(L, d, f), R = n(R, d, f), A = L.length, O = R.length), q = A, b = R.slice(0, A), x = b.length; A > x;) b[x++] = 0; D = L.slice(), D.unshift(0), F = L[0], L[1] >= f / 2 && ++F; do d = 0, a = e(L, b, A, x), 0 > a ? (E = b[0], A != x && (E = E * f + (b[1] || 0)), d = E / F | 0, d > 1 ? (d >= f && (d = f - 1), w = n(L, d, f), m = w.length, x = b.length, a = e(w, b, m, x), 1 == a && (d--, i(w, m > A ? D : L, m, f))) : (0 == d && (a = d = 1), w = L.slice()), m = w.length, x > m && w.unshift(0), i(b, w, x, f), -1 == a && (x = b.length, a = e(L, b, A, x), 1 > a && (d++, i(b, x > A ? D : L, x, f))), x = b.length) : 0 === a && (d++, b = [0]), N[l++] = d, a && b[0] ? b[x++] = R[q] || 0 : (b = [R[q]], x = 1); while ((q++ < O || void 0 !== b[0]) && M--); g = void 0 !== b[0] } N[0] || N.shift() } if (1 == p) v.e = h, hn = g; else { for (l = 1, d = N[0]; d >= 10; d /= 10) l++; v.e = l + h * p - 1, o(v, c ? s + v.e + 1 : s, u, g) } return v } }(); Nn = I(Nn), mn = new Nn(mn), vn = new Nn(vn), Bridge.$Decimal = Nn, \"function\" == typeof define && define.amd ? define(function () { return Nn }) : \"undefined\" != typeof module && module.exports ? module.exports = Nn[\"default\"] = Nn.Decimal = Nn : (n || (n = \"undefined\" != typeof self && self && self.self == self ? self : Function(\"return this\")()), ln = n.Decimal, Nn.noConflict = function () { return n.Decimal = ln, Nn }/*, n.Decimal = Nn*/) }(Bridge.global);\n\n    System.Decimal = function (v, provider, T) {\n        if (this.constructor !== System.Decimal) {\n            return new System.Decimal(v, provider, T);\n        }\n\n        if (v == null) {\n            v = 0;\n        }\n\n        if (typeof v === \"string\") {\n            provider = provider || System.Globalization.CultureInfo.getCurrentCulture();\n\n            var nfInfo = provider && provider.getFormat(System.Globalization.NumberFormatInfo);\n\n            if (nfInfo && nfInfo.numberDecimalSeparator !== \".\") {\n                v = v.replace(nfInfo.numberDecimalSeparator, \".\");\n            }\n\n            if (!/^\\s*[+-]?(\\d+|\\d+.|\\d*\\.\\d+)((e|E)[+-]?\\d+)?\\s*$/.test(v)) {\n                throw new System.FormatException();\n            }\n\n            v = v.replace(/\\s/g, \"\");\n        }\n\n        if (T && T.precision && typeof v === \"number\") {\n            var i = Bridge.Int.trunc(v);\n            var length = (i + '').length;\n            var p = T.precision - length;\n            if (p < 0) {\n                p = 0;\n            }\n            v = v.toFixed(p);\n        }\n\n        this.value = System.Decimal.getValue(v);\n    }\n\n    System.Decimal.$number = true;\n    System.Decimal.$$name = \"System.Decimal\";\n    System.Decimal.prototype.$$name = \"System.Decimal\";\n    System.Decimal.$kind = \"struct\";\n    System.Decimal.prototype.$kind = \"struct\";\n    System.Decimal.$$inherits = [];\n    Bridge.Class.addExtend(System.Decimal, [System.IComparable, System.IFormattable, System.IComparable$1(System.Decimal), System.IEquatable$1(System.Decimal)]);\n\n    System.Decimal.$is = function (instance) {\n        return instance instanceof System.Decimal;\n    };\n\n    System.Decimal.getDefaultValue = function () {\n        return new System.Decimal(0);\n    };\n\n    System.Decimal.getValue = function (d) {\n        if (!Bridge.hasValue(d)) {\n            return this.getDefaultValue();\n        }\n\n        if (d instanceof System.Decimal) {\n            return d.value;\n        }\n\n        if (d instanceof System.Int64 || d instanceof System.UInt64) {\n            return new Bridge.$Decimal(d.toString());\n        }\n\n        return new Bridge.$Decimal(d);\n    };\n\n    System.Decimal.create = function (d) {\n        if (!Bridge.hasValue(d)) {\n            return null;\n        }\n\n        if (d instanceof System.Decimal) {\n            return d;\n        }\n\n        return new System.Decimal(d);\n    };\n\n    System.Decimal.lift = function (d) {\n        return d == null ? null : System.Decimal.create(d);\n    };\n\n    System.Decimal.prototype.toString = function (format, provider) {\n        return Bridge.Int.format(this, format || \"G\", provider);\n    };\n\n    System.Decimal.prototype.toFloat = function () {\n        return this.value.toNumber();\n    };\n\n    System.Decimal.prototype.toJSON = function () {\n        return this.value.toNumber();\n    };\n\n    System.Decimal.prototype.format = function (format, provider) {\n        return Bridge.Int.format(this, format, provider);\n    };\n\n    System.Decimal.prototype.decimalPlaces = function () {\n        return this.value.decimalPlaces();\n    };\n\n    System.Decimal.prototype.dividedToIntegerBy = function (d) {\n        return new System.Decimal(this.value.dividedToIntegerBy(System.Decimal.getValue(d)));\n    };\n\n    System.Decimal.prototype.exponential = function () {\n        return new System.Decimal(this.value.exponential());\n    };\n\n    System.Decimal.prototype.abs = function () {\n        return new System.Decimal(this.value.abs());\n    };\n\n    System.Decimal.prototype.floor = function () {\n        return new System.Decimal(this.value.floor());\n    };\n\n    System.Decimal.prototype.ceil = function () {\n        return new System.Decimal(this.value.ceil());\n    };\n\n    System.Decimal.prototype.trunc = function () {\n        return new System.Decimal(this.value.trunc());\n    };\n\n    System.Decimal.round = function (obj, mode) {\n        obj = System.Decimal.create(obj);\n\n        var old = Bridge.$Decimal.rounding;\n\n        Bridge.$Decimal.rounding = mode;\n\n        var d = new System.Decimal(obj.value.round());\n\n        Bridge.$Decimal.rounding = old;\n\n        return d;\n    };\n\n    System.Decimal.toDecimalPlaces = function (obj, decimals, mode) {\n        obj = System.Decimal.create(obj);\n        var d = new System.Decimal(obj.value.toDecimalPlaces(decimals, mode));\n        return d;\n    };\n\n    System.Decimal.prototype.compareTo = function (another) {\n        return this.value.comparedTo(System.Decimal.getValue(another));\n    };\n\n    System.Decimal.prototype.add = function (another) {\n        return new System.Decimal(this.value.plus(System.Decimal.getValue(another)));\n    };\n\n    System.Decimal.prototype.sub = function (another) {\n        return new System.Decimal(this.value.minus(System.Decimal.getValue(another)));\n    };\n\n    System.Decimal.prototype.isZero = function () {\n        return this.value.isZero;\n    };\n\n    System.Decimal.prototype.mul = function (another) {\n        return new System.Decimal(this.value.times(System.Decimal.getValue(another)));\n    };\n\n    System.Decimal.prototype.div = function (another) {\n        return new System.Decimal(this.value.dividedBy(System.Decimal.getValue(another)));\n    };\n\n    System.Decimal.prototype.mod = function (another) {\n        return new System.Decimal(this.value.modulo(System.Decimal.getValue(another)));\n    };\n\n    System.Decimal.prototype.neg = function () {\n        return new System.Decimal(this.value.negated());\n    };\n\n    System.Decimal.prototype.inc = function () {\n        return new System.Decimal(this.value.plus(System.Decimal.getValue(1)));\n    };\n\n    System.Decimal.prototype.dec = function () {\n        return new System.Decimal(this.value.minus(System.Decimal.getValue(1)));\n    };\n\n    System.Decimal.prototype.sign = function () {\n        return this.value.isZero() ? 0 : (this.value.isNegative() ? -1 : 1);\n    };\n\n    System.Decimal.prototype.clone = function () {\n        return new System.Decimal(this);\n    };\n\n    System.Decimal.prototype.ne = function (v) {\n        return !!this.compareTo(v);\n    };\n\n    System.Decimal.prototype.lt = function (v) {\n        return this.compareTo(v) < 0;\n    };\n\n    System.Decimal.prototype.lte = function (v) {\n        return this.compareTo(v) <= 0;\n    };\n\n    System.Decimal.prototype.gt = function (v) {\n        return this.compareTo(v) > 0;\n    };\n\n    System.Decimal.prototype.gte = function (v) {\n        return this.compareTo(v) >= 0;\n    };\n\n    System.Decimal.prototype.equals = function (v) {\n        if (v instanceof System.Decimal) {\n            return !this.compareTo(v);\n        }\n\n        return false;\n    };\n\n    System.Decimal.prototype.equalsT = function (v) {\n        return !this.compareTo(v);\n    };\n\n    System.Decimal.prototype.getHashCode = function () {\n        var n = (this.sign() * 397 + this.value.e) | 0;\n\n        for (var i = 0; i < this.value.d.length; i++) {\n            n = (n * 397 + this.value.d[i]) | 0;\n        }\n\n        return n;\n    };\n\n    System.Decimal.toInt = function (v, tp) {\n        if (!v) {\n            return null;\n        }\n\n        if (tp) {\n            var str,\n                r;\n\n            if (tp === System.Int64) {\n                str = v.value.trunc().toString();\n                r = new System.Int64(str);\n\n                if (str !== r.value.toString()) {\n                    throw new System.OverflowException();\n                }\n\n                return r;\n            }\n\n            if (tp === System.UInt64) {\n                if (v.value.isNegative()) {\n                    throw new System.OverflowException();\n                }\n\n                str = v.value.trunc().toString();\n                r = new System.UInt64(str);\n\n                if (str !== r.value.toString()) {\n                    throw new System.OverflowException();\n                }\n\n                return r;\n            }\n\n            return Bridge.Int.check(Bridge.Int.trunc(v.value.toNumber()), tp);\n        }\n\n        var i = Bridge.Int.trunc(System.Decimal.getValue(v).toNumber());\n\n        if (!Bridge.Int.$is(i)) {\n            throw new System.OverflowException();\n        }\n\n        return i;\n    };\n\n    System.Decimal.tryParse = function (s, provider, v) {\n        try {\n            v.v = new System.Decimal(s, provider);\n\n            return true;\n        } catch (e) {\n            v.v = new System.Decimal(0);\n\n            return false;\n        }\n    };\n\n    System.Decimal.toFloat = function (v) {\n        if (!v) {\n            return null;\n        }\n\n        return System.Decimal.getValue(v).toNumber();\n    };\n\n    System.Decimal.setConfig = function (config) {\n        Bridge.$Decimal.config(config);\n    };\n\n    System.Decimal.min = function () {\n        var values = [];\n\n        for (var i = 0, len = arguments.length; i < len; i++) {\n            values.push(System.Decimal.getValue(arguments[i]));\n        }\n\n        return new System.Decimal(Bridge.$Decimal.min.apply(Bridge.$Decimal, values));\n    };\n\n    System.Decimal.max = function () {\n        var values = [];\n\n        for (var i = 0, len = arguments.length; i < len; i++) {\n            values.push(System.Decimal.getValue(arguments[i]));\n        }\n\n        return new System.Decimal(Bridge.$Decimal.max.apply(Bridge.$Decimal, values));\n    };\n\n    System.Decimal.random = function (dp) {\n        return new System.Decimal(Bridge.$Decimal.random(dp));\n    };\n\n    System.Decimal.exp = function (d) {\n        return new System.Decimal(System.Decimal.getValue(d).exp());\n    };\n\n    System.Decimal.exp = function (d) {\n        return new System.Decimal(System.Decimal.getValue(d).exp());\n    };\n\n    System.Decimal.ln = function (d) {\n        return new System.Decimal(System.Decimal.getValue(d).ln());\n    };\n\n    System.Decimal.log = function (d, logBase) {\n        return new System.Decimal(System.Decimal.getValue(d).log(logBase));\n    };\n\n    System.Decimal.pow = function (d, exponent) {\n        return new System.Decimal(System.Decimal.getValue(d).pow(exponent));\n    };\n\n    System.Decimal.sqrt = function (d) {\n        return new System.Decimal(System.Decimal.getValue(d).sqrt());\n    };\n\n    System.Decimal.prototype.isFinite = function () {\n        return this.value.isFinite();\n    };\n\n    System.Decimal.prototype.isInteger = function () {\n        return this.value.isInteger();\n    };\n\n    System.Decimal.prototype.isNaN = function () {\n        return this.value.isNaN();\n    };\n\n    System.Decimal.prototype.isNegative = function () {\n        return this.value.isNegative();\n    };\n\n    System.Decimal.prototype.isZero = function () {\n        return this.value.isZero();\n    };\n\n    System.Decimal.prototype.log = function (logBase) {\n        return new System.Decimal(this.value.log(logBase));\n    };\n\n    System.Decimal.prototype.ln = function () {\n        return new System.Decimal(this.value.ln());\n    };\n\n    System.Decimal.prototype.precision = function () {\n        return this.value.precision();\n    };\n\n    System.Decimal.prototype.round = function () {\n        var old = Bridge.$Decimal.rounding,\n            r;\n\n        Bridge.$Decimal.rounding = 6;\n        r = new System.Decimal(this.value.round());\n        Bridge.$Decimal.rounding = old;\n\n        return r;\n    };\n\n    System.Decimal.prototype.sqrt = function () {\n        return new System.Decimal(this.value.sqrt());\n    };\n\n    System.Decimal.prototype.toDecimalPlaces = function (dp, rm) {\n        return new System.Decimal(this.value.toDecimalPlaces(dp, rm));\n    };\n\n    System.Decimal.prototype.toExponential = function (dp, rm) {\n        return this.value.toExponential(dp, rm);\n    };\n\n    System.Decimal.prototype.toFixed = function (dp, rm) {\n        return this.value.toFixed(dp, rm);\n    };\n\n    System.Decimal.prototype.pow = function (n) {\n        return new System.Decimal(this.value.pow(n));\n    };\n\n    System.Decimal.prototype.toPrecision = function (dp, rm) {\n        return this.value.toPrecision(dp, rm);\n    };\n\n    System.Decimal.prototype.toSignificantDigits = function (dp, rm) {\n        return new System.Decimal(this.value.toSignificantDigits(dp, rm));\n    };\n\n    System.Decimal.prototype.valueOf = function () {\n        return this.value.valueOf();\n    };\n\n    System.Decimal.prototype._toFormat = function(dp, rm, f) {\n        var x = this.value;\n\n        if (!x.isFinite()) {\n            return x.toString();\n        }\n\n        var i,\n            isNeg = x.isNeg(),\n            groupSeparator = f.groupSeparator,\n            g1 = +f.groupSize,\n            g2 = +f.secondaryGroupSize,\n            arr = x.toFixed(dp, rm).split('.'),\n            intPart = arr[0],\n            fractionPart = arr[1],\n            intDigits = isNeg ? intPart.slice(1) : intPart,\n            len = intDigits.length;\n\n        if (g2) {\n            len -= (i = g1, g1 = g2, g2 = i);\n        }\n\n        if (g1 > 0 && len > 0) {\n            i = len % g1 || g1;\n            intPart = intDigits.substr(0, i);\n\n            for (; i < len; i += g1) {\n                intPart += groupSeparator + intDigits.substr(i, g1);\n            }\n\n            if (g2 > 0) {\n                intPart += groupSeparator + intDigits.slice(i);\n            }\n\n            if (isNeg) {\n                intPart = '-' + intPart;\n            }\n        }\n\n        return fractionPart\n            ? intPart + f.decimalSeparator + ((g2 = +f.fractionGroupSize)\n                ? fractionPart.replace(new RegExp('\\\\d{' + g2 + '}\\\\B', 'g'),\n                    '$&' + f.fractionGroupSeparator)\n                : fractionPart)\n            : intPart;\n    };\n\n    System.Decimal.prototype.toFormat = function (dp, rm, provider) {\n        var config = {\n                decimalSeparator : '.',\n                groupSeparator : ',',\n                groupSize : 3,\n                secondaryGroupSize : 0,\n                fractionGroupSeparator : '\\xA0',\n                fractionGroupSize : 0\n            },\n            d;\n\n        if (provider && !provider.getFormat) {\n            config = Bridge.merge(config, provider);\n            d = this._toFormat(dp, rm, config);\n        } else {\n            provider = provider || System.Globalization.CultureInfo.getCurrentCulture();\n\n            var nfInfo = provider && provider.getFormat(System.Globalization.NumberFormatInfo);\n\n            if (nfInfo) {\n                config.decimalSeparator = nfInfo.numberDecimalSeparator;\n                config.groupSeparator = nfInfo.numberGroupSeparator;\n                config.groupSize = nfInfo.numberGroupSizes[0];\n            }\n\n            d = this._toFormat(dp, rm, config);\n        }\n\n        return d;\n    };\n\n    System.Decimal.prototype.getBytes = function () {\n        var s = this.value.s,\n            e = this.value.e,\n            d = this.value.d,\n            bytes = System.Array.init(23, 0, System.Byte);\n\n        bytes[0] = s & 255;\n        bytes[1] = e;\n\n        if (d && d.length > 0) {\n            bytes[2] = d.length * 4;\n\n            for (var i = 0; i < d.length; i++) {\n                bytes[i*4 + 3] = d[i] & 255;\n                bytes[i*4 + 4] = (d[i] >> 8) & 255;\n                bytes[i*4 + 5] = (d[i] >> 16) & 255;\n                bytes[i*4 + 6] = (d[i] >> 24) & 255;\n            }            \n        }\n        else {\n            bytes[2] = 0;\n        }\n\n        return bytes;\n    };\n\n    System.Decimal.fromBytes = function (bytes) {\n        var value = new System.Decimal(0),\n            s = Bridge.Int.sxb(bytes[0] & 255),\n            e = bytes[1],\n            ln = bytes[2],\n            d = [];\n\n        value.value.s = s;\n        value.value.e = e;\n\n        if (ln > 0) {\n            for (var i = 3; i < (ln + 3);) {\n                d.push(bytes[i] | bytes[i + 1] << 8 | bytes[i + 2] << 16 | bytes[i + 3] << 24);\n                i = i + 4;\n            }\n        }\n        \n        value.value.d = d;\n\n        return value;\n    };\n\n    Bridge.$Decimal.config({ precision: 29 });\n\n    System.Decimal.Zero = System.Decimal(0);\n    System.Decimal.One = System.Decimal(1);\n    System.Decimal.MinusOne = System.Decimal(-1);\n    System.Decimal.MinValue = System.Decimal(\"-79228162514264337593543950335\");\n    System.Decimal.MaxValue = System.Decimal(\"79228162514264337593543950335\");\n    System.Decimal.precision = 29;\n\n    // @source dayOfWeek.js\n\n    Bridge.define(\"System.DayOfWeek\", {\n        $kind: \"enum\",\n        statics: {\n            fields: {\n                Sunday: 0,\n                Monday: 1,\n                Tuesday: 2,\n                Wednesday: 3,\n                Thursday: 4,\n                Friday: 5,\n                Saturday: 6\n            }\n        }\n    });\n\n    // @source dateTimeKind.js\n\n    Bridge.define(\"System.DateTimeKind\", {\n        $kind: \"enum\",\n        statics: {\n            fields: {\n                Unspecified: 0,\n                Utc: 1,\n                Local: 2\n            }\n        }\n    });\n\n    // @source Date.js\n\n    Bridge.define(\"System.DateTime\", {\n        inherits: function () { return [System.IComparable, System.IComparable$1(System.DateTime), System.IEquatable$1(System.DateTime), System.IFormattable]; },\n        $kind: \"struct\",\n        fields: {\n            kind: 0\n        },\n        methods: {\n            $clone: function (to) { return this; }\n        },\n        statics: {\n            // Difference in Ticks from 1-Jan-0001 to 1-Jan-1970 at UTC\n            minOffset: System.Int64(\"621355968000000000\"),\n            maxTicks: System.Int64(\"3155378975999999999\"),\n\n            $is: function (instance) {\n                return Bridge.isDate(instance);\n            },\n\n            // UTC Min Value\n            getMinValue: function () {\n                return System.DateTime.create$2(0);\n            },\n\n            // UTC Max Value\n            getMaxValue: function () {\n                var d = System.DateTime.create$2(System.DateTime.maxTicks);\n                d.ticks = System.DateTime.maxTicks;\n\n                return d;\n            },\n\n            // Get the number of ticks since 0001-01-01T00:00:00.0000000 UTC\n            getTicks: function (d) {\n                d.kind = (d.kind !== undefined) ? d.kind : 0\n                d.ticks = (d.ticks !== undefined) ? d.ticks : System.Int64(d.getTime() - d.getTimezoneOffset() * 60 * 1000).mul(10000).add(System.DateTime.minOffset);\n\n                return d.ticks;\n            },\n\n            toLocalTime: function (d) {\n                var d1,\n                    ticks = System.DateTime.getTicks(d);\n\n                if (d.kind !== 2) {\n                    ticks = d.ticks.sub(System.Int64(d.getTimezoneOffset() * 60 * 1000).mul(10000));\n                }\n\n                d1 = System.DateTime.create$2(ticks, 2);\n\n                // Check if Ticks are out of range\n                if (ticks.gt(System.DateTime.maxTicks) || ticks.lt(0)) {\n                    ticks = ticks.add(System.Int64(d1.getTimezoneOffset() * 60 * 1000).mul(10000));\n                    d1 = System.DateTime.create$2(ticks, 2);\n                }\n\n                return d1;\n            },\n\n            toUniversalTime: function (d) {\n                var ticks = System.DateTime.getTicks(d),\n                    d1;\n\n                // Assuming d is Local time, so adjust to UTC\n                if (d.kind !== 1) {\n                    ticks = ticks.add(System.Int64(d.getTimezoneOffset() * 60 * 1000).mul(10000));\n                }\n\n                d1 = System.DateTime.create$2(ticks, 1);\n\n                // Check if Ticks are out of range\n                if (ticks.gt(System.DateTime.maxTicks) || ticks.lt(0)) {\n                    ticks = ticks.sub(System.Int64(d1.getTimezoneOffset() * 60 * 1000).mul(10000));\n                    d1 = System.DateTime.create$2(ticks, 1);\n                }\n\n                return d1;\n            },\n\n            getDefaultValue: function () {\n                return System.DateTime.getMinValue();\n            },\n\n            create: function (year, month, day, hour, minute, second, millisecond, kind) {\n                year = (year !== undefined) ? year : new Date().getFullYear();\n                month = (month !== undefined) ? month : new Date().getMonth() + 1;\n                day = (day !== undefined) ? day : 1;\n                hour = (hour !== undefined) ? hour : 0;\n                minute = (minute !== undefined) ? minute : 0;\n                second = (second !== undefined) ? second : 0;\n                millisecond = (millisecond !== undefined) ? millisecond : 0;\n                kind = (kind !== undefined) ? kind : 0;\n\n                var d,\n                    ticks;\n\n                d = new Date(year, month - 1, day, hour, minute, second, millisecond);\n                d.setFullYear(year);\n\n                ticks = System.DateTime.getTicks(d);\n\n                if (kind === 1) {\n                    d = new Date(d.getTime() - d.getTimezoneOffset() * 60 * 1000)\n                }\n\n                d.kind = kind;\n                d.ticks = ticks;\n\n                return d;\n            },\n\n            create$1: function (date, kind) {\n                kind = (kind !== undefined) ? kind : 0;\n\n                var d;\n\n                if (kind === 1) {\n                    d = System.DateTime.create(date.getUTCFullYear(), date.getUTCMonth() + 1, date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds(), kind);\n                } else {\n                    d = System.DateTime.create(date.getFullYear(), date.getMonth() + 1, date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds(), kind);\n                }\n\n                d.ticks = System.DateTime.getTicks(d)\n\n                return d;\n            },\n\n            create$2: function (ticks, kind) {\n                ticks = System.Int64.is64Bit(ticks) ? ticks : System.Int64(ticks);\n                kind = (kind !== undefined) ? kind : 0\n\n                var d = new Date(ticks.sub(System.DateTime.minOffset).div(10000).toNumber());\n\n                if (kind !== 1) {\n                    d = System.DateTime.addMilliseconds(d, d.getTimezoneOffset() * 60 * 1000);\n                }\n\n                d.ticks = ticks;\n                d.kind = kind;\n\n                return d;\n            },\n\n            getToday: function () {\n                var d = new Date();\n\n                return System.DateTime.create(d.getFullYear(), d.getMonth() + 1, d.getDate(), 0, 0, 0, 0, 2);\n            },\n\n            getNow: function () {\n                return System.DateTime.create$1(new Date(), 2);\n            },\n\n            getUtcNow: function () {\n                return System.DateTime.create$1(new Date(), 1);\n            },\n\n            getTimeOfDay: function (d) {\n                var d1 = System.DateTime.getDate(d);\n\n                return new System.TimeSpan((d - d1) * 10000);\n            },\n\n            getKind: function (d) {\n                d.kind = (d.kind !== undefined) ? d.kind : 0\n\n                return d.kind;\n            },\n\n            specifyKind: function (d, kind) {\n                return System.DateTime.create$2(System.DateTime.getTicks(d), kind);\n            },\n\n            isUseGenitiveForm: function (format, index, tokenLen, patternToMatch) {\n                var i,\n                    repeat = 0;\n\n                for (i = index - 1; i >= 0 && format[i] !== patternToMatch; i--) { }\n\n                if (i >= 0) {\n                    while (--i >= 0 && format[i] === patternToMatch) {\n                        repeat++;\n                    }\n\n                    if (repeat <= 1) {\n                        return true;\n                    }\n                }\n\n                for (i = index + tokenLen; i < format.length && format[i] !== patternToMatch; i++) { }\n\n                if (i < format.length) {\n                    repeat = 0;\n\n                    while (++i < format.length && format[i] === patternToMatch) {\n                        repeat++;\n                    }\n\n                    if (repeat <= 1) {\n                        return true;\n                    }\n                }\n\n                return false;\n            },\n\n            format: function (d, f, p) {\n                var me = this,\n                    kind = d.kind || 0,\n                    isUtc = (kind === 1),\n                    df = (p || System.Globalization.CultureInfo.getCurrentCulture()).getFormat(System.Globalization.DateTimeFormatInfo),\n                    year = isUtc ? d.getUTCFullYear() : d.getFullYear(),\n                    month = isUtc ? d.getUTCMonth() : d.getMonth(),\n                    dayOfMonth = isUtc ? d.getUTCDate() : d.getDate(),\n                    dayOfWeek = isUtc ? d.getUTCDay() : d.getDay(),\n                    hour = isUtc ? d.getUTCHours() : d.getHours(),\n                    minute = isUtc ? d.getUTCMinutes() : d.getMinutes(),\n                    second = isUtc ? d.getUTCSeconds() : d.getSeconds(),\n                    millisecond = isUtc ? d.getUTCMilliseconds() : d.getMilliseconds(),\n                    timezoneOffset = d.getTimezoneOffset(),\n                    formats;\n\n                f = f || \"G\";\n\n                if (f.length === 1) {\n                    formats = df.getAllDateTimePatterns(f, true);\n                    f = formats ? formats[0] : f;\n                } else if (f.length === 2 && f.charAt(0) === \"%\") {\n                    f = f.charAt(1);\n                }\n\n                var removeDot = false;\n\n                f = f.replace(/(\\\\.|'[^']*'|\"[^\"]*\"|d{1,4}|M{1,4}|yyyy|yy|y|HH?|hh?|mm?|ss?|tt?|u|f{1,7}|F{1,7}|K|z{1,3}|\\:|\\/)/g,\n                    function (match, group, index) {\n                        var part = match;\n\n                        switch (match) {\n                            case \"dddd\":\n                                part = df.dayNames[dayOfWeek];\n\n                                break;\n                            case \"ddd\":\n                                part = df.abbreviatedDayNames[dayOfWeek];\n\n                                break;\n                            case \"dd\":\n                                part = dayOfMonth < 10 ? \"0\" + dayOfMonth : dayOfMonth;\n\n                                break;\n                            case \"d\":\n                                part = dayOfMonth;\n\n                                break;\n                            case \"MMMM\":\n                                if (me.isUseGenitiveForm(f, index, 4, \"d\")) {\n                                    part = df.monthGenitiveNames[month];\n                                } else {\n                                    part = df.monthNames[month];\n                                }\n\n                                break;\n                            case \"MMM\":\n                                if (me.isUseGenitiveForm(f, index, 3, \"d\")) {\n                                    part = df.abbreviatedMonthGenitiveNames[month];\n                                } else {\n                                    part = df.abbreviatedMonthNames[month];\n                                }\n\n                                break;\n                            case \"MM\":\n                                part = (month + 1) < 10 ? \"0\" + (month + 1) : (month + 1);\n\n                                break;\n                            case \"M\":\n                                part = month + 1;\n\n                                break;\n                            case \"yyyy\":\n                                part = (\"0000\" + year).substring(year.toString().length);\n\n                                break;\n                            case \"yy\":\n                                part = (year % 100).toString();\n\n                                if (part.length === 1) {\n                                    part = \"0\" + part;\n                                }\n\n                                break;\n                            case \"y\":\n                                part = year % 100;\n\n                                break;\n                            case \"h\":\n                            case \"hh\":\n                                part = hour % 12;\n\n                                if (!part) {\n                                    part = \"12\";\n                                } else if (match === \"hh\" && part.length === 1) {\n                                    part = \"0\" + part;\n                                }\n\n                                break;\n                            case \"HH\":\n                                part = hour.toString();\n\n                                if (part.length === 1) {\n                                    part = \"0\" + part;\n                                }\n\n                                break;\n                            case \"H\":\n                                part = hour;\n                                break;\n                            case \"mm\":\n                                part = minute.toString();\n\n                                if (part.length === 1) {\n                                    part = \"0\" + part;\n                                }\n\n                                break;\n                            case \"m\":\n                                part = minute;\n\n                                break;\n                            case \"ss\":\n                                part = second.toString();\n\n                                if (part.length === 1) {\n                                    part = \"0\" + part;\n                                }\n\n                                break;\n                            case \"s\":\n                                part = second;\n                                break;\n                            case \"t\":\n                            case \"tt\":\n                                part = (hour < 12) ? df.amDesignator : df.pmDesignator;\n\n                                if (match === \"t\") {\n                                    part = part.charAt(0);\n                                }\n\n                                break;\n                            case \"F\":\n                            case \"FF\":\n                            case \"FFF\":\n                            case \"FFFF\":\n                            case \"FFFFF\":\n                            case \"FFFFFF\":\n                            case \"FFFFFFF\":\n                                part = millisecond.toString();\n\n                                if (part.length < 3) {\n                                    part = Array(4 - part.length).join(\"0\") + part;\n                                }\n\n                                part = part.substr(0, match.length);\n\n                                var c = '0',\n                                    i = part.length - 1;\n\n                                for (; i >= 0 && part.charAt(i) === c; i--);\n                                part = part.substring(0, i + 1);\n\n                                removeDot = part.length == 0;\n\n                                break;\n                            case \"f\":\n                            case \"ff\":\n                            case \"fff\":\n                            case \"ffff\":\n                            case \"fffff\":\n                            case \"ffffff\":\n                            case \"fffffff\":\n                                part = millisecond.toString();\n\n                                if (part.length < 3) {\n                                    part = Array(4 - part.length).join(\"0\") + part;\n                                }\n\n                                var ln = match === \"u\" ? 7 : match.length;\n                                if (part.length < ln) {\n                                    part = part + Array(8 - part.length).join(\"0\");\n                                }\n\n                                part = part.substr(0, ln);\n\n                                break;\n                            case \"z\":\n                                part = timezoneOffset / 60;\n                                part = ((part >= 0) ? \"-\" : \"+\") + Math.floor(Math.abs(part));\n\n                                break;\n                            case \"K\":\n                            case \"zz\":\n                            case \"zzz\":\n                                if (kind === 0) {\n                                    part = \"\";\n                                } else if (kind === 1) {\n                                    part = \"Z\";\n                                } else {\n                                    part = timezoneOffset / 60;\n                                    part = ((part > 0) ? \"-\" : \"+\") + System.String.alignString(Math.floor(Math.abs(part)).toString(), 2, \"0\", 2);\n\n                                    if (match === \"zzz\" || match === \"K\") {\n                                        part += df.timeSeparator + System.String.alignString(Math.floor(Math.abs(timezoneOffset % 60)).toString(), 2, \"0\", 2);\n                                    }\n                                }\n\n                                break;\n                            case \":\":\n                                part = df.timeSeparator;\n\n                                break;\n                            case \"/\":\n                                part = df.dateSeparator;\n\n                                break;\n                            default:\n                                part = match.substr(1, match.length - 1 - (match.charAt(0) !== \"\\\\\"));\n\n                                break;\n                        }\n\n                        return part;\n                    });\n\n                if (removeDot) {\n                    if (System.String.endsWith(f, \".\")) {\n                        f = f.substring(0, f.length - 1);\n                    } else if (System.String.endsWith(f, \".Z\")) {\n                        f = f.substring(0, f.length - 2) + \"Z\";\n                    } else if (kind === 2 && f.match(/\\.([+-])/g) !== null) {\n                        f = f.replace(/\\.([+-])/g, '$1');\n                    }\n                }\n\n                return f;\n            },\n\n            parse: function (value, provider, utc, silent) {\n                var d = this.parseExact(value, null, provider, utc, true);\n\n                if (d !== null) {\n                    return d;\n                }\n\n                d = Date.parse(value);\n\n                if (!isNaN(d)) {\n                    return new Date(d);\n                } else if (!silent) {\n                    throw new System.FormatException(\"String does not contain a valid string representation of a date and time.\");\n                }\n            },\n\n            parseExact: function (str, format, provider, utc, silent) {\n                if (!format) {\n                    format = [\"G\", \"g\", \"F\", \"f\", \"D\", \"d\", \"R\", \"r\", \"s\", \"S\", \"U\", \"u\", \"O\", \"o\", \"Y\", \"y\", \"M\", \"m\", \"T\", \"t\"];\n                }\n\n                if (Bridge.isArray(format)) {\n                    var j = 0,\n                        d;\n\n                    for (j; j < format.length; j++) {\n                        d = System.DateTime.parseExact(str, format[j], provider, utc, true);\n\n                        if (d != null) {\n                            return d;\n                        }\n                    }\n\n                    if (silent) {\n                        return null;\n                    }\n\n                    throw new System.FormatException(\"String does not contain a valid string representation of a date and time.\");\n                }\n\n                var now = new Date(),\n                    df = (provider || System.Globalization.CultureInfo.getCurrentCulture()).getFormat(System.Globalization.DateTimeFormatInfo),\n                    am = df.amDesignator,\n                    pm = df.pmDesignator,\n                    idx = 0,\n                    index = 0,\n                    i = 0,\n                    c,\n                    token,\n                    year = now.getFullYear(),\n                    month = now.getMonth() + 1,\n                    date = now.getDate(),\n                    hh = 0,\n                    mm = 0,\n                    ss = 0,\n                    ff = 0,\n                    tt = \"\",\n                    zzh = 0,\n                    zzm = 0,\n                    zzi,\n                    sign,\n                    neg,\n                    names,\n                    name,\n                    invalid = false,\n                    inQuotes = false,\n                    tokenMatched,\n                    formats,\n                    kind = 0,\n                    adjust = false,\n                    offset = 0;\n\n                if (str == null) {\n                    throw new System.ArgumentNullException(\"str\");\n                }\n\n                format = format || \"G\";\n\n                if (format.length === 1) {\n                    formats = df.getAllDateTimePatterns(format, true);\n                    format = formats ? formats[0] : format;\n                } else if (format.length === 2 && format.charAt(0) === \"%\") {\n                    format = format.charAt(1);\n                }\n\n                while (index < format.length) {\n                    c = format.charAt(index);\n                    token = \"\";\n\n                    if (inQuotes === \"\\\\\") {\n                        token += c;\n                        index++;\n                    } else {\n                        var nextChar = format.charAt(index + 1);\n                        if (c === '.' && str.charAt(idx) !== c && (nextChar === 'F' || nextChar === 'f')) {\n                            index++;\n                            c = nextChar;\n                        }\n\n                        while ((format.charAt(index) === c) && (index < format.length)) {\n                            token += c;\n                            index++;\n                        }\n                    }\n\n                    tokenMatched = true;\n\n                    if (!inQuotes) {\n                        if (token === \"yyyy\" || token === \"yy\" || token === \"y\") {\n                            if (token === \"yyyy\") {\n                                year = this.subparseInt(str, idx, 4, 4);\n                            } else if (token === \"yy\") {\n                                year = this.subparseInt(str, idx, 2, 2);\n                            } else if (token === \"y\") {\n                                year = this.subparseInt(str, idx, 2, 4);\n                            }\n\n                            if (year == null) {\n                                invalid = true;\n                                break;\n                            }\n\n                            idx += year.length;\n\n                            if (year.length === 2) {\n                                year = ~~year;\n                                year = (year > 30 ? 1900 : 2000) + year;\n                            }\n                        } else if (token === \"MMM\" || token === \"MMMM\") {\n                            month = 0;\n\n                            if (token === \"MMM\") {\n                                if (this.isUseGenitiveForm(format, index, 3, \"d\")) {\n                                    names = df.abbreviatedMonthGenitiveNames;\n                                } else {\n                                    names = df.abbreviatedMonthNames;\n                                }\n                            } else {\n                                if (this.isUseGenitiveForm(format, index, 4, \"d\")) {\n                                    names = df.monthGenitiveNames;\n                                } else {\n                                    names = df.monthNames;\n                                }\n                            }\n\n                            for (i = 0; i < names.length; i++) {\n                                name = names[i];\n\n                                if (str.substring(idx, idx + name.length).toLowerCase() === name.toLowerCase()) {\n                                    month = (i % 12) + 1;\n                                    idx += name.length;\n\n                                    break;\n                                }\n                            }\n\n                            if ((month < 1) || (month > 12)) {\n                                invalid = true;\n\n                                break;\n                            }\n                        } else if (token === \"MM\" || token === \"M\") {\n                            month = this.subparseInt(str, idx, token.length, 2);\n\n                            if (month == null || month < 1 || month > 12) {\n                                invalid = true;\n\n                                break;\n                            }\n\n                            idx += month.length;\n                        } else if (token === \"dddd\" || token === \"ddd\") {\n                            names = token === \"ddd\" ? df.abbreviatedDayNames : df.dayNames;\n\n                            for (i = 0; i < names.length; i++) {\n                                name = names[i];\n\n                                if (str.substring(idx, idx + name.length).toLowerCase() === name.toLowerCase()) {\n                                    idx += name.length;\n\n                                    break;\n                                }\n                            }\n                        } else if (token === \"dd\" || token === \"d\") {\n                            date = this.subparseInt(str, idx, token.length, 2);\n\n                            if (date == null || date < 1 || date > 31) {\n                                invalid = true;\n\n                                break;\n                            }\n\n                            idx += date.length;\n                        } else if (token === \"hh\" || token === \"h\") {\n                            hh = this.subparseInt(str, idx, token.length, 2);\n\n                            if (hh == null || hh < 1 || hh > 12) {\n                                invalid = true;\n\n                                break;\n                            }\n\n                            idx += hh.length;\n                        } else if (token === \"HH\" || token === \"H\") {\n                            hh = this.subparseInt(str, idx, token.length, 2);\n\n                            if (hh == null || hh < 0 || hh > 23) {\n                                invalid = true;\n\n                                break;\n                            }\n\n                            idx += hh.length;\n                        } else if (token === \"mm\" || token === \"m\") {\n                            mm = this.subparseInt(str, idx, token.length, 2);\n\n                            if (mm == null || mm < 0 || mm > 59) {\n                                return null;\n                            }\n\n                            idx += mm.length;\n                        } else if (token === \"ss\" || token === \"s\") {\n                            ss = this.subparseInt(str, idx, token.length, 2);\n\n                            if (ss == null || ss < 0 || ss > 59) {\n                                invalid = true;\n\n                                break;\n                            }\n\n                            idx += ss.length;\n                        } else if (token === \"u\") {\n                            ff = this.subparseInt(str, idx, 1, 7);\n\n                            if (ff == null) {\n                                invalid = true;\n\n                                break;\n                            }\n\n                            idx += ff.length;\n\n                            if (ff.length > 3) {\n                                ff = ff.substring(0, 3);\n                            }\n                        } else if (token.match(/f{1,7}/) !== null) {\n                            ff = this.subparseInt(str, idx, token.length, 7);\n\n                            if (ff == null) {\n                                invalid = true;\n\n                                break;\n                            }\n\n                            idx += ff.length;\n\n                            if (ff.length > 3) {\n                                ff = ff.substring(0, 3);\n                            }\n                        } else if (token.match(/F{1,7}/) !== null) {\n                            ff = this.subparseInt(str, idx, 0, 7);\n\n                            if (ff !== null) {\n                                idx += ff.length;\n\n                                if (ff.length > 3) {\n                                    ff = ff.substring(0, 3);\n                                }\n                            }\n                        } else if (token === \"t\") {\n                            if (str.substring(idx, idx + 1).toLowerCase() === am.charAt(0).toLowerCase()) {\n                                tt = am;\n                            } else if (str.substring(idx, idx + 1).toLowerCase() === pm.charAt(0).toLowerCase()) {\n                                tt = pm;\n                            } else {\n                                invalid = true;\n\n                                break;\n                            }\n\n                            idx += 1;\n                        } else if (token === \"tt\") {\n                            if (str.substring(idx, idx + 2).toLowerCase() === am.toLowerCase()) {\n                                tt = am;\n                            } else if (str.substring(idx, idx + 2).toLowerCase() === pm.toLowerCase()) {\n                                tt = pm;\n                            } else {\n                                invalid = true;\n\n                                break;\n                            }\n\n                            idx += 2;\n                        } else if (token === \"z\" || token === \"zz\") {\n                            sign = str.charAt(idx);\n\n                            if (sign === \"-\") {\n                                neg = true;\n                            } else if (sign === \"+\") {\n                                neg = false;\n                            } else {\n                                invalid = true;\n\n                                break;\n                            }\n\n                            idx++;\n\n                            zzh = this.subparseInt(str, idx, 1, 2);\n\n                            if (zzh == null || zzh > 14) {\n                                invalid = true;\n\n                                break;\n                            }\n\n                            idx += zzh.length;\n\n                            offset = zzh * 60 * 60 * 1000;\n\n                            if (neg) {\n                                offset = -offset;\n                            }\n                        } else if (token === \"Z\") {\n                            var ch = str.substring(idx, idx + 1);\n                            if (ch === \"Z\" || ch === \"z\") {\n                                kind = 2;\n                                adjust = true;\n                                idx += 1;\n                            }\n                            else {\n                                invalid = true;\n                            }\n\n                            break;\n\n                        } else if (token === \"zzz\" || token === \"K\") {\n                            if (str.substring(idx, idx + 1) === \"Z\") {\n                                kind = 2;\n                                adjust = true;\n                                idx += 1;\n\n                                break;\n                            }\n\n                            name = str.substring(idx, idx + 6);\n\n                            if (name === \"\") {\n                                kind = 0;\n\n                                break;\n                            }\n\n                            idx += name.length;\n\n                            if (name.length !== 6 && name.length !== 5) {\n                                invalid = true;\n\n                                break;\n                            }\n\n                            sign = name.charAt(0);\n\n                            if (sign === \"-\") {\n                                neg = true;\n                            } else if (sign === \"+\") {\n                                neg = false;\n                            } else {\n                                invalid = true;\n\n                                break;\n                            }\n\n                            zzi = 1;\n                            zzh = this.subparseInt(name, zzi, 1, name.length === 6 ? 2 : 1);\n\n                            if (zzh == null || zzh > 14) {\n                                invalid = true;\n\n                                break;\n                            }\n\n                            zzi += zzh.length;\n\n                            if (name.charAt(zzi) !== df.timeSeparator) {\n                                invalid = true;\n\n                                break;\n                            }\n\n                            zzi++;\n\n                            zzm = this.subparseInt(name, zzi, 1, 2);\n\n                            if (zzm == null || zzh > 59) {\n                                invalid = true;\n\n                                break;\n                            }\n\n                            offset = zzh * 60 * 60 * 1000 + zzm * 60 * 1000;\n\n                            if (neg) {\n                                offset = -offset;\n                            }\n\n                            kind = 2;\n                        } else {\n                            tokenMatched = false;\n                        }\n                    }\n\n                    if (inQuotes || !tokenMatched) {\n                        name = str.substring(idx, idx + token.length);\n\n                        if (!inQuotes && name === \":\" && (token === df.timeSeparator || token === \":\")) {\n\n                        } else if ((!inQuotes && ((token === \":\" && name !== df.timeSeparator) || (token === \"/\" && name !== df.dateSeparator))) || (name !== token && token !== \"'\" && token !== '\"' && token !== \"\\\\\")) {\n                            invalid = true;\n\n                            break;\n                        }\n\n                        if (inQuotes === \"\\\\\") {\n                            inQuotes = false;\n                        }\n\n                        if (token !== \"'\" && token !== '\"' && token !== \"\\\\\") {\n                            idx += token.length;\n                        } else {\n                            if (inQuotes === false) {\n                                inQuotes = token;\n                            } else {\n                                if (inQuotes !== token) {\n                                    invalid = true;\n                                    break;\n                                }\n\n                                inQuotes = false;\n                            }\n                        }\n                    }\n                }\n\n                if (inQuotes) {\n                    invalid = true;\n                }\n\n                if (!invalid) {\n                    if (idx !== str.length) {\n                        invalid = true;\n                    } else if (month === 2) {\n                        if (((year % 4 === 0) && (year % 100 !== 0)) || (year % 400 === 0)) {\n                            if (date > 29) {\n                                invalid = true;\n                            }\n                        } else if (date > 28) {\n                            invalid = true;\n                        }\n                    } else if ((month === 4) || (month === 6) || (month === 9) || (month === 11)) {\n                        if (date > 30) {\n                            invalid = true;\n                        }\n                    }\n                }\n\n                if (invalid) {\n                    if (silent) {\n                        return null;\n                    }\n\n                    throw new System.FormatException(\"String does not contain a valid string representation of a date and time.\");\n                }\n\n                if (tt) {\n                    if (hh < 12 && tt === pm) {\n                        hh = hh - 0 + 12;\n                    } else if (hh > 11 && tt === am) {\n                        hh -= 12;\n                    }\n                }\n\n                var d = System.DateTime.create(year, month, date, hh, mm, ss, ff, kind);\n\n                if (kind === 2) {\n                    if (adjust === true) {\n                        d = new Date(d.getTime() - d.getTimezoneOffset() * 60 * 1000);\n                        d.kind = kind;\n                    } else if (offset !== 0) {\n                        d = new Date(d.getTime() - d.getTimezoneOffset() * 60 * 1000);\n                        d = System.DateTime.addMilliseconds(d, -offset);\n                        d.kind = kind;\n                    }\n                }\n\n                return d;\n            },\n\n            subparseInt: function (str, index, min, max) {\n                var x,\n                    token;\n\n                for (x = max; x >= min; x--) {\n                    token = str.substring(index, index + x);\n\n                    if (token.length < min) {\n                        return null;\n                    }\n\n                    if (/^\\d+$/.test(token)) {\n                        return token;\n                    }\n                }\n\n                return null;\n            },\n\n            tryParse: function (value, provider, result, utc) {\n                result.v = this.parse(value, provider, utc, true);\n\n                if (result.v == null) {\n                    result.v = System.DateTime.getMinValue();\n\n                    return false;\n                }\n\n                return true;\n            },\n\n            tryParseExact: function (v, f, p, r, utc) {\n                r.v = this.parseExact(v, f, p, utc, true);\n\n                if (r.v == null) {\n                    r.v = System.DateTime.getMinValue();\n\n                    return false;\n                }\n\n                return true;\n            },\n\n            isDaylightSavingTime: function (d) {\n                var temp = System.DateTime.getToday();\n\n                temp.setMonth(0);\n                temp.setDate(1);\n\n                return temp.getTimezoneOffset() !== d.getTimezoneOffset();\n            },\n\n            dateAddSubTimespan: function (d, t, direction) {\n                var r = new Date(d.getTime());\n\n                r.setDate(r.getDate() + (direction * t.getDays()));\n                r.setHours(r.getHours() + (direction * t.getHours()));\n                r.setMinutes(r.getMinutes() + (direction * t.getMinutes()));\n                r.setSeconds(r.getSeconds() + (direction * t.getSeconds()));\n                r.setMilliseconds(r.getMilliseconds() + (direction * t.getMilliseconds()));\n\n                return r;\n            },\n\n            subdt: function (d, t) {\n                return Bridge.hasValue$1(d, t) ? this.dateAddSubTimespan(d, t, -1) : null;\n            },\n\n            adddt: function (d, t) {\n                return Bridge.hasValue$1(d, t) ? this.dateAddSubTimespan(d, t, 1) : null;\n            },\n\n            subdd: function (a, b) {\n                return Bridge.hasValue$1(a, b) ? (new System.TimeSpan((a - b) * 10000)) : null;\n            },\n\n            addYears: function (d, v) {\n                return System.DateTime.addMonths(d, v * 12);\n            },\n\n            addMonths: function (d, v) {\n                d.kind = (d.kind !== undefined) ? d.kind : 0\n\n                var d1 = new Date(d.getTime()),\n                    day = d1.getDate();\n\n                d1.setMonth(d1.getMonth() + v);\n\n                if (d1.getDate() != day) {\n                    d1.setDate(0);\n                }\n\n                d1.kind = d.kind;\n\n                return d1;\n            },\n\n            addDays: function (d, v) {\n                d.kind = (d.kind !== undefined) ? d.kind : 0\n\n                var d1 = new Date(d.getTime());\n\n                d1.setDate(d.getDate() + Math.floor(v));\n\n                d1.kind = d.kind;\n\n                return System.DateTime.addMilliseconds(d1, Math.round((v % 1) * 864e5));\n            },\n\n            addHours: function (d, v) {\n                return System.DateTime.addMilliseconds(d, Math.round(v * 36e5));\n            },\n\n            addMinutes: function (d, v) {\n                return System.DateTime.addMilliseconds(d, Math.round(v * 6e4));\n            },\n\n            addSeconds: function (d, v) {\n                return System.DateTime.addMilliseconds(d, Math.round(v * 1e3));\n            },\n\n            addMilliseconds: function (d, v) {\n                d.kind = (d.kind !== undefined) ? d.kind : 0\n\n                var d1 = new Date(d.getTime() + Math.round(v));\n\n                d1.kind = d.kind;\n\n                return d1;\n            },\n\n            addTicks: function (d, v) {\n                return System.DateTime.addMilliseconds(d, v / 10000);\n            },\n\n            add: function (d, value) {\n                d.kind = (d.kind !== undefined) ? d.kind : 0\n\n                var d1 = new Date(d.getTime() + value.ticks.div(10000).toNumber());\n\n                d1.kind = d.kind;\n\n                return d1;\n            },\n\n            subtract: function (d, value) {\n                d.kind = (d.kind !== undefined) ? d.kind : 0\n\n                var d1 = new Date(d.getTime() - value.ticks.div(10000).toNumber());\n\n                d1.kind = d.kind;\n\n                return d1;\n            },\n\n            getIsLeapYear: function (year) {\n                return new Date(year, 2, - 1).getDate() === 28;\n            },\n\n            getDaysInMonth: function (year, month) {\n                return new Date(year, month, - 1).getDate() + 1;\n            },\n\n            getDayOfYear: function (d) {\n                var ny = new Date(d.getTime());\n\n                ny.setMonth(0);\n                ny.setDate(1);\n                ny.setHours(0);\n                ny.setMinutes(0);\n                ny.setMilliseconds(0);\n\n                return Math.ceil((d - ny) / 864e5);\n            },\n\n            getDate: function (d) {\n                d.kind = (d.kind !== undefined) ? d.kind : 0\n\n                var d1 = new Date(d.getTime());\n                d1.setHours(0);\n                d1.setMinutes(0);\n                d1.setSeconds(0);\n                d1.setMilliseconds(0);\n                d1.kind = d.kind;\n\n                return d1;\n            },\n\n            getDayOfWeek: function (d) {\n                return (System.DateTime.getKind(d) === 1) ? d.getUTCDay() : d.getDay();\n            },\n\n            getYear: function (d) {\n                return (System.DateTime.getKind(d) === 1) ? d.getUTCFullYear() : d.getFullYear();\n            },\n\n            getMonth: function (d) {\n                return ((System.DateTime.getKind(d) === 1) ? d.getUTCMonth() : d.getMonth()) + 1;\n            },\n\n            getDay: function (d) {\n                return (System.DateTime.getKind(d) === 1) ? d.getUTCDate() : d.getDate();\n            },\n\n            getHour: function (d) {\n                return (System.DateTime.getKind(d) === 1) ? d.getUTCHours() : d.getHours();\n            },\n\n            getMinute: function (d) {\n                return (System.DateTime.getKind(d) === 1) ? d.getUTCMinutes() : d.getMinutes();\n            },\n\n            getSecond: function (d) {\n                return (System.DateTime.getKind(d) === 1) ? d.getUTCSeconds() : d.getSeconds();\n            },\n\n            getMillisecond: function (d) {\n                return (System.DateTime.getKind(d) === 1) ? d.getUTCMilliseconds() : d.getMilliseconds();\n            },\n\n            gt: function (a, b) {\n                return (System.DateTime.$is(a) && System.DateTime.$is(b)) ? (System.DateTime.getTicks(a) > System.DateTime.getTicks(b)) : false;\n            },\n\n            gte: function (a, b) {\n                return (System.DateTime.$is(a) && System.DateTime.$is(b)) ? (System.DateTime.getTicks(a) >= System.DateTime.getTicks(b)) : false;\n            },\n\n            lt: function (a, b) {\n                return (System.DateTime.$is(a) && System.DateTime.$is(b)) ? (System.DateTime.getTicks(a) < System.DateTime.getTicks(b)) : false;\n            },\n\n            lte: function (a, b) {\n                return (System.DateTime.$is(a) && System.DateTime.$is(b)) ? (System.DateTime.getTicks(a) <= System.DateTime.getTicks(b)) : false;\n            }\n        }\n    });\n    // @source TimeSpan.js\n\n    Bridge.define(\"System.TimeSpan\", {\n        inherits: [System.IComparable],\n\n        config: {\n            alias: [\n                \"compareTo\", [\"System$IComparable$compareTo\", \"System$IComparable$1$compareTo\", \"System$IComparable$1System$TimeSpan$compareTo\"]\n            ]\n        },\n\n        $kind: \"struct\",\n        statics: {\n            fromDays: function (value) {\n                return new System.TimeSpan(value * 864e9);\n            },\n\n            fromHours: function (value) {\n                return new System.TimeSpan(value * 36e9);\n            },\n\n            fromMilliseconds: function (value) {\n                return new System.TimeSpan(value * 1e4);\n            },\n\n            fromMinutes: function (value) {\n                return new System.TimeSpan(value * 6e8);\n            },\n\n            fromSeconds: function (value) {\n                return new System.TimeSpan(value * 1e7);\n            },\n\n            fromTicks: function (value) {\n                return new System.TimeSpan(value);\n            },\n\n            ctor: function () {\n                this.zero = new System.TimeSpan(System.Int64.Zero);\n                this.maxValue = new System.TimeSpan(System.Int64.MaxValue);\n                this.minValue = new System.TimeSpan(System.Int64.MinValue);\n            },\n\n            getDefaultValue: function () {\n                return new System.TimeSpan(System.Int64.Zero);\n            },\n\n            neg: function (t) {\n                return Bridge.hasValue(t) ? (new System.TimeSpan(t.ticks.neg())) : null;\n            },\n\n            sub: function (t1, t2) {\n                return Bridge.hasValue$1(t1, t2) ? (new System.TimeSpan(t1.ticks.sub(t2.ticks))) : null;\n            },\n\n            eq: function (t1, t2) {\n                return Bridge.hasValue$1(t1, t2) ? (t1.ticks.eq(t2.ticks)) : null;\n            },\n\n            neq: function (t1, t2) {\n                return Bridge.hasValue$1(t1, t2) ? (t1.ticks.ne(t2.ticks)) : null;\n            },\n\n            plus: function (t) {\n                return Bridge.hasValue(t) ? (new System.TimeSpan(t.ticks)) : null;\n            },\n\n            add: function (t1, t2) {\n                return Bridge.hasValue$1(t1, t2) ? (new System.TimeSpan(t1.ticks.add(t2.ticks))) : null;\n            },\n\n            gt: function (a, b) {\n                return Bridge.hasValue$1(a, b) ? (a.ticks.gt(b.ticks)) : false;\n            },\n\n            gte: function (a, b) {\n                return Bridge.hasValue$1(a, b) ? (a.ticks.gte(b.ticks)) : false;\n            },\n\n            lt: function (a, b) {\n                return Bridge.hasValue$1(a, b) ? (a.ticks.lt(b.ticks)) : false;\n            },\n\n            lte: function (a, b) {\n                return Bridge.hasValue$1(a, b) ? (a.ticks.lte(b.ticks)) : false;\n            }\n        },\n\n        ctor: function () {\n            this.$initialize();\n            this.ticks = System.Int64.Zero;\n\n            if (arguments.length === 1) {\n                this.ticks = arguments[0] instanceof System.Int64 ? arguments[0] : new System.Int64(arguments[0]);\n            } else if (arguments.length === 3) {\n                this.ticks = new System.Int64(arguments[0]).mul(60).add(arguments[1]).mul(60).add(arguments[2]).mul(1e7);\n            } else if (arguments.length === 4) {\n                this.ticks = new System.Int64(arguments[0]).mul(24).add(arguments[1]).mul(60).add(arguments[2]).mul(60).add(arguments[3]).mul(1e7);\n            } else if (arguments.length === 5) {\n                this.ticks = new System.Int64(arguments[0]).mul(24).add(arguments[1]).mul(60).add(arguments[2]).mul(60).add(arguments[3]).mul(1e3).add(arguments[4]).mul(1e4);\n            }\n        },\n\n        getTicks: function () {\n            return this.ticks;\n        },\n\n        getDays: function () {\n            return this.ticks.div(864e9).toNumber();\n        },\n\n        getHours: function () {\n            return this.ticks.div(36e9).mod(24).toNumber();\n        },\n\n        getMilliseconds: function () {\n            return this.ticks.div(1e4).mod(1e3).toNumber();\n        },\n\n        getMinutes: function () {\n            return this.ticks.div(6e8).mod(60).toNumber();\n        },\n\n        getSeconds: function () {\n            return this.ticks.div(1e7).mod(60).toNumber();\n        },\n\n        getTotalDays: function () {\n            return this.ticks.toNumberDivided(864e9);\n        },\n\n        getTotalHours: function () {\n            return this.ticks.toNumberDivided(36e9);\n        },\n\n        getTotalMilliseconds: function () {\n            return this.ticks.toNumberDivided(1e4);\n        },\n\n        getTotalMinutes: function () {\n            return this.ticks.toNumberDivided(6e8);\n        },\n\n        getTotalSeconds: function () {\n            return this.ticks.toNumberDivided(1e7);\n        },\n\n        get12HourHour: function () {\n            return (this.getHours() > 12) ? this.getHours() - 12 : (this.getHours() === 0) ? 12 : this.getHours();\n        },\n\n        add: function (ts) {\n            return new System.TimeSpan(this.ticks.add(ts.ticks));\n        },\n\n        subtract: function (ts) {\n            return new System.TimeSpan(this.ticks.sub(ts.ticks));\n        },\n\n        duration: function () {\n            return new System.TimeSpan(this.ticks.abs());\n        },\n\n        negate: function () {\n            return new System.TimeSpan(this.ticks.neg());\n        },\n\n        compareTo: function (other) {\n            return this.ticks.compareTo(other.ticks);\n        },\n\n        equals: function (other) {\n            return other.ticks.eq(this.ticks);\n        },\n\n        equalsT: function (other) {\n            return other.ticks.eq(this.ticks);\n        },\n\n        format: function (formatStr, provider) {\n            return this.toString(formatStr, provider);\n        },\n\n        getHashCode: function () {\n            return this.ticks.getHashCode();\n        },\n\n        toString: function (formatStr, provider) {\n            var ticks = this.ticks,\n                result = \"\",\n                me = this,\n                dtInfo = (provider || System.Globalization.CultureInfo.getCurrentCulture()).getFormat(System.Globalization.DateTimeFormatInfo),\n                format = function (t, n, dir, cut) {\n                    return System.String.alignString((t | 0).toString(), n || 2, \"0\", dir || 2, cut || false);\n                };\n\n            if (formatStr) {\n                return formatStr.replace(/(\\\\.|'[^']*'|\"[^\"]*\"|dd?|HH?|hh?|mm?|ss?|tt?|f{1,7}|\\:|\\/)/g,\n                    function (match, group, index) {\n                        var part = match;\n\n                        switch (match) {\n                            case \"d\":\n                                return me.getDays();\n                            case \"dd\":\n                                return format(me.getDays());\n                            case \"H\":\n                                return me.getHours();\n                            case \"HH\":\n                                return format(me.getHours());\n                            case \"h\":\n                                return me.get12HourHour();\n                            case \"hh\":\n                                return format(me.get12HourHour());\n                            case \"m\":\n                                return me.getMinutes();\n                            case \"mm\":\n                                return format(me.getMinutes());\n                            case \"s\":\n                                return me.getSeconds();\n                            case \"ss\":\n                                return format(me.getSeconds());\n                            case \"t\":\n                                return ((me.getHours() < 12) ? dtInfo.amDesignator : dtInfo.pmDesignator).substring(0, 1);\n                            case \"tt\":\n                                return (me.getHours() < 12) ? dtInfo.amDesignator : dtInfo.pmDesignator;\n                            case \"f\":\n                            case \"ff\":\n                            case \"fff\":\n                            case \"ffff\":\n                            case \"fffff\":\n                            case \"ffffff\":\n                            case \"fffffff\":\n                                return format(me.getMilliseconds(), match.length, 1, true);\n                            default:\n                                return match.substr(1, match.length - 1 - (match.charAt(0) !== \"\\\\\"));\n                        }\n                    }\n                );\n            }\n\n            if (ticks.abs().gte(864e9)) {\n                result += format(ticks.toNumberDivided(864e9)) + \".\";\n                ticks = ticks.mod(864e9);\n            }\n\n            result += format(ticks.toNumberDivided(36e9)) + \":\";\n            ticks = ticks.mod(36e9);\n            result += format(ticks.toNumberDivided(6e8) | 0) + \":\";\n            ticks = ticks.mod(6e8);\n            result += format(ticks.toNumberDivided(1e7));\n            ticks = ticks.mod(1e7);\n\n            if (ticks.gt(0)) {\n                result += \".\" + format(ticks.toNumber(), 7);\n            }\n\n            return result;\n        }\n    });\n\n    Bridge.Class.addExtend(System.TimeSpan, [System.IComparable$1(System.TimeSpan), System.IEquatable$1(System.TimeSpan)]);\n\n    // @source StringBuilder.js\n\n    Bridge.define(\"System.Text.StringBuilder\", {\n        ctor: function () {\n            this.$initialize();\n            this.buffer = [],\n            this.capacity = 16;\n\n            if (arguments.length === 1) {\n                this.append(arguments[0]);\n            } else if (arguments.length === 2) {\n                this.append(arguments[0]);\n                this.setCapacity(arguments[1]);\n            } else if (arguments.length >= 3) {\n                this.append(arguments[0], arguments[1], arguments[2]);\n                if (arguments.length === 4) {\n                    this.setCapacity(arguments[3]);\n                }\n            }\n        },\n\n        getLength: function () {\n            if (this.buffer.length < 2) {\n                return this.buffer[0] ? this.buffer[0].length : 0;\n            }\n\n            var s = this.getString();\n            return s.length;\n        },\n\n        setLength: function (value) {\n            if (value === 0) {\n                this.clear();\n            } else if (value < 0) {\n                throw new System.ArgumentOutOfRangeException(\"value\", \"Length cannot be less than zero\");\n            } else {\n                var l = this.getLength();\n                if (value === l) {\n                    return;\n                }\n\n                var delta = value - l;\n                if (delta > 0) {\n                    this.append('\\0', delta);\n                } else {\n                    this.remove(l + delta, -delta);\n                }\n            }\n        },\n\n        getCapacity: function () {\n            var length = this.getLength();\n\n            return (this.capacity > length) ? this.capacity : length;\n        },\n\n        setCapacity: function (value) {\n            var length = this.getLength();\n\n            if (value > length) {\n                this.capacity = value;\n            }\n        },\n\n        toString: function () {\n            var s = this.getString();\n\n            if (arguments.length === 2) {\n                var startIndex = arguments[0],\n                    length = arguments[1];\n\n                this.checkLimits(s, startIndex, length);\n\n                return s.substr(startIndex, length);\n            }\n\n            return s;\n        },\n\n        append: function (value) {\n            if (value == null) {\n                return this;\n            }\n\n            if (arguments.length === 2) {\n                // append a char repeated count times\n                var count = arguments[1];\n\n                if (count === 0) {\n                    return this;\n                } else if (count < 0) {\n                    throw new System.ArgumentOutOfRangeException(\"count\", \"cannot be less than zero\");\n                }\n\n                value = Array(count + 1).join(value).toString();\n            } else if (arguments.length === 3) {\n                // append a (startIndex, count) substring of value\n                var startIndex = arguments[1],\n                    count = arguments[2];\n\n                if (count === 0) {\n                    return this;\n                }\n\n                this.checkLimits(value, startIndex, count);\n                value = value.substr(startIndex, count);\n            }\n\n            this.buffer[this.buffer.length] = value;\n            this.clearString();\n\n            return this;\n        },\n\n        appendFormat: function (format) {\n            return this.append(System.String.format.apply(System.String, arguments));\n        },\n\n        clear: function () {\n            this.buffer = [];\n            this.clearString();\n\n            return this;\n        },\n\n        appendLine: function () {\n            if (arguments.length === 1) {\n                this.append(arguments[0]);\n            }\n\n            return this.append(\"\\r\\n\");\n        },\n\n        equals: function (sb) {\n            if (sb == null) {\n                return false;\n            }\n\n            if (sb === this) {\n                return true;\n            }\n\n            return this.toString() === sb.toString();\n        },\n\n        remove: function (startIndex, length) {\n            var s = this.getString();\n\n            this.checkLimits(s, startIndex, length);\n\n            if (s.length === length && startIndex === 0) {\n                // Optimization.  If we are deleting everything\n                return this.clear();\n            }\n\n            if (length > 0) {\n                this.buffer = [];\n                this.buffer[0] = s.substring(0, startIndex);\n                this.buffer[1] = s.substring(startIndex + length, s.length);\n                this.clearString();\n            }\n\n            return this;\n        },\n\n        insert: function (index, value) {\n            if (value == null) {\n                return this;\n            }\n\n            if (arguments.length === 3) {\n                // insert value repeated count times\n                var count = arguments[2];\n\n                if (count === 0) {\n                    return this;\n                } else if (count < 0) {\n                    throw new System.ArgumentOutOfRangeException(\"count\", \"cannot be less than zero\");\n                }\n\n                value = Array(count + 1).join(value).toString();\n            }\n\n            var s = this.getString();\n            this.buffer = [];\n\n            if (index < 1) {\n                this.buffer[0] = value;\n                this.buffer[1] = s;\n            } else if (index >= s.length) {\n                this.buffer[0] = s;\n                this.buffer[1] = value;\n            } else {\n                this.buffer[0] = s.substring(0, index);\n                this.buffer[1] = value;\n                this.buffer[2] = s.substring(index, s.length);\n            }\n\n            this.clearString();\n\n            return this;\n        },\n\n        replace: function (oldValue, newValue) {\n            var r = new RegExp(oldValue, \"g\"),\n                s = this.buffer.join(\"\");\n\n            this.buffer = [];\n\n            if (arguments.length === 4) {\n                var startIndex = arguments[2],\n                    count = arguments[3],\n                    b = s.substr(startIndex, count);\n\n                this.checkLimits(s, startIndex, count);\n\n                this.buffer[0] = s.substring(0, startIndex);\n                this.buffer[1] = b.replace(r, newValue);\n                this.buffer[2] = s.substring(startIndex + count, s.length);\n            } else {\n                this.buffer[0] = s.replace(r, newValue);\n            }\n\n            this.clearString();\n            return this;\n        },\n\n        checkLimits: function (value, startIndex, length) {\n            if (length < 0) {\n                throw new System.ArgumentOutOfRangeException(\"length\", \"must be non-negative\");\n            }\n\n            if (startIndex < 0) {\n                throw new System.ArgumentOutOfRangeException(\"startIndex\", \"startIndex cannot be less than zero\");\n            }\n\n            if (length > value.length - startIndex) {\n                throw new System.ArgumentOutOfRangeException(\"Index and length must refer to a location within the string\");\n            }\n        },\n\n        clearString: function() {\n            this.$str = null;\n        },\n\n        getString: function() {\n            if (!this.$str) {\n                this.$str = this.buffer.join(\"\");\n                this.buffer = [];\n                this.buffer[0] = this.$str;\n            }\n\n            return this.$str;\n        },\n\n        getChar: function (index) {\n            var str = this.getString();\n            if (index < 0 || index >= str.length) {\n                throw new System.IndexOutOfRangeException();\n            }\n\n            return str.charCodeAt(index);\n        },\n\n        setChar: function(index, value) {\n            var str = this.getString();\n            if (index < 0 || index >= str.length) {\n                throw new System.ArgumentOutOfRangeException();\n            }\n\n            value = String.fromCharCode(value);\n            this.buffer = [];\n            this.buffer[0] = str.substring(0, index);\n            this.buffer[1] = value;\n            this.buffer[2] = str.substring(index + 1, str.length);\n            this.clearString();\n        }\n    });\n\n    // @source BridgeRegex.js\n\n    (function () {\n        var specials = [\n                // order matters for these\n                  \"-\"\n                , \"[\"\n                , \"]\"\n                // order doesn't matter for any of these\n                , \"/\"\n                , \"{\"\n                , \"}\"\n                , \"(\"\n                , \")\"\n                , \"*\"\n                , \"+\"\n                , \"?\"\n                , \".\"\n                , \"\\\\\"\n                , \"^\"\n                , \"$\"\n                , \"|\"\n        ],\n\n        regex = RegExp(\"[\" + specials.join(\"\\\\\") + \"]\", \"g\"),\n\n        regexpEscape = function (s) {\n            return s.replace(regex, \"\\\\$&\");\n        };\n\n        Bridge.regexpEscape = regexpEscape;\n    })();\n\n    // @source Diagnostics.js\n\n    System.Diagnostics.Debug = {\n        writeln: function (text) {\n            if (Bridge.global.console && Bridge.global.console.debug) {\n                Bridge.global.console.debug(text);\n            }\n        },\n\n        _fail: function (message) {\n            System.Diagnostics.Debug.writeln(message);\n            debugger;\n        },\n\n        assert: function (condition, message) {\n            if (!condition) {\n                message = 'Assert failed: ' + message;\n\n                if (confirm(message + '\\r\\n\\r\\nBreak into debugger?')) {\n                    System.Diagnostics.Debug._fail(message);\n                }\n            }\n        },\n\n        fail: function (message) {\n            System.Diagnostics.Debug._fail(message);\n        }\n    }\n\n    Bridge.define(\"System.Diagnostics.Stopwatch\", {\n        ctor: function () {\n            this.$initialize();\n            this.reset();\n        },\n\n        start: function () {\n            if (this.isRunning) {\n                return;\n            }\n\n            this._startTime = System.Diagnostics.Stopwatch.getTimestamp();\n            this.isRunning = true;\n        },\n\n        stop: function () {\n            if (!this.isRunning) {\n                return;\n            }\n\n            var endTimeStamp = System.Diagnostics.Stopwatch.getTimestamp();\n            var elapsedThisPeriod = endTimeStamp.sub(this._startTime);\n            this._elapsed = this._elapsed.add(elapsedThisPeriod);\n            this.isRunning = false;\n        },\n\n        reset: function () {\n            this._startTime = System.Int64.Zero;\n            this._elapsed = System.Int64.Zero;\n            this.isRunning = false;\n        },\n\n        restart: function () {\n            this.isRunning = false;\n            this._elapsed = System.Int64.Zero;\n            this._startTime = System.Diagnostics.Stopwatch.getTimestamp();\n            this.start();\n        },\n\n        ticks: function () {\n            var timeElapsed = this._elapsed;\n\n            if (this.isRunning)\n            {\n                var currentTimeStamp = System.Diagnostics.Stopwatch.getTimestamp();\n                var elapsedUntilNow = currentTimeStamp.sub(this._startTime);\n                timeElapsed = timeElapsed.add(elapsedUntilNow);\n            }\n            return timeElapsed;\n        },\n\n        milliseconds: function () {\n            return this.ticks().mul(1000).div(System.Diagnostics.Stopwatch.frequency);\n        },\n\n        timeSpan: function () {\n            return new System.TimeSpan(this.milliseconds().mul(10000));\n        },\n\n        statics: {\n            startNew: function () {\n                var s = new System.Diagnostics.Stopwatch();\n                s.start();\n                return s;\n            }\n        }\n    });\n\n    if (typeof (window) !== 'undefined' && window.performance && window.performance.now) {\n        System.Diagnostics.Stopwatch.frequency = new System.Int64(1e6);\n        System.Diagnostics.Stopwatch.isHighResolution = true;\n        System.Diagnostics.Stopwatch.getTimestamp = function () {\n            return new System.Int64(Math.round(window.performance.now() * 1000));\n        };\n    } else if (typeof (process) !== 'undefined' && process.hrtime) {\n        System.Diagnostics.Stopwatch.frequency = new System.Int64(1e9);\n        System.Diagnostics.Stopwatch.isHighResolution = true;\n        System.Diagnostics.Stopwatch.getTimestamp = function () {\n            var hr = process.hrtime();\n            return new System.Int64(hr[0]).mul(1e9).add(hr[1]);\n        };\n    } else {\n        System.Diagnostics.Stopwatch.frequency = new System.Int64(1e3);\n        System.Diagnostics.Stopwatch.isHighResolution = false;\n        System.Diagnostics.Stopwatch.getTimestamp = function () {\n            return new System.Int64(new Date().valueOf());\n        };\n    }\n\n    System.Diagnostics.Contracts.Contract = {\n        reportFailure: function (failureKind, userMessage, condition, innerException, TException) {\n            var conditionText = condition.toString();\n\n            conditionText = conditionText.substring(conditionText.indexOf(\"return\") + 7);\n            conditionText = conditionText.substr(0, conditionText.lastIndexOf(\";\"));\n\n            var failureMessage = (conditionText) ? \"Contract '\" + conditionText + \"' failed\" : \"Contract failed\",\n                displayMessage = (userMessage) ? failureMessage + \": \" + userMessage : failureMessage;\n\n            if (TException) {\n                throw new TException(conditionText, userMessage);\n            } else {\n                throw new System.Diagnostics.Contracts.ContractException(failureKind, displayMessage, userMessage, conditionText, innerException);\n            }\n        },\n        assert: function (failureKind, scope, condition, message) {\n            if (!condition.call(scope)) {\n                System.Diagnostics.Contracts.Contract.reportFailure(failureKind, message, condition, null);\n            }\n        },\n        requires: function (TException, scope, condition, message) {\n            if (!condition.call(scope)) {\n                System.Diagnostics.Contracts.Contract.reportFailure(0, message, condition, null, TException);\n            }\n        },\n        forAll: function (fromInclusive, toExclusive, predicate) {\n            if (!predicate) {\n                throw new System.ArgumentNullException(\"predicate\");\n            }\n\n            for (; fromInclusive < toExclusive; fromInclusive++) {\n                if (!predicate(fromInclusive)) {\n                    return false;\n                }\n            }\n\n            return true;\n        },\n        forAll$1: function (collection, predicate) {\n            if (!collection) {\n                throw new System.ArgumentNullException(\"collection\");\n            }\n\n            if (!predicate) {\n                throw new System.ArgumentNullException(\"predicate\");\n            }\n\n            var enumerator = Bridge.getEnumerator(collection);\n\n            try {\n                while (enumerator.moveNext()) {\n                    if (!predicate(enumerator.Current)) {\n                        return false;\n                    }\n                }\n                return true;\n            } finally {\n                enumerator.dispose();\n            }\n        },\n        exists: function (fromInclusive, toExclusive, predicate) {\n            if (!predicate) {\n                throw new System.ArgumentNullException(\"predicate\");\n            }\n\n            for (; fromInclusive < toExclusive; fromInclusive++) {\n                if (predicate(fromInclusive)) {\n                    return true;\n                }\n            }\n\n            return false;\n        },\n        exists$1: function (collection, predicate) {\n            if (!collection) {\n                throw new System.ArgumentNullException(\"collection\");\n            }\n\n            if (!predicate) {\n                throw new System.ArgumentNullException(\"predicate\");\n            }\n\n            var enumerator = Bridge.getEnumerator(collection);\n\n            try {\n                while (enumerator.moveNext()) {\n                    if (predicate(enumerator.Current)) {\n                        return true;\n                    }\n                }\n                return false;\n            } finally {\n                enumerator.dispose();\n            }\n        }\n    };\n\n    Bridge.define(\"System.Diagnostics.Contracts.ContractFailureKind\", {\n        $kind: \"enum\",\n        $statics: {\n            precondition: 0,\n            postcondition: 1,\n            postconditionOnException: 2,\n            invarian: 3,\n            assert: 4,\n            assume: 5\n        }\n    });\n\n    Bridge.define(\"System.Diagnostics.Contracts.ContractException\", {\n        inherits: [System.Exception],\n\n        config: {\n            properties: {\n                Kind: {\n                    get: function() {\n                        return this._kind;\n                    }\n                },\n\n                Failure: {\n                    get: function () {\n                        return this._failureMessage;\n                    }\n                },\n\n                UserMessage: {\n                    get: function () {\n                        return this._userMessage;\n                    }\n                },\n\n                Condition: {\n                    get: function () {\n                        return this._condition;\n                    }\n                }\n            }  \n        },\n\n        ctor: function (failureKind, failureMessage, userMessage, condition, innerException) {\n            this.$initialize();\n            System.Exception.ctor.call(this, failureMessage, innerException);\n            this._kind = failureKind;\n            this._failureMessage = failureMessage || null;\n            this._userMessage = userMessage || null;\n            this._condition = condition || null;\n        }\n    });\n\n    // @source Array.js\n\n    var array = {\n        toIndex: function (arr, indices) {\n            if (indices.length !== (arr.$s ? arr.$s.length : 1)) {\n                throw new System.ArgumentException(\"Invalid number of indices\");\n            }\n\n            if (indices[0] < 0 || indices[0] >= (arr.$s ? arr.$s[0] : arr.length)) {\n                throw new System.IndexOutOfRangeException(\"Index 0 out of range\");\n            }\n\n            var idx = indices[0],\n                i;\n\n            if (arr.$s) {\n                for (i = 1; i < arr.$s.length; i++) {\n                    if (indices[i] < 0 || indices[i] >= arr.$s[i]) {\n                        throw new System.IndexOutOfRangeException(\"Index \" + i + \" out of range\");\n                    }\n\n                    idx = idx * arr.$s[i] + indices[i];\n                }\n            }\n\n            return idx;\n        },\n\n        index: function (index, arr) {\n            if (index < 0 || index >= arr.length) {\n                throw new System.IndexOutOfRangeException();\n            }\n            return index;\n        },\n\n        $get: function (indices) {\n            var r = this[System.Array.toIndex(this, indices)];\n\n            return typeof r !== \"undefined\" ? r : this.$v;\n        },\n\n        get: function (arr) {\n            if (arguments.length < 2) {\n                throw new System.ArgumentNullException(\"indices\");\n            }\n\n            var idx = Array.prototype.slice.call(arguments, 1);\n\n            for (var i = 0; i < idx.length; i++) {\n                if (!Bridge.hasValue(idx[i])) {\n                    throw new System.ArgumentNullException(\"indices\");\n                }\n            }\n\n            var r = arr[System.Array.toIndex(arr, idx)];\n\n            return typeof r !== \"undefined\" ? r : arr.$v;\n        },\n\n        $set: function (indices, value) {\n            this[System.Array.toIndex(this, indices)] = value;\n        },\n\n        set: function (arr, value) {\n            var indices = Array.prototype.slice.call(arguments, 2);\n\n            arr[System.Array.toIndex(arr, indices)] = value;\n        },\n\n        getLength: function (arr, dimension) {\n            if (dimension < 0 || dimension >= (arr.$s ? arr.$s.length : 1)) {\n                throw new System.IndexOutOfRangeException();\n            }\n\n            return arr.$s ? arr.$s[dimension] : arr.length;\n        },\n\n        getRank: function (arr) {\n            return arr.$s ? arr.$s.length : 1;\n        },\n\n        getLower: function (arr, d) {\n            System.Array.getLength(arr, d);\n\n            return 0;\n        },\n\n        create: function (defvalue, initValues, T, sizes) {\n            if (sizes === null) {\n                throw new System.ArgumentNullException(\"length\");\n            }\n\n            var arr = [],\n                length = arguments.length > 3 ? 1 : 0,\n                i, s, v, j,\n                idx,\n                indices,\n                flatIdx;\n\n            arr.$v = defvalue;\n            arr.$s = [];\n            arr.get = System.Array.$get;\n            arr.set = System.Array.$set;\n\n            if (sizes && Bridge.isArray(sizes)) {\n                for (i = 0; i < sizes.length; i++) {\n                    j = sizes[i];\n                    if (isNaN(j) || j < 0) {\n                        throw new System.ArgumentOutOfRangeException(\"length\");\n                    }\n                    length *= j;\n                    arr.$s[i] = j;\n                }\n            } else {\n                for (i = 3; i < arguments.length; i++) {\n                    j = arguments[i];\n                    if (isNaN(j) || j < 0) {\n                        throw new System.ArgumentOutOfRangeException(\"length\");\n                    }\n                    length *= j;\n                    arr.$s[i - 3] = j;\n                }\n            }\n\n            arr.length = length;\n\n            for (var k = 0; k < length; k++) {\n                arr[k] = defvalue;\n            }\n\n            if (initValues) {\n                for (i = 0; i < arr.length; i++) {\n                    indices = [];\n                    flatIdx = i;\n\n                    for (s = arr.$s.length - 1; s >= 0; s--) {\n                        idx = flatIdx % arr.$s[s];\n                        indices.unshift(idx);\n                        flatIdx = Bridge.Int.div(flatIdx - idx, arr.$s[s]);\n                    }\n\n                    v = initValues;\n\n                    for (idx = 0; idx < indices.length; idx++) {\n                        v = v[indices[idx]];\n                    }\n\n                    arr[i] = v;\n                }\n            }\n\n            System.Array.init(arr, T, arr.$s.length);\n\n            return arr;\n        },\n\n        init: function (length, value, T, addFn) {\n            if (length == null) {\n                throw new System.ArgumentNullException(\"length\");\n            }\n\n            if (Bridge.isArray(length)) {\n                var elementType = value,\n                    rank = T || 1;\n                System.Array.type(elementType, rank, length);\n                return length;\n            }\n\n            if (isNaN(length) || length < 0) {\n                throw new System.ArgumentOutOfRangeException(\"length\");\n            }\n\n            var arr = new Array(length),\n                isFn = addFn !== true && Bridge.isFunction(value);\n\n            for (var i = 0; i < length; i++) {\n                arr[i] = isFn ? value() : value;\n            }\n\n            return System.Array.init(arr, T, 1);\n        },\n\n        toEnumerable: function (array) {\n            return new Bridge.ArrayEnumerable(array);\n        },\n\n        toEnumerator: function (array, T) {\n            return new Bridge.ArrayEnumerator(array, T);\n        },\n\n        _typedArrays: {\n            Float32Array: System.Single,\n            Float64Array: System.Double,\n            Int8Array: System.SByte,\n            Int16Array: System.Int16,\n            Int32Array: System.Int32,\n            Uint8Array: System.Byte,\n            Uint8ClampedArray: System.Byte,\n            Uint16Array: System.UInt16,\n            Uint32Array: System.UInt32\n        },\n\n        is: function (obj, type) {\n            if (obj instanceof Bridge.ArrayEnumerator) {\n                if ((obj.constructor === type) || (obj instanceof type) ||\n                    type === Bridge.ArrayEnumerator ||\n                    type.$$name && System.String.startsWith(type.$$name, \"System.Collections.IEnumerator\") ||\n                    type.$$name && System.String.startsWith(type.$$name, \"System.Collections.Generic.IEnumerator\")) {\n                    return true;\n                }\n\n                return false;\n            }\n\n            if (!Bridge.isArray(obj)) {\n                return false;\n            }\n\n            if (type.$elementType && type.$isArray) {\n                var et = Bridge.getType(obj).$elementType;\n                if (et) {\n                    return System.Array.getRank(obj) === type.$rank && Bridge.Reflection.isAssignableFrom(type.$elementType, et);\n                }\n                type = Array;\n            }\n\n            if ((obj.constructor === type) || (obj instanceof type)) {\n                return true;\n            }\n\n            if (type === System.Collections.IEnumerable ||\n                type === System.Collections.ICollection ||\n                type === System.ICloneable ||\n                type === System.Collections.IList ||\n                type.$$name && System.String.startsWith(type.$$name, \"System.Collections.Generic.IEnumerable$1\") ||\n                type.$$name && System.String.startsWith(type.$$name, \"System.Collections.Generic.ICollection$1\") ||\n                type.$$name && System.String.startsWith(type.$$name, \"System.Collections.Generic.IList$1\") ||\n                type.$$name && System.String.startsWith(type.$$name, \"System.Collections.Generic.IReadOnlyCollection$1\") ||\n                type.$$name && System.String.startsWith(type.$$name, \"System.Collections.Generic.IReadOnlyList$1\")) {\n                return true;\n            }\n\n            return !!System.Array._typedArrays[String.prototype.slice.call(Object.prototype.toString.call(obj), 8, -1)];\n        },\n\n        clone: function (arr) {\n            var newArr;\n            if (arr.length === 1) {\n                newArr = [arr[0]];\n            } else {\n                newArr = arr.slice(0);\n            }\n            newArr.$type = arr.$type;\n            return newArr;\n        },\n\n        getCount: function (obj, T) {\n            var name,\n                v;\n            if (Bridge.isArray(obj)) {\n                return obj.length;\n            } else if (T && Bridge.isFunction(obj[name = \"System$Collections$Generic$ICollection$1$\" + Bridge.getTypeAlias(T) + \"$getCount\"])) {\n                return obj[name]();\n            } else if (Bridge.isFunction(obj[name = \"System$Collections$ICollection$getCount\"])) {\n                return obj[name]();\n            } else if (T && (v = obj[\"System$Collections$Generic$ICollection$1$\" + Bridge.getTypeAlias(T) + \"$Count\"]) !== undefined) {\n                return v;\n            } else if ((v = obj[\"System$Collections$ICollection$Count\"]) !== undefined) {\n                return v;\n            } else if ((v = obj.Count) !== undefined) {\n                return v;\n            } else if (Bridge.isFunction(obj.getCount)) {\n                return obj.getCount();\n            }\n\n            return 0;\n        },\n\n        getIsReadOnly: function (obj, T) {\n            var name,\n                v;\n\n            if (Bridge.isArray(obj)) {\n                return T ? true : false;\n            } else if (T && Bridge.isFunction(obj[name = \"System$Collections$Generic$ICollection$1$\" + Bridge.getTypeAlias(T) + \"$getIsReadOnly\"])) {\n                return obj[name]();\n            } else if (T && (v = obj[\"System$Collections$Generic$ICollection$1$\" + Bridge.getTypeAlias(T) + \"$IsReadOnly\"]) !== undefined) {\n                return v;\n            } else if (Bridge.isFunction(obj[name = \"System$Collections$IList$getIsReadOnly\"])) {\n                return obj[name]();\n            } else if ((v = obj[\"System$Collections$IList$IsReadOnly\"]) !== undefined) {\n                return v;\n            } else if ((v = obj.IsReadOnly) !== undefined) {\n                return v;\n            } else if (Bridge.isFunction(obj.getIsReadOnly)) {\n                return obj.getIsReadOnly();\n            }\n\n            return false;\n        },\n\n        checkReadOnly: function(obj, T, msg) {\n            if (System.Array.getIsReadOnly(obj, T)) {\n                throw new System.NotSupportedException(msg || \"Collection was of a fixed size.\");\n            }\n        },\n\n        add: function (obj, item, T) {\n            var name;\n\n            System.Array.checkReadOnly(obj, T);\n\n            if (T) {\n                item = System.Array.checkNewElementType(item, T);\n            }\n\n            if (T && Bridge.isFunction(obj[name = \"System$Collections$Generic$ICollection$1$\" + Bridge.getTypeAlias(T) + \"$add\"])) {\n                return obj[name](item);\n            } else if (Bridge.isFunction(obj[name = \"System$Collections$IList$add\"])) {\n                return obj[name](item);\n            } else if (Bridge.isFunction(obj.add)) {\n                return obj.add(item);\n            }\n\n            return -1;\n        },\n\n        checkNewElementType: function (v, type) {\n            var unboxed = Bridge.unbox(v, true);\n\n            if (Bridge.isNumber(unboxed)) {\n                if (type === System.Decimal) {\n                    return new System.Decimal(unboxed);\n                }\n\n                if (type === System.Int64) {\n                    return new System.Int64(unboxed);\n                }\n\n                if (type === System.UInt64) {\n                    return new System.UInt64(unboxed);\n                }\n            }\n\n            var is = Bridge.is(v, type);\n            if (!is) {\n                if (v == null && Bridge.getDefaultValue(type) == null) {\n                    return null;\n                }\n\n                throw new System.ArgumentException(\"The value \" + unboxed + \"is not of type \" + Bridge.getTypeName(type) + \" and cannot be used in this generic collection.\");\n            }\n\n            return unboxed;\n        },\n\n        clear: function (obj, T) {\n            var name;\n\n            System.Array.checkReadOnly(obj, T, \"Collection is read-only.\");\n\n            if (Bridge.isArray(obj)) {\n                System.Array.fill(obj, T ? (T.getDefaultValue || Bridge.getDefaultValue(T)) : null, 0, obj.length);\n            } else if (T && Bridge.isFunction(obj[name = \"System$Collections$Generic$ICollection$1$\" + Bridge.getTypeAlias(T) + \"$clear\"])) {\n                obj[name]();\n            } else if (Bridge.isFunction(obj[name = \"System$Collections$IList$clear\"])) {\n                obj[name]();\n            } else if (Bridge.isFunction(obj.clear)) {\n                obj.clear();\n            }\n        },\n\n        fill: function (dst, val, index, count) {\n            if (!Bridge.hasValue(dst)) {\n                throw new System.ArgumentNullException(\"dst\");\n            }\n\n            if (index < 0 || count < 0 || (index + count) > dst.length) {\n                throw new System.IndexOutOfRangeException();\n            }\n\n            var isFn = Bridge.isFunction(val);\n\n            while (--count >= 0) {\n                dst[index + count] = isFn ? val() : val;\n            }\n        },\n\n        copy: function (src, spos, dest, dpos, len) {\n            if (!dest) {\n                throw new System.ArgumentNullException(\"dest\", \"Value cannot be null\");\n            }\n\n            if (!src) {\n                throw new System.ArgumentNullException(\"src\", \"Value cannot be null\");\n            }\n\n            if (spos < 0 || dpos < 0 || len < 0) {\n                throw new System.ArgumentOutOfRangeException(\"Number was less than the array's lower bound in the first dimension\");\n            }\n\n            if (len > (src.length - spos) || len > (dest.length - dpos)) {\n                throw new System.ArgumentException(\"Destination array was not long enough. Check destIndex and length, and the array's lower bounds\");\n            }\n\n            if (spos < dpos && src === dest) {\n                while (--len >= 0) {\n                    dest[dpos + len] = src[spos + len];\n                }\n            } else {\n                for (var i = 0; i < len; i++) {\n                    dest[dpos + i] = src[spos + i];\n                }\n            }\n        },\n\n        copyTo: function (obj, dest, index, T) {\n            var name;\n\n            if (Bridge.isArray(obj)) {\n                System.Array.copy(obj, 0, dest, index, obj ? obj.length : 0);\n            } else if (Bridge.isFunction(obj.copyTo)) {\n                obj.copyTo(dest, index);\n            } else if (T && Bridge.isFunction(obj[name = \"System$Collections$Generic$ICollection$1$\" + Bridge.getTypeAlias(T) + \"$copyTo\"])) {\n                obj[name](dest, index);\n            } else if (Bridge.isFunction(obj[name = \"System$Collections$ICollection$copyTo\"])) {\n                obj[name](dest, index);\n            } else {\n                throw new System.NotImplementedException(\"copyTo\");\n            }\n        },\n\n        indexOf: function (arr, item, startIndex, count, T) {\n            var name;\n\n            if (Bridge.isArray(arr)) {\n                var i,\n                    el,\n                    endIndex;\n\n                startIndex = startIndex || 0;\n                count = Bridge.isNumber(count) ? count : arr.length;\n                endIndex = startIndex + count;\n\n                for (i = startIndex; i < endIndex; i++) {\n                    el = arr[i];\n\n                    if (el === item || System.Collections.Generic.EqualityComparer$1.$default.equals2(el, item)) {\n                        return i;\n                    }\n                }\n            } else if (T && Bridge.isFunction(arr[name = \"System$Collections$Generic$IList$1$\" + Bridge.getTypeAlias(T) + \"$indexOf\"])) {\n                return arr[name](item);\n            } else if (Bridge.isFunction(arr[name = \"System$Collections$IList$indexOf\"])) {\n                return arr[name](item);\n            } else if (Bridge.isFunction(arr.indexOf)) {\n                return arr.indexOf(item);\n            }\n\n            return -1;\n        },\n\n        contains: function (obj, item, T) {\n            var name;\n\n            if (Bridge.isArray(obj)) {\n                return System.Array.indexOf(obj, item) > -1;\n            } else if (T && Bridge.isFunction(obj[name = \"System$Collections$Generic$ICollection$1$\" + Bridge.getTypeAlias(T) + \"$contains\"])) {\n                return obj[name](item);\n            } else if (Bridge.isFunction(obj[name = \"System$Collections$IList$contains\"])) {\n                return obj[name](item);\n            } else if (Bridge.isFunction(obj.contains)) {\n                return obj.contains(item);\n            }\n\n            return false;\n        },\n\n        remove: function (obj, item, T) {\n            var name;\n\n            System.Array.checkReadOnly(obj, T);\n\n            if (Bridge.isArray(obj)) {\n                var index = System.Array.indexOf(obj, item);\n\n                if (index > -1) {\n                    obj.splice(index, 1);\n\n                    return true;\n                }\n            } else if (T && Bridge.isFunction(obj[name = \"System$Collections$Generic$ICollection$1$\" + Bridge.getTypeAlias(T) + \"$remove\"])) {\n                return obj[name](item);\n            } else if (Bridge.isFunction(obj[name = \"System$Collections$IList$remove\"])) {\n                return obj[name](item);\n            } else if (Bridge.isFunction(obj.remove)) {\n                return obj.remove(item);\n            }\n\n            return false;\n        },\n\n        insert: function (obj, index, item, T) {\n            var name;\n\n            System.Array.checkReadOnly(obj, T);\n\n            if (T) {\n                item = System.Array.checkNewElementType(item, T);\n            }\n\n            if (T && Bridge.isFunction(obj[name = \"System$Collections$Generic$IList$1$\" + Bridge.getTypeAlias(T) + \"$insert\"])) {\n                obj[name](index, item);\n            } else if (Bridge.isFunction(obj[name = \"System$Collections$IList$insert\"])) {\n                obj[name](index, item);\n            } else if (Bridge.isFunction(obj.insert)) {\n                obj.insert(index, item);\n            }\n        },\n\n        removeAt: function (obj, index, T) {\n            var name;\n\n            System.Array.checkReadOnly(obj, T);\n\n            if (Bridge.isArray(obj)) {\n                obj.splice(index, 1);\n            } else if (T && Bridge.isFunction(obj[name = \"System$Collections$Generic$IList$1$\" + Bridge.getTypeAlias(T) + \"$removeAt\"])) {\n                obj[name](index);\n            } else if (Bridge.isFunction(obj[name = \"System$Collections$IList$removeAt\"])) {\n                obj[name](index);\n            } else if (Bridge.isFunction(obj.removeAt)) {\n                obj.removeAt(index);\n            }\n        },\n\n        getItem: function (obj, idx, T) {\n            var name,\n                v;\n\n            if (Bridge.isArray(obj)) {\n                return obj.$type && Bridge.getDefaultValue(obj.$type.$elementType) != null ? Bridge.box(obj[idx], obj.$type.$elementType) : obj[idx];\n            } else if (T && Bridge.isFunction(obj[name = \"System$Collections$Generic$IList$1$\" + Bridge.getTypeAlias(T) + \"$getItem\"])) {\n                v = obj[name](idx);\n                return v;\n            } else if (Bridge.isFunction(obj.get)) {\n                v = obj.get(idx);\n            } else if (Bridge.isFunction(obj.getItem)) {\n                v = obj.getItem(idx);\n            } else if (Bridge.isFunction(obj[name = \"System$Collections$IList$$getItem\"])) {\n                v = obj[name](idx);\n            } else if (Bridge.isFunction(obj.get_Item)) {\n                v = obj.get_Item(idx);\n            }\n\n            return T && Bridge.getDefaultValue(T) != null ? Bridge.box(v, T) : v;\n        },\n\n        setItem: function (obj, idx, value, T) {\n            var name;\n\n            if (Bridge.isArray(obj)) {\n                if (obj.$type) {\n                    value = System.Array.checkElementType(value, obj.$type.$elementType);\n                }\n\n                obj[idx] = value;\n            } else {\n                if (T) {\n                    value = System.Array.checkElementType(value, T);\n                }\n\n                if (Bridge.isFunction(obj.set)) {\n                    obj.set(idx, value);\n                } else if (Bridge.isFunction(obj.setItem)) {\n                    obj.setItem(idx, value);\n                } else if (T && Bridge.isFunction(obj[name = \"System$Collections$Generic$IList$1$\" + Bridge.getTypeAlias(T) + \"$setItem\"])) {\n                    return obj[name](idx, value);\n                } else if (T && Bridge.isFunction(obj[name = \"System$Collections$IList$setItem\"])) {\n                    return obj[name](idx, value);\n                } else if (Bridge.isFunction(obj.set_Item)) {\n                    obj.set_Item(idx, value);\n                }\n            }\n        },\n\n        checkElementType: function (v, type) {\n            var unboxed = Bridge.unbox(v, true);\n\n            if (Bridge.isNumber(unboxed)) {\n                if (type === System.Decimal) {\n                    return new System.Decimal(unboxed);\n                }\n\n                if (type === System.Int64) {\n                    return new System.Int64(unboxed);\n                }\n\n                if (type === System.UInt64) {\n                    return new System.UInt64(unboxed);\n                }\n            }\n\n            var is = Bridge.is(v, type);\n            if (!is) {\n                if (v == null) {\n                    return Bridge.getDefaultValue(type);\n                }\n\n                throw new System.ArgumentException(\"Cannot widen from source type to target type either because the source type is a not a primitive type or the conversion cannot be accomplished.\");\n            }\n\n            return unboxed;\n        },\n\n        resize: function (arr, newSize, val) {\n            if (newSize < 0) {\n                throw new System.ArgumentOutOfRangeException(\"newSize\", null, null, newSize);\n            }\n\n            var oldSize = 0,\n                isFn = Bridge.isFunction(val),\n                ref = arr.v;\n\n            if (!ref) {\n                ref = new Array(newSize);\n            } else {\n                oldSize = ref.length;\n                ref.length = newSize;\n            }\n\n            for (var i = oldSize; i < newSize; i++) {\n                ref[i] = isFn ? val() : val;\n            }\n\n            arr.v = ref;\n        },\n\n        reverse: function (arr, index, length) {\n            if (!array) {\n                throw new System.ArgumentNullException(\"arr\");\n            }\n\n            if (!index && index !== 0) {\n                index = 0;\n                length = arr.length;\n            }\n\n            if (index < 0 || length < 0) {\n                throw new System.ArgumentOutOfRangeException((index < 0 ? \"index\" : \"length\"), \"Non-negative number required.\");\n            }\n\n            if ((array.length - index) < length) {\n                throw new System.ArgumentException(\"Offset and length were out of bounds for the array or count is greater than the number of elements from index to the end of the source collection.\");\n            }\n\n            if (System.Array.getRank(arr) !== 1) {\n                throw new System.Exception(\"Only single dimension arrays are supported here.\");\n            }\n\n            var i = index,\n                j = index + length - 1;\n\n            while (i < j) {\n                var temp = arr[i];\n                arr[i] = arr[j];\n                arr[j] = temp;\n                i++;\n                j--;\n            }\n        },\n\n        binarySearch: function (array, index, length, value, comparer) {\n            if (!array) {\n                throw new System.ArgumentNullException(\"array\");\n            }\n\n            var lb = 0;\n\n            if (index < lb || length < 0) {\n                throw new System.ArgumentOutOfRangeException(index < lb ? \"index\" : \"length\", \"Non-negative number required.\");\n            }\n\n            if (array.length - (index - lb) < length) {\n                throw new System.ArgumentException(\"Offset and length were out of bounds for the array or count is greater than the number of elements from index to the end of the source collection.\");\n            }\n\n            if (System.Array.getRank(array) !== 1) {\n                throw new System.RankException(\"Only single dimensional arrays are supported for the requested action.\");\n            }\n\n            if (!comparer) {\n                comparer = System.Collections.Generic.Comparer$1.$default;\n            }\n\n            var lo = index,\n                hi = index + length - 1,\n                i,\n                c;\n\n            while (lo <= hi) {\n                i = lo + ((hi - lo) >> 1);\n\n                try {\n                    c = comparer.compare(array[i], value);\n                } catch (e) {\n                    throw new System.InvalidOperationException(\"Failed to compare two elements in the array.\", e);\n                }\n\n                if (c === 0) {\n                    return i;\n                }\n\n                if (c < 0) {\n                    lo = i + 1;\n                } else {\n                    hi = i - 1;\n                }\n            }\n\n            return ~lo;\n        },\n\n        sort: function (array, index, length, comparer) {\n            if (!array) {\n                throw new System.ArgumentNullException(\"array\");\n            }\n\n            if (arguments.length === 2 && typeof index === \"function\") {\n                array.sort(index);\n                return;\n            }\n\n            if (arguments.length === 2 && typeof index === \"object\") {\n                comparer = index;\n                index = null;\n            }\n\n            if (!Bridge.isNumber(index)) {\n                index = 0;\n            }\n\n            if (!Bridge.isNumber(length)) {\n                length = array.length;\n            }\n\n            if (!comparer) {\n                comparer = System.Collections.Generic.Comparer$1.$default;\n            }\n\n            if (index === 0 && length === array.length) {\n                array.sort(Bridge.fn.bind(comparer, comparer.compare));\n            } else {\n                var newarray = array.slice(index, index + length);\n\n                newarray.sort(Bridge.fn.bind(comparer, comparer.compare));\n\n                for (var i = index; i < (index + length) ; i++) {\n                    array[i] = newarray[i - index];\n                }\n            }\n        },\n\n        min: function (arr, minValue) {\n            var min = arr[0],\n                len = arr.length;\n\n            for (var i = 0; i < len; i++) {\n                if ((arr[i] < min || min < minValue) && !(arr[i] < minValue)) {\n                    min = arr[i];\n                }\n            }\n\n            return min;\n        },\n\n        max: function (arr, maxValue) {\n            var max = arr[0],\n                len = arr.length;\n\n            for (var i = 0; i < len; i++) {\n                if ((arr[i] > max || max > maxValue) && !(arr[i] > maxValue)) {\n                    max = arr[i];\n                }\n            }\n\n            return max;\n        },\n\n        addRange: function (arr, items) {\n            if (Bridge.isArray(items)) {\n                arr.push.apply(arr, items);\n            } else {\n                var e = Bridge.getEnumerator(items);\n\n                try {\n                    while (e.moveNext()) {\n                        arr.push(e.Current);\n                    }\n                } finally {\n                    if (Bridge.is(e, System.IDisposable)) {\n                        e.dispose();\n                    }\n                }\n            }\n        },\n\n        convertAll: function (array, converter) {\n            if (!Bridge.hasValue(array)) {\n                throw new System.ArgumentNullException(\"array\");\n            }\n\n            if (!Bridge.hasValue(converter)) {\n                throw new System.ArgumentNullException(\"converter\");\n            }\n\n            var array2 = array.map(converter);\n\n            return array2;\n        },\n\n        find: function (T, array, match) {\n            if (!Bridge.hasValue(array)) {\n                throw new System.ArgumentNullException(\"array\");\n            }\n\n            if (!Bridge.hasValue(match)) {\n                throw new System.ArgumentNullException(\"match\");\n            }\n\n            for (var i = 0; i < array.length; i++) {\n                if (match(array[i])) {\n                    return array[i];\n                }\n            }\n\n            return Bridge.getDefaultValue(T);\n        },\n\n        findAll: function (array, match) {\n            if (!Bridge.hasValue(array)) {\n                throw new System.ArgumentNullException(\"array\");\n            }\n\n            if (!Bridge.hasValue(match)) {\n                throw new System.ArgumentNullException(\"match\");\n            }\n\n            var list = [];\n\n            for (var i = 0; i < array.length; i++) {\n                if (match(array[i])) {\n                    list.push(array[i]);\n                }\n            }\n\n            return list;\n        },\n\n        findIndex: function (array, startIndex, count, match) {\n            if (!Bridge.hasValue(array)) {\n                throw new System.ArgumentNullException(\"array\");\n            }\n\n            if (arguments.length === 2) {\n                match = startIndex;\n                startIndex = 0;\n                count = array.length;\n            } else if (arguments.length === 3) {\n                match = count;\n                count = array.length - startIndex;\n            }\n\n            if (startIndex < 0 || startIndex > array.length) {\n                throw new System.ArgumentOutOfRangeException(\"startIndex\");\n            }\n\n            if (count < 0 || startIndex > array.length - count) {\n                throw new System.ArgumentOutOfRangeException(\"count\");\n            }\n\n            if (!Bridge.hasValue(match)) {\n                throw new System.ArgumentNullException(\"match\");\n            }\n\n            var endIndex = startIndex + count;\n\n            for (var i = startIndex; i < endIndex; i++) {\n                if (match(array[i])) {\n                    return i;\n                }\n            }\n\n            return -1;\n        },\n\n        findLast: function (T, array, match) {\n            if (!Bridge.hasValue(array)) {\n                throw new System.ArgumentNullException(\"array\");\n            }\n\n            if (!Bridge.hasValue(match)) {\n                throw new System.ArgumentNullException(\"match\");\n            }\n\n            for (var i = array.length - 1; i >= 0; i--) {\n                if (match(array[i])) {\n                    return array[i];\n                }\n            }\n\n            return Bridge.getDefaultValue(T);\n        },\n\n        findLastIndex: function (array, startIndex, count, match) {\n            if (!Bridge.hasValue(array)) {\n                throw new System.ArgumentNullException(\"array\");\n            }\n\n            if (arguments.length === 2) {\n                match = startIndex;\n                startIndex = array.length - 1;\n                count = array.length;\n            } else if (arguments.length === 3) {\n                match = count;\n                count = startIndex + 1;\n            }\n\n            if (!Bridge.hasValue(match)) {\n                throw new System.ArgumentNullException(\"match\");\n            }\n\n            if (array.length === 0) {\n                if (startIndex !== -1) {\n                    throw new System.ArgumentOutOfRangeException(\"startIndex\");\n                }\n            } else {\n                if (startIndex < 0 || startIndex >= array.length) {\n                    throw new System.ArgumentOutOfRangeException(\"startIndex\");\n                }\n            }\n\n            if (count < 0 || startIndex - count + 1 < 0) {\n                throw new System.ArgumentOutOfRangeException(\"count\");\n            }\n\n            var endIndex = startIndex - count;\n\n            for (var i = startIndex; i > endIndex; i--) {\n                if (match(array[i])) {\n                    return i;\n                }\n            }\n\n            return -1;\n        },\n\n        forEach: function (array, action) {\n            if (!Bridge.hasValue(array)) {\n                throw new System.ArgumentNullException(\"array\");\n            }\n\n            if (!Bridge.hasValue(action)) {\n                throw new System.ArgumentNullException(\"action\");\n            }\n\n            for (var i = 0; i < array.length; i++) {\n                action(array[i], i, array);\n            }\n        },\n\n        indexOfT: function (array, value, startIndex, count) {\n            if (!Bridge.hasValue(array)) {\n                throw new System.ArgumentNullException(\"array\");\n            }\n\n            if (arguments.length === 2) {\n                startIndex = 0;\n                count = array.length;\n            } else if (arguments.length === 3) {\n                count = array.length - startIndex;\n            }\n\n            if (startIndex < 0 || (startIndex >= array.length && array.length > 0)) {\n                throw new System.ArgumentOutOfRangeException(\"startIndex\", \"out of range\");\n            }\n\n            if (count < 0 || count > array.length - startIndex) {\n                throw new System.ArgumentOutOfRangeException(\"count\", \"out of range\");\n            }\n\n            return System.Array.indexOf(array, value, startIndex, count);\n        },\n\n        lastIndexOfT: function (array, value, startIndex, count) {\n            if (!Bridge.hasValue(array)) {\n                throw new System.ArgumentNullException(\"array\");\n            }\n\n            if (arguments.length === 2) {\n                startIndex = array.length - 1;\n                count = array.length;\n            } else if (arguments.length === 3) {\n                count = (array.length === 0) ? 0 : (startIndex + 1);\n            }\n\n            if (startIndex < 0 || (startIndex >= array.length && array.length > 0)) {\n                throw new System.ArgumentOutOfRangeException(\"startIndex\", \"out of range\");\n            }\n\n            if (count < 0 || startIndex - count + 1 < 0) {\n                throw new System.ArgumentOutOfRangeException(\"count\", \"out of range\");\n            }\n\n            var endIndex = startIndex - count + 1;\n\n            for (var i = startIndex; i >= endIndex; i--) {\n                var el = array[i];\n\n                if (el === value || System.Collections.Generic.EqualityComparer$1.$default.equals2(el, value)) {\n                    return i;\n                }\n            }\n\n            return -1;\n        },\n\n        trueForAll: function (array, match) {\n            if (!Bridge.hasValue(array)) {\n                throw new System.ArgumentNullException(\"array\");\n            }\n\n            if (!Bridge.hasValue(match)) {\n                throw new System.ArgumentNullException(\"match\");\n            }\n\n            for (var i = 0; i < array.length; i++) {\n                if (!match(array[i])) {\n                    return false;\n                }\n            }\n\n            return true;\n        },\n\n        type: function (t, rank, arr) {\n            rank = rank || 1;\n\n            var typeCache = System.Array.$cache[rank],\n                result,\n                name;\n\n            if (!typeCache) {\n                typeCache = [];\n                System.Array.$cache[rank] = typeCache;\n            }\n\n            for (var i = 0; i < typeCache.length; i++) {\n                if (typeCache[i].$elementType === t) {\n                    result = typeCache[i];\n                    break;\n                }\n            }\n\n            if (!result) {\n                name = Bridge.getTypeName(t) + \"[\" + System.String.fromCharCount(\",\".charCodeAt(0), rank - 1) + \"]\";\n                var old = Bridge.Class.staticInitAllow;\n                result = Bridge.define(name, {\n                    $inherits: [Array, System.Collections.ICollection, System.ICloneable, System.Collections.Generic.IList$1(t), System.Collections.Generic.IReadOnlyCollection$1(t)],\n                    $noRegister: true,\n                    statics: {\n                        $elementType: t,\n                        $rank: rank,\n                        $isArray: true,\n                        $is: function(obj) {\n                            return System.Array.is(obj, this);\n                        },\n                        getDefaultValue: function() {\n                            return null;\n                        },\n                        createInstance: function() {\n                            var arr;\n                            if (this.$rank === 1) {\n                                arr = [];\n                            } else {\n                                var args = [Bridge.getDefaultValue(this.$elementType), null, this.$elementType];\n                                for (var j = 0; j < this.$rank; j++) {\n                                    args.push(0);\n                                }\n                                arr = System.Array.create.apply(System.Array, args);\n                            }\n\n                            arr.$type = this;\n                            return arr;\n                        }\n                    }\n                });\n\n                typeCache.push(result);\n\n                Bridge.Class.staticInitAllow = true;\n                if (result.$staticInit) {\n                    result.$staticInit();\n                }\n                Bridge.Class.staticInitAllow = old;\n            }\n\n            if (arr) {\n                arr.$type = result;\n            }\n\n            return arr || result;\n        }\n    };\n\n    System.Array = array;\n    System.Array.$cache = {};\n\n    // @source ArraySegment.js\n\n    Bridge.define('System.ArraySegment', {\n        $kind: \"struct\",\n\n        statics: {\n            getDefaultValue: function () {\n                return new System.ArraySegment();\n            }\n        },\n\n        ctor: function (array, offset, count) {\n            this.$initialize();\n\n            if (arguments.length === 0) {\n                this.array = null;\n                this.offset = 0;\n                this.count = 0;\n                return;\n            }\n\n            if (array == null) {\n                throw new System.ArgumentNullException(\"array\");\n            }\n\n            this.array = array;\n                \n            if (Bridge.isNumber(offset)) {\n                if (offset < 0) {\n                    throw new System.ArgumentOutOfRangeException(\"offset\");\n                }\n\n                this.offset = offset;\n            }\n            else {\n                this.offset = 0;\n            }\n\n            if (Bridge.isNumber(count)) {\n                if (count < 0) {\n                    throw new System.ArgumentOutOfRangeException(\"count\");\n                }\n\n                this.count = count;\n            }\n            else {\n                this.count = array.length;\n            }\n            \n            if (array.length - this.offset < this.count) {\n                throw new ArgumentException();\n            }                \n        },\n\n        getArray: function () {\n            return this.array;\n        },\n\n        getCount: function () {\n            return this.count;\n        },\n\n        getOffset: function () {\n            return this.offset;\n        },\n\n        getHashCode: function () {\n            var h = Bridge.addHash([5322976039, this.array, this.count, this.offset]);\n            return h;\n        },\n\n        equals: function (o) {\n            if (!Bridge.is(o, System.ArraySegment)) {\n                return false;\n            }\n            return Bridge.equals(this.array, o.array) && Bridge.equals(this.count, o.count) && Bridge.equals(this.offset, o.offset);\n        },\n\n        $clone: function (to) { return this; }\n    });\n\n    // @source KeyValuePair.js\n\n    Bridge.define('System.Collections.Generic.KeyValuePair$2', function (TKey, TValue) {\n        return {\n            $kind: \"struct\",\n\n            statics: {\n                getDefaultValue: function () {\n                    return new (System.Collections.Generic.KeyValuePair$2(TKey, TValue))(Bridge.getDefaultValue(TKey), Bridge.getDefaultValue(TValue));\n                }\n            },\n\n            ctor: function (key, value) {\n                if (key === undefined) {\n                    key = Bridge.getDefaultValue(TKey);\n                }\n\n                if (value === undefined) {\n                    value = Bridge.getDefaultValue(TValue);\n                }\n\n                this.$initialize();\n                this.key = key;\n                this.value = value;\n            },\n\n            toString: function () {\n                var s = \"[\";\n\n                if (this.key != null) {\n                    s += this.key.toString();\n                }\n\n                s += \", \";\n\n                if (this.value != null) {\n                    s += this.value.toString();\n                }\n\n                s += \"]\";\n\n                return s;\n            }\n        };\n    });\n    // @source Interfaces.js\n\n    Bridge.define('System.Collections.IEnumerable', {\n        $kind: \"interface\"\n    });\n    Bridge.define('System.Collections.IEnumerator', {\n        $kind: \"interface\"\n    });\n    Bridge.define('System.Collections.IEqualityComparer', {\n        $kind: \"interface\"\n    });\n    Bridge.define('System.Collections.ICollection', {\n        inherits: [System.Collections.IEnumerable],\n        $kind: \"interface\"\n    });\n    Bridge.define('System.Collections.IList', {\n        inherits: [System.Collections.ICollection],\n        $kind: \"interface\"\n    });\n    Bridge.define('System.Collections.IDictionary', {\n        inherits: [System.Collections.ICollection],\n        $kind: \"interface\"\n    });\n\n    Bridge.define('System.Collections.Generic.IEnumerator$1', function (T) {\n        return {\n            inherits: [System.Collections.IEnumerator],\n            $kind: \"interface\"\n        };\n    });\n\n    Bridge.define('System.Collections.Generic.IEnumerable$1', function (T) {\n        return {\n            inherits: [System.Collections.IEnumerable],\n            $kind: \"interface\"\n        };\n    });\n\n    Bridge.define('System.Collections.Generic.ICollection$1', function (T) {\n        return {\n            inherits: [System.Collections.Generic.IEnumerable$1(T)],\n            $kind: \"interface\"\n        };\n    });\n\n    Bridge.define('System.Collections.Generic.IEqualityComparer$1', function (T) {\n        return {\n            $kind: \"interface\"\n        };\n    });\n\n    Bridge.define('System.Collections.Generic.IDictionary$2', function (TKey, TValue) {\n        return {\n            inherits: [System.Collections.Generic.ICollection$1(System.Collections.Generic.KeyValuePair$2(TKey, TValue))],\n            $kind: \"interface\"\n        };\n    });\n\n    Bridge.define('System.Collections.Generic.IList$1', function (T) {\n        return {\n            inherits: [System.Collections.Generic.ICollection$1(T)],\n            $kind: \"interface\"\n        };\n    });\n\n    Bridge.define('System.Collections.Generic.IComparer$1', function (T) {\n        return {\n            $kind: \"interface\"\n        };\n    });\n\n    Bridge.define('System.Collections.Generic.ISet$1', function (T) {\n        return {\n            inherits: [System.Collections.Generic.ICollection$1(T)],\n            $kind: \"interface\"\n        };\n    });\n\n    Bridge.define('System.Collections.Generic.IReadOnlyCollection$1', function (T) {\n        return {\n            inherits: [System.Collections.Generic.IEnumerable$1(T)],\n            $kind: \"interface\"\n        };\n    });\n\n    Bridge.define('System.Collections.Generic.IReadOnlyList$1', function (T) {\n        return {\n            inherits: [System.Collections.Generic.IReadOnlyCollection$1(T)],\n            $kind: \"interface\"\n        };\n    });\n\n    Bridge.define('System.Collections.Generic.IReadOnlyDictionary$2', function (TKey, TValue) {\n        return {\n            inherits: [System.Collections.Generic.IReadOnlyCollection$1(System.Collections.Generic.KeyValuePair$2(TKey, TValue))],\n            $kind: \"interface\"\n        };\n    });\n\n    // @source CustomEnumerator.js\n\n    Bridge.define('Bridge.CustomEnumerator', {\n        inherits: [System.Collections.IEnumerator, System.IDisposable],\n\n        config: {\n\t\t\tproperties: {\n\t\t\t\tCurrent: {\n\t\t\t\t\tget: function () {\n\t\t\t\t\t\treturn this.getCurrent();\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tCurrent$1: {\n\t\t\t\t    get: function () {\n\t\t\t\t        return this.getCurrent();\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t},\n\t\t\t\n            alias: [\n                \"getCurrent\", \"System$Collections$IEnumerator$getCurrent\",\n                \"moveNext\", \"System$Collections$IEnumerator$moveNext\",\n                \"reset\", \"System$Collections$IEnumerator$reset\",\n\t\t\t\t\"dispose\", \"System$IDisposable$dispose\",\n\t\t\t\t\"Current\", \"System$Collections$IEnumerator$Current\"\n            ]\n        },\n\n        ctor: function (moveNext, getCurrent, reset, dispose, scope, T) {\n            this.$initialize();\n            this.$moveNext = moveNext;\n            this.$getCurrent = getCurrent;\n            this.$dispose = dispose;\n            this.$reset = reset;\n            this.scope = scope;\n\n            if (T) {\n                this[\"System$Collections$Generic$IEnumerator$1$\" + Bridge.getTypeAlias(T) + \"$getCurrent$1\"] = this.getCurrent;\n                this[\"System$Collections$Generic$IEnumerator$1$getCurrent$1\"] = this.getCurrent;\n\n                Object.defineProperty(this, \"System$Collections$Generic$IEnumerator$1$\" + Bridge.getTypeAlias(T) + \"$Current$1\", {\n                    get: this.getCurrent,\n                    enumerable: true\n                });\n\n                Object.defineProperty(this, \"System$Collections$Generic$IEnumerator$1$Current$1\", {\n                    get: this.getCurrent,\n                    enumerable: true\n                });\n            }\n        },\n\n        moveNext: function () {\n            try {\n                return this.$moveNext.call(this.scope);\n            }\n            catch (ex) {\n                this.dispose.call(this.scope);\n\n                throw ex;\n            }\n        },\n\n        getCurrent: function () {\n            return this.$getCurrent.call(this.scope);\n        },\n\n        getCurrent$1: function () {\n            return this.$getCurrent.call(this.scope);\n        },\n\n        reset: function () {\n            if (this.$reset) {\n                this.$reset.call(this.scope);\n            }\n        },\n\n        dispose: function () {\n            if (this.$dispose) {\n                this.$dispose.call(this.scope);\n            }\n        }\n    });\n\n    // @source ArrayEnumerator.js\n\n    Bridge.define('Bridge.ArrayEnumerator', {\n        inherits: [System.Collections.IEnumerator, System.IDisposable],\n\n        statics: {\n            $isArrayEnumerator: true\n        },\n\n        config: {\n\t\t\tproperties: {\n\t\t\t\tCurrent: {\n\t\t\t\t\tget: function () {\n\t\t\t\t\t\treturn this.getCurrent();\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tCurrent$1: {\n\t\t\t\t    get: function () {\n\t\t\t\t        return this.getCurrent();\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t},\n\t\t\t\n            alias: [\n                \"getCurrent\", \"System$Collections$IEnumerator$getCurrent\",\n                \"moveNext\", \"System$Collections$IEnumerator$moveNext\",\n                \"reset\", \"System$Collections$IEnumerator$reset\",\n                \"dispose\", \"System$IDisposable$dispose\",\n\t\t\t\t\"Current\", \"System$Collections$IEnumerator$Current\"\n            ]\n        },\n\n        ctor: function (array, T) {\n            this.$initialize();\n            this.array = array;\n            this.reset();\n\n            if (T) {\n                this[\"System$Collections$Generic$IEnumerator$1$\" + Bridge.getTypeAlias(T) + \"$getCurrent$1\"] = this.getCurrent;\n                this[\"System$Collections$Generic$IEnumerator$1$getCurrent$1\"] = this.getCurrent;\n\n                Object.defineProperty(this, \"System$Collections$Generic$IEnumerator$1$\" + Bridge.getTypeAlias(T) + \"$Current$1\", {\n                    get: this.getCurrent,\n                    enumerable: true\n                });\n\n                Object.defineProperty(this, \"System$Collections$Generic$IEnumerator$1$Current$1\", {\n                    get: this.getCurrent,\n                    enumerable: true\n                });\n            }\n        },\n\n        moveNext: function () {\n            this.index++;\n\n            return this.index < this.array.length;\n        },\n\n        getCurrent: function () {\n            return this.array[this.index];\n        },\n\n        getCurrent$1: function () {\n            return this.array[this.index];\n        },\n\n        reset: function () {\n            this.index = -1;\n        },\n\n        dispose: Bridge.emptyFn\n    });\n\n    Bridge.define('Bridge.ArrayEnumerable', {\n        inherits: [System.Collections.IEnumerable],\n\n        config: {\n            alias: [\n                \"getEnumerator\", \"System$Collections$IEnumerable$getEnumerator\"\n            ]\n        },\n\n        ctor: function (array) {\n            this.$initialize();\n            this.array = array;\n        },\n\n        getEnumerator: function () {\n            return new Bridge.ArrayEnumerator(this.array);\n        }\n    });\n\n    // @source EqualityComparer.js\n\n    Bridge.define('System.Collections.Generic.EqualityComparer$1', function (T) {\n        return {\n            inherits: [System.Collections.Generic.IEqualityComparer$1(T)],\n\n            statics: {\n                config: {\n                    init: function () {\n                        this.def = new (System.Collections.Generic.EqualityComparer$1(T))();\n                    }\n                }\n            },\n\n            config: {\n                alias: [\n                    \"equals2\", [\"System$Collections$Generic$IEqualityComparer$1$\" + Bridge.getTypeAlias(T) + \"$equals2\", \"System$Collections$Generic$IEqualityComparer$1$equals2\"],\n                    \"getHashCode2\", [\"System$Collections$Generic$IEqualityComparer$1$\" + Bridge.getTypeAlias(T) + \"$getHashCode2\", \"System$Collections$Generic$IEqualityComparer$1$getHashCode2\"]\n                ]\n            },\n\n            equals2: function (x, y) {\n                if (!Bridge.isDefined(x, true)) {\n                    return !Bridge.isDefined(y, true);\n                } else if (Bridge.isDefined(y, true)) {\n                    var isBridge = x && x.$$name;\n\n                    if (Bridge.isFunction(x) && Bridge.isFunction(y)) {\n                        return Bridge.fn.equals.call(x, y);\n                    }\n                    else if (!isBridge || x && x.$boxed || y && y.$boxed) {\n                        return Bridge.equals(x, y);\n                    }\n                    else if (Bridge.isFunction(x.equalsT)) {\n                        return Bridge.equalsT(x, y);\n                    }\n                    else if (Bridge.isFunction(x.equals)) {\n                        return Bridge.equals(x, y);\n                    }\n\n                    return x === y;\n                }\n\n                return false;\n            },\n\n            getHashCode2: function (obj) {\n                return Bridge.isDefined(obj, true) ? Bridge.getHashCode(obj) : 0;\n            }\n        };\n    });\n\n    System.Collections.Generic.EqualityComparer$1.$default = new (System.Collections.Generic.EqualityComparer$1(System.Object))();\n\n    // @source Comparer.js\n\n    Bridge.define('System.Collections.Generic.Comparer$1', function (T) {\n        return {\n            inherits: [System.Collections.Generic.IComparer$1(T)],\n\n            ctor: function (fn) {\n                this.$initialize();\n                this.fn = fn;\n                this.compare = fn;\n                this[\"System$Collections$Generic$IComparer$1$\" + Bridge.getTypeAlias(T) + \"$compare\"] = fn;\n                this[\"System$Collections$Generic$IComparer$1$compare\"] = fn;\n            }\n        }\n    });\n\n    System.Collections.Generic.Comparer$1.$default = new (System.Collections.Generic.Comparer$1(System.Object))(function (x, y) {\n        if (!Bridge.hasValue(x)) {\n            return !Bridge.hasValue(y) ? 0 : -1;\n        } else if (!Bridge.hasValue(y)) {\n            return 1;\n        }\n\n        return Bridge.compare(x, y);\n    });\n\n    // @source Dictionary.js\n\n    Bridge.define('System.Collections.Generic.Dictionary$2', function (TKey, TValue) {\n        return {\n            inherits: [System.Collections.Generic.IDictionary$2(TKey, TValue),\n                System.Collections.IDictionary,\n                System.Collections.Generic.IReadOnlyDictionary$2(TKey, TValue)],\n\n            config: {\n                properties: {\n                    Keys: {\n                        get: function () {\n                            return this.getKeys();\n                        }\n                    },\n\n                    Values: {\n                        get: function () {\n                            return this.getValues();\n                        }\n                    },\n\n                    IsReadOnly: {\n                        get: function () {\n                            return this.getIsReadOnly();\n                        }\n                    }\n                },\n                alias: [\n                    \"getCount\", \"System$Collections$Generic$ICollection$1$\" + Bridge.getTypeAlias(System.Collections.Generic.KeyValuePair$2(TKey, TValue)) + \"$getCount\",\n                    \"getKeys\", \"System$Collections$Generic$IDictionary$2$\" + Bridge.getTypeAlias(TKey) + \"$\" + Bridge.getTypeAlias(TValue) + \"$getKeys\",\n                    \"getValues\", \"System$Collections$Generic$IDictionary$2$\" + Bridge.getTypeAlias(TKey) + \"$\" + Bridge.getTypeAlias(TValue) + \"$getValues\",\n                    \"Keys\", \"System$Collections$Generic$IDictionary$2$\" + Bridge.getTypeAlias(TKey) + \"$\" + Bridge.getTypeAlias(TValue) + \"$Keys\",\n                    \"Values\", \"System$Collections$Generic$IDictionary$2$\" + Bridge.getTypeAlias(TKey) + \"$\" + Bridge.getTypeAlias(TValue) + \"$Values\",\n                    \"get\", \"System$Collections$Generic$IDictionary$2$\" + Bridge.getTypeAlias(TKey) + \"$\" + Bridge.getTypeAlias(TValue) + \"$getItem\",\n                    \"set\", \"System$Collections$Generic$IDictionary$2$\" + Bridge.getTypeAlias(TKey) + \"$\" + Bridge.getTypeAlias(TValue) + \"$setItem\",\n                    \"add\", \"System$Collections$Generic$IDictionary$2$\" + Bridge.getTypeAlias(TKey) + \"$\" + Bridge.getTypeAlias(TValue) + \"$add\",\n                    \"containsKey\", \"System$Collections$Generic$IDictionary$2$\" + Bridge.getTypeAlias(TKey) + \"$\" + Bridge.getTypeAlias(TValue) + \"$containsKey\",\n                    \"getEnumerator\", [\"System$Collections$Generic$IEnumerable$1$System$Collections$Generic$KeyValuePair$2$\" + Bridge.getTypeAlias(TKey) + \"$\" + Bridge.getTypeAlias(TValue) + \"$getEnumerator\", \"System$Collections$Generic$IEnumerable$1$getEnumerator\"],\n                    \"remove\", \"System$Collections$Generic$IDictionary$2$\" + Bridge.getTypeAlias(TKey) + \"$\" + Bridge.getTypeAlias(TValue) + \"$remove\",\n                    \"tryGetValue\", \"System$Collections$Generic$IDictionary$2$\" + Bridge.getTypeAlias(TKey) + \"$\" + Bridge.getTypeAlias(TValue) + \"$tryGetValue\",\n                    \"getIsReadOnly\", \"System$Collections$Generic$ICollection$1$\" + Bridge.getTypeAlias(System.Collections.Generic.KeyValuePair$2(TKey, TValue)) + \"$getIsReadOnly\",\n                    \"IsReadOnly\", \"System$Collections$Generic$ICollection$1$\" + Bridge.getTypeAlias(System.Collections.Generic.KeyValuePair$2(TKey, TValue)) + \"$IsReadOnly\",\n                    \"addPair\", \"System$Collections$Generic$ICollection$1$\" + Bridge.getTypeAlias(System.Collections.Generic.KeyValuePair$2(TKey, TValue)) + \"$add\",\n                    \"copyTo\", \"System$Collections$Generic$ICollection$1$\" + Bridge.getTypeAlias(System.Collections.Generic.KeyValuePair$2(TKey, TValue)) + \"$copyTo\",\n                    \"clear\", \"System$Collections$Generic$ICollection$1$\" + Bridge.getTypeAlias(System.Collections.Generic.KeyValuePair$2(TKey, TValue)) + \"$clear\",\n                    \"containsPair\", \"System$Collections$Generic$ICollection$1$\" + Bridge.getTypeAlias(System.Collections.Generic.KeyValuePair$2(TKey, TValue)) + \"$contains\",\n                    \"removePair\", \"System$Collections$Generic$ICollection$1$\" + Bridge.getTypeAlias(System.Collections.Generic.KeyValuePair$2(TKey, TValue)) + \"$remove\",\n                    \"copyTo\", \"System$Collections$ICollection$copyTo\",\n                    \"get\", \"System$Collections$IDictionary$getItem\",\n                    \"set\", \"System$Collections$IDictionary$setItem\",\n                    \"containsKey\", \"System$Collections$IDictionary$containsKey\",\n                    \"add\", \"System$Collections$IDictionary$add\",\n                    \"remove\", \"System$Collections$IDictionary$remove\",\n                    \"getIsReadOnly\", \"System$Collections$IDictionary$getIsReadOnly\",\n                    \"getKeys\", \"System$Collections$IDictionary$getKeys\",\n                    \"getValues\", \"System$Collections$IDictionary$getValues\",\n                    \"IsReadOnly\", \"System$Collections$IDictionary$IsReadOnly\",\n                    \"Keys\", \"System$Collections$IDictionary$Keys\",\n                    \"Values\", \"System$Collections$IDictionary$Values\",\n                    \"get\", \"System$Collections$Generic$IReadOnlyDictionary$2$\" + Bridge.getTypeAlias(TKey) + \"$\" + Bridge.getTypeAlias(TValue) + \"$getItem\",\n                    \"Keys\", \"System$Collections$Generic$IReadOnlyDictionary$2$\" + Bridge.getTypeAlias(TKey) + \"$\" + Bridge.getTypeAlias(TValue) + \"$Keys\",\n                    \"getKeys\", \"System$Collections$Generic$IReadOnlyDictionary$2$\" + Bridge.getTypeAlias(TKey) + \"$\" + Bridge.getTypeAlias(TValue) + \"$getKeys\",\n                    \"getValues\", \"System$Collections$Generic$IReadOnlyDictionary$2$\" + Bridge.getTypeAlias(TKey) + \"$\" + Bridge.getTypeAlias(TValue) + \"$getValues\",\n                    \"Values\", \"System$Collections$Generic$IReadOnlyDictionary$2$\" + Bridge.getTypeAlias(TKey) + \"$\" + Bridge.getTypeAlias(TValue) + \"$Values\",\n                    \"containsKey\", \"System$Collections$Generic$IReadOnlyDictionary$2$\" + Bridge.getTypeAlias(TKey) + \"$\" + Bridge.getTypeAlias(TValue) + \"$containsKey\",\n                    \"tryGetValue\", \"System$Collections$Generic$IReadOnlyDictionary$2$\" + Bridge.getTypeAlias(TKey) + \"$\" + Bridge.getTypeAlias(TValue) + \"$tryGetValue\"\n                ]\n            },\n\n            noKeyCheck: false,\n\n            ctor: function (obj, comparer) {\n                this.$initialize();\n                this.comparer = comparer || System.Collections.Generic.EqualityComparer$1(TKey).def;\n                this.clear();\n                this.isSimpleKey = ((TKey === System.String) || (TKey.$number === true && TKey !== System.Int64 && TKey !== System.UInt64) || (TKey === System.Char)) && (this.comparer === System.Collections.Generic.EqualityComparer$1(TKey).def);\n\n                if (Bridge.is(obj, System.Collections.Generic.Dictionary$2(TKey, TValue))) {\n                    var e = Bridge.getEnumerator(obj),\n                        c;\n\n                    while (e.moveNext()) {\n                        c = e.Current;\n                        this.add(c.key, c.value);\n                    }\n                } else if (Object.prototype.toString.call(obj) === '[object Object]') {\n                    var names = Object.keys(obj),\n                        name;\n\n                    for (var i = 0; i < names.length; i++) {\n                        name = names[i];\n                        this.add(name, obj[name]);\n                    }\n                }\n            },\n\n            containsPair: function (pair) {\n                var entry = this.findEntry(pair.key);\n                return entry && this.comparer.equals2(entry.value, pair.value);\n            },\n\n            removePair: function (pair) {\n                var entry = this.findEntry(pair.key);\n                if (entry && this.comparer.equals2(entry.value, pair.value)) {\n                    this.remove(pair.key);\n                    return true;\n                }\n\n                return false;\n            },\n\n            copyTo: function (array, arrayIndex) {\n                var items = System.Linq.Enumerable.from(this).toArray();\n                System.Array.copy(items, 0, array, arrayIndex, items.length);\n            },\n\n            getIsReadOnly: function () {\n                return !!this.readOnly;\n            },\n\n            getKeys: function () {\n                if (this.isSimpleKey) {\n                    return System.Array.init(this.keys, TKey);\n                }\n\n                return new (System.Collections.Generic.DictionaryCollection$1(TKey))(this, true);\n            },\n\n            getValues: function () {\n                if (this.isSimpleKey) {\n                    var values = [];\n\n                    for (var i = 0; i < this.keys.length; i++) {\n                        values.push(this.entries[this.keys[i]].value);\n                    }\n\n                    return System.Array.init(values, TValue);\n                }\n\n                return new (System.Collections.Generic.DictionaryCollection$1(TValue))(this, false);\n            },\n\n            clear: function () {\n                this.entries = {};\n                this.keys = [];\n                this.count = 0;\n            },\n\n            findEntry: function (key) {\n                var hash, entries, i;\n\n                if (this.isSimpleKey) {\n                    if (this.entries.hasOwnProperty(key)) {\n                        return this.entries[key];\n                    }\n                    return;\n                }\n\n                hash = this.comparer.getHashCode2(key);\n\n                if (Bridge.isDefined(this.entries[hash])) {\n                    entries = this.entries[hash];\n\n                    for (i = 0; i < entries.length; i++) {\n                        if (this.comparer.equals2(entries[i].key, key)) {\n                            return entries[i];\n                        }\n                    }\n                }\n            },\n\n            containsKey: function (key) {\n                return !!this.findEntry(key);\n            },\n\n            containsValue: function (value) {\n                var e, i;\n\n                for (e in this.entries) {\n                    if (this.entries.hasOwnProperty(e)) {\n                        var entries = this.isSimpleKey ? [this.entries[e]] : this.entries[e];\n\n                        for (i = 0; i < entries.length; i++) {\n                            if (this.comparer.equals2(entries[i].value, value)) {\n                                return true;\n                            }\n                        }\n                    }\n                }\n\n                return false;\n            },\n\n            get: function (key) {\n                var entry = this.findEntry(key);\n\n                if (!entry) {\n                    if (this.noKeyCheck) {\n                        return Bridge.getDefaultValue(TValue);\n                    }\n\n                    throw new System.Collections.Generic.KeyNotFoundException('Key ' + key + ' does not exist.');\n                }\n\n                return entry.value;\n            },\n\n            getItem: function (key) {\n                return this.get(key);\n            },\n\n            set: function (key, value, add) {\n                var entry = this.findEntry(key),\n                    hash;\n\n                if (entry) {\n                    if (add) {\n                        throw new System.ArgumentException('Key ' + key + ' already exists.');\n                    }\n\n                    entry.value = value;\n                    return;\n                }\n\n                entry = new (System.Collections.Generic.KeyValuePair$2(TKey, TValue))(key, value);\n\n                if (this.isSimpleKey) {\n                    this.entries[key] = entry;\n                    this.keys.push(key);\n                }\n                else {\n                    hash = this.comparer.getHashCode2(key);\n\n                    if (this.entries[hash]) {\n                        this.entries[hash].push(entry);\n                    } else {\n                        this.entries[hash] = [entry];\n                        this.keys.push(hash);\n                    }\n                }\n\n                this.count++;\n            },\n\n            setItem: function (key, value, add) {\n                this.set(key, value, add);\n            },\n\n            add: function (key, value) {\n                this.set(key, value, true);\n            },\n\n            addPair: function (pair) {\n                this.set(pair.key, pair.value, true);\n            },\n\n            remove: function (key) {\n                var hash, entries, i;\n\n                if (this.isSimpleKey) {\n                    if (this.entries.hasOwnProperty(key)) {\n                        delete this.entries[key];\n                        this.keys.splice(this.keys.indexOf(key), 1);\n                        this.count--;\n                        return true;\n                    }\n                    return false;\n                }\n\n                hash = this.comparer.getHashCode2(key);\n\n                if (!this.entries[hash]) {\n                    return false;\n                }\n\n                entries = this.entries[hash];\n\n                for (i = 0; i < entries.length; i++) {\n                    if (this.comparer.equals2(entries[i].key, key)) {\n                        entries.splice(i, 1);\n\n                        if (entries.length == 0) {\n                            delete this.entries[hash];\n                            this.keys.splice(this.keys.indexOf(hash), 1);\n                        }\n\n                        this.count--;\n\n                        return true;\n                    }\n                }\n\n                return false;\n            },\n\n            getCount: function () {\n                return this.count;\n            },\n\n            getComparer: function () {\n                return this.comparer;\n            },\n\n            tryGetValue: function (key, value) {\n                var entry = this.findEntry(key);\n\n                value.v = entry ? entry.value : Bridge.getDefaultValue(TValue);\n\n                return !!entry;\n            },\n\n            getCustomEnumerator: function (fn) {\n                var hashes = this.keys,\n                    hashIndex = -1,\n                    keyIndex;\n\n                return new Bridge.CustomEnumerator(function () {\n                    if (hashIndex < 0 || this.isSimpleKey || keyIndex >= (this.entries[hashes[hashIndex]].length - 1)) {\n                        keyIndex = -1;\n                        hashIndex++;\n                    }\n\n                    if (hashIndex >= hashes.length) {\n                        return false;\n                    }\n\n                    keyIndex++;\n\n                    return true;\n                }, function () {\n                    if (hashIndex < 0 || hashIndex >= hashes.length) {\n                        return new (System.Collections.Generic.KeyValuePair$2(TKey, TValue))()\n                    }\n\n                    return fn(this.isSimpleKey ? this.entries[hashes[hashIndex]] : this.entries[hashes[hashIndex]][keyIndex]);\n                }, function () {\n                    hashIndex = -1;\n                }, null, this, System.Collections.Generic.KeyValuePair$2(TKey, TValue));\n            },\n\n            getEnumerator: function () {\n                return this.getCustomEnumerator(function (e) {\n                    return e;\n                });\n            }\n        };\n    });\n\n    System.Collections.Generic.Dictionary$2.getTypeParameters = function (type) {\n        var interfaceType;\n        if (System.String.startsWith(type.$$name, \"System.Collections.Generic.IDictionary\")) {\n            interfaceType = type;\n        } else {\n            var interfaces = Bridge.Reflection.getInterfaces(type);\n\n            for (var j = 0; j < interfaces.length; j++) {\n                if (System.String.startsWith(interfaces[j].$$name, \"System.Collections.Generic.IDictionary\")) {\n                    interfaceType = interfaces[j];\n                    break;\n                }\n            }\n        }\n\n        var typesGeneric = interfaceType ? Bridge.Reflection.getGenericArguments(interfaceType) : null;\n        var typeKey = typesGeneric ? typesGeneric[0] : null;\n        var typeValue = typesGeneric ? typesGeneric[1] : null;\n\n        return [typeKey, typeValue];\n    };\n\n    Bridge.define('System.Collections.Generic.DictionaryCollection$1', function (T) {\n        return {\n            inherits: [System.Collections.Generic.ICollection$1(T)],\n\n            config: {\n                alias: [\n                  \"getEnumerator\", [\"System$Collections$Generic$IEnumerable$1$\" + Bridge.getTypeAlias(T) + \"$getEnumerator\", \"System$Collections$Generic$IEnumerable$1$getEnumerator\"],\n                  \"getCount\", \"System$Collections$Generic$ICollection$1$\" + Bridge.getTypeAlias(T) + \"$getCount\",\n                  \"add\", \"System$Collections$Generic$ICollection$1$\" + Bridge.getTypeAlias(T) + \"$add\",\n                  \"clear\", \"System$Collections$Generic$ICollection$1$\" + Bridge.getTypeAlias(T) + \"$clear\",\n                  \"contains\", \"System$Collections$Generic$ICollection$1$\" + Bridge.getTypeAlias(T) + \"$contains\",\n                  \"remove\", \"System$Collections$Generic$ICollection$1$\" + Bridge.getTypeAlias(T) + \"$remove\"\n                ]\n            },\n\n            ctor: function (dictionary, keys) {\n                this.$initialize();\n                this.dictionary = dictionary;\n                this.keys = keys;\n            },\n\n            getCount: function () {\n                return this.dictionary.getCount();\n            },\n\n            getEnumerator: function () {\n                return this.dictionary.getCustomEnumerator(this.keys ? function (e) {\n                    return e.key;\n                } : function (e) {\n                    return e.value;\n                });\n            },\n\n            contains: function (value) {\n                return this.keys ? this.dictionary.containsKey(value) : this.dictionary.containsValue(value);\n            },\n\n            add: function (v) {\n                throw new System.NotSupportedException();\n            },\n\n            clear: function () {\n                throw new System.NotSupportedException();\n            },\n\n            remove: function () {\n                throw new System.NotSupportedException();\n            }\n        };\n    });\n\n    // @source enumerator.js\n\n    Bridge.define(\"System.Collections.Generic.List$1.Enumerator\", function (T) { return {\n        inherits: [System.Collections.Generic.IEnumerator$1(T),System.Collections.IEnumerator],\n        $kind: \"struct\",\n        statics: {\n            methods: {\n                getDefaultValue: function () { return new (System.Collections.Generic.List$1.Enumerator(T))(); }\n            }\n        },\n        fields: {\n            list: null,\n            index: 0,\n            version: 0,\n            current: Bridge.getDefaultValue(T)\n        },\n        props: {\n            Current: {\n                get: function () {\n                    return this.current;\n                }\n            },\n            System$Collections$IEnumerator$Current: {\n                get: function () {\n                    if (this.index === 0 || this.index === ((this.list._size + 1) | 0)) {\n                        throw new System.InvalidOperationException();\n                    }\n                    return this.Current;\n                }\n            }\n        },\n        alias: [\n            \"dispose\", \"System$IDisposable$dispose\",\n            \"moveNext\", \"System$Collections$IEnumerator$moveNext\",\n            \"Current\", [\"System$Collections$Generic$IEnumerator$1$\" + Bridge.getTypeAlias(T) + \"$Current$1\", \"System$Collections$Generic$IEnumerator$1$Current$1\"]\n        ],\n        ctors: {\n            $ctor1: function (list) {\n                this.$initialize();\n                this.list = list;\n                this.index = 0;\n                this.version = list._version;\n                this.current = Bridge.getDefaultValue(T);\n            },\n            ctor: function () {\n                this.$initialize();\n            }\n        },\n        methods: {\n            dispose: function () { },\n            moveNext: function () {\n\n                var localList = this.list;\n\n                if (this.version === localList._version && ((this.index >>> 0) < (localList._size >>> 0))) {\n                    this.current = localList._items[System.Array.index(this.index, localList._items)];\n                    this.index = (this.index + 1) | 0;\n                    return true;\n                }\n                return this.moveNextRare();\n            },\n            moveNextRare: function () {\n                if (this.version !== this.list._version) {\n                    throw new System.InvalidOperationException();\n                }\n\n                this.index = (this.list._size + 1) | 0;\n                this.current = Bridge.getDefaultValue(T);\n                return false;\n            },\n            System$Collections$IEnumerator$reset: function () {\n                if (this.version !== this.list._version) {\n                    throw new System.InvalidOperationException();\n                }\n\n                this.index = 0;\n                this.current = Bridge.getDefaultValue(T);\n            },\n            getHashCode: function () {\n                var h = Bridge.addHash([3788985113, this.list, this.index, this.version, this.current]);\n                return h;\n            },\n            equals: function (o) {\n                if (!Bridge.is(o, System.Collections.Generic.List$1.Enumerator(T))) {\n                    return false;\n                }\n                return Bridge.equals(this.list, o.list) && Bridge.equals(this.index, o.index) && Bridge.equals(this.version, o.version) && Bridge.equals(this.current, o.current);\n            },\n            $clone: function (to) {\n                var s = to || new (System.Collections.Generic.List$1.Enumerator(T))();\n                s.list = this.list;\n                s.index = this.index;\n                s.version = this.version;\n                s.current = this.current;\n                return s;\n            }\n        }\n    }; });\n\n    // @source list.js\n\n    Bridge.define(\"System.Collections.Generic.List$1\", function (T) { return {\n        inherits: [System.Collections.Generic.IList$1(T),System.Collections.IList,System.Collections.Generic.IReadOnlyList$1(T)],\n        statics: {\n            fields: {\n                _defaultCapacity: 0,\n                _emptyArray: null\n            },\n            ctors: {\n                init: function () {\n                    this._defaultCapacity = 4;\n                    this._emptyArray = System.Array.init(0, function (){\n                        return Bridge.getDefaultValue(T);\n                    }, T);\n                }\n            },\n            methods: {\n                isCompatibleObject: function (value) {\n                    // Non-null values are fine.  Only accept nulls if T is a class or Nullable<U>.\n                    // Note that default(T) is not equal to null for value types except when T is Nullable<U>.\n                    return ((Bridge.is(value, T)) || (value == null && Bridge.getDefaultValue(T) == null));\n                }\n            }\n        },\n        fields: {\n            _items: null,\n            _size: 0,\n            _version: 0\n        },\n        props: {\n            Capacity: {\n                get: function () {\n                    return this._items.length;\n                },\n                set: function (value) {\n                    if (value < this._size) {\n                        throw new System.ArgumentOutOfRangeException(\"value\");\n                    }\n\n                    if (value !== this._items.length) {\n                        if (value > 0) {\n                            var newItems = System.Array.init(value, function (){\n                                return Bridge.getDefaultValue(T);\n                            }, T);\n                            if (this._size > 0) {\n                                System.Array.copy(this._items, 0, newItems, 0, this._size);\n                            }\n                            this._items = newItems;\n                        } else {\n                            this._items = System.Collections.Generic.List$1(T)._emptyArray;\n                        }\n                    }\n                }\n            },\n            Count: {\n                get: function () {\n                    return this._size;\n                }\n            },\n            System$Collections$Generic$ICollection$1$IsReadOnly: {\n                get: function () {\n                    return false;\n                }\n            },\n            System$Collections$IList$IsReadOnly: {\n                get: function () {\n                    return false;\n                }\n            }\n        },\n        alias: [\n            \"Count\", \"System$Collections$Generic$IReadOnlyCollection$1$\" + Bridge.getTypeAlias(T) + \"$Count\",\n            \"Count\", \"System$Collections$ICollection$Count\",\n            \"Count\", \"System$Collections$Generic$ICollection$1$\" + Bridge.getTypeAlias(T) + \"$Count\",\n            \"System$Collections$Generic$ICollection$1$IsReadOnly\", \"System$Collections$Generic$ICollection$1$\" + Bridge.getTypeAlias(T) + \"$IsReadOnly\",\n            \"getItem\", \"System$Collections$Generic$IReadOnlyList$1$\" + Bridge.getTypeAlias(T) + \"$getItem\",\n            \"setItem\", \"System$Collections$Generic$IReadOnlyList$1$\" + Bridge.getTypeAlias(T) + \"$setItem\",\n            \"getItem\", \"System$Collections$Generic$IList$1$\" + Bridge.getTypeAlias(T) + \"$getItem\",\n            \"setItem\", \"System$Collections$Generic$IList$1$\" + Bridge.getTypeAlias(T) + \"$setItem\",\n            \"add\", \"System$Collections$Generic$ICollection$1$\" + Bridge.getTypeAlias(T) + \"$add\",\n            \"clear\", \"System$Collections$IList$clear\",\n            \"clear\", \"System$Collections$Generic$ICollection$1$\" + Bridge.getTypeAlias(T) + \"$clear\",\n            \"contains\", \"System$Collections$Generic$ICollection$1$\" + Bridge.getTypeAlias(T) + \"$contains\",\n            \"copyTo\", \"System$Collections$Generic$ICollection$1$\" + Bridge.getTypeAlias(T) + \"$copyTo\",\n            \"System$Collections$Generic$IEnumerable$1$getEnumerator\", \"System$Collections$Generic$IEnumerable$1$\" + Bridge.getTypeAlias(T) + \"$getEnumerator\",\n            \"indexOf\", \"System$Collections$Generic$IList$1$\" + Bridge.getTypeAlias(T) + \"$indexOf\",\n            \"insert\", \"System$Collections$Generic$IList$1$\" + Bridge.getTypeAlias(T) + \"$insert\",\n            \"remove\", \"System$Collections$Generic$ICollection$1$\" + Bridge.getTypeAlias(T) + \"$remove\",\n            \"removeAt\", \"System$Collections$IList$removeAt\",\n            \"removeAt\", \"System$Collections$Generic$IList$1$\" + Bridge.getTypeAlias(T) + \"$removeAt\"\n        ],\n        ctors: {\n            ctor: function () {\n                this.$initialize();\n                this._items = System.Collections.Generic.List$1(T)._emptyArray;\n            },\n            $ctor2: function (capacity) {\n                this.$initialize();\n                if (capacity < 0) {\n                    throw new System.ArgumentOutOfRangeException(\"capacity\");\n                }\n\n                if (capacity === 0) {\n                    this._items = System.Collections.Generic.List$1(T)._emptyArray;\n                } else {\n                    this._items = System.Array.init(capacity, function (){\n                        return Bridge.getDefaultValue(T);\n                    }, T);\n                }\n            },\n            $ctor1: function (collection) {\n                this.$initialize();\n                if (collection == null) {\n                    throw new System.ArgumentNullException(\"collection\");\n                }\n\n                var c = Bridge.as(collection, System.Collections.Generic.ICollection$1(T));\n                if (c != null) {\n                    var count = System.Array.getCount(c, T);\n                    if (count === 0) {\n                        this._items = System.Collections.Generic.List$1(T)._emptyArray;\n                    } else {\n                        this._items = System.Array.init(count, function (){\n                            return Bridge.getDefaultValue(T);\n                        }, T);\n                        System.Array.copyTo(c, this._items, 0, T);\n                        this._size = count;\n                    }\n                } else {\n                    this._size = 0;\n                    this._items = System.Collections.Generic.List$1(T)._emptyArray;\n                    // This enumerable could be empty.  Let Add allocate a new array, if needed.\n                    // Note it will also go to _defaultCapacity first, not 1, then 2, etc.\n\n                    var en = Bridge.getEnumerator(collection, T);\n                    try {\n                        while (en.System$Collections$IEnumerator$moveNext()) {\n                            this.add(en[Bridge.geti(en, \"System$Collections$Generic$IEnumerator$1$\" + Bridge.getTypeAlias(T) + \"$Current$1\", \"System$Collections$Generic$IEnumerator$1$Current$1\")]);\n                        }\n                    }\n                    finally {\n                        if (Bridge.hasValue(en)) {\n                            en.System$IDisposable$dispose();\n                        }\n                    }\n                }\n            }\n        },\n        methods: {\n            getItem: function (index) {\n                // Following trick can reduce the range check by one\n                if ((index >>> 0) >= (this._size >>> 0)) {\n                    throw new System.ArgumentOutOfRangeException();\n                }\n                return this._items[System.Array.index(index, this._items)];\n            },\n            setItem: function (index, value) {\n                if ((index >>> 0) >= (this._size >>> 0)) {\n                    throw new System.ArgumentOutOfRangeException();\n                }\n                this._items[System.Array.index(index, this._items)] = value;\n                this._version = (this._version + 1) | 0;\n            },\n            System$Collections$IList$getItem: function (index) {\n                return this.getItem(index);\n            },\n            System$Collections$IList$setItem: function (index, value) {\n                if (value == null && !(Bridge.getDefaultValue(T) == null)) {\n                    throw new System.ArgumentNullException(\"value\");\n                }\n\n                try {\n                    this.setItem(index, Bridge.cast(Bridge.unbox(value), T));\n                }\n                catch ($e1) {\n                    $e1 = System.Exception.create($e1);\n                    if (Bridge.is($e1, System.InvalidCastException)) {\n                        throw new System.ArgumentException(\"value\");\n                    } else {\n                        throw $e1;\n                    }\n                }\n            },\n            add: function (item) {\n                if (this._size === this._items.length) {\n                    this.ensureCapacity(((this._size + 1) | 0));\n                }\n                this._items[System.Array.index(Bridge.identity(this._size, (this._size = (this._size + 1) | 0)), this._items)] = item;\n                this._version = (this._version + 1) | 0;\n            },\n            System$Collections$IList$add: function (item) {\n                if (item == null && !(Bridge.getDefaultValue(T) == null)) {\n                    throw new System.ArgumentNullException(\"item\");\n                }\n\n                try {\n                    this.add(Bridge.cast(Bridge.unbox(item), T));\n                }\n                catch ($e1) {\n                    $e1 = System.Exception.create($e1);\n                    if (Bridge.is($e1, System.InvalidCastException)) {\n                        throw new System.ArgumentException(\"item\");\n                    } else {\n                        throw $e1;\n                    }\n                }\n\n                return ((this.Count - 1) | 0);\n            },\n            addRange: function (collection) {\n                this.insertRange(this._size, collection);\n            },\n            asReadOnly: function () {\n                return new (System.Collections.ObjectModel.ReadOnlyCollection$1(T))(this);\n            },\n            binarySearch$2: function (index, count, item, comparer) {\n                if (index < 0) {\n                    throw new System.ArgumentOutOfRangeException(\"index\");\n                }\n                if (count < 0) {\n                    throw new System.ArgumentOutOfRangeException(\"count\");\n                }\n                if (((this._size - index) | 0) < count) {\n                    throw new System.ArgumentException();\n                }\n\n                return System.Array.binarySearch(this._items, index, count, item, comparer);\n            },\n            binarySearch: function (item) {\n                return this.binarySearch$2(0, this.Count, item, null);\n            },\n            binarySearch$1: function (item, comparer) {\n                return this.binarySearch$2(0, this.Count, item, comparer);\n            },\n            clear: function () {\n                if (this._size > 0) {\n                    System.Array.fill(this._items, Bridge.getDefaultValue(T), 0, this._size); // Don't need to doc this but we clear the elements so that the gc can reclaim the references.\n                    this._size = 0;\n                }\n                this._version = (this._version + 1) | 0;\n            },\n            contains: function (item) {\n                if (item == null) {\n                    for (var i = 0; i < this._size; i = (i + 1) | 0) {\n                        if (this._items[System.Array.index(i, this._items)] == null) {\n                            return true;\n                        }\n                    }\n                    return false;\n                } else {\n                    var c = System.Collections.Generic.EqualityComparer$1(T).def;\n                    for (var i1 = 0; i1 < this._size; i1 = (i1 + 1) | 0) {\n                        if (c.equals2(this._items[System.Array.index(i1, this._items)], item)) {\n                            return true;\n                        }\n                    }\n                    return false;\n                }\n            },\n            System$Collections$IList$contains: function (item) {\n                if (System.Collections.Generic.List$1(T).isCompatibleObject(item)) {\n                    return this.contains(Bridge.cast(Bridge.unbox(item), T));\n                }\n                return false;\n            },\n            convertAll: function (TOutput, converter) {\n                if (Bridge.staticEquals(converter, null)) {\n                    throw new System.ArgumentNullException(\"converter\");\n                }\n\n                var list = new (System.Collections.Generic.List$1(TOutput)).$ctor2(this._size);\n                for (var i = 0; i < this._size; i = (i + 1) | 0) {\n                    list._items[System.Array.index(i, list._items)] = converter(this._items[System.Array.index(i, this._items)]);\n                }\n                list._size = this._size;\n                return list;\n            },\n            copyTo$1: function (array) {\n                this.copyTo(array, 0);\n            },\n            System$Collections$ICollection$copyTo: function (array, arrayIndex) {\n                if ((array != null) && (System.Array.getRank(array) !== 1)) {\n                    throw new System.ArgumentException(\"array\");\n                }\n\n                System.Array.copy(this._items, 0, array, arrayIndex, this._size);\n            },\n            copyTo$2: function (index, array, arrayIndex, count) {\n                if (((this._size - index) | 0) < count) {\n                    throw new System.ArgumentException();\n                }\n\n                // Delegate rest of error checking to Array.Copy.\n                System.Array.copy(this._items, index, array, arrayIndex, count);\n            },\n            copyTo: function (array, arrayIndex) {\n                // Delegate rest of error checking to Array.Copy.\n                System.Array.copy(this._items, 0, array, arrayIndex, this._size);\n            },\n            ensureCapacity: function (min) {\n                if (this._items.length < min) {\n                    var newCapacity = this._items.length === 0 ? System.Collections.Generic.List$1(T)._defaultCapacity : Bridge.Int.mul(this._items.length, 2);\n                    // Allow the list to grow to maximum possible capacity (~2G elements) before encountering overflow.\n                    // Note that this check works even when _items.Length overflowed thanks to the (uint) cast\n                    if ((newCapacity >>> 0) > 2146435071) {\n                        newCapacity = 2146435071;\n                    }\n                    if (newCapacity < min) {\n                        newCapacity = min;\n                    }\n                    this.Capacity = newCapacity;\n                }\n            },\n            exists: function (match) {\n                return this.findIndex$2(match) !== -1;\n            },\n            find: function (match) {\n                if (Bridge.staticEquals(match, null)) {\n                    throw new System.ArgumentNullException(\"match\");\n                }\n\n                for (var i = 0; i < this._size; i = (i + 1) | 0) {\n                    if (match(this._items[System.Array.index(i, this._items)])) {\n                        return this._items[System.Array.index(i, this._items)];\n                    }\n                }\n                return Bridge.getDefaultValue(T);\n            },\n            findAll: function (match) {\n                if (Bridge.staticEquals(match, null)) {\n                    throw new System.ArgumentNullException(\"match\");\n                }\n\n                var list = new (System.Collections.Generic.List$1(T)).ctor();\n                for (var i = 0; i < this._size; i = (i + 1) | 0) {\n                    if (match(this._items[System.Array.index(i, this._items)])) {\n                        list.add(this._items[System.Array.index(i, this._items)]);\n                    }\n                }\n                return list;\n            },\n            findIndex$2: function (match) {\n                return this.findIndex(0, this._size, match);\n            },\n            findIndex$1: function (startIndex, match) {\n                return this.findIndex(startIndex, ((this._size - startIndex) | 0), match);\n            },\n            findIndex: function (startIndex, count, match) {\n                if ((startIndex >>> 0) > (this._size >>> 0)) {\n                    throw new System.ArgumentOutOfRangeException(\"startIndex\");\n                }\n\n                if (count < 0 || startIndex > ((this._size - count) | 0)) {\n                    throw new System.ArgumentOutOfRangeException(\"count\");\n                }\n\n                if (Bridge.staticEquals(match, null)) {\n                    throw new System.ArgumentNullException(\"match\");\n                }\n\n                var endIndex = (startIndex + count) | 0;\n                for (var i = startIndex; i < endIndex; i = (i + 1) | 0) {\n                    if (match(this._items[System.Array.index(i, this._items)])) {\n                        return i;\n                    }\n                }\n                return -1;\n            },\n            findLast: function (match) {\n                if (Bridge.staticEquals(match, null)) {\n                    throw new System.ArgumentNullException(\"match\");\n                }\n\n                for (var i = (this._size - 1) | 0; i >= 0; i = (i - 1) | 0) {\n                    if (match(this._items[System.Array.index(i, this._items)])) {\n                        return this._items[System.Array.index(i, this._items)];\n                    }\n                }\n                return Bridge.getDefaultValue(T);\n            },\n            findLastIndex$2: function (match) {\n                return this.findLastIndex(((this._size - 1) | 0), this._size, match);\n            },\n            findLastIndex$1: function (startIndex, match) {\n                return this.findLastIndex(startIndex, ((startIndex + 1) | 0), match);\n            },\n            findLastIndex: function (startIndex, count, match) {\n                if (Bridge.staticEquals(match, null)) {\n                    throw new System.ArgumentNullException(\"match\");\n                }\n\n                if (this._size === 0) {\n                    // Special case for 0 length List\n                    if (startIndex !== -1) {\n                        throw new System.ArgumentOutOfRangeException(\"startIndex\");\n                    }\n                } else {\n                    // Make sure we're not out of range\n                    if ((startIndex >>> 0) >= (this._size >>> 0)) {\n                        throw new System.ArgumentOutOfRangeException(\"startIndex\");\n                    }\n                }\n\n                // 2nd have of this also catches when startIndex == MAXINT, so MAXINT - 0 + 1 == -1, which is < 0.\n                if (count < 0 || ((((startIndex - count) | 0) + 1) | 0) < 0) {\n                    throw new System.ArgumentOutOfRangeException(\"count\");\n                }\n\n                var endIndex = (startIndex - count) | 0;\n                for (var i = startIndex; i > endIndex; i = (i - 1) | 0) {\n                    if (match(this._items[System.Array.index(i, this._items)])) {\n                        return i;\n                    }\n                }\n                return -1;\n            },\n            forEach: function (action) {\n                if (Bridge.staticEquals(action, null)) {\n                    throw new System.ArgumentNullException(\"match\");\n                }\n\n                var version = this._version;\n\n                for (var i = 0; i < this._size; i = (i + 1) | 0) {\n                    if (version !== this._version) {\n                        break;\n                    }\n                    action(this._items[System.Array.index(i, this._items)]);\n                }\n\n                if (version !== this._version) {\n                    throw new System.InvalidOperationException();\n                }\n            },\n            getEnumerator: function () {\n                return new (System.Collections.Generic.List$1.Enumerator(T)).$ctor1(this);\n            },\n            System$Collections$Generic$IEnumerable$1$getEnumerator: function () {\n                return new (System.Collections.Generic.List$1.Enumerator(T)).$ctor1(this).$clone();\n            },\n            System$Collections$IEnumerable$getEnumerator: function () {\n                return new (System.Collections.Generic.List$1.Enumerator(T)).$ctor1(this).$clone();\n            },\n            getRange: function (index, count) {\n                if (index < 0) {\n                    throw new System.ArgumentOutOfRangeException(\"index\");\n                }\n\n                if (count < 0) {\n                    throw new System.ArgumentOutOfRangeException(\"count\");\n                }\n\n                if (((this._size - index) | 0) < count) {\n                    throw new System.ArgumentException();\n                }\n\n                var list = new (System.Collections.Generic.List$1(T)).$ctor2(count);\n                System.Array.copy(this._items, index, list._items, 0, count);\n                list._size = count;\n                return list;\n            },\n            indexOf: function (item) {\n                return System.Array.indexOfT(this._items, item, 0, this._size);\n            },\n            System$Collections$IList$indexOf: function (item) {\n                if (System.Collections.Generic.List$1(T).isCompatibleObject(item)) {\n                    return this.indexOf(Bridge.cast(Bridge.unbox(item), T));\n                }\n                return -1;\n            },\n            indexOf$1: function (item, index) {\n                if (index > this._size) {\n                    throw new System.ArgumentOutOfRangeException(\"index\");\n                }\n                return System.Array.indexOfT(this._items, item, index, ((this._size - index) | 0));\n            },\n            indexOf$2: function (item, index, count) {\n                if (index > this._size) {\n                    throw new System.ArgumentOutOfRangeException(\"index\");\n                }\n\n                if (count < 0 || index > ((this._size - count) | 0)) {\n                    throw new System.ArgumentOutOfRangeException(\"count\");\n                }\n\n                return System.Array.indexOfT(this._items, item, index, count);\n            },\n            insert: function (index, item) {\n                // Note that insertions at the end are legal.\n                if ((index >>> 0) > (this._size >>> 0)) {\n                    throw new System.ArgumentOutOfRangeException(\"index\");\n                }\n                if (this._size === this._items.length) {\n                    this.ensureCapacity(((this._size + 1) | 0));\n                }\n                if (index < this._size) {\n                    System.Array.copy(this._items, index, this._items, ((index + 1) | 0), ((this._size - index) | 0));\n                }\n                this._items[System.Array.index(index, this._items)] = item;\n                this._size = (this._size + 1) | 0;\n                this._version = (this._version + 1) | 0;\n            },\n            System$Collections$IList$insert: function (index, item) {\n                if (item == null && !(Bridge.getDefaultValue(T) == null)) {\n                    throw new System.ArgumentNullException(\"item\");\n                }\n\n                try {\n                    this.insert(index, Bridge.cast(Bridge.unbox(item), T));\n                }\n                catch ($e1) {\n                    $e1 = System.Exception.create($e1);\n                    if (Bridge.is($e1, System.InvalidCastException)) {\n                        throw new System.ArgumentException(\"item\");\n                    } else {\n                        throw $e1;\n                    }\n                }\n            },\n            insertRange: function (index, collection) {\n                if (collection == null) {\n                    throw new System.ArgumentNullException(\"collection\");\n                }\n\n                if ((index >>> 0) > (this._size >>> 0)) {\n                    throw new System.ArgumentOutOfRangeException(\"index\");\n                }\n\n                var c = Bridge.as(collection, System.Collections.Generic.ICollection$1(T));\n                if (c != null) { // if collection is ICollection<T>\n                    var count = System.Array.getCount(c, T);\n                    if (count > 0) {\n                        this.ensureCapacity(((this._size + count) | 0));\n                        if (index < this._size) {\n                            System.Array.copy(this._items, index, this._items, ((index + count) | 0), ((this._size - index) | 0));\n                        }\n\n                        // If we're inserting a List into itself, we want to be able to deal with that.\n                        if (Bridge.referenceEquals(this, c)) {\n                            // Copy first part of _items to insert location\n                            System.Array.copy(this._items, 0, this._items, index, index);\n                            // Copy last part of _items back to inserted location\n                            System.Array.copy(this._items, ((index + count) | 0), this._items, Bridge.Int.mul(index, 2), ((this._size - index) | 0));\n                        } else {\n                            var itemsToInsert = System.Array.init(count, function (){\n                                return Bridge.getDefaultValue(T);\n                            }, T);\n                            System.Array.copyTo(c, itemsToInsert, 0, T);\n                            System.Array.copy(itemsToInsert, 0, this._items, index, itemsToInsert.length);\n                        }\n                        this._size = (this._size + count) | 0;\n                    }\n                } else {\n                    var en = Bridge.getEnumerator(collection, T);\n                    try {\n                        while (en.System$Collections$IEnumerator$moveNext()) {\n                            this.insert(Bridge.identity(index, (index = (index + 1) | 0)), en[Bridge.geti(en, \"System$Collections$Generic$IEnumerator$1$\" + Bridge.getTypeAlias(T) + \"$Current$1\", \"System$Collections$Generic$IEnumerator$1$Current$1\")]);\n                        }\n                    }\n                    finally {\n                        if (Bridge.hasValue(en)) {\n                            en.System$IDisposable$dispose();\n                        }\n                    }\n                }\n                this._version = (this._version + 1) | 0;\n            },\n            lastIndexOf: function (item) {\n                if (this._size === 0) { // Special case for empty list\n                    return -1;\n                } else {\n                    return this.lastIndexOf$2(item, ((this._size - 1) | 0), this._size);\n                }\n            },\n            lastIndexOf$1: function (item, index) {\n                if (index >= this._size) {\n                    throw new System.ArgumentOutOfRangeException(\"index\");\n                }\n                return this.lastIndexOf$2(item, index, ((index + 1) | 0));\n            },\n            lastIndexOf$2: function (item, index, count) {\n                if ((this.Count !== 0) && (index < 0)) {\n                    throw new System.ArgumentOutOfRangeException(\"index\");\n                }\n\n                if ((this.Count !== 0) && (count < 0)) {\n                    throw new System.ArgumentOutOfRangeException(\"count\");\n                }\n\n                if (this._size === 0) { // Special case for empty list\n                    return -1;\n                }\n\n                if (index >= this._size) {\n                    throw new System.ArgumentOutOfRangeException(\"index\");\n                }\n\n                if (count > ((index + 1) | 0)) {\n                    throw new System.ArgumentOutOfRangeException(\"count\");\n                }\n\n                return System.Array.lastIndexOfT(this._items, item, index, count);\n            },\n            remove: function (item) {\n                var index = this.indexOf(item);\n                if (index >= 0) {\n                    this.removeAt(index);\n                    return true;\n                }\n\n                return false;\n            },\n            System$Collections$IList$remove: function (item) {\n                if (System.Collections.Generic.List$1(T).isCompatibleObject(item)) {\n                    this.remove(Bridge.cast(Bridge.unbox(item), T));\n                }\n            },\n            removeAll: function (match) {\n                if (Bridge.staticEquals(match, null)) {\n                    throw new System.ArgumentNullException(\"match\");\n                }\n\n                var freeIndex = 0; // the first free slot in items array\n\n                // Find the first item which needs to be removed.\n                while (freeIndex < this._size && !match(this._items[System.Array.index(freeIndex, this._items)])) {\n                    freeIndex = (freeIndex + 1) | 0;\n                }\n                if (freeIndex >= this._size) {\n                    return 0;\n                }\n\n                var current = (freeIndex + 1) | 0;\n                while (current < this._size) {\n                    // Find the first item which needs to be kept.\n                    while (current < this._size && match(this._items[System.Array.index(current, this._items)])) {\n                        current = (current + 1) | 0;\n                    }\n\n                    if (current < this._size) {\n                        // copy item to the free slot.\n                        this._items[System.Array.index(Bridge.identity(freeIndex, (freeIndex = (freeIndex + 1) | 0)), this._items)] = this._items[System.Array.index(Bridge.identity(current, (current = (current + 1) | 0)), this._items)];\n                    }\n                }\n\n                System.Array.fill(this._items, Bridge.getDefaultValue(T), freeIndex, ((this._size - freeIndex) | 0));\n                var result = (this._size - freeIndex) | 0;\n                this._size = freeIndex;\n                this._version = (this._version + 1) | 0;\n                return result;\n            },\n            removeAt: function (index) {\n                if ((index >>> 0) >= (this._size >>> 0)) {\n                    throw new System.ArgumentOutOfRangeException();\n                }\n                this._size = (this._size - 1) | 0;\n                if (index < this._size) {\n                    System.Array.copy(this._items, ((index + 1) | 0), this._items, index, ((this._size - index) | 0));\n                }\n                this._items[System.Array.index(this._size, this._items)] = Bridge.getDefaultValue(T);\n                this._version = (this._version + 1) | 0;\n            },\n            removeRange: function (index, count) {\n                if (index < 0) {\n                    throw new System.ArgumentOutOfRangeException(\"index\");\n                }\n\n                if (count < 0) {\n                    throw new System.ArgumentOutOfRangeException(\"count\");\n                }\n\n                if (((this._size - index) | 0) < count) {\n                    throw new System.ArgumentException();\n                }\n\n                if (count > 0) {\n                    var i = this._size;\n                    this._size = (this._size - count) | 0;\n                    if (index < this._size) {\n                        System.Array.copy(this._items, ((index + count) | 0), this._items, index, ((this._size - index) | 0));\n                    }\n                    System.Array.fill(this._items, Bridge.getDefaultValue(T), this._size, count);\n                    this._version = (this._version + 1) | 0;\n                }\n            },\n            reverse: function () {\n                this.reverse$1(0, this.Count);\n            },\n            reverse$1: function (index, count) {\n                if (index < 0) {\n                    throw new System.ArgumentOutOfRangeException(\"index\");\n                }\n\n                if (count < 0) {\n                    throw new System.ArgumentOutOfRangeException(\"count\");\n                }\n\n                if (((this._size - index) | 0) < count) {\n                    throw new System.ArgumentException();\n                }\n                System.Array.reverse(this._items, index, count);\n                this._version = (this._version + 1) | 0;\n            },\n            sort: function () {\n                this.sort$3(0, this.Count, null);\n            },\n            sort$1: function (comparer) {\n                this.sort$3(0, this.Count, comparer);\n            },\n            sort$3: function (index, count, comparer) {\n                if (index < 0) {\n                    throw new System.ArgumentOutOfRangeException(\"index\");\n                }\n\n                if (count < 0) {\n                    throw new System.ArgumentOutOfRangeException(\"count\");\n                }\n\n                if (((this._size - index) | 0) < count) {\n                    throw new System.ArgumentException();\n                }\n\n                System.Array.sort(this._items, index, count, comparer);\n                this._version = (this._version + 1) | 0;\n            },\n            sort$2: function (comparison) {\n                if (Bridge.staticEquals(comparison, null)) {\n                    throw new System.ArgumentNullException(\"comparison\");\n                }\n\n                if (this._size > 0) {\n                    if (this._items.length === this._size) {\n                        System.Array.sort(this._items, comparison);\n                    } else {\n                        var newItems = System.Array.init(this._size, function (){\n                            return Bridge.getDefaultValue(T);\n                        }, T);\n                        System.Array.copy(this._items, 0, newItems, 0, this._size);\n                        System.Array.sort(newItems, comparison);\n                        System.Array.copy(newItems, 0, this._items, 0, this._size);\n                    }\n                }\n            },\n            toArray: function () {\n\n                var array = System.Array.init(this._size, function (){\n                    return Bridge.getDefaultValue(T);\n                }, T);\n                System.Array.copy(this._items, 0, array, 0, this._size);\n                return array;\n            },\n            trimExcess: function () {\n                var threshold = Bridge.Int.clip32(this._items.length * 0.9);\n                if (this._size < threshold) {\n                    this.Capacity = this._size;\n                }\n            },\n            trueForAll: function (match) {\n                if (Bridge.staticEquals(match, null)) {\n                    throw new System.ArgumentNullException(\"match\");\n                }\n\n                for (var i = 0; i < this._size; i = (i + 1) | 0) {\n                    if (!match(this._items[System.Array.index(i, this._items)])) {\n                        return false;\n                    }\n                }\n                return true;\n            },\n            toJSON: function () {\n                var newItems = System.Array.init(this._size, function (){\n                    return Bridge.getDefaultValue(T);\n                }, T);\n                if (this._size > 0) {\n                    System.Array.copy(this._items, 0, newItems, 0, this._size);\n                }\n\n                return newItems;\n            }\n        }\n    }; });\n\n    // @source List.js\n\n    System.Collections.Generic.List$1.getElementType = function (type) {\n        var interfaceType;\n        if (System.String.startsWith(type.$$name, \"System.Collections.Generic.IList\")) {\n            interfaceType = type;\n        } else {\n            var interfaces = Bridge.Reflection.getInterfaces(type);\n\n            for (var j = 0; j < interfaces.length; j++) {\n                if (System.String.startsWith(interfaces[j].$$name, \"System.Collections.Generic.IList\")) {\n                    interfaceType = interfaces[j];\n                    break;\n                }\n            }\n        }\n\n        return interfaceType ? Bridge.Reflection.getGenericArguments(interfaceType)[0] : null;\n    };\n\n    // @source readOnlyCollection.js\n\n    Bridge.define(\"System.Collections.ObjectModel.ReadOnlyCollection$1\", function (T) { return {\n        inherits: [System.Collections.Generic.IList$1(T),System.Collections.IList,System.Collections.Generic.IReadOnlyList$1(T)],\n        statics: {\n            methods: {\n                isCompatibleObject: function (value) {\n                    // Non-null values are fine.  Only accept nulls if T is a class or Nullable<U>.\n                    // Note that default(T) is not equal to null for value types except when T is Nullable<U>. \n                    return ((Bridge.is(value, T)) || (value == null && Bridge.getDefaultValue(T) == null));\n                }\n            }\n        },\n        fields: {\n            list: null\n        },\n        props: {\n            Count: {\n                get: function () {\n                    return System.Array.getCount(this.list, T);\n                }\n            },\n            Items: {\n                get: function () {\n                    return this.list;\n                }\n            },\n            System$Collections$Generic$ICollection$1$IsReadOnly: {\n                get: function () {\n                    return true;\n                }\n            },\n            System$Collections$IList$IsReadOnly: {\n                get: function () {\n                    return true;\n                }\n            }\n        },\n        alias: [\n            \"Count\", \"System$Collections$Generic$IReadOnlyCollection$1$\" + Bridge.getTypeAlias(T) + \"$Count\",\n            \"Count\", \"System$Collections$ICollection$Count\",\n            \"Count\", \"System$Collections$Generic$ICollection$1$\" + Bridge.getTypeAlias(T) + \"$Count\",\n            \"getItem\", \"System$Collections$Generic$IReadOnlyList$1$\" + Bridge.getTypeAlias(T) + \"$getItem\",\n            \"contains\", \"System$Collections$Generic$ICollection$1$\" + Bridge.getTypeAlias(T) + \"$contains\",\n            \"copyTo\", \"System$Collections$Generic$ICollection$1$\" + Bridge.getTypeAlias(T) + \"$copyTo\",\n            \"getEnumerator\", [\"System$Collections$Generic$IEnumerable$1$\" + Bridge.getTypeAlias(T) + \"$getEnumerator\", \"System$Collections$Generic$IEnumerable$1$getEnumerator\"],\n            \"indexOf\", \"System$Collections$Generic$IList$1$\" + Bridge.getTypeAlias(T) + \"$indexOf\",\n            \"System$Collections$Generic$ICollection$1$IsReadOnly\", \"System$Collections$Generic$ICollection$1$\" + Bridge.getTypeAlias(T) + \"$IsReadOnly\",\n            \"System$Collections$Generic$IList$1$getItem\", \"System$Collections$Generic$IList$1$\" + Bridge.getTypeAlias(T) + \"$getItem\",\n            \"System$Collections$Generic$IList$1$setItem\", \"System$Collections$Generic$IList$1$\" + Bridge.getTypeAlias(T) + \"$setItem\",\n            \"System$Collections$Generic$ICollection$1$add\", \"System$Collections$Generic$ICollection$1$\" + Bridge.getTypeAlias(T) + \"$add\",\n            \"System$Collections$Generic$ICollection$1$clear\", \"System$Collections$Generic$ICollection$1$\" + Bridge.getTypeAlias(T) + \"$clear\",\n            \"System$Collections$Generic$IList$1$insert\", \"System$Collections$Generic$IList$1$\" + Bridge.getTypeAlias(T) + \"$insert\",\n            \"System$Collections$Generic$ICollection$1$remove\", \"System$Collections$Generic$ICollection$1$\" + Bridge.getTypeAlias(T) + \"$remove\",\n            \"System$Collections$Generic$IList$1$removeAt\", \"System$Collections$Generic$IList$1$\" + Bridge.getTypeAlias(T) + \"$removeAt\"\n        ],\n        ctors: {\n            ctor: function (list) {\n                this.$initialize();\n                if (list == null) {\n                    throw new System.ArgumentNullException(\"list\");\n                }\n                this.list = list;\n            }\n        },\n        methods: {\n            getItem: function (index) {\n                return System.Array.getItem(this.list, index, T);\n            },\n            System$Collections$Generic$IList$1$getItem: function (index) {\n                return System.Array.getItem(this.list, index, T);\n            },\n            System$Collections$Generic$IList$1$setItem: function (index, value) {\n                throw new System.NotSupportedException();\n            },\n            System$Collections$IList$getItem: function (index) {\n                return System.Array.getItem(this.list, index, T);\n            },\n            System$Collections$IList$setItem: function (index, value) {\n                throw new System.NotSupportedException();\n            },\n            contains: function (value) {\n                return System.Array.contains(this.list, value, T);\n            },\n            System$Collections$IList$contains: function (value) {\n                if (System.Collections.ObjectModel.ReadOnlyCollection$1(T).isCompatibleObject(value)) {\n                    return this.contains(Bridge.cast(Bridge.unbox(value), T));\n                }\n                return false;\n            },\n            copyTo: function (array, index) {\n                System.Array.copyTo(this.list, array, index, T);\n            },\n            System$Collections$ICollection$copyTo: function (array, index) {\n                if (array == null) {\n                    throw new System.ArgumentNullException(\"array\");\n                }\n\n                if (System.Array.getRank(array) !== 1) {\n                    throw new System.ArgumentException(\"array\");\n                }\n\n                if (System.Array.getLower(array, 0) !== 0) {\n                    throw new System.ArgumentException(\"array\");\n                }\n\n                if (index < 0) {\n                    throw new System.ArgumentOutOfRangeException(\"index\");\n                }\n\n                if (((array.length - index) | 0) < this.Count) {\n                    throw new System.ArgumentException();\n                }\n\n                var items = Bridge.as(array, System.Array.type(T));\n                if (items != null) {\n                    System.Array.copyTo(this.list, items, index, T);\n                } else {\n                    //\n                    // Catch the obvious case assignment will fail.\n                    // We can found all possible problems by doing the check though.\n                    // For example, if the element type of the Array is derived from T,\n                    // we can't figure out if we can successfully copy the element beforehand.\n                    //\n                    var targetType = (Bridge.getType(array).$elementType || null);\n                    var sourceType = T;\n                    if (!(Bridge.Reflection.isAssignableFrom(targetType, sourceType) || Bridge.Reflection.isAssignableFrom(sourceType, targetType))) {\n                        throw new System.ArgumentException();\n                    }\n\n                    //\n                    // We can't cast array of value type to object[], so we don't support \n                    // widening of primitive types here.\n                    //\n                    var objects = Bridge.as(array, System.Array.type(System.Object));\n                    if (objects == null) {\n                        throw new System.ArgumentException();\n                    }\n\n                    var count = System.Array.getCount(this.list, T);\n                    for (var i = 0; i < count; i = (i + 1) | 0) {\n                        objects[System.Array.index(Bridge.identity(index, (index = (index + 1) | 0)), objects)] = System.Array.getItem(this.list, i, T);\n                    }\n                }\n            },\n            getEnumerator: function () {\n                return Bridge.getEnumerator(this.list, T);\n            },\n            System$Collections$IEnumerable$getEnumerator: function () {\n                return Bridge.getEnumerator(Bridge.cast(this.list, System.Collections.IEnumerable));\n            },\n            indexOf: function (value) {\n                return System.Array.indexOf(this.list, value, 0, null, T);\n            },\n            System$Collections$IList$indexOf: function (value) {\n                if (System.Collections.ObjectModel.ReadOnlyCollection$1(T).isCompatibleObject(value)) {\n                    return this.indexOf(Bridge.cast(Bridge.unbox(value), T));\n                }\n                return -1;\n            },\n            System$Collections$Generic$ICollection$1$add: function (value) {\n                throw new System.NotSupportedException();\n            },\n            System$Collections$IList$add: function (value) {\n                throw new System.NotSupportedException();\n            },\n            System$Collections$Generic$ICollection$1$clear: function () {\n                throw new System.NotSupportedException();\n            },\n            System$Collections$IList$clear: function () {\n                throw new System.NotSupportedException();\n            },\n            System$Collections$Generic$IList$1$insert: function (index, value) {\n                throw new System.NotSupportedException();\n            },\n            System$Collections$IList$insert: function (index, value) {\n                throw new System.NotSupportedException();\n            },\n            System$Collections$Generic$ICollection$1$remove: function (value) {\n                throw new System.NotSupportedException();\n            },\n            System$Collections$IList$remove: function (value) {\n                throw new System.NotSupportedException();\n            },\n            System$Collections$Generic$IList$1$removeAt: function (index) {\n                throw new System.NotSupportedException();\n            },\n            System$Collections$IList$removeAt: function (index) {\n                throw new System.NotSupportedException();\n            }\n        }\n    }; });\n\n    // @source String.js\n\nBridge.define(\"System.String\", {\n    inherits: [System.IComparable, System.ICloneable, System.Collections.IEnumerable, System.Collections.Generic.IEnumerable$1(System.Char)],\n\n    statics: {\n        $is: function (instance) {\n            return typeof (instance) === \"string\";\n        },\n\n        charCodeAt: function (str, idx) {\n            idx = idx || 0;\n            var code = str.charCodeAt(idx),\n                hi,\n                low;\n\n            if (0xD800 <= code && code <= 0xDBFF) {\n                hi = code;\n                low = str.charCodeAt(idx + 1);\n                if (isNaN(low)) {\n                    throw new System.Exception(\"High surrogate not followed by low surrogate\");\n                }\n\n                return ((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000;\n            }\n\n            if (0xDC00 <= code && code <= 0xDFFF) {\n                return false;\n            }\n\n            return code;\n        },\n\n        fromCharCode: function (codePt) {\n            if (codePt > 0xFFFF) {\n                codePt -= 0x10000;\n                return String.fromCharCode(0xD800 + (codePt >> 10), 0xDC00 + (codePt & 0x3FF));\n            }\n\n            return String.fromCharCode(codePt);\n        },\n\n        fromCharArray: function (chars, startIndex, length) {\n            if (chars == null) {\n                throw new System.ArgumentNullException(\"chars\");\n            }                \n\n            if (startIndex < 0) {\n                throw new System.ArgumentOutOfRangeException(\"startIndex\");\n            }\n                \n            if (length < 0) {\n                throw new System.ArgumentOutOfRangeException(\"length\");\n            }\n                \n            if (chars.length - startIndex < length) {\n                throw new System.ArgumentOutOfRangeException(\"startIndex\");\n            }                \n\n            var result = \"\";\n\n            startIndex = startIndex || 0;\n            length = Bridge.isNumber(length) ? length : chars.length;\n\n            if ((startIndex + length) > chars.length) {\n                length = chars.length - startIndex;\n            }\n\n            for (var i = 0; i < length; i++) {\n                var ch = chars[i + startIndex] | 0;\n                result += String.fromCharCode(ch);\n            }\n\n            return result;\n        },\n\n        lastIndexOf: function (s, search, startIndex, count) {\n            var index = s.lastIndexOf(search, startIndex);\n\n            return (index < (startIndex - count + 1)) ? -1 : index;\n        },\n\n        lastIndexOfAny: function (s, chars, startIndex, count) {\n            var length = s.length;\n\n            if (!length) {\n                return -1;\n            }\n\n            chars = String.fromCharCode.apply(null, chars);\n            startIndex = startIndex || length - 1;\n            count = count || length;\n\n            var endIndex = startIndex - count + 1;\n\n            if (endIndex < 0) {\n                endIndex = 0;\n            }\n\n            for (var i = startIndex; i >= endIndex; i--) {\n                if (chars.indexOf(s.charAt(i)) >= 0) {\n                    return i;\n                }\n            }\n\n            return -1;\n        },\n\n        isNullOrWhiteSpace: function (s) {\n            if (!s) {\n                return true;\n            }\n\n            return System.Char.isWhiteSpace(s);\n        },\n\n        isNullOrEmpty: function (s) {\n            return !s;\n        },\n\n        fromCharCount: function (c, count) {\n            if (count >= 0) {\n                return String(Array(count + 1).join(String.fromCharCode(c)));\n            } else {\n                throw new System.ArgumentOutOfRangeException(\"count\", \"cannot be less than zero\");\n            }\n        },\n\n        format: function (format, args) {\n            return System.String._format(System.Globalization.CultureInfo.getCurrentCulture(), format, !Array.isArray(args) ? Array.prototype.slice.call(arguments, 1) : args);\n        },\n\n        formatProvider: function (provider, format, args) {\n            return System.String._format(provider, format, !Array.isArray(args) ? Array.prototype.slice.call(arguments, 2) : args);\n        },\n\n        _format: function (provider, format, args) {\n            if (format == null) {\n                throw new System.ArgumentNullException(\"format\");\n            }\n\n            var me = this,\n                _formatRe = /(\\{+)((\\d+|[a-zA-Z_$]\\w+(?:\\.[a-zA-Z_$]\\w+|\\[\\d+\\])*)(?:\\,(-?\\d*))?(?:\\:([^\\}]*))?)(\\}+)|(\\{+)|(\\}+)/g,\n                fn = this.decodeBraceSequence;\n\n            return format.replace(_formatRe, function (m, openBrace, elementContent, index, align, format, closeBrace, repeatOpenBrace, repeatCloseBrace) {\n                if (repeatOpenBrace) {\n                    return fn(repeatOpenBrace);\n                }\n\n                if (repeatCloseBrace) {\n                    return fn(repeatCloseBrace);\n                }\n\n                if (openBrace.length % 2 === 0 || closeBrace.length % 2 === 0) {\n                    return fn(openBrace) + elementContent + fn(closeBrace);\n                }\n\n                return fn(openBrace, true) + me.handleElement(provider, index, align, format, args) + fn(closeBrace, true);\n            });\n        },\n\n        handleElement: function (provider, index, alignment, formatStr, args) {\n            var value;\n\n            index = parseInt(index, 10);\n\n            if (index > args.length - 1) {\n                throw new System.FormatException(\"Input string was not in a correct format.\");\n            }\n\n            value = args[index];\n\n            if (value == null) {\n                value = \"\";\n            }\n\n            if (formatStr && value.$boxed && value.type.$kind === \"enum\") {\n                value = System.Enum.format(value.type, value.v, formatStr);\n            } else if (formatStr && value.$boxed && value.type.format) {\n                value = value.type.format(Bridge.unbox(value, true), formatStr, provider);\n            } else if (formatStr && Bridge.is(value, System.IFormattable)) {\n                value = Bridge.format(Bridge.unbox(value, true), formatStr, provider);\n            } if (Bridge.isNumber(value)) {\n                value = Bridge.Int.format(value, formatStr, provider);\n            } else if (Bridge.isDate(value)) {\n                value = System.DateTime.format(value, formatStr, provider);\n            } else {\n                value = \"\" + value.toString();\n            }\n\n            if (alignment) {\n                alignment = parseInt(alignment, 10);\n\n                if (!Bridge.isNumber(alignment)) {\n                    alignment = null;\n                }\n            }\n\n            return System.String.alignString(value.toString(), alignment);\n        },\n\n        decodeBraceSequence: function (braces, remove) {\n            return braces.substr(0, (braces.length + (remove ? 0 : 1)) / 2);\n        },\n\n        alignString: function (str, alignment, pad, dir, cut) {\n            if (str == null || !alignment) {\n                return str;\n            }\n\n            if (!pad) {\n                pad = \" \";\n            }\n\n            if (Bridge.isNumber(pad)) {\n                pad = String.fromCharCode(pad);\n            }\n\n            if (!dir) {\n                dir = alignment < 0 ? 1 : 2;\n            }\n\n            alignment = Math.abs(alignment);\n\n            if (cut && (str.length > alignment)) {\n                str = str.substring(0, alignment);\n            }\n\n            if (alignment + 1 >= str.length) {\n                switch (dir) {\n                    case 2:\n                        str = Array(alignment + 1 - str.length).join(pad) + str;\n                        break;\n\n                    case 3:\n                        var padlen = alignment - str.length,\n                            right = Math.ceil(padlen / 2),\n                            left = padlen - right;\n\n                        str = Array(left + 1).join(pad) + str + Array(right + 1).join(pad);\n                        break;\n\n                    case 1:\n                    default:\n                        str = str + Array(alignment + 1 - str.length).join(pad);\n                        break;\n                }\n            }\n\n            return str;\n        },\n\n        startsWith: function (str, prefix) {\n            if (!prefix.length) {\n                return true;\n            }\n\n            if (prefix.length > str.length) {\n                return false;\n            }\n\n            prefix = System.String.escape(prefix);\n\n            return str.match(\"^\" + prefix) !== null;\n        },\n\n        endsWith: function (str, suffix) {\n            if (!suffix.length) {\n                return true;\n            }\n\n            if (suffix.length > str.length) {\n                return false;\n            }\n\n            suffix = System.String.escape(suffix);\n\n            return str.match(suffix + \"$\") !== null;\n        },\n\n        contains: function (str, value) {\n            if (value == null) {\n                throw new System.ArgumentNullException();\n            }\n\n            if (str == null) {\n                return false;\n            }\n\n            return str.indexOf(value) > -1;\n        },\n\n        indexOfAny: function (str, anyOf) {\n            if (anyOf == null) {\n                throw new System.ArgumentNullException();\n            }\n\n            if (str == null || str === \"\") {\n                return -1;\n            }\n\n            var startIndex = (arguments.length > 2) ? arguments[2] : 0;\n\n            if (startIndex < 0) {\n                throw new System.ArgumentOutOfRangeException(\"startIndex\", \"startIndex cannot be less than zero\");\n            }\n\n            var length = (arguments.length > 3) ? arguments[3] : str.length - startIndex;\n\n            if (length < 0) {\n                throw new System.ArgumentOutOfRangeException(\"length\", \"must be non-negative\");\n            }\n\n            if (length > str.length - startIndex) {\n                throw new System.ArgumentOutOfRangeException(\"Index and length must refer to a location within the string\");\n            }\n\n            var s = str.substr(startIndex, length);\n\n            for (var i = 0; i < anyOf.length; i++) {\n                var c = String.fromCharCode(anyOf[i]),\n                    index = s.indexOf(c);\n\n                if (index > -1) {\n                    return index + startIndex;\n                }\n            }\n\n            return -1;\n        },\n\n        indexOf: function (str, value) {\n            if (value == null) {\n                throw new System.ArgumentNullException();\n            }\n\n            if (str == null || str === \"\") {\n                return -1;\n            }\n\n            var startIndex = (arguments.length > 2) ? arguments[2] : 0;\n\n            if (startIndex < 0 || startIndex > str.length) {\n                throw new System.ArgumentOutOfRangeException(\"startIndex\", \"startIndex cannot be less than zero and must refer to a location within the string\");\n            }\n\n            if (value === \"\") {\n                return (arguments.length > 2) ? startIndex : 0;\n            }\n\n            var length = (arguments.length > 3) ? arguments[3] : str.length - startIndex;\n\n            if (length < 0) {\n                throw new System.ArgumentOutOfRangeException(\"length\", \"must be non-negative\");\n            }\n\n            if (length > str.length - startIndex) {\n                throw new System.ArgumentOutOfRangeException(\"Index and length must refer to a location within the string\");\n            }\n\n            var s = str.substr(startIndex, length),\n                index = (arguments.length === 5 && arguments[4] % 2 !== 0) ? s.toLocaleUpperCase().indexOf(value.toLocaleUpperCase()) : s.indexOf(value);\n\n            if (index > -1) {\n                if (arguments.length === 5) {\n                    // StringComparison\n                    return (System.String.compare(value, s.substr(index, value.length), arguments[4]) === 0) ? index + startIndex : -1;\n                } else {\n                    return index + startIndex;\n                }\n            }\n\n            return -1;\n        },\n\n        equals: function () {\n            return System.String.compare.apply(this, arguments) === 0;\n        },\n\n        compare: function (strA, strB) {\n            if (strA == null) {\n                return (strB == null) ? 0 : -1;\n            }\n\n            if (strB == null) {\n                return 1;\n            }\n\n            if (arguments.length >= 3) {\n                if (!Bridge.isBoolean(arguments[2])) {\n                    // StringComparison\n                    switch (arguments[2]) {\n                        case 1: // CurrentCultureIgnoreCase\n                            return strA.localeCompare(strB, System.Globalization.CultureInfo.getCurrentCulture().name, {\n                                sensitivity: \"accent\"\n                            });\n                        case 2: // InvariantCulture\n                            return strA.localeCompare(strB, System.Globalization.CultureInfo.invariantCulture.name);\n                        case 3: // InvariantCultureIgnoreCase\n                            return strA.localeCompare(strB, System.Globalization.CultureInfo.invariantCulture.name, {\n                                sensitivity: \"accent\"\n                            });\n                        case 4: // Ordinal\n                            return (strA === strB) ? 0 : ((strA > strB) ? 1 : -1);\n                        case 5: // OrdinalIgnoreCase\n                            return (strA.toUpperCase() === strB.toUpperCase()) ? 0 : ((strA.toUpperCase() > strB.toUpperCase()) ? 1 : -1);\n                        case 0: // CurrentCulture\n                        default:\n                            break;\n                    }\n                } else {\n                    // ignoreCase\n                    if (arguments[2]) {\n                        strA = strA.toLocaleUpperCase();\n                        strB = strB.toLocaleUpperCase();\n                    }\n\n                    if (arguments.length === 4) {\n                        // CultureInfo\n                        return strA.localeCompare(strB, arguments[3].name);\n                    }\n                }\n            }\n\n            return strA.localeCompare(strB);\n        },\n\n        toCharArray: function (str, startIndex, length) {\n            if (startIndex < 0 || startIndex > str.length || startIndex > str.length - length) {\n                throw new System.ArgumentOutOfRangeException(\"startIndex\", \"startIndex cannot be less than zero and must refer to a location within the string\");\n            }\n\n            if (length < 0) {\n                throw new System.ArgumentOutOfRangeException(\"length\", \"must be non-negative\");\n            }\n\n            if (!Bridge.hasValue(startIndex)) {\n                startIndex = 0;\n            }\n\n            if (!Bridge.hasValue(length)) {\n                length = str.length;\n            }\n\n            var arr = [];\n\n            for (var i = startIndex; i < startIndex + length; i++) {\n                arr.push(str.charCodeAt(i));\n            }\n\n            return arr;\n        },\n\n        escape: function (str) {\n            return str.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, \"\\\\$&\");\n        },\n\n        replaceAll: function (str, a, b) {\n            var reg = new RegExp(System.String.escape(a), \"g\");\n\n            return str.replace(reg, b);\n        },\n\n        insert: function (index, strA, strB) {\n            return index > 0 ? (strA.substring(0, index) + strB + strA.substring(index, strA.length)) : (strB + strA);\n        },\n\n        remove: function (s, index, count) {\n            if (s == null) {\n                throw new System.NullReferenceException();\n            }\n\n            if (index < 0) {\n                throw new System.ArgumentOutOfRangeException(\"startIndex\", \"StartIndex cannot be less than zero\");\n            }\n\n            if (count != null) {\n                if (count < 0) {\n                    throw new System.ArgumentOutOfRangeException(\"count\", \"Count cannot be less than zero\");\n                }\n\n                if (count > s.length - index) {\n                    throw new System.ArgumentOutOfRangeException(\"count\", \"Index and count must refer to a location within the string\");\n                }\n            } else {\n                if (index >= s.length) {\n                    throw new System.ArgumentOutOfRangeException(\"startIndex\", \"startIndex must be less than length of string\");\n                }\n            }\n\n            if (count == null || ((index + count) > s.length)) {\n                return s.substr(0, index);\n            }\n\n            return s.substr(0, index) + s.substr(index + count);\n        },\n\n        split: function (s, strings, limit, options) {\n            var re = (!Bridge.hasValue(strings) || strings.length === 0) ? new RegExp(\"\\\\s\", \"g\") : new RegExp(strings.map(System.String.escape).join('|'), 'g'),\n                res = [],\n                m,\n                i;\n\n            for (i = 0; ; i = re.lastIndex) {\n                if (m = re.exec(s)) {\n                    if (options !== 1 || m.index > i) {\n                        if (res.length === limit - 1) {\n                            res.push(s.substr(i));\n\n                            return res;\n                        } else {\n                            res.push(s.substring(i, m.index));\n                        }\n                    }\n                } else {\n                    if (options !== 1 || i !== s.length) {\n                        res.push(s.substr(i));\n                    }\n\n                    return res;\n                }\n            }\n        },\n\n        trimEnd: function (str, chars) {\n            return str.replace(chars ? new RegExp('[' + System.String.escape(String.fromCharCode.apply(null, chars)) + ']+$') : /\\s*$/, '');\n        },\n\n        trimStart: function (str, chars) {\n            return str.replace(chars ? new RegExp('^[' + System.String.escape(String.fromCharCode.apply(null, chars)) + ']+') : /^\\s*/, '');\n        },\n\n        trim: function (str, chars) {\n            return System.String.trimStart(System.String.trimEnd(str, chars), chars);\n        },\n\n        trimStartZeros: function (str) {\n            return str.replace(new RegExp('^[ 0+]+(?=.)'), '');\n        },\n\n        concat: function (values) {\n            var list = (arguments.length == 1 && Array.isArray(values)) ? values : [].slice.call(arguments),\n                s = \"\";\n\n            for (var i = 0; i < list.length; i++) {\n                s += list[i] == null ? \"\" : list[i].toString();\n            }\n\n            return s;\n        },\n\n        copyTo: function (str, sourceIndex, destination, destinationIndex, count) {\n            if (destination == null) {\n                throw new System.ArgumentNullException(\"destination\");\n            }\n\n            if (str == null) {\n                throw new System.ArgumentNullException(\"str\");\n            }\n\n            if (count < 0) {\n                throw new System.ArgumentOutOfRangeException(\"count\");\n            }\n\n            if (sourceIndex < 0) {\n                throw new System.ArgumentOutOfRangeException(\"sourceIndex\");\n            }\n\n            if (count > str.length - sourceIndex) {\n                throw new System.ArgumentOutOfRangeException(\"sourceIndex\");\n            }\n\n            if (destinationIndex > destination.length - count || destinationIndex < 0) {\n                throw new System.ArgumentOutOfRangeException(\"destinationIndex\");\n            }\n\n            if (count > 0) {\n                for (var i = 0; i < count; i++) {\n                    destination[destinationIndex + i] = str.charCodeAt(sourceIndex + i);\n                }\n            }\n        }\n    }\n});\n\nBridge.Class.addExtend(System.String, [System.IComparable$1(System.String), System.IEquatable$1(System.String)]);\n\n    // @source Task.js\n\n    Bridge.define(\"System.Threading.Tasks.Task\", {\n        inherits: [System.IDisposable],\n\n        config: {\n            alias: [\n                \"dispose\", \"System$IDisposable$dispose\"\n            ]\n        },\n\n        ctor: function (action, state) {\n            this.$initialize();\n            this.action = action;\n            this.state = state;\n            this.exception = null;\n            this.status = System.Threading.Tasks.TaskStatus.created;\n            this.callbacks = [];\n            this.result = null;\n        },\n\n        statics: {\n            delay: function (delay, state) {\n                var tcs = new System.Threading.Tasks.TaskCompletionSource();\n\n                setTimeout(function () {\n                    tcs.setResult(state);\n                }, delay);\n\n                return tcs.task;\n            },\n\n            fromResult: function (result) {\n                var t = new System.Threading.Tasks.Task();\n\n                t.status = System.Threading.Tasks.TaskStatus.ranToCompletion;\n                t.result = result;\n\n                return t;\n            },\n\n            run: function (fn) {\n                var tcs = new System.Threading.Tasks.TaskCompletionSource();\n\n                setTimeout(function () {\n                    try {\n                        tcs.setResult(fn());\n                    } catch (e) {\n                        tcs.setException(System.Exception.create(e));\n                    }\n                }, 0);\n\n                return tcs.task;\n            },\n\n            whenAll: function (tasks) {\n                var tcs = new System.Threading.Tasks.TaskCompletionSource(),\n                    result,\n                    executing,\n                    cancelled = false,\n                    exceptions = [],\n                    i;\n\n                if (Bridge.is(tasks, System.Collections.IEnumerable)) {\n                    tasks = Bridge.toArray(tasks);\n                } else if (!Bridge.isArray(tasks)) {\n                    tasks = Array.prototype.slice.call(arguments, 0);\n                }\n\n                if (tasks.length === 0) {\n                    tcs.setResult([]);\n\n                    return tcs.task;\n                }\n\n                executing = tasks.length;\n                result = new Array(tasks.length);\n\n                for (i = 0; i < tasks.length; i++) {\n                    (function (i) {\n                        tasks[i].continueWith(function (t) {\n                            switch (t.status) {\n                                case System.Threading.Tasks.TaskStatus.ranToCompletion:\n                                    result[i] = t.getResult();\n                                    break;\n                                case System.Threading.Tasks.TaskStatus.canceled:\n                                    cancelled = true;\n                                    break;\n                                case System.Threading.Tasks.TaskStatus.faulted:\n                                    System.Array.addRange(exceptions, t.exception.innerExceptions);\n                                    break;\n                                default:\n                                    throw new System.InvalidOperationException(\"Invalid task status: \" + t.status);\n                            }\n\n                            if (--executing === 0) {\n                                if (exceptions.length > 0) {\n                                    tcs.setException(exceptions);\n                                } else if (cancelled) {\n                                    tcs.setCanceled();\n                                } else {\n                                    tcs.setResult(result);\n                                }\n                            }\n                        });\n                    })(i);\n                }\n\n                return tcs.task;\n            },\n\n            whenAny: function (tasks) {\n                if (Bridge.is(tasks, System.Collections.IEnumerable)) {\n                    tasks = Bridge.toArray(tasks);\n                } else if (!Bridge.isArray(tasks)) {\n                    tasks = Array.prototype.slice.call(arguments, 0);\n                }\n\n                if (!tasks.length) {\n                    throw new System.ArgumentException(\"At least one task is required\");\n                }\n\n                var tcs = new System.Threading.Tasks.TaskCompletionSource(),\n                    i;\n\n                for (i = 0; i < tasks.length; i++) {\n                    tasks[i].continueWith(function (t) {\n                        switch (t.status) {\n                            case System.Threading.Tasks.TaskStatus.ranToCompletion:\n                                tcs.trySetResult(t);\n                                break;\n                            case System.Threading.Tasks.TaskStatus.canceled:\n                                tcs.trySetCanceled();\n                                break;\n                            case System.Threading.Tasks.TaskStatus.faulted:\n                                tcs.trySetException(t.exception.innerExceptions);\n                                break;\n                            default:\n                                throw new System.InvalidOperationException(\"Invalid task status: \" + t.status);\n                        }\n                    });\n                }\n\n                return tcs.task;\n            },\n\n            fromCallback: function (target, method) {\n                var tcs = new System.Threading.Tasks.TaskCompletionSource(),\n                    args = Array.prototype.slice.call(arguments, 2),\n                    callback;\n\n                callback = function (value) {\n                    tcs.setResult(value);\n                };\n\n                args.push(callback);\n\n                target[method].apply(target, args);\n\n                return tcs.task;\n            },\n\n            fromCallbackResult: function (target, method, resultHandler) {\n                var tcs = new System.Threading.Tasks.TaskCompletionSource(),\n                    args = Array.prototype.slice.call(arguments, 3),\n                    callback;\n\n                callback = function (value) {\n                    tcs.setResult(value);\n                };\n\n                resultHandler(args, callback);\n\n                target[method].apply(target, args);\n\n                return tcs.task;\n            },\n\n            fromCallbackOptions: function (target, method, name) {\n                var tcs = new System.Threading.Tasks.TaskCompletionSource(),\n                    args = Array.prototype.slice.call(arguments, 3),\n                    callback;\n\n                callback = function (value) {\n                    tcs.setResult(value);\n                };\n\n                args[0] = args[0] || {};\n                args[0][name] = callback;\n\n                target[method].apply(target, args);\n\n                return tcs.task;\n            },\n\n            fromPromise: function (promise, handler, errorHandler, progressHandler) {\n                var tcs = new System.Threading.Tasks.TaskCompletionSource();\n\n                if (!promise.then) {\n                    promise = promise.promise();\n                }\n\n                if (typeof (handler) === 'number') {\n                    handler = (function (i) {\n                        return function () {\n                            return arguments[i >= 0 ? i : (arguments.length + i)];\n                        };\n                    })(handler);\n                } else if (typeof (handler) !== 'function') {\n                    handler = function () {\n                        return Array.prototype.slice.call(arguments, 0);\n                    };\n                }\n\n                promise.then(function () {\n                    tcs.setResult(handler ? handler.apply(null, arguments) : Array.prototype.slice.call(arguments, 0));\n                }, function () {\n                    tcs.setException(errorHandler ? errorHandler.apply(null, arguments) : new Bridge.PromiseException(Array.prototype.slice.call(arguments, 0)));\n                }, progressHandler);\n\n                return tcs.task;\n            }\n        },\n\n        continueWith: function (continuationAction, raise) {\n            var tcs = new System.Threading.Tasks.TaskCompletionSource(),\n                me = this,\n                fn = raise ? function () {\n                    tcs.setResult(continuationAction(me));\n                } : function () {\n                    try {\n                        tcs.setResult(continuationAction(me));\n                    } catch (e) {\n                        tcs.setException(System.Exception.create(e));\n                    }\n                };\n\n            if (this.isCompleted()) {\n                setTimeout(fn, 0);\n            } else {\n                this.callbacks.push(fn);\n            }\n\n            return tcs.task;\n        },\n\n        start: function () {\n            if (this.status !== System.Threading.Tasks.TaskStatus.created) {\n                throw new System.InvalidOperationException(\"Task was already started.\");\n            }\n\n            var me = this;\n\n            this.status = System.Threading.Tasks.TaskStatus.running;\n\n            setTimeout(function () {\n                try {\n                    var result = me.action(me.state);\n\n                    delete me.action;\n                    delete me.state;\n\n                    me.complete(result);\n                } catch (e) {\n                    me.fail(new System.AggregateException(null, [System.Exception.create(e)]));\n                }\n            }, 0);\n        },\n\n        runCallbacks: function () {\n            var me = this;\n\n            setTimeout(function () {\n                for (var i = 0; i < me.callbacks.length; i++) {\n                    me.callbacks[i](me);\n                }\n\n                delete me.callbacks;\n            }, 0);\n        },\n\n        complete: function (result) {\n            if (this.isCompleted()) {\n                return false;\n            }\n\n            this.result = result;\n            this.status = System.Threading.Tasks.TaskStatus.ranToCompletion;\n            this.runCallbacks();\n\n            return true;\n        },\n\n        fail: function (error) {\n            if (this.isCompleted()) {\n                return false;\n            }\n\n            this.exception = error;\n            this.status = System.Threading.Tasks.TaskStatus.faulted;\n            this.runCallbacks();\n\n            return true;\n        },\n\n        cancel: function () {\n            if (this.isCompleted()) {\n                return false;\n            }\n\n            this.status = System.Threading.Tasks.TaskStatus.canceled;\n            this.runCallbacks();\n\n            return true;\n        },\n\n        isCanceled: function () {\n            return this.status === System.Threading.Tasks.TaskStatus.canceled;\n        },\n\n        isCompleted: function () {\n            return this.status === System.Threading.Tasks.TaskStatus.ranToCompletion || this.status === System.Threading.Tasks.TaskStatus.canceled || this.status === System.Threading.Tasks.TaskStatus.faulted;\n        },\n\n        isFaulted: function () {\n            return this.status === System.Threading.Tasks.TaskStatus.faulted;\n        },\n\n        _getResult: function (awaiting) {\n            switch (this.status) {\n                case System.Threading.Tasks.TaskStatus.ranToCompletion:\n                    return this.result;\n                case System.Threading.Tasks.TaskStatus.canceled:\n                    var ex = new System.Threading.Tasks.TaskCanceledException(null, this);\n\n                    throw awaiting ? ex : new System.AggregateException(null, [ex]);\n                case System.Threading.Tasks.TaskStatus.faulted:\n                    throw awaiting ? (this.exception.innerExceptions.Count > 0 ? this.exception.innerExceptions.getItem(0) : null) : this.exception;\n                default:\n                    throw new System.InvalidOperationException(\"Task is not yet completed.\");\n            }\n        },\n\n        getResult: function () {\n            return this._getResult(false);\n        },\n\n        dispose: function () {},\n\n        getAwaiter: function () {\n            return this;\n        },\n\n        getAwaitedResult: function () {\n            return this._getResult(true);\n        }\n    });\n\n    Bridge.define(\"System.Threading.Tasks.Task$1\", function (T) {\n        return {\n            inherits: [System.Threading.Tasks.Task],\n            ctor: function(action, state) {\n                this.$initialize();\n                System.Threading.Tasks.Task.ctor.call(this, action, state);\n            }\n        };\n    });\n\n    Bridge.define(\"System.Threading.Tasks.TaskStatus\", {\n        $kind: \"enum\",\n        $statics: {\n            created: 0,\n            waitingForActivation: 1,\n            waitingToRun: 2,\n            running: 3,\n            waitingForChildrenToComplete: 4,\n            ranToCompletion: 5,\n            canceled: 6,\n            faulted: 7\n        }\n    });\n\n    Bridge.define(\"System.Threading.Tasks.TaskCompletionSource\", {\n        ctor: function () {\n            this.$initialize();\n            this.task = new System.Threading.Tasks.Task();\n            this.task.status = System.Threading.Tasks.TaskStatus.running;\n        },\n\n        setCanceled: function () {\n            if (!this.task.cancel()) {\n                throw new System.InvalidOperationException(\"Task was already completed.\");\n            }\n        },\n\n        setResult: function (result) {\n            if (!this.task.complete(result)) {\n                throw new System.InvalidOperationException(\"Task was already completed.\");\n            }\n        },\n\n        setException: function (exception) {\n            if (!this.trySetException(exception)) {\n                throw new System.InvalidOperationException(\"Task was already completed.\");\n            }\n        },\n\n        trySetCanceled: function () {\n            return this.task.cancel();\n        },\n\n        trySetResult: function (result) {\n            return this.task.complete(result);\n        },\n\n        trySetException: function (exception) {\n            if (Bridge.is(exception, System.Exception)) {\n                exception = [exception];\n            }\n\n            return this.task.fail(new System.AggregateException(null, exception));\n        }\n    });\n\n    Bridge.define(\"System.Threading.CancellationTokenSource\", {\n        inherits: [System.IDisposable],\n\n        config: {\n            alias: [\n                \"dispose\", \"System$IDisposable$dispose\"\n            ]\n        },\n\n        ctor: function (delay) {\n            this.$initialize();\n            this.timeout = typeof delay === \"number\" && delay >= 0 ? setTimeout(Bridge.fn.bind(this, this.cancel), delay, -1) : null;\n            this.isCancellationRequested = false;\n            this.token = new System.Threading.CancellationToken(this);\n            this.handlers = [];\n        },\n\n        cancel: function (throwFirst) {\n            if (this.isCancellationRequested) {\n                return;\n            }\n\n            this.isCancellationRequested = true;\n\n            var x = [],\n                h = this.handlers;\n\n            this.clean();\n\n            for (var i = 0; i < h.length; i++) {\n                try {\n                    h[i].f(h[i].s);\n                } catch (ex) {\n                    if (throwFirst && throwFirst !== -1) {\n                        throw ex;\n                    }\n\n                    x.push(ex);\n                }\n            }\n\n            if (x.length > 0 && throwFirst !== -1) {\n                throw new System.AggregateException(null, x);\n            }\n        },\n\n        cancelAfter: function (delay) {\n            if (this.isCancellationRequested) {\n                return;\n            }\n\n            if (this.timeout) {\n                clearTimeout(this.timeout);\n            }\n\n            this.timeout = setTimeout(Bridge.fn.bind(this, this.cancel), delay, -1);\n        },\n\n        register: function (f, s) {\n            if (this.isCancellationRequested) {\n                f(s);\n\n                return new System.Threading.CancellationTokenRegistration();\n            } else {\n                var o = {\n                    f: f,\n                    s: s\n                };\n                this.handlers.push(o);\n\n                return new System.Threading.CancellationTokenRegistration(this, o);\n            }\n        },\n\n        deregister: function (o) {\n            var ix = this.handlers.indexOf(o);\n\n            if (ix >= 0) {\n                this.handlers.splice(ix, 1);\n            }\n        },\n\n        dispose: function () {\n            this.clean();\n        },\n\n        clean: function () {\n            if (this.timeout) {\n                clearTimeout(this.timeout);\n            }\n\n            this.timeout = null;\n            this.handlers = [];\n\n            if (this.links) {\n                for (var i = 0; i < this.links.length; i++) {\n                    this.links[i].dispose();\n                }\n\n                this.links = null;\n            }\n        },\n\n        statics: {\n            createLinked: function () {\n                var cts = new System.Threading.CancellationTokenSource();\n\n                cts.links = [];\n\n                var d = Bridge.fn.bind(cts, cts.cancel);\n\n                for (var i = 0; i < arguments.length; i++) {\n                    cts.links.push(arguments[i].register(d));\n                }\n\n                return cts;\n            }\n        }\n    });\n\n    Bridge.define(\"System.Threading.CancellationToken\", {\n         $kind: \"struct\",\n\n        ctor: function (source) {\n            this.$initialize();\n\n            if (!Bridge.is(source, System.Threading.CancellationTokenSource)) {\n                source = source ? System.Threading.CancellationToken.sourceTrue : System.Threading.CancellationToken.sourceFalse;\n            }\n\n            this.source = source;\n        },\n\n        getCanBeCanceled: function () {\n            return !this.source.uncancellable;\n        },\n\n        getIsCancellationRequested: function () {\n            return this.source.isCancellationRequested;\n        },\n\n        throwIfCancellationRequested: function () {\n            if (this.source.isCancellationRequested) {\n                throw new System.OperationCanceledException(this);\n            }\n        },\n\n        register: function (cb, s) {\n            return this.source.register(cb, s);\n        },\n\n        getHashCode: function () {\n            return Bridge.getHashCode(this.source);\n        },\n\n        equals: function (other) {\n            return other.source === this.source;\n        },\n\n        equalsT: function (other) {\n            return other.source === this.source;\n        },\n\n        statics: {\n            sourceTrue: {\n                isCancellationRequested: true,\n                register: function (f, s) {\n                    f(s);\n\n                    return new System.Threading.CancellationTokenRegistration();\n                }\n            },\n            sourceFalse: {\n                uncancellable: true,\n                isCancellationRequested: false,\n                register: function () {\n                    return new System.Threading.CancellationTokenRegistration();\n                }\n            },\n            getDefaultValue: function () {\n                return new System.Threading.CancellationToken();\n            }\n        }\n    });\n\n    System.Threading.CancellationToken.none = new System.Threading.CancellationToken();\n\n    Bridge.define(\"System.Threading.CancellationTokenRegistration\", {\n        inherits: function () {\n            return [System.IDisposable, System.IEquatable$1(System.Threading.CancellationTokenRegistration)];\n        },\n\n        $kind: \"struct\",\n\n        config: {\n            alias: [\n                \"dispose\", \"System$IDisposable$dispose\"\n            ]\n        },\n\n        ctor: function (cts, o) {\n            this.$initialize();\n            this.cts = cts;\n            this.o = o;\n        },\n\n        dispose: function () {\n            if (this.cts) {\n                this.cts.deregister(this.o);\n                this.cts = this.o = null;\n            }\n        },\n\n        equalsT: function (o) {\n            return this === o;\n        },\n\n        equals: function (o) {\n            return this === o;\n        },\n\n        statics: {\n            getDefaultValue: function () {\n                return new System.Threading.CancellationTokenRegistration();\n            }\n        }\n    });\n    // @source Validation.js\n\n    var validation = {\n        isNull: function (value) {\n            return !Bridge.isDefined(value, true);\n        },\n\n        isEmpty: function (value) {\n            return value == null || value.length === 0 || Bridge.is(value, System.Collections.ICollection) ? value.getCount() === 0 : false;\n        },\n\n        isNotEmptyOrWhitespace: function (value) {\n            return Bridge.isDefined(value, true) && !(/^$|\\s+/.test(value));\n        },\n\n        isNotNull: function (value) {\n            return Bridge.isDefined(value, true);\n        },\n\n        isNotEmpty: function (value) {\n            return !Bridge.Validation.isEmpty(value);\n        },\n\n        email: function (value) {\n            var re = /^(\")?(?:[^\\.\"])(?:(?:[\\.])?(?:[\\w\\-!#$%&'*+/=?^_`{|}~]))*\\1@(\\w[\\-\\w]*\\.){1,5}([A-Za-z]){2,6}$/;\n\n            return re.test(value);\n        },\n\n        url: function (value) {\n            var re = /(?:(?:https?|ftp):\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?!(?:\\.\\d{1,3}){3})(?!(?:\\.\\d{1,3}){2})(?!\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))\\.?)(?::\\d{2,5})?(?:[/?#]\\S*)?$/;\n            return re.test(value);\n        },\n\n        alpha: function (value) {\n            var re = /^[a-zA-Z_]+$/;\n\n            return re.test(value);\n        },\n\n        alphaNum: function (value) {\n            var re = /^[a-zA-Z_]+$/;\n\n            return re.test(value);\n        },\n\n        creditCard: function (value, type) {\n            var re,\n                checksum,\n                i,\n                digit,\n                notype = false;\n\n            if (type === \"Visa\") {\n                // Visa: length 16, prefix 4, dashes optional.\n                re = /^4\\d{3}[- ]?\\d{4}[- ]?\\d{4}[- ]?\\d{4}$/;\n            } else if (type === \"MasterCard\") {\n                // Mastercard: length 16, prefix 51-55, dashes optional.\n                re = /^5[1-5]\\d{2}[- ]?\\d{4}[- ]?\\d{4}[- ]?\\d{4}$/;\n            } else if (type === \"Discover\") {\n                // Discover: length 16, prefix 6011, dashes optional.\n                re = /^6011[- ]?\\d{4}[- ]?\\d{4}[- ]?\\d{4}$/;\n            } else if (type === \"AmericanExpress\") {\n                // American Express: length 15, prefix 34 or 37.\n                re = /^3[4,7]\\d{13}$/;\n            } else if (type === \"DinersClub\") {\n                // Diners: length 14, prefix 30, 36, or 38.\n                re = /^(3[0,6,8]\\d{12})|(5[45]\\d{14})$/;\n            } else {\n                // Basing min and max length on\n                // http://developer.ean.com/general_info/Valid_Credit_Card_Types\n                if (!value || value.length < 13 || value.length > 19) {\n                    return false;\n                }\n\n                re = /[^0-9 \\-]+/;\n                notype = true;\n            }\n\n            if (!re.test(value)) {\n                return false;\n            }\n\n            // Remove all dashes for the checksum checks to eliminate negative numbers\n            value = value.split(notype ? \"-\" : /[- ]/).join(\"\");\n\n            // Checksum (\"Mod 10\")\n            // Add even digits in even length strings or odd digits in odd length strings.\n            checksum = 0;\n\n            for (i = (2 - (value.length % 2)); i <= value.length; i += 2) {\n                checksum += parseInt(value.charAt(i - 1));\n            }\n\n            // Analyze odd digits in even length strings or even digits in odd length strings.\n            for (i = (value.length % 2) + 1; i < value.length; i += 2) {\n                digit = parseInt(value.charAt(i - 1)) * 2;\n\n                if (digit < 10) {\n                    checksum += digit;\n                } else {\n                    checksum += (digit - 9);\n                }\n            }\n\n            return (checksum % 10) === 0;\n        }\n    };\n\n    Bridge.Validation = validation;\n\n    // @source version.js\n\n    Bridge.define(\"System.Version\", {\n        inherits: function () { return [System.ICloneable,System.IComparable$1(System.Version),System.IEquatable$1(System.Version)]; },\n        statics: {\n            fields: {\n                separatorsArray: 0,\n                ZERO_CHAR_VALUE: 0\n            },\n            ctors: {\n                init: function () {\n                    this.separatorsArray = 46;\n                    this.ZERO_CHAR_VALUE = 48;\n                }\n            },\n            methods: {\n                appendPositiveNumber: function (num, sb) {\n                    var index = sb.getLength();\n                    var reminder;\n\n                    do {\n                        reminder = num % 10;\n                        num = (Bridge.Int.div(num, 10)) | 0;\n                        sb.insert(index, String.fromCharCode(((((System.Version.ZERO_CHAR_VALUE + reminder) | 0)) & 65535)));\n                    } while (num > 0);\n                },\n                parse: function (input) {\n                    if (input == null) {\n                        throw new System.ArgumentNullException(\"input\");\n                    }\n\n                    var r = { v : new System.Version.VersionResult() };\n                    r.v.init(\"input\", true);\n                    if (!System.Version.tryParseVersion(input, r)) {\n                        throw r.v.getVersionParseException();\n                    }\n                    return r.v.m_parsedVersion;\n                },\n                tryParse: function (input, result) {\n                    var r = { v : new System.Version.VersionResult() };\n                    r.v.init(\"input\", false);\n                    var b = System.Version.tryParseVersion(input, r);\n                    result.v = r.v.m_parsedVersion;\n                    return b;\n                },\n                tryParseVersion: function (version, result) {\n                    var major = { }, minor = { }, build = { }, revision = { };\n\n                    if (version == null) {\n                        result.v.setFailure(System.Version.ParseFailureKind.ArgumentNullException);\n\n                        return false;\n                    }\n\n                    var parsedComponents = System.String.split(version, [System.Version.separatorsArray].map(function(i) {{ return String.fromCharCode(i); }}));\n                    var parsedComponentsLength = parsedComponents.length;\n\n                    if ((parsedComponentsLength < 2) || (parsedComponentsLength > 4)) {\n                        result.v.setFailure(System.Version.ParseFailureKind.ArgumentException);\n                        return false;\n                    }\n\n                    if (!System.Version.tryParseComponent(parsedComponents[System.Array.index(0, parsedComponents)], \"version\", result, major)) {\n                        return false;\n                    }\n\n                    if (!System.Version.tryParseComponent(parsedComponents[System.Array.index(1, parsedComponents)], \"version\", result, minor)) {\n                        return false;\n                    }\n\n                    parsedComponentsLength = (parsedComponentsLength - 2) | 0;\n\n                    if (parsedComponentsLength > 0) {\n                        if (!System.Version.tryParseComponent(parsedComponents[System.Array.index(2, parsedComponents)], \"build\", result, build)) {\n                            return false;\n                        }\n\n                        parsedComponentsLength = (parsedComponentsLength - 1) | 0;\n\n                        if (parsedComponentsLength > 0) {\n                            if (!System.Version.tryParseComponent(parsedComponents[System.Array.index(3, parsedComponents)], \"revision\", result, revision)) {\n                                return false;\n                            } else {\n                                result.v.m_parsedVersion = new System.Version.$ctor3(major.v, minor.v, build.v, revision.v);\n                            }\n                        } else {\n                            result.v.m_parsedVersion = new System.Version.$ctor2(major.v, minor.v, build.v);\n                        }\n                    } else {\n                        result.v.m_parsedVersion = new System.Version.$ctor1(major.v, minor.v);\n                    }\n\n                    return true;\n                },\n                tryParseComponent: function (component, componentName, result, parsedComponent) {\n                    if (!System.Int32.tryParse(component, parsedComponent)) {\n                        result.v.setFailure$1(System.Version.ParseFailureKind.FormatException, component);\n                        return false;\n                    }\n\n                    if (parsedComponent.v < 0) {\n                        result.v.setFailure$1(System.Version.ParseFailureKind.ArgumentOutOfRangeException, componentName);\n                        return false;\n                    }\n\n                    return true;\n                },\n                op_Equality: function (v1, v2) {\n                    if (Bridge.referenceEquals(v1, null)) {\n                        return Bridge.referenceEquals(v2, null);\n                    }\n\n                    return v1.equalsT(v2);\n                },\n                op_Inequality: function (v1, v2) {\n                    return !(System.Version.op_Equality(v1, v2));\n                },\n                op_LessThan: function (v1, v2) {\n                    if (v1 == null) {\n                        throw new System.ArgumentNullException(\"v1\");\n                    }\n\n                    return (v1.compareTo(v2) < 0);\n                },\n                op_LessThanOrEqual: function (v1, v2) {\n                    if (v1 == null) {\n                        throw new System.ArgumentNullException(\"v1\");\n                    }\n\n                    return (v1.compareTo(v2) <= 0);\n                },\n                op_GreaterThan: function (v1, v2) {\n                    return (System.Version.op_LessThan(v2, v1));\n                },\n                op_GreaterThanOrEqual: function (v1, v2) {\n                    return (System.Version.op_LessThanOrEqual(v2, v1));\n                }\n            }\n        },\n        fields: {\n            _Major: 0,\n            _Minor: 0,\n            _Build: 0,\n            _Revision: 0\n        },\n        props: {\n            Major: {\n                get: function () {\n                    return this._Major;\n                }\n            },\n            Minor: {\n                get: function () {\n                    return this._Minor;\n                }\n            },\n            Build: {\n                get: function () {\n                    return this._Build;\n                }\n            },\n            Revision: {\n                get: function () {\n                    return this._Revision;\n                }\n            },\n            MajorRevision: {\n                get: function () {\n                    return Bridge.Int.sxs((this._Revision >> 16) & 65535);\n                }\n            },\n            MinorRevision: {\n                get: function () {\n                    return Bridge.Int.sxs((this._Revision & 65535) & 65535);\n                }\n            }\n        },\n        alias: [\n            \"clone\", \"System$ICloneable$clone\",\n            \"compareTo\", [\"System$IComparable$1$System$Version$compareTo\", \"System$IComparable$1$compareTo\"],\n            \"equalsT\", \"System$IEquatable$1$System$Version$equalsT\"\n        ],\n        ctors: {\n            init: function () {\n                this._Build = -1;\n                this._Revision = -1;\n            },\n            $ctor3: function (major, minor, build, revision) {\n                this.$initialize();\n                if (major < 0) {\n                    throw new System.ArgumentOutOfRangeException(\"major\", \"Cannot be < 0\");\n                }\n\n                if (minor < 0) {\n                    throw new System.ArgumentOutOfRangeException(\"minor\", \"Cannot be < 0\");\n                }\n\n                if (build < 0) {\n                    throw new System.ArgumentOutOfRangeException(\"build\", \"Cannot be < 0\");\n                }\n\n                if (revision < 0) {\n                    throw new System.ArgumentOutOfRangeException(\"revision\", \"Cannot be < 0\");\n                }\n\n                this._Major = major;\n                this._Minor = minor;\n                this._Build = build;\n                this._Revision = revision;\n            },\n            $ctor2: function (major, minor, build) {\n                this.$initialize();\n                if (major < 0) {\n                    throw new System.ArgumentOutOfRangeException(\"major\", \"Cannot be < 0\");\n                }\n\n                if (minor < 0) {\n                    throw new System.ArgumentOutOfRangeException(\"minor\", \"Cannot be < 0\");\n                }\n\n                if (build < 0) {\n                    throw new System.ArgumentOutOfRangeException(\"build\", \"Cannot be < 0\");\n                }\n\n                this._Major = major;\n                this._Minor = minor;\n                this._Build = build;\n            },\n            $ctor1: function (major, minor) {\n                this.$initialize();\n                if (major < 0) {\n                    throw new System.ArgumentOutOfRangeException(\"major\", \"Cannot be < 0\");\n                }\n\n                if (minor < 0) {\n                    throw new System.ArgumentOutOfRangeException(\"minor\", \"Cannot be < 0\");\n                }\n\n                this._Major = major;\n                this._Minor = minor;\n            },\n            $ctor4: function (version) {\n                this.$initialize();\n                var v = System.Version.parse(version);\n                this._Major = v.Major;\n                this._Minor = v.Minor;\n                this._Build = v.Build;\n                this._Revision = v.Revision;\n            },\n            ctor: function () {\n                this.$initialize();\n                this._Major = 0;\n                this._Minor = 0;\n            }\n        },\n        methods: {\n            clone: function () {\n                var v = new System.Version.ctor();\n                v._Major = this._Major;\n                v._Minor = this._Minor;\n                v._Build = this._Build;\n                v._Revision = this._Revision;\n                return (v);\n            },\n            compareTo$1: function (version) {\n                if (version == null) {\n                    return 1;\n                }\n\n                var v = Bridge.as(version, System.Version);\n                if (System.Version.op_Equality(v, null)) {\n                    throw new System.ArgumentException(\"version should be of System.Version type\");\n                }\n\n                if (this._Major !== v._Major) {\n                    if (this._Major > v._Major) {\n                        return 1;\n                    } else {\n                        return -1;\n                    }\n                }\n\n                if (this._Minor !== v._Minor) {\n                    if (this._Minor > v._Minor) {\n                        return 1;\n                    } else {\n                        return -1;\n                    }\n                }\n\n                if (this._Build !== v._Build) {\n                    if (this._Build > v._Build) {\n                        return 1;\n                    } else {\n                        return -1;\n                    }\n                }\n\n                if (this._Revision !== v._Revision) {\n                    if (this._Revision > v._Revision) {\n                        return 1;\n                    } else {\n                        return -1;\n                    }\n                }\n\n                return 0;\n            },\n            compareTo: function (value) {\n                if (System.Version.op_Equality(value, null)) {\n                    return 1;\n                }\n\n                if (this._Major !== value._Major) {\n                    if (this._Major > value._Major) {\n                        return 1;\n                    } else {\n                        return -1;\n                    }\n                }\n\n                if (this._Minor !== value._Minor) {\n                    if (this._Minor > value._Minor) {\n                        return 1;\n                    } else {\n                        return -1;\n                    }\n                }\n\n                if (this._Build !== value._Build) {\n                    if (this._Build > value._Build) {\n                        return 1;\n                    } else {\n                        return -1;\n                    }\n                }\n\n                if (this._Revision !== value._Revision) {\n                    if (this._Revision > value._Revision) {\n                        return 1;\n                    } else {\n                        return -1;\n                    }\n                }\n\n                return 0;\n            },\n            equals: function (obj) {\n                return this.equalsT(Bridge.as(obj, System.Version));\n            },\n            equalsT: function (obj) {\n                if (System.Version.op_Equality(obj, null)) {\n                    return false;\n                }\n\n                // check that major, minor, build & revision numbers match\n                if ((this._Major !== obj._Major) || (this._Minor !== obj._Minor) || (this._Build !== obj._Build) || (this._Revision !== obj._Revision)) {\n                    return false;\n                }\n\n                return true;\n            },\n            getHashCode: function () {\n                // Let's assume that most version numbers will be pretty small and just\n                // OR some lower order bits together.\n\n                var accumulator = 0;\n\n                accumulator = accumulator | ((this._Major & 15) << 28);\n                accumulator = accumulator | ((this._Minor & 255) << 20);\n                accumulator = accumulator | ((this._Build & 255) << 12);\n                accumulator = accumulator | (this._Revision & 4095);\n\n                return accumulator;\n            },\n            toString: function () {\n                if (this._Build === -1) {\n                    return (this.toString$1(2));\n                }\n                if (this._Revision === -1) {\n                    return (this.toString$1(3));\n                }\n                return (this.toString$1(4));\n            },\n            toString$1: function (fieldCount) {\n                var sb;\n                switch (fieldCount) {\n                    case 0: \n                        return (\"\");\n                    case 1: \n                        return (this._Major.toString());\n                    case 2: \n                        sb = new System.Text.StringBuilder();\n                        System.Version.appendPositiveNumber(this._Major, sb);\n                        sb.append(String.fromCharCode(46));\n                        System.Version.appendPositiveNumber(this._Minor, sb);\n                        return sb.toString();\n                    default: \n                        if (this._Build === -1) {\n                            throw new System.ArgumentException(\"Build should be > 0 if fieldCount > 2\", \"fieldCount\");\n                        }\n                        if (fieldCount === 3) {\n                            sb = new System.Text.StringBuilder();\n                            System.Version.appendPositiveNumber(this._Major, sb);\n                            sb.append(String.fromCharCode(46));\n                            System.Version.appendPositiveNumber(this._Minor, sb);\n                            sb.append(String.fromCharCode(46));\n                            System.Version.appendPositiveNumber(this._Build, sb);\n                            return sb.toString();\n                        }\n                        if (this._Revision === -1) {\n                            throw new System.ArgumentException(\"Revision should be > 0 if fieldCount > 3\", \"fieldCount\");\n                        }\n                        if (fieldCount === 4) {\n                            sb = new System.Text.StringBuilder();\n                            System.Version.appendPositiveNumber(this._Major, sb);\n                            sb.append(String.fromCharCode(46));\n                            System.Version.appendPositiveNumber(this._Minor, sb);\n                            sb.append(String.fromCharCode(46));\n                            System.Version.appendPositiveNumber(this._Build, sb);\n                            sb.append(String.fromCharCode(46));\n                            System.Version.appendPositiveNumber(this._Revision, sb);\n                            return sb.toString();\n                        }\n                        throw new System.ArgumentException(\"Should be < 5\", \"fieldCount\");\n                }\n            }\n        }\n    });\n\n    // @source parseFailureKind.js\n\n    Bridge.define(\"System.Version.ParseFailureKind\", {\n        $kind: \"enum\",\n        statics: {\n            fields: {\n                ArgumentNullException: 0,\n                ArgumentException: 1,\n                ArgumentOutOfRangeException: 2,\n                FormatException: 3\n            }\n        }\n    });\n\n    // @source versionResult.js\n\n    Bridge.define(\"System.Version.VersionResult\", {\n        $kind: \"struct\",\n        statics: {\n            methods: {\n                getDefaultValue: function () { return new System.Version.VersionResult(); }\n            }\n        },\n        fields: {\n            m_parsedVersion: null,\n            m_failure: 0,\n            m_exceptionArgument: null,\n            m_argumentName: null,\n            m_canThrow: false\n        },\n        ctors: {\n            ctor: function () {\n                this.$initialize();\n            }\n        },\n        methods: {\n            init: function (argumentName, canThrow) {\n                this.m_canThrow = canThrow;\n                this.m_argumentName = argumentName;\n            },\n            setFailure: function (failure) {\n                this.setFailure$1(failure, \"\");\n            },\n            setFailure$1: function (failure, argument) {\n                this.m_failure = failure;\n                this.m_exceptionArgument = argument;\n                if (this.m_canThrow) {\n                    throw this.getVersionParseException();\n                }\n            },\n            getVersionParseException: function () {\n                switch (this.m_failure) {\n                    case System.Version.ParseFailureKind.ArgumentNullException: \n                        return new System.ArgumentNullException(this.m_argumentName);\n                    case System.Version.ParseFailureKind.ArgumentException: \n                        return new System.ArgumentException(\"VersionString\");\n                    case System.Version.ParseFailureKind.ArgumentOutOfRangeException: \n                        return new System.ArgumentOutOfRangeException(this.m_exceptionArgument, \"Cannot be < 0\");\n                    case System.Version.ParseFailureKind.FormatException: \n                        // Regenerate the FormatException as would be thrown by Int32.Parse()\n                        try {\n                            System.Int32.parse(this.m_exceptionArgument);\n                        }\n                        catch ($e1) {\n                            $e1 = System.Exception.create($e1);\n                            var e;\n                            if (Bridge.is($e1, System.FormatException)) {\n                                e = $e1;\n                                return e;\n                            } else if (Bridge.is($e1, System.OverflowException)) {\n                                e = $e1;\n                                return e;\n                            } else {\n                                throw $e1;\n                            }\n                        }\n                        return new System.FormatException(\"InvalidString\");\n                    default: \n                        return new System.ArgumentException(\"VersionString\");\n                }\n            },\n            getHashCode: function () {\n                var h = Bridge.addHash([5139482776, this.m_parsedVersion, this.m_failure, this.m_exceptionArgument, this.m_argumentName, this.m_canThrow]);\n                return h;\n            },\n            equals: function (o) {\n                if (!Bridge.is(o, System.Version.VersionResult)) {\n                    return false;\n                }\n                return Bridge.equals(this.m_parsedVersion, o.m_parsedVersion) && Bridge.equals(this.m_failure, o.m_failure) && Bridge.equals(this.m_exceptionArgument, o.m_exceptionArgument) && Bridge.equals(this.m_argumentName, o.m_argumentName) && Bridge.equals(this.m_canThrow, o.m_canThrow);\n            },\n            $clone: function (to) {\n                var s = to || new System.Version.VersionResult();\n                s.m_parsedVersion = this.m_parsedVersion;\n                s.m_failure = this.m_failure;\n                s.m_exceptionArgument = this.m_exceptionArgument;\n                s.m_argumentName = this.m_argumentName;\n                s.m_canThrow = this.m_canThrow;\n                return s;\n            }\n        }\n    });\n\n    // @source Attribute.js\n\n    Bridge.define(\"System.Attribute\", {\n        statics: {\n            getCustomAttributes: function (o, t, b) {\n                if (o == null) {\n                    throw new System.ArgumentNullException(\"element\");\n                }\n\n                if (t == null)\n                {\n                    throw new System.ArgumentNullException(\"attributeType\");\n                }\n\n                var r = o.at || [];\n\n                if (!t) {\n                    return r;\n                }\n\n                return r.filter(function (a) { return Bridge.is(a, t); });\n            },\n\n            getCustomAttributes$1: function (a, t, b) {\n                if (a == null) {\n                    throw new System.ArgumentNullException(\"element\");\n                }\n\n                if (t == null)\n                {\n                    throw new System. ArgumentNullException(\"attributeType\");\n                }\n\n                return a.getCustomAttributes(t || b);\n            }\n        }\n    });\n\n    // @source INotifyPropertyChanged.js\n\n    Bridge.define(\"System.ComponentModel.INotifyPropertyChanged\", {\n        $kind: \"interface\"\n    });\n\n    Bridge.define(\"System.ComponentModel.PropertyChangedEventArgs\", {\n        ctor: function (propertyName, newValue, oldValue) {\n            this.$initialize();\n            this.propertyName = propertyName;\n            this.newValue = newValue;\n            this.oldValue = oldValue;\n        }\n    });\n\n    // @source Convert.js\n\n    var scope = {};\n\n    scope.convert = {\n        typeCodes: {\n            Empty: 0,\n            Object: 1,\n            DBNull: 2,\n            Boolean: 3,\n            Char: 4,\n            SByte: 5,\n            Byte: 6,\n            Int16: 7,\n            UInt16: 8,\n            Int32: 9,\n            UInt32: 10,\n            Int64: 11,\n            UInt64: 12,\n            Single: 13,\n            Double: 14,\n            Decimal: 15,\n            DateTime: 16,\n            String: 18\n        },\n\n        toBoolean: function (value, formatProvider) {\n            value = Bridge.unbox(value, true);\n\n            switch (typeof (value)) {\n                case \"boolean\":\n                    return value;\n\n                case \"number\":\n                    return value !== 0; // non-zero int/float value is always converted to True;\n\n                case \"string\":\n                    var lowCaseVal = value.toLowerCase().trim();\n\n                    if (lowCaseVal === \"true\") {\n                        return true;\n                    } else if (lowCaseVal === \"false\") {\n                        return false;\n                    } else {\n                        throw new System.FormatException(\"String was not recognized as a valid Boolean.\");\n                    }\n\n                case \"object\":\n                    if (value == null) {\n                        return false;\n                    }\n\n                    if (value instanceof System.Decimal) {\n                        return !value.isZero();\n                    }\n\n                    if (System.Int64.is64Bit(value)) {\n                        return value.ne(0);\n                    }\n\n                    break;\n            }\n\n            // TODO: #822 When IConvertible is implemented, try it before throwing InvalidCastEx\n            var typeCode = scope.internal.suggestTypeCode(value);\n            scope.internal.throwInvalidCastEx(typeCode, scope.convert.typeCodes.Boolean);\n\n            // try converting using IConvertible\n            return scope.convert.convertToType(scope.convert.typeCodes.Boolean, value, formatProvider || null);\n        },\n\n        toChar: function (value, formatProvider, valueTypeCode) {\n            var typeCodes = scope.convert.typeCodes;\n\n            value = Bridge.unbox(value, true);\n\n            if (value instanceof System.Decimal) {\n                value = value.toFloat();\n            }\n\n            if (value instanceof System.Int64 || value instanceof System.UInt64) {\n                value = value.toNumber();\n            }\n\n            var type = typeof (value);\n\n            valueTypeCode = valueTypeCode || scope.internal.suggestTypeCode(value);\n\n            if (valueTypeCode === typeCodes.String && value == null) {\n                type = \"string\";\n            }\n\n            if (valueTypeCode !== typeCodes.Object) {\n                switch (type) {\n                    case \"boolean\":\n                        scope.internal.throwInvalidCastEx(typeCodes.Boolean, typeCodes.Char);\n\n                    case \"number\":\n                        var isFloatingType = scope.internal.isFloatingType(valueTypeCode);\n\n                        if (isFloatingType || value % 1 !== 0) {\n                            scope.internal.throwInvalidCastEx(valueTypeCode, typeCodes.Char);\n                        }\n\n                        scope.internal.validateNumberRange(value, typeCodes.Char, true);\n\n                        return value;\n\n                    case \"string\":\n                        if (value == null) {\n                            throw new System.ArgumentNullException(\"value\");\n                        }\n\n                        if (value.length !== 1) {\n                            throw new System.FormatException(\"String must be exactly one character long.\");\n                        }\n\n                        return value.charCodeAt(0);\n                }\n            }\n\n            if (valueTypeCode === typeCodes.Object || type === \"object\") {\n                if (value == null) {\n                    return 0;\n                }\n\n                if (Bridge.isDate(value)) {\n                    scope.internal.throwInvalidCastEx(typeCodes.DateTime, typeCodes.Char);\n                }\n            }\n\n            // TODO: #822 When IConvertible is implemented, try it before throwing InvalidCastEx\n            scope.internal.throwInvalidCastEx(valueTypeCode, scope.convert.typeCodes.Char);\n\n            // try converting using IConvertible\n            return scope.convert.convertToType(typeCodes.Char, value, formatProvider || null);\n        },\n\n        toSByte: function (value, formatProvider, valueTypeCode) {\n            return scope.internal.toNumber(value, formatProvider || null, scope.convert.typeCodes.SByte, valueTypeCode || null);\n        },\n\n        toByte: function (value, formatProvider) {\n            return scope.internal.toNumber(value, formatProvider || null, scope.convert.typeCodes.Byte);\n        },\n\n        toInt16: function (value, formatProvider) {\n            return scope.internal.toNumber(value, formatProvider || null, scope.convert.typeCodes.Int16);\n        },\n\n        toUInt16: function (value, formatProvider) {\n            return scope.internal.toNumber(value, formatProvider || null, scope.convert.typeCodes.UInt16);\n        },\n\n        toInt32: function (value, formatProvider) {\n            return scope.internal.toNumber(value, formatProvider || null, scope.convert.typeCodes.Int32);\n        },\n\n        toUInt32: function (value, formatProvider) {\n            return scope.internal.toNumber(value, formatProvider || null, scope.convert.typeCodes.UInt32);\n        },\n\n        toInt64: function (value, formatProvider) {\n            var result = scope.internal.toNumber(value, formatProvider || null, scope.convert.typeCodes.Int64);\n            return new System.Int64(result);\n        },\n\n        toUInt64: function (value, formatProvider) {\n            var result = scope.internal.toNumber(value, formatProvider || null, scope.convert.typeCodes.UInt64);\n            return new System.UInt64(result);\n        },\n\n        toSingle: function (value, formatProvider) {\n            return scope.internal.toNumber(value, formatProvider || null, scope.convert.typeCodes.Single);\n        },\n\n        toDouble: function (value, formatProvider) {\n            return scope.internal.toNumber(value, formatProvider || null, scope.convert.typeCodes.Double);\n        },\n\n        toDecimal: function (value, formatProvider) {\n            if (value instanceof System.Decimal) {\n                return value;\n            }\n\n            return new System.Decimal(scope.internal.toNumber(value, formatProvider || null, scope.convert.typeCodes.Decimal));\n        },\n\n        toDateTime: function (value, formatProvider) {\n            var typeCodes = scope.convert.typeCodes;\n\n            value = Bridge.unbox(value, true);\n\n            switch (typeof (value)) {\n                case \"boolean\":\n                    scope.internal.throwInvalidCastEx(typeCodes.Boolean, typeCodes.DateTime);\n\n                case \"number\":\n                    var fromType = scope.internal.suggestTypeCode(value);\n                    scope.internal.throwInvalidCastEx(fromType, typeCodes.DateTime);\n\n                case \"string\":\n                    value = System.DateTime.parse(value, formatProvider || null);\n\n                    return value;\n\n                case \"object\":\n                    if (value == null) {\n                        return scope.internal.getMinValue(typeCodes.DateTime);\n                    }\n\n                    if (Bridge.isDate(value)) {\n                        return value;\n                    }\n\n                    if (value instanceof System.Decimal) {\n                        scope.internal.throwInvalidCastEx(typeCodes.Decimal, typeCodes.DateTime);\n                    }\n\n                    if (value instanceof System.Int64) {\n                        scope.internal.throwInvalidCastEx(typeCodes.Int64, typeCodes.DateTime);\n                    }\n\n                    if (value instanceof System.UInt64) {\n                        scope.internal.throwInvalidCastEx(typeCodes.UInt64, typeCodes.DateTime);\n                    }\n\n                    break;\n            }\n\n            // TODO: #822 When IConvertible is implemented, try it before throwing InvalidCastEx\n            var valueTypeCode = scope.internal.suggestTypeCode(value);\n\n            scope.internal.throwInvalidCastEx(valueTypeCode, scope.convert.typeCodes.DateTime);\n\n            // try converting using IConvertible\n            return scope.convert.convertToType(typeCodes.DateTime, value, formatProvider || null);\n        },\n\n        toString: function (value, formatProvider, valueTypeCode) {\n            if (value && value.$boxed) {\n                return value.toString();\n            }\n\n            var typeCodes = scope.convert.typeCodes,\n                type = typeof (value);\n\n            switch (type) {\n                case \"boolean\":\n                    return value ? \"True\" : \"False\";\n\n                case \"number\":\n                    if ((valueTypeCode || null) === typeCodes.Char) {\n                        return String.fromCharCode(value);\n                    }\n\n                    if (isNaN(value)) {\n                        return \"NaN\";\n                    }\n\n                    if (value % 1 !== 0) {\n                        value = parseFloat(value.toPrecision(15));\n                    }\n\n                    return value.toString();\n\n                case \"string\":\n                    return value;\n\n                case \"object\":\n                    if (value == null) {\n                        return \"\";\n                    }\n\n                    if (Bridge.isDate(value)) {\n                        return System.DateTime.format(value, null, formatProvider || null);\n                    }\n\n                    if (value instanceof System.Decimal) {\n                        if (value.isInteger()) {\n                            return value.toFixed(0, 4);\n                        }\n                        return value.toPrecision(value.precision());\n                    }\n\n                    if (System.Int64.is64Bit(value)) {\n                        return value.toString();\n                    }\n\n                    if (value.format) {\n                        return value.format(null, formatProvider || null);\n                    }\n\n                    var typeName = Bridge.getTypeName(value);\n\n                    return typeName;\n            }\n\n            // try converting using IConvertible\n            return scope.convert.convertToType(scope.convert.typeCodes.String, value, formatProvider || null);\n        },\n\n        toNumberInBase: function (str, fromBase, typeCode) {\n            if (fromBase !== 2 && fromBase !== 8 && fromBase !== 10 && fromBase !== 16) {\n                throw new System.ArgumentException(\"Invalid Base.\");\n            }\n\n            var typeCodes = scope.convert.typeCodes;\n\n            if (str == null) {\n                if (typeCode === typeCodes.Int64) {\n                    return System.Int64.Zero;\n                }\n\n                if (typeCode === typeCodes.UInt64) {\n                    return System.UInt64.Zero;\n                }\n\n                return 0;\n            }\n\n            if (str.length === 0) {\n                throw new System.ArgumentOutOfRangeException(\"Index was out of range. Must be non-negative and less than the size of the collection.\");\n            }\n\n            // Let's process the string in lower case.\n            str = str.toLowerCase();\n\n            var minValue = scope.internal.getMinValue(typeCode),\n                maxValue = scope.internal.getMaxValue(typeCode);\n\n            // Calculate offset (start index)\n            var isNegative = false,\n                startIndex = 0;\n\n            if (str[startIndex] === \"-\") {\n                if (fromBase !== 10) {\n                    throw new System.ArgumentException(\"String cannot contain a minus sign if the base is not 10.\");\n                }\n\n                if (minValue >= 0) {\n                    throw new System.OverflowException(\"The string was being parsed as an unsigned number and could not have a negative sign.\");\n                }\n\n                isNegative = true;\n                ++startIndex;\n            } else if (str[startIndex] === \"+\") {\n                ++startIndex;\n            }\n\n            if (fromBase === 16 && str.length >= 2 && str[startIndex] === \"0\" && str[startIndex + 1] === \"x\") {\n                startIndex += 2;\n            }\n\n            // Fill allowed codes for the specified base:\n            var allowedCodes;\n\n            if (fromBase === 2) {\n                allowedCodes = scope.internal.charsToCodes(\"01\");\n            } else if (fromBase === 8) {\n                allowedCodes = scope.internal.charsToCodes(\"01234567\");\n            } else if (fromBase === 10) {\n                allowedCodes = scope.internal.charsToCodes(\"0123456789\");\n            } else if (fromBase === 16) {\n                allowedCodes = scope.internal.charsToCodes(\"0123456789abcdef\");\n            } else {\n                throw new System.ArgumentException(\"Invalid Base.\");\n            }\n\n            // Create charCode-to-Value map\n            var codeValues = {};\n\n            for (var i = 0; i < allowedCodes.length; i++) {\n                var allowedCode = allowedCodes[i];\n\n                codeValues[allowedCode] = i;\n            }\n\n            var firstAllowed = allowedCodes[0],\n                lastAllowed = allowedCodes[allowedCodes.length - 1],\n                res,\n                totalMax,\n                code,\n                j;\n\n            if (typeCode === typeCodes.Int64 || typeCode === typeCodes.UInt64) {\n                for (j = startIndex; j < str.length; j++) {\n                    code = str[j].charCodeAt(0);\n\n                    if (!(code >= firstAllowed && code <= lastAllowed)) {\n                        if (j === startIndex) {\n                            throw new System.FormatException(\"Could not find any recognizable digits.\");\n                        } else {\n                            throw new System.FormatException(\"Additional non-parsable characters are at the end of the string.\");\n                        }\n                    }\n                }\n\n                var isSign = typeCode === typeCodes.Int64;\n\n                if (isSign) {\n                    res = new System.Int64(Bridge.$Long.fromString(str, false, fromBase));\n                } else {\n                    res = new System.UInt64(Bridge.$Long.fromString(str, true, fromBase));\n                }\n\n                if (res.toString(fromBase) !== System.String.trimStartZeros(str)) {\n                    throw new System.OverflowException(\"Value was either too large or too small.\");\n                }\n\n                return res;\n            } else {\n                // Parse the number:\n                res = 0;\n                totalMax = maxValue - minValue + 1;\n\n                for (j = startIndex; j < str.length; j++) {\n                    code = str[j].charCodeAt(0);\n\n                    if (code >= firstAllowed && code <= lastAllowed) {\n                        res *= fromBase;\n                        res += codeValues[code];\n\n                        if (res > scope.internal.typeRanges.Int64_MaxValue) {\n                            throw new System.OverflowException(\"Value was either too large or too small.\");\n                        }\n                    } else {\n                        if (j === startIndex) {\n                            throw new System.FormatException(\"Could not find any recognizable digits.\");\n                        } else {\n                            throw new System.FormatException(\"Additional non-parsable characters are at the end of the string.\");\n                        }\n                    }\n                }\n\n                if (isNegative) {\n                    res *= -1;\n                }\n\n                if (res > maxValue && fromBase !== 10 && minValue < 0) {\n                    // Assume that the value is negative, transform it:\n                    res = res - totalMax;\n                }\n\n                if (res < minValue || res > maxValue) {\n                    throw new System.OverflowException(\"Value was either too large or too small.\");\n                }\n\n                return res;\n            }\n        },\n\n        toStringInBase: function (value, toBase, typeCode) {\n            var typeCodes = scope.convert.typeCodes;\n            value = Bridge.unbox(value, true);\n            if (toBase !== 2 && toBase !== 8 && toBase !== 10 && toBase !== 16) {\n                throw new System.ArgumentException(\"Invalid Base.\");\n            }\n\n            var minValue = scope.internal.getMinValue(typeCode),\n                maxValue = scope.internal.getMaxValue(typeCode),\n                special = System.Int64.is64Bit(value);\n\n            if (special) {\n                if (value.lt(minValue) || value.gt(maxValue)) {\n                    throw new System.OverflowException(\"Value was either too large or too small for an unsigned byte.\");\n                }\n            } else if (value < minValue || value > maxValue) {\n                throw new System.OverflowException(\"Value was either too large or too small for an unsigned byte.\");\n            }\n\n            // Handle negative numbers:\n            var isNegative = false;\n\n            if (special) {\n                if (toBase === 10) {\n                    return value.toString();\n                } else {\n                    return value.value.toUnsigned().toString(toBase);\n                }\n            } else if (value < 0) {\n                if (toBase === 10) {\n                    isNegative = true;\n                    value *= -1;\n                } else {\n                    value = (maxValue + 1 - minValue) + value;\n                }\n            }\n\n            // Fill allowed codes for the specified base:\n            var allowedChars;\n\n            if (toBase === 2) {\n                allowedChars = \"01\";\n            } else if (toBase === 8) {\n                allowedChars = \"01234567\";\n            } else if (toBase === 10) {\n                allowedChars = \"0123456789\";\n            } else if (toBase === 16) {\n                allowedChars = \"0123456789abcdef\";\n            } else {\n                throw new System.ArgumentException(\"Invalid Base.\");\n            }\n\n            // Fill Value-To-Char map:\n            var charByValues = {},\n                allowedCharArr = allowedChars.split(\"\"),\n                allowedChar;\n\n            for (var i = 0; i < allowedCharArr.length; i++) {\n                allowedChar = allowedCharArr[i];\n\n                charByValues[i] = allowedChar;\n            }\n\n            // Parse the number:\n            var res = \"\";\n\n            if (value === 0 || (special && value.eq(0))) {\n                res = \"0\";\n            } else {\n                var mod, char;\n\n                if (special) {\n                    while (value.gt(0)) {\n                        mod = value.mod(toBase);\n                        value = value.sub(mod).div(toBase);\n\n                        char = charByValues[mod.toNumber()];\n                        res += char;\n                    }\n                } else {\n                    while (value > 0) {\n                        mod = value % toBase;\n                        value = (value - mod) / toBase;\n\n                        char = charByValues[mod];\n                        res += char;\n                    }\n                }\n            }\n\n            if (isNegative) {\n                res += \"-\";\n            }\n\n            res = res.split(\"\").reverse().join(\"\");\n\n            return res;\n        },\n\n        toBase64String: function (inArray, offset, length, options) {\n            if (inArray == null) {\n                throw new System.ArgumentNullException(\"inArray\");\n            }\n\n            offset = offset || 0;\n            length = length != null ? length : inArray.length;\n            options = options || 0; // 0 - means \"None\", 1 - stands for \"InsertLineBreaks\"\n\n            if (length < 0) {\n                throw new System.ArgumentOutOfRangeException(\"length\", \"Index was out of range. Must be non-negative and less than the size of the collection.\");\n            }\n\n            if (offset < 0) {\n                throw new System.ArgumentOutOfRangeException(\"offset\", \"Value must be positive.\");\n            }\n\n            if (options < 0 || options > 1) {\n                throw new System.ArgumentException(\"Illegal enum value.\");\n            }\n\n            var inArrayLength = inArray.length;\n\n            if (offset > (inArrayLength - length)) {\n                throw new System.ArgumentOutOfRangeException(\"offset\", \"Offset and length must refer to a position in the string.\");\n            }\n\n            if (inArrayLength === 0) {\n                return \"\";\n            }\n\n            var insertLineBreaks = (options === 1),\n                strArrayLen = scope.internal.toBase64_CalculateAndValidateOutputLength(length, insertLineBreaks);\n\n            var strArray = [];\n            strArray.length = strArrayLen;\n\n            scope.internal.convertToBase64Array(strArray, inArray, offset, length, insertLineBreaks);\n\n            var str = strArray.join(\"\");\n\n            return str;\n        },\n\n        toBase64CharArray: function (inArray, offsetIn, length, outArray, offsetOut, options) {\n            if (inArray == null) {\n                throw new System.ArgumentNullException(\"inArray\");\n            }\n\n            if (outArray == null) {\n                throw new System.ArgumentNullException(\"outArray\");\n            }\n\n            if (length < 0) {\n                throw new System.ArgumentOutOfRangeException(\"length\", \"Index was out of range. Must be non-negative and less than the size of the collection.\");\n            }\n\n            if (offsetIn < 0) {\n                throw new System.ArgumentOutOfRangeException(\"offsetIn\", \"Value must be positive.\");\n            }\n\n            if (offsetOut < 0) {\n                throw new System.ArgumentOutOfRangeException(\"offsetOut\", \"Value must be positive.\");\n            }\n\n            options = options || 0; // 0 - means \"None\", 1 - stands for \"InsertLineBreaks\"\n\n            if (options < 0 || options > 1) {\n                throw new System.ArgumentException(\"Illegal enum value.\");\n            }\n            var inArrayLength = inArray.length;\n\n            if (offsetIn > inArrayLength - length) {\n                throw new System.ArgumentOutOfRangeException(\"offsetIn\", \"Offset and length must refer to a position in the string.\");\n            }\n\n            if (inArrayLength === 0) {\n                return 0;\n            }\n\n            var insertLineBreaks = options === 1,\n                outArrayLength = outArray.length; //This is the maximally required length that must be available in the char array\n\n            // Length of the char buffer required\n            var numElementsToCopy = scope.internal.toBase64_CalculateAndValidateOutputLength(length, insertLineBreaks);\n\n            if (offsetOut > (outArrayLength - numElementsToCopy)) {\n                throw new System.ArgumentOutOfRangeException(\"offsetOut\", \"Either offset did not refer to a position in the string, or there is an insufficient length of destination character array.\");\n            }\n\n            var charsArr = [],\n                charsArrLength = scope.internal.convertToBase64Array(charsArr, inArray, offsetIn, length, insertLineBreaks);\n\n            scope.internal.charsToCodes(charsArr, outArray, offsetOut);\n\n            return charsArrLength;\n        },\n\n        fromBase64String: function (s) {\n            // \"s\" is an unfortunate parameter name, but we need to keep it for backward compat.\n\n            if (s == null) {\n                throw new System.ArgumentNullException(\"s\");\n            }\n\n            var sChars = s.split(\"\"),\n                bytes = scope.internal.fromBase64CharPtr(sChars, 0, sChars.length);\n\n            return bytes;\n        },\n\n        fromBase64CharArray: function (inArray, offset, length) {\n            if (inArray == null) {\n                throw new System.ArgumentNullException(\"inArray\");\n            }\n\n            if (length < 0) {\n                throw new System.ArgumentOutOfRangeException(\"length\", \"Index was out of range. Must be non-negative and less than the size of the collection.\");\n            }\n\n            if (offset < 0) {\n                throw new System.ArgumentOutOfRangeException(\"offset\", \"Value must be positive.\");\n            }\n\n            if (offset > (inArray.length - length)) {\n                throw new System.ArgumentOutOfRangeException(\"offset\", \"Offset and length must refer to a position in the string.\");\n            }\n\n            var chars = scope.internal.codesToChars(inArray),\n                bytes = scope.internal.fromBase64CharPtr(chars, offset, length);\n\n            return bytes;\n        },\n\n        convertToType: function (typeCode, value, formatProvider) {\n            //TODO: #822 IConvertible\n            throw new System.NotSupportedException(\"IConvertible interface is not supported.\");\n        }\n    };\n\n    scope.internal = {\n        base64Table: [\n            \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\",\n            \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\", \"a\", \"b\", \"c\", \"d\",\n            \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\",\n            \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\",\n            \"8\", \"9\", \"+\", \"/\", \"=\"\n        ],\n\n        typeRanges: {\n            Char_MinValue: 0,\n            Char_MaxValue: 65535,\n\n            Byte_MinValue: 0,\n            Byte_MaxValue: 255,\n\n            SByte_MinValue: -128,\n            SByte_MaxValue: 127,\n\n            Int16_MinValue: -32768,\n            Int16_MaxValue: 32767,\n\n            UInt16_MinValue: 0,\n            UInt16_MaxValue: 65535,\n\n            Int32_MinValue: -2147483648,\n            Int32_MaxValue: 2147483647,\n\n            UInt32_MinValue: 0,\n            UInt32_MaxValue: 4294967295,\n\n            Int64_MinValue: System.Int64.MinValue,\n            Int64_MaxValue: System.Int64.MaxValue,\n\n            UInt64_MinValue: System.UInt64.MinValue,\n            UInt64_MaxValue: System.UInt64.MaxValue,\n\n            Single_MinValue: -3.40282347e+38,\n            Single_MaxValue: 3.40282347e+38,\n\n            Double_MinValue: -1.7976931348623157e+308,\n            Double_MaxValue: 1.7976931348623157e+308,\n\n            Decimal_MinValue: System.Decimal.MinValue,\n            Decimal_MaxValue: System.Decimal.MaxValue\n        },\n\n        base64LineBreakPosition: 76,\n\n        getTypeCodeName: function (typeCode) {\n            var typeCodes = scope.convert.typeCodes;\n\n            if (scope.internal.typeCodeNames == null) {\n                var names = {};\n\n                for (var codeName in typeCodes) {\n                    if (!typeCodes.hasOwnProperty(codeName)) {\n                        continue;\n                    }\n\n                    var codeValue = typeCodes[codeName];\n\n                    names[codeValue] = codeName;\n                }\n                scope.internal.typeCodeNames = names;\n            }\n\n            var name = scope.internal.typeCodeNames[typeCode];\n\n            if (name == null) {\n                throw System.ArgumentOutOfRangeException(\"typeCode\", \"The specified typeCode is undefined.\");\n            }\n\n            return name;\n        },\n\n        suggestTypeCode: function (value) {\n            var typeCodes = scope.convert.typeCodes,                type = typeof (value);\n\n            switch (type) {\n                case \"boolean\":\n                    return typeCodes.Boolean;\n\n                case \"number\":\n                    if (value % 1 !== 0)\n                        return typeCodes.Double;\n\n                    return typeCodes.Int32;\n\n                case \"string\":\n                    return typeCodes.String;\n\n                case \"object\":\n                    if (Bridge.isDate(value)) {\n                        return typeCodes.DateTime;\n                    }\n\n                    if (value != null) {\n                        return typeCodes.Object;\n                    }\n\n                    break;\n            }\n            return null;\n        },\n\n        getMinValue: function (typeCode) {\n            var typeCodes = scope.convert.typeCodes;\n\n            switch (typeCode) {\n                case typeCodes.Char:\n                    return scope.internal.typeRanges.Char_MinValue;\n                case typeCodes.SByte:\n                    return scope.internal.typeRanges.SByte_MinValue;\n                case typeCodes.Byte:\n                    return scope.internal.typeRanges.Byte_MinValue;\n                case typeCodes.Int16:\n                    return scope.internal.typeRanges.Int16_MinValue;\n                case typeCodes.UInt16:\n                    return scope.internal.typeRanges.UInt16_MinValue;\n                case typeCodes.Int32:\n                    return scope.internal.typeRanges.Int32_MinValue;\n                case typeCodes.UInt32:\n                    return scope.internal.typeRanges.UInt32_MinValue;\n                case typeCodes.Int64:\n                    return scope.internal.typeRanges.Int64_MinValue;\n                case typeCodes.UInt64:\n                    return scope.internal.typeRanges.UInt64_MinValue;\n                case typeCodes.Single:\n                    return scope.internal.typeRanges.Single_MinValue;\n                case typeCodes.Double:\n                    return scope.internal.typeRanges.Double_MinValue;\n                case typeCodes.Decimal:\n                    return scope.internal.typeRanges.Decimal_MinValue;\n                case typeCodes.DateTime:\n                    return System.DateTime.getMinValue();\n\n                default:\n                    return null;\n            }\n        },\n\n        getMaxValue: function (typeCode) {\n            var typeCodes = scope.convert.typeCodes;\n\n            switch (typeCode) {\n                case typeCodes.Char:\n                    return scope.internal.typeRanges.Char_MaxValue;\n                case typeCodes.SByte:\n                    return scope.internal.typeRanges.SByte_MaxValue;\n                case typeCodes.Byte:\n                    return scope.internal.typeRanges.Byte_MaxValue;\n                case typeCodes.Int16:\n                    return scope.internal.typeRanges.Int16_MaxValue;\n                case typeCodes.UInt16:\n                    return scope.internal.typeRanges.UInt16_MaxValue;\n                case typeCodes.Int32:\n                    return scope.internal.typeRanges.Int32_MaxValue;\n                case typeCodes.UInt32:\n                    return scope.internal.typeRanges.UInt32_MaxValue;\n                case typeCodes.Int64:\n                    return scope.internal.typeRanges.Int64_MaxValue;\n                case typeCodes.UInt64:\n                    return scope.internal.typeRanges.UInt64_MaxValue;\n                case typeCodes.Single:\n                    return scope.internal.typeRanges.Single_MaxValue;\n                case typeCodes.Double:\n                    return scope.internal.typeRanges.Double_MaxValue;\n                case typeCodes.Decimal:\n                    return scope.internal.typeRanges.Decimal_MaxValue;\n                case typeCodes.DateTime:\n                    return System.DateTime.getMaxValue();\n                default:\n                    throw new System.ArgumentOutOfRangeException(\"typeCode\", \"The specified typeCode is undefined.\");\n            }\n        },\n\n        isFloatingType: function (typeCode) {\n            var typeCodes = scope.convert.typeCodes;\n            var isFloatingType =\n                typeCode === typeCodes.Single ||\n                typeCode === typeCodes.Double ||\n                typeCode === typeCodes.Decimal;\n\n            return isFloatingType;\n        },\n\n        toNumber: function (value, formatProvider, typeCode, valueTypeCode) {\n            value = Bridge.unbox(value, true);\n\n            var typeCodes = scope.convert.typeCodes,\n                type = typeof (value),\n                isFloating = scope.internal.isFloatingType(typeCode);\n\n            if (valueTypeCode === typeCodes.String) {\n                type = \"string\";\n            }\n\n            if (System.Int64.is64Bit(value) || value instanceof System.Decimal) {\n                type = \"number\";\n            }\n\n            switch (type) {\n                case \"boolean\":\n                    return value ? 1 : 0;\n\n                case \"number\":\n                    if (typeCode === typeCodes.Decimal) {\n                        scope.internal.validateNumberRange(value, typeCode, true);\n\n                        return new System.Decimal(value, formatProvider);\n                    }\n\n                    if (typeCode === typeCodes.Int64) {\n                        scope.internal.validateNumberRange(value, typeCode, true);\n\n                        return new System.Int64(value);\n                    }\n\n                    if (typeCode === typeCodes.UInt64) {\n                        scope.internal.validateNumberRange(value, typeCode, true);\n\n                        return new System.UInt64(value);\n                    }\n\n                    if (System.Int64.is64Bit(value)) {\n                        value = value.toNumber();\n                    } else if (value instanceof System.Decimal) {\n                        value = value.toFloat();\n                    }\n\n                    if (!isFloating && (value % 1 !== 0)) {\n                        value = scope.internal.roundToInt(value, typeCode);\n                    }\n\n                    if (isFloating) {\n                        var minValue = scope.internal.getMinValue(typeCode),\n                            maxValue = scope.internal.getMaxValue(typeCode);\n\n                        if (value > maxValue) {\n                            value = Infinity;\n                        } else if (value < minValue) {\n                            value = -Infinity;\n                        }\n                    }\n\n                    scope.internal.validateNumberRange(value, typeCode, false);\n                    return value;\n\n                case \"string\":\n                    if (value == null) {\n                        if (formatProvider != null) {\n                            throw new System.ArgumentNullException(\"String\", \"Value cannot be null.\");\n                        }\n\n                        return 0;\n                    }\n\n                    if (isFloating) {\n                        if (typeCode === typeCodes.Decimal) {\n                            if (!/^[+-]?(\\d+|\\d+.|\\d*\\.\\d+)$/.test(value)) {\n                                if (!/^[+-]?[0-9]+$/.test(value)) {\n                                    throw new System.FormatException(\"Input string was not in a correct format.\");\n                                }\n                            }\n\n                            value = System.Decimal(value, formatProvider);\n                        } else {\n                            if (!/^[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?$/.test(value)) {\n                                throw new System.FormatException(\"Input string was not in a correct format.\");\n                            }\n\n                            value = parseFloat(value);\n                        }\n                    } else {\n                        if (!/^[+-]?[0-9]+$/.test(value)) {\n                            throw new System.FormatException(\"Input string was not in a correct format.\");\n                        }\n\n                        var str = value;\n\n                        if (typeCode === typeCodes.Int64) {\n                            value = new System.Int64(value);\n\n                            if (System.String.trimStartZeros(str) !== value.toString()) {\n                                this.throwOverflow(scope.internal.getTypeCodeName(typeCode));\n                            }\n                        } else if (typeCode === typeCodes.UInt64) {\n                            value = new System.UInt64(value);\n\n                            if (System.String.trimStartZeros(str) !== value.toString()) {\n                                this.throwOverflow(scope.internal.getTypeCodeName(typeCode));\n                            }\n                        } else {\n                            value = parseInt(value, 10);\n                        }\n                    }\n\n                    if (isNaN(value)) {\n                        throw new System.FormatException(\"Input string was not in a correct format.\");\n                    }\n\n                    scope.internal.validateNumberRange(value, typeCode, true);\n\n                    return value;\n\n                case \"object\":\n                    if (value == null) {\n                        return 0;\n                    }\n\n                    if (Bridge.isDate(value)) {\n                        scope.internal.throwInvalidCastEx(scope.convert.typeCodes.DateTime, typeCode);\n                    }\n\n                    break;\n            }\n\n            // TODO: #822 When IConvertible is implemented, try it before throwing InvalidCastEx\n            valueTypeCode = valueTypeCode || scope.internal.suggestTypeCode(value);\n            scope.internal.throwInvalidCastEx(valueTypeCode, typeCode);\n\n            // try converting using IConvertible\n            return scope.convert.convertToType(typeCode, value, formatProvider);\n        },\n\n        validateNumberRange: function (value, typeCode, denyInfinity) {\n            var typeCodes = scope.convert.typeCodes,\n                minValue = scope.internal.getMinValue(typeCode),\n                maxValue = scope.internal.getMaxValue(typeCode),\n                typeName = scope.internal.getTypeCodeName(typeCode);\n\n            if (typeCode === typeCodes.Single ||\n                typeCode === typeCodes.Double) {\n                if (!denyInfinity && (value === Infinity || value === -Infinity)) {\n                    return;\n                }\n            }\n\n            if (typeCode === typeCodes.Decimal || typeCode === typeCodes.Int64 || typeCode === typeCodes.UInt64) {\n                if (typeCode === typeCodes.Decimal) {\n                    if (!System.Int64.is64Bit(value)) {\n                        if (minValue.gt(value) || maxValue.lt(value)) {\n                            this.throwOverflow(typeName);\n                        }\n                    }\n\n                    value = new System.Decimal(value);\n                } else if (typeCode === typeCodes.Int64) {\n                    if (value instanceof System.UInt64) {\n                        if (value.gt(System.Int64.MaxValue)) {\n                            this.throwOverflow(typeName);\n                        }\n                    } else if (value instanceof System.Decimal) {\n                        if ((value.gt(new System.Decimal(maxValue)) || value.lt(new System.Decimal(minValue)))) {\n                            this.throwOverflow(typeName);\n                        }\n                    } else if (!(value instanceof System.Int64)) {\n                        if (minValue.toNumber() > value || maxValue.toNumber() < value) {\n                            this.throwOverflow(typeName);\n                        }\n                    }\n\n                    value = new System.Int64(value);\n                } else if (typeCode === typeCodes.UInt64) {\n                    if (value instanceof System.Int64) {\n                        if (value.isNegative()) {\n                            this.throwOverflow(typeName);\n                        }\n                    } else if (value instanceof System.Decimal) {\n                        if ((value.gt(new System.Decimal(maxValue)) || value.lt(new System.Decimal(minValue)))) {\n                            this.throwOverflow(typeName);\n                        }\n                    } else if (!(value instanceof System.UInt64)) {\n                        if (minValue.toNumber() > value || maxValue.toNumber() < value) {\n                            this.throwOverflow(typeName);\n                        }\n                    }\n\n                    value = new System.UInt64(value);\n                }\n            } else if (value < minValue || value > maxValue) {\n                this.throwOverflow(typeName);\n            }\n        },\n\n        throwOverflow: function (typeName) {\n            throw new System.OverflowException(\"Value was either too large or too small for '\" + typeName + \"'.\");\n        },\n\n        roundToInt: function (value, typeCode) {\n            if (value % 1 === 0) {\n                return value;\n            }\n\n            var intPart;\n\n            if (value >= 0) {\n                intPart = Math.floor(value);\n            } else {\n                intPart = -1 * Math.floor(-value);\n            }\n\n            var floatPart = value - intPart,\n                minValue = scope.internal.getMinValue(typeCode),\n                maxValue = scope.internal.getMaxValue(typeCode);\n\n            if (value >= 0.0) {\n                if (value < (maxValue + 0.5)) {\n                    if (floatPart > 0.5 || floatPart === 0.5 && (intPart & 1) !== 0) {\n                        ++intPart;\n                    }\n\n                    return intPart;\n                }\n            } else if (value >= (minValue - 0.5)) {\n                if (floatPart < -0.5 || floatPart === -0.5 && (intPart & 1) !== 0) {\n                    --intPart;\n                }\n\n                return intPart;\n            }\n\n            var typeName = scope.internal.getTypeCodeName(typeCode);\n\n            throw new System.OverflowException(\"Value was either too large or too small for an '\" + typeName + \"'.\");\n        },\n\n        toBase64_CalculateAndValidateOutputLength: function (inputLength, insertLineBreaks) {\n            var base64LineBreakPosition = scope.internal.base64LineBreakPosition,\n                outlen = ~~(inputLength / 3) * 4; // the base length - we want integer division here.\n\n            outlen += ((inputLength % 3) !== 0) ? 4 : 0; // at most 4 more chars for the remainder\n\n            if (outlen === 0) {\n                return 0;\n            }\n\n            if (insertLineBreaks) {\n                var newLines = ~~(outlen / base64LineBreakPosition);\n\n                if ((outlen % base64LineBreakPosition) === 0) {\n                    --newLines;\n                }\n\n                outlen += newLines * 2; // the number of line break chars we'll add, \"\\r\\n\"\n            }\n\n            // If we overflow an int then we cannot allocate enough\n            // memory to output the value so throw\n            if (outlen > 2147483647) {\n                throw new System.OutOfMemoryException();\n            }\n\n            return outlen;\n        },\n\n        convertToBase64Array: function (outChars, inData, offset, length, insertLineBreaks) {\n            var base64Table = scope.internal.base64Table,\n                base64LineBreakPosition = scope.internal.base64LineBreakPosition,\n                lengthmod3 = length % 3,\n                calcLength = offset + (length - lengthmod3),\n                charCount = 0,\n                j = 0;\n\n            // Convert three bytes at a time to base64 notation.  This will consume 4 chars.\n            var i;\n\n            for (i = offset; i < calcLength; i += 3) {\n                if (insertLineBreaks) {\n                    if (charCount === base64LineBreakPosition) {\n                        outChars[j++] = \"\\r\";\n                        outChars[j++] = \"\\n\";\n                        charCount = 0;\n                    }\n\n                    charCount += 4;\n                }\n\n                outChars[j] = base64Table[(inData[i] & 0xfc) >> 2];\n                outChars[j + 1] = base64Table[((inData[i] & 0x03) << 4) | ((inData[i + 1] & 0xf0) >> 4)];\n                outChars[j + 2] = base64Table[((inData[i + 1] & 0x0f) << 2) | ((inData[i + 2] & 0xc0) >> 6)];\n                outChars[j + 3] = base64Table[(inData[i + 2] & 0x3f)];\n                j += 4;\n            }\n\n            //Where we left off before\n            i = calcLength;\n\n            if (insertLineBreaks && (lengthmod3 !== 0) && (charCount === scope.internal.base64LineBreakPosition)) {\n                outChars[j++] = \"\\r\";\n                outChars[j++] = \"\\n\";\n            }\n\n            switch (lengthmod3) {\n                case 2: //One character padding needed\n                    outChars[j] = base64Table[(inData[i] & 0xfc) >> 2];\n                    outChars[j + 1] = base64Table[((inData[i] & 0x03) << 4) | ((inData[i + 1] & 0xf0) >> 4)];\n                    outChars[j + 2] = base64Table[(inData[i + 1] & 0x0f) << 2];\n                    outChars[j + 3] = base64Table[64]; //Pad\n                    j += 4;\n                    break;\n\n                case 1: // Two character padding needed\n                    outChars[j] = base64Table[(inData[i] & 0xfc) >> 2];\n                    outChars[j + 1] = base64Table[(inData[i] & 0x03) << 4];\n                    outChars[j + 2] = base64Table[64]; //Pad\n                    outChars[j + 3] = base64Table[64]; //Pad\n                    j += 4;\n                    break;\n            }\n\n            return j;\n        },\n\n        fromBase64CharPtr: function (input, offset, inputLength) {\n            if (inputLength < 0) {\n                throw new System.ArgumentOutOfRangeException(\"inputLength\", \"Index was out of range. Must be non-negative and less than the size of the collection.\");\n            }\n\n            if (offset < 0) {\n                throw new System.ArgumentOutOfRangeException(\"offset\", \"Value must be positive.\");\n            }\n\n            // We need to get rid of any trailing white spaces.\n            // Otherwise we would be rejecting input such as \"abc= \":\n            while (inputLength > 0) {\n                var lastChar = input[offset + inputLength - 1];\n\n                if (lastChar !== \" \" && lastChar !== \"\\n\" && lastChar !== \"\\r\" && lastChar !== \"\\t\") {\n                    break;\n                }\n\n                inputLength--;\n            }\n\n            // Compute the output length:\n            var resultLength = scope.internal.fromBase64_ComputeResultLength(input, offset, inputLength);\n\n            if (0 > resultLength) {\n                throw new System.InvalidOperationException(\"Contract voilation: 0 <= resultLength.\");\n            }\n\n            // resultLength can be zero. We will still enter FromBase64_Decode and process the input.\n            // It may either simply write no bytes (e.g. input = \" \") or throw (e.g. input = \"ab\").\n\n            // Create result byte blob:\n            var decodedBytes = [];\n            decodedBytes.length = resultLength;\n\n            // Convert Base64 chars into bytes:\n            scope.internal.fromBase64_Decode(input, offset, inputLength, decodedBytes, 0, resultLength);\n\n            // We are done:\n            return decodedBytes;\n        },\n\n        fromBase64_Decode: function (input, inputIndex, inputLength, dest, destIndex, destLength) {\n            var startDestIndex = destIndex;\n\n            // You may find this method weird to look at. Its written for performance, not aesthetics.\n            // You will find unrolled loops label jumps and bit manipulations.\n\n            var intA = \"A\".charCodeAt(0),\n                inta = \"a\".charCodeAt(0),\n                int0 = \"0\".charCodeAt(0),\n                intEq = \"=\".charCodeAt(0),\n                intPlus = \"+\".charCodeAt(0),\n                intSlash = \"/\".charCodeAt(0),\n                intSpace = \" \".charCodeAt(0),\n                intTab = \"\\t\".charCodeAt(0),\n                intNLn = \"\\n\".charCodeAt(0),\n                intCRt = \"\\r\".charCodeAt(0),\n                intAtoZ = (\"Z\".charCodeAt(0) - \"A\".charCodeAt(0)),\n                int0To9 = (\"9\".charCodeAt(0) - \"0\".charCodeAt(0));\n\n            var endInputIndex = inputIndex + inputLength,\n                endDestIndex = destIndex + destLength;\n\n            // Current char code/value:\n            var currCode;\n\n            // This 4-byte integer will contain the 4 codes of the current 4-char group.\n            // Eeach char codes for 6 bits = 24 bits.\n            // The remaining byte will be FF, we use it as a marker when 4 chars have been processed.\n            var currBlockCodes = 0x000000FF;\n\n            var allInputConsumed = false,\n                equalityCharEncountered = false;\n\n            while (true) {\n                // break when done:\n                if (inputIndex >= endInputIndex) {\n                    allInputConsumed = true;\n                    break;\n                }\n\n                // Get current char:\n                currCode = input[inputIndex].charCodeAt(0);\n                inputIndex++;\n\n                // Determine current char code (unsigned Int comparison):\n                if (((currCode - intA) >>> 0) <= intAtoZ) {\n                    currCode -= intA;\n                } else if (((currCode - inta) >>> 0) <= intAtoZ) {\n                    currCode -= (inta - 26);\n                } else if (((currCode - int0) >>> 0) <= int0To9) {\n                    currCode -= (int0 - 52);\n                } else {\n                    // Use the slower switch for less common cases:\n                    switch (currCode) {\n                        // Significant chars:\n                        case intPlus:\n                            currCode = 62;\n                            break;\n\n                        case intSlash:\n                            currCode = 63;\n                            break;\n\n                            // Legal no-value chars (we ignore these):\n                        case intCRt:\n                        case intNLn:\n                        case intSpace:\n                        case intTab:\n                            continue;\n\n                            // The equality char is only legal at the end of the input.\n                            // Jump after the loop to make it easier for the JIT register predictor to do a good job for the loop itself:\n                        case intEq:\n                            equalityCharEncountered = true;\n                            break;\n\n                            // Other chars are illegal:\n                        default:\n                            throw new System.FormatException(\"The input is not a valid Base-64 string as it contains a non-base 64 character, more than two padding characters, or an illegal character among the padding characters.\");\n                    }\n                }\n\n                if (equalityCharEncountered) {\n                    break;\n                }\n\n                // Ok, we got the code. Save it:\n                currBlockCodes = (currBlockCodes << 6) | currCode;\n\n                // Last bit in currBlockCodes will be on after in shifted right 4 times:\n                if ((currBlockCodes & 0x80000000) !== 0) {\n                    if ((endDestIndex - destIndex) < 3) {\n                        return -1;\n                    }\n\n                    dest[destIndex] = 0xFF & (currBlockCodes >> 16);\n                    dest[destIndex + 1] = 0xFF & (currBlockCodes >> 8);\n                    dest[destIndex + 2] = 0xFF & (currBlockCodes);\n                    destIndex += 3;\n\n                    currBlockCodes = 0x000000FF;\n                }\n            } // end of while\n\n            if (!allInputConsumed && !equalityCharEncountered) {\n                throw new System.InvalidOperationException(\"Contract violation: should never get here.\");\n            }\n\n            if (equalityCharEncountered) {\n                if (currCode !== intEq) {\n                    throw new System.InvalidOperationException(\"Contract violation: currCode == intEq.\");\n                }\n\n                // Recall that inputIndex is now one position past where '=' was read.\n                // '=' can only be at the last input pos:\n                if (inputIndex === endInputIndex) {\n                    // Code is zero for trailing '=':\n                    currBlockCodes <<= 6;\n\n                    // The '=' did not complete a 4-group. The input must be bad:\n                    if ((currBlockCodes & 0x80000000) === 0) {\n                        throw new System.FormatException(\"Invalid length for a Base-64 char array or string.\");\n                    }\n\n                    if ((endDestIndex - destIndex) < 2) {\n                        // Autch! We underestimated the output length!\n                        return -1;\n                    }\n\n                    // We are good, store bytes form this past group. We had a single \"=\", so we take two bytes:\n                    dest[destIndex] = 0xFF & (currBlockCodes >> 16);\n                    dest[destIndex + 1] = 0xFF & (currBlockCodes >> 8);\n                    destIndex += 2;\n\n                    currBlockCodes = 0x000000FF;\n                } else { // '=' can also be at the pre-last position iff the last is also a '=' excluding the white spaces:\n                    // We need to get rid of any intermediate white spaces.\n                    // Otherwise we would be rejecting input such as \"abc= =\":\n                    while (inputIndex < (endInputIndex - 1)) {\n                        var lastChar = input[inputIndex];\n\n                        if (lastChar !== \" \" && lastChar !== \"\\n\" && lastChar !== \"\\r\" && lastChar !== \"\\t\") {\n                            break;\n                        }\n\n                        inputIndex++;\n                    }\n\n                    if (inputIndex === (endInputIndex - 1) && input[inputIndex] === \"=\") {\n                        // Code is zero for each of the two '=':\n                        currBlockCodes <<= 12;\n\n                        // The '=' did not complete a 4-group. The input must be bad:\n                        if ((currBlockCodes & 0x80000000) === 0) {\n                            throw new System.FormatException(\"Invalid length for a Base-64 char array or string.\");\n                        }\n\n                        if ((endDestIndex - destIndex) < 1) {\n                            // Autch! We underestimated the output length!\n                            return -1;\n                        }\n\n                        // We are good, store bytes form this past group. We had a \"==\", so we take only one byte:\n                        dest[destIndex] = 0xFF & (currBlockCodes >> 16);\n                        destIndex++;\n\n                        currBlockCodes = 0x000000FF;\n                    } else {\n                        // '=' is not ok at places other than the end:\n                        throw new System.FormatException(\"The input is not a valid Base-64 string as it contains a non-base 64 character, more than two padding characters, or an illegal character among the padding characters.\");\n                    }\n                }\n            }\n\n            // We get here either from above or by jumping out of the loop:\n            // The last block of chars has less than 4 items\n            if (currBlockCodes !== 0x000000FF) {\n                throw new System.FormatException(\"Invalid length for a Base-64 char array or string.\");\n            }\n\n            // Return how many bytes were actually recovered:\n            return (destIndex - startDestIndex);\n        },\n\n        fromBase64_ComputeResultLength: function (input, startIndex, inputLength) {\n            var intEq = \"=\",\n                intSpace = \" \";\n\n            if (inputLength < 0) {\n                throw new System.ArgumentOutOfRangeException(\"inputLength\", \"Index was out of range. Must be non-negative and less than the size of the collection.\");\n            }\n\n            var endIndex = startIndex + inputLength,\n                usefulInputLength = inputLength,\n                padding = 0;\n\n            while (startIndex < endIndex) {\n                var c = input[startIndex];\n\n                startIndex++;\n\n                // We want to be as fast as possible and filter out spaces with as few comparisons as possible.\n                // We end up accepting a number of illegal chars as legal white-space chars.\n                // This is ok: as soon as we hit them during actual decode we will recognise them as illegal and throw.\n                if (c <= intSpace) {\n                    usefulInputLength--;\n                } else if (c === intEq) {\n                    usefulInputLength--;\n                    padding++;\n                }\n            }\n\n            if (0 > usefulInputLength) {\n                throw new System.InvalidOperationException(\"Contract violation: 0 <= usefulInputLength.\");\n            }\n\n            if (0 > padding) {\n                // For legal input, we can assume that 0 <= padding < 3. But it may be more for illegal input.\n                // We will notice it at decode when we see a '=' at the wrong place.\n                throw new System.InvalidOperationException(\"Contract violation: 0 <= padding.\");\n            }\n\n            // Perf: reuse the variable that stored the number of '=' to store the number of bytes encoded by the\n            // last group that contains the '=':\n            if (padding !== 0) {\n                if (padding === 1) {\n                    padding = 2;\n                } else if (padding === 2) {\n                    padding = 1;\n                } else {\n                    throw new System.FormatException(\"The input is not a valid Base-64 string as it contains a non-base 64 character, more than two padding characters, or an illegal character among the padding characters.\");\n                }\n            }\n\n            // Done:\n            return ~~(usefulInputLength / 4) * 3 + padding;\n        },\n\n        charsToCodes: function (chars, codes, codesOffset) {\n            if (chars == null) {\n                return null;\n            }\n\n            codesOffset = codesOffset || 0;\n\n            if (codes == null) {\n                codes = [];\n                codes.length = chars.length;\n            }\n\n            for (var i = 0; i < chars.length; i++) {\n                codes[i + codesOffset] = chars[i].charCodeAt(0);\n            }\n\n            return codes;\n        },\n\n        codesToChars: function (codes, chars) {\n            if (codes == null) {\n                return null;\n            }\n\n            chars = chars || [];\n\n            for (var i = 0; i < codes.length; i++) {\n                var code = codes[i];\n\n                chars[i] = String.fromCharCode(code);\n            }\n\n            return chars;\n        },\n\n        throwInvalidCastEx: function (fromTypeCode, toTypeCode) {\n            var fromType = scope.internal.getTypeCodeName(fromTypeCode),                toType = scope.internal.getTypeCodeName(toTypeCode);\n\n            throw new System.InvalidCastException(\"Invalid cast from '\" + fromType + \"' to '\" + toType + \"'.\");\n        }\n    };\n\n    System.Convert = scope.convert;\n\n    // @source ClientWebSocket.js\n\n    Bridge.define(\"System.Net.WebSockets.ClientWebSocket\", {\n        inherits: [System.IDisposable],\n\n        ctor: function () {\n            this.$initialize();\n            this.messageBuffer = [];\n            this.state = \"none\";\n            this.options = new System.Net.WebSockets.ClientWebSocketOptions();\n            this.disposed = false;\n            this.closeStatus = null;\n            this.closeStatusDescription = null;\n        },\n\n        getCloseStatus: function () {\n            return this.closeStatus;\n        },\n\n        getState: function () {\n            return this.state;\n        },\n\n        getCloseStatusDescription: function () {\n            return this.closeStatusDescription;\n        },\n\n        getSubProtocol: function () {\n            return this.socket ? this.socket.protocol : null;\n        },\n\n        connectAsync: function (uri, cancellationToken) {\n            if (this.state !== \"none\") {\n                throw new System.InvalidOperationException(\"Socket is not in initial state\");\n            }\n\n            this.options.setToReadOnly();\n            this.state = \"connecting\";\n\n            var tcs = new System.Threading.Tasks.TaskCompletionSource(),\n                self = this;\n\n            try {\n                this.socket = new WebSocket(uri.getAbsoluteUri(), this.options.requestedSubProtocols);\n                this.socket.binaryType = \"arraybuffer\";\n                this.socket.onopen = function () {\n                    self.state = \"open\";\n                    tcs.setResult(null);\n                };\n\n                this.socket.onmessage = function (e) {\n                    var data = e.data,\n                        message = {},\n                        i;\n\n                    message.bytes = [];\n\n                    if (typeof (data) === \"string\") {\n                        for (i = 0; i < data.length; ++i) {\n                            message.bytes.push(data.charCodeAt(i));\n                        }\n\n                        message.messageType = \"text\";\n                        self.messageBuffer.push(message);\n\n                        return;\n                    }\n\n                    if (data instanceof ArrayBuffer) {\n                        var dataView = new Uint8Array(data);\n\n                        for (i = 0; i < dataView.length; i++) {\n                            message.bytes.push(dataView[i]);\n                        }\n\n                        message.messageType = \"binary\";\n                        self.messageBuffer.push(message);\n\n                        return;\n                    }\n\n                    throw new System.ArgumentException(\"Invalid message type.\");\n                };\n\n                this.socket.onclose = function (e) {\n                    self.state = \"closed\";\n                    self.closeStatus = e.code;\n                    self.closeStatusDescription = e.reason;\n                }\n            } catch (e) {\n                tcs.setException(System.Exception.create(e));\n            }\n\n            return tcs.task;\n        },\n\n        sendAsync: function (buffer, messageType, endOfMessage, cancellationToken) {\n            this.throwIfNotConnected();\n\n            var tcs = new System.Threading.Tasks.TaskCompletionSource();\n\n            try {\n                if (messageType === \"close\") {\n                    this.socket.close();\n                } else {\n                    var array = buffer.getArray(),\n                        count = buffer.getCount(),\n                        offset = buffer.getOffset();\n \n                    var data = new Uint8Array(count);\n\n                    for (var i = 0; i < count; i++) {\n                        data[i] = array[i + offset];\n                    }\n\n                    if (messageType === \"text\") {\n                        data = String.fromCharCode.apply(null, data);\n                    }\n \n                    this.socket.send(data);\n                }\n\n                tcs.setResult(null);\n            } catch (e) {\n                tcs.setException(System.Exception.create(e));\n            }\n\n            return tcs.task;\n        },\n\n        receiveAsync: function (buffer, cancellationToken) {\n            this.throwIfNotConnected();\n\n            var task,\n                tcs = new System.Threading.Tasks.TaskCompletionSource(),\n                self = this,\n                asyncBody = Bridge.fn.bind(this, function () {\n                    try {\n                        if (cancellationToken.getIsCancellationRequested()) {\n                            tcs.setException(new System.Threading.Tasks.TaskCanceledException(\"Receive has been cancelled.\", tcs.task));\n                            return;\n                        }\n\n                        if (self.messageBuffer.length === 0) {\n                            task = System.Threading.Tasks.Task.delay(0);\n                            task.continueWith(asyncBody);\n                            return;\n                        }\n\n                        var message = self.messageBuffer[0],\n                            array = buffer.getArray(),\n                            resultBytes,\n                            endOfMessage;\n\n                        if (message.bytes.length <= array.length) {\n                            self.messageBuffer.shift();\n                            resultBytes = message.bytes;\n                            endOfMessage = true;\n                        } else {\n                            resultBytes = message.bytes.slice(0, array.length);\n                            message.bytes = message.bytes.slice(array.length, message.bytes.length);\n                            endOfMessage = false;\n                        }\n\n                        for (var i = 0; i < resultBytes.length; i++) {\n                            array[i] = resultBytes[i];\n                        }\n\n                        tcs.setResult(new System.Net.WebSockets.WebSocketReceiveResult(\n                            resultBytes.length, message.messageType, endOfMessage));\n                    } catch (e) {\n                        tcs.setException(System.Exception.create(e));\n                    }\n                }, arguments);\n\n            asyncBody();\n\n            return tcs.task;\n        },\n\n        closeAsync: function (closeStatus, statusDescription, cancellationToken) {\n            this.throwIfNotConnected();\n\n            if (this.state !== \"open\") {\n                throw new System.InvalidOperationException(\"Socket is not in connected state\");\n            }\n\n            var tcs = new System.Threading.Tasks.TaskCompletionSource(),\n                self = this,\n                task,\n                asyncBody = function () {\n                    if (self.state === \"closed\") {\n                        tcs.setResult(null);\n                        return;\n                    }\n\n                    if (cancellationToken.getIsCancellationRequested()) {\n                        tcs.setException(new System.Threading.Tasks.TaskCanceledException(\"Closing has been cancelled.\", tcs.task));\n                        return;\n                    }\n\n                    task = System.Threading.Tasks.Task.delay(0);\n                    task.continueWith(asyncBody);\n                };\n            try {\n                this.state = \"closesent\";\n                this.socket.close(closeStatus, statusDescription);\n            } catch (e) {\n                tcs.setException(System.Exception.create(e));\n            }\n\n            asyncBody();\n\n            return tcs.task;\n        },\n\n        closeOutputAsync: function (closeStatus, statusDescription, cancellationToken) {\n            this.throwIfNotConnected();\n\n            if (this.state !== \"open\") {\n                throw new System.InvalidOperationException(\"Socket is not in connected state\");\n            }\n\n            var tcs = new System.Threading.Tasks.TaskCompletionSource();\n\n            try {\n                this.state = \"closesent\";\n                this.socket.close(closeStatus, statusDescription);\n                tcs.setResult(null);\n            } catch (e) {\n                tcs.setException(System.Exception.create(e));\n            }\n\n            return tcs.task;\n        },\n\n        abort: function () {\n            this.dispose();\n        },\n\n        dispose: function () {\n            if (this.disposed) {\n                return;\n            }\n\n            this.disposed = true;\n            this.messageBuffer = [];\n\n            if (state === \"open\") {\n                this.state = \"closesent\";\n                this.socket.close();\n            }\n        },\n\n        throwIfNotConnected: function () {\n            if (this.disposed) {\n                throw new System.InvalidOperationException(\"Socket is disposed.\");\n            }\n\n            if (this.socket.readyState !== 1) {\n                throw new System.InvalidOperationException(\"Socket is not connected.\");\n            }\n        }\n    });\n\n    Bridge.define(\"System.Net.WebSockets.ClientWebSocketOptions\", {\n        ctor: function () {\n            this.$initialize();\n            this.isReadOnly = false;\n            this.requestedSubProtocols = [];\n        },\n\n        setToReadOnly: function () {\n            if (this.isReadOnly) {\n                throw new System.InvalidOperationException(\"Options are already readonly.\");\n            }\n\n            this.isReadOnly = true;\n        },\n\n        addSubProtocol: function (subProtocol) {\n            if (this.isReadOnly) {\n                throw new System.InvalidOperationException(\"Socket already started.\");\n            }\n\n            if (this.requestedSubProtocols.indexOf(subProtocol) > -1) {\n                throw new System.ArgumentException(\"Socket cannot have duplicate sub-protocols.\", \"subProtocol\");\n            }\n\n            this.requestedSubProtocols.push(subProtocol);\n        }\n    });\n\n    Bridge.define(\"System.Net.WebSockets.WebSocketReceiveResult\", {\n        ctor: function (count, messageType, endOfMessage, closeStatus, closeStatusDescription) {\n            this.$initialize();\n            this.count = count;\n            this.messageType = messageType;\n            this.endOfMessage = endOfMessage;\n            this.closeStatus = closeStatus;\n            this.closeStatusDescription = closeStatusDescription;\n        },\n\n        getCount: function () {\n            return this.count;\n        },\n\n        getMessageType: function () {\n            return this.messageType;\n        },\n\n        getEndOfMessage: function () {\n            return this.endOfMessage;\n        },\n\n        getCloseStatus: function () {\n            return this.closeStatus;\n        },\n\n        getCloseStatusDescription: function () {\n            return this.closeStatusDescription;\n        }\n    });\n\n    // @source Uri.js\n\n    Bridge.define(\"System.Uri\", {\n        ctor: function (uriString) {\n            this.$initialize();\n            this.absoluteUri = uriString;\n        },\n\n        getAbsoluteUri: function () {\n            return this.absoluteUri;\n        },\n\n        toJSON: function () {\n            return this.absoluteUri;\n        }\n    });\n\n    // @source Generator.js\n\n    Bridge.define(\"Bridge.GeneratorEnumerable\", {\n        inherits: [System.Collections.IEnumerable],\n\n        config: {\n            alias: [\n            \"getEnumerator\", \"System$Collections$IEnumerable$getEnumerator\"\n            ]\n        },\n\n        ctor: function (action) {\n            this.$initialize();\n            this.getEnumerator = action;\n            this.System$Collections$IEnumerable$getEnumerator = action;\n        }\n    });\n\n    Bridge.define(\"Bridge.GeneratorEnumerable$1\", function(T)\n    {\n        return {\n            inherits: [System.Collections.Generic.IEnumerable$1(T)],\n\n            config: {\n                alias: [\n                \"getEnumerator\", [\"System$Collections$Generic$IEnumerable$1$\" + Bridge.getTypeAlias(T) + \"$getEnumerator\", \"System$Collections$Generic$IEnumerable$1$getEnumerator\"]\n                ]\n            },\n\n            ctor: function(action) {\n                this.$initialize();\n                this.getEnumerator = action;\n                this[\"System$Collections$Generic$IEnumerable$1$\" + Bridge.getTypeAlias(T) + \"$getEnumerator\"] = action;\n                this[\"System$Collections$Generic$IEnumerable$1$getEnumerator\"] = action;\n            }\n        };\n    });\n\n    Bridge.define(\"Bridge.GeneratorEnumerator\", {\n        inherits: [System.Collections.IEnumerator],\n\n        current: null,\n\n        config: {\n\t\t\tproperties: {\n\t\t\t\tCurrent: {\n\t\t\t\t\tget: function () {\n\t\t\t\t\t\treturn this.getCurrent();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\t\n            alias: [\n\t\t\t\t\"getCurrent\", \"System$Collections$IEnumerator$getCurrent\",\n\t\t\t\t\"moveNext\", \"System$Collections$IEnumerator$moveNext\",\n\t\t\t\t\"reset\", \"System$Collections$IEnumerator$reset\",\n\t\t\t\t\"Current\", \"System$Collections$IEnumerator$Current\"\n            ]\n        },\n\n        ctor: function (action) {\n            this.$initialize();\n            this.moveNext = action;\n            this.System$Collections$IEnumerator$moveNext = action;\n        },\n\n        getCurrent: function () {\n            return this.current;\n        },\n\n        getCurrent$1: function () {\n            return this.current;\n        },\n\n        reset: function () {\n            throw new System.NotSupportedException();\n        }\n    });\n\n    Bridge.define(\"Bridge.GeneratorEnumerator$1\", function (T) {\n        return {\n            inherits: [System.Collections.Generic.IEnumerator$1(T), System.IDisposable],\n\n            current: null,\n\n            config: {\n\t\t\t\tproperties: {\n\t\t\t\t\tCurrent: {\n\t\t\t\t\t\tget: function () {\n\t\t\t\t\t\t\treturn this.getCurrent();\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t\n\t\t\t\t\tCurrent$1: {\n\t\t\t\t\t\tget: function () {\n\t\t\t\t\t\t\treturn this.getCurrent();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n                alias: [\n\t\t\t\t\t\"getCurrent\", [\"System$Collections$Generic$IEnumerator$1$\" + Bridge.getTypeAlias(T) + \"$getCurrent$1\", \"System$Collections$Generic$IEnumerator$1$getCurrent$1\"],\n\t\t\t\t\t\"Current\", [\"System$Collections$Generic$IEnumerator$1$\" + Bridge.getTypeAlias(T) + \"$Current$1\", \"System$Collections$Generic$IEnumerator$1$Current$1\"],\n\t\t\t\t\t\"Current\", \"System$Collections$IEnumerator$Current\",\n\t\t\t\t\t\"dispose\", \"System$IDisposable$dispose\",\n\t\t\t\t\t\"moveNext\", \"System$Collections$IEnumerator$moveNext\",\n\t\t\t\t\t\"reset\", \"System$Collections$IEnumerator$reset\"\n                ]\n            },\n\n            ctor: function (action, final) {\n                this.$initialize();\n                this.moveNext = action;\n                this.System$Collections$IEnumerator$moveNext = action;\n                this.final = final;\n            },\n\n            getCurrent: function () {\n                return this.current;\n            },\n\n            getCurrent$1: function () {\n                return this.current;\n            },\n\n            System$Collections$IEnumerator$getCurrent: function () {\n                return this.current;\n            },\n\n            dispose: function () {\n                if (this.final) {\n                    this.final();\n                }\n            },\n\n            reset: function () {\n                throw new System.NotSupportedException();\n            }\n        };\n    });\n    // @source linq.js\n\n/*--------------------------------------------------------------------------\n * linq.js - LINQ for JavaScript\n * ver 3.0.4-Beta5 (Jun. 20th, 2013)\n *\n * created and maintained by neuecc <ils@neue.cc>\n * licensed under MIT License\n * http://linqjs.codeplex.com/\n *------------------------------------------------------------------------*/\n\n(function (root, undefined) {\n    // ReadOnly Function\n    var Functions = {\n        Identity: function (x) { return x; },\n        True: function () { return true; },\n        Blank: function () { }\n    };\n\n    // const Type\n    var Types = {\n        Boolean: typeof true,\n        Number: typeof 0,\n        String: typeof \"\",\n        Object: typeof {},\n        Undefined: typeof undefined,\n        Function: typeof function () { }\n    };\n\n    // createLambda cache\n    var funcCache = { \"\": Functions.Identity };\n\n    // private utility methods\n    var Utils = {\n        // Create anonymous function from lambda expression string\n        createLambda: function (expression) {\n            if (expression == null) return Functions.Identity;\n            if (typeof expression === Types.String) {\n                // get from cache\n                var f = funcCache[expression];\n                if (f != null) {\n                    return f;\n                }\n\n                if (expression.indexOf(\"=>\") === -1) {\n                    var regexp = new RegExp(\"[$]+\", \"g\");\n\n                    var maxLength = 0;\n                    var match;\n                    while ((match = regexp.exec(expression)) != null) {\n                        var paramNumber = match[0].length;\n                        if (paramNumber > maxLength) {\n                            maxLength = paramNumber;\n                        }\n                    }\n\n                    var argArray = [];\n                    for (var i = 1; i <= maxLength; i++) {\n                        var dollar = \"\";\n                        for (var j = 0; j < i; j++) {\n                            dollar += \"$\";\n                        }\n                        argArray.push(dollar);\n                    }\n\n                    var args = Array.prototype.join.call(argArray, \",\");\n\n                    f = new Function(args, \"return \" + expression);\n                    funcCache[expression] = f;\n                    return f;\n                }\n                else {\n                    var expr = expression.match(/^[(\\s]*([^()]*?)[)\\s]*=>(.*)/);\n                    f = new Function(expr[1], \"return \" + expr[2]);\n                    funcCache[expression] = f;\n                    return f;\n                }\n            }\n            return expression;\n        },\n\n        isIEnumerable: function (obj) {\n            if (typeof Enumerator !== Types.Undefined) {\n                try {\n                    new Enumerator(obj); // check JScript(IE)'s Enumerator\n                    return true;\n                }\n                catch (e) { }\n            }\n\n            return false;\n        },\n\n        // IE8's defineProperty is defined but cannot use, therefore check defineProperties\n        defineProperty: (Object.defineProperties != null)\n            ? function (target, methodName, value) {\n                Object.defineProperty(target, methodName, {\n                    enumerable: false,\n                    configurable: true,\n                    writable: true,\n                    value: value\n                })\n            }\n            : function (target, methodName, value) {\n                target[methodName] = value;\n            },\n\n        compare: function (a, b) {\n            return (a === b) ? 0\n                 : (a > b) ? 1\n                 : -1;\n        },\n\n        dispose: function (obj) {\n            if (obj != null) obj.dispose();\n        }\n    };\n\n    // IEnumerator State\n    var State = { Before: 0, Running: 1, After: 2 };\n\n    // \"Enumerator\" is conflict JScript's \"Enumerator\"\n    var IEnumerator = function (initialize, tryGetNext, dispose) {\n        var yielder = new Yielder();\n        var state = State.Before;\n\n        this.getCurrent = yielder.getCurrent;\n        this.reset = function () { throw new Error('Reset is not supported'); };\n\n        this.moveNext = function () {\n            try {\n                switch (state) {\n                    case State.Before:\n                        state = State.Running;\n                        initialize();\n                        // fall through\n                    case State.Running:\n                        if (tryGetNext.apply(yielder)) {\n                            return true;\n                        }\n                        else {\n                            this.dispose();\n                            return false;\n                        }\n                    case State.After:\n                        return false;\n                }\n            }\n            catch (e) {\n                this.dispose();\n                throw e;\n            }\n        };\n\n        this.dispose = function () {\n            if (state != State.Running) return;\n\n            try {\n                dispose();\n            }\n            finally {\n                state = State.After;\n            }\n        };\n\n        this.System$IDisposable$dispose = this.dispose;\n        this.getCurrent$1 = this.getCurrent;\n        this.System$Collections$IEnumerator$getCurrent = this.getCurrent;\n        this.System$Collections$IEnumerator$moveNext = this.moveNext;\n        this.System$Collections$IEnumerator$reset = this.reset;\n\n        Object.defineProperties(this,\n        {\n            \"Current$1\": {\n                get: this.getCurrent,\n                enumerable: true\n            },\n\n            \"Current\": {\n                get: this.getCurrent,\n                enumerable: true\n            },\n\n            \"System$Collections$IEnumerator$Current\": {\n                get: this.getCurrent,\n                enumerable: true\n            }\n        });\n    };\n\n    IEnumerator.$$inherits = [];\n    Bridge.Class.addExtend(IEnumerator, [System.IDisposable, System.Collections.IEnumerator]);\n\n    // for tryGetNext\n    var Yielder = function () {\n        var current = null;\n        this.getCurrent = function () { return current; };\n        this.yieldReturn = function (value) {\n            current = value;\n            return true;\n        };\n        this.yieldBreak = function () {\n            return false;\n        };\n    };\n\n    // Enumerable constuctor\n    var Enumerable = function (getEnumerator) {\n        this.getEnumerator = getEnumerator;\n    };\n\n    Enumerable.$$inherits = [];\n    Bridge.Class.addExtend(Enumerable, [System.Collections.IEnumerable]);\n\n    // Utility\n\n    Enumerable.Utils = {}; // container\n\n    Enumerable.Utils.createLambda = function (expression) {\n        return Utils.createLambda(expression);\n    };\n\n    Enumerable.Utils.createEnumerable = function (getEnumerator) {\n        return new Enumerable(getEnumerator);\n    };\n\n    Enumerable.Utils.createEnumerator = function (initialize, tryGetNext, dispose) {\n        return new IEnumerator(initialize, tryGetNext, dispose);\n    };\n\n    Enumerable.Utils.extendTo = function (type) {\n        var typeProto = type.prototype;\n        var enumerableProto;\n\n        if (type === Array) {\n            enumerableProto = ArrayEnumerable.prototype;\n            Utils.defineProperty(typeProto, \"getSource\", function () {\n                return this;\n            });\n        }\n        else {\n            enumerableProto = Enumerable.prototype;\n            Utils.defineProperty(typeProto, \"getEnumerator\", function () {\n                return Enumerable.from(this).getEnumerator();\n            });\n        }\n\n        for (var methodName in enumerableProto) {\n            var func = enumerableProto[methodName];\n\n            // already extended\n            if (typeProto[methodName] == func) continue;\n\n            // already defined(example Array#reverse/join/forEach...)\n            if (typeProto[methodName] != null) {\n                methodName = methodName + \"ByLinq\";\n                if (typeProto[methodName] == func) continue; // recheck\n            }\n\n            if (func instanceof Function) {\n                Utils.defineProperty(typeProto, methodName, func);\n            }\n        }\n    };\n\n    // Generator\n\n    Enumerable.choice = function () // variable argument\n    {\n        var args = arguments;\n\n        return new Enumerable(function () {\n            return new IEnumerator(\n                function () {\n                    args = (args[0] instanceof Array) ? args[0]\n                        : (args[0].getEnumerator != null) ? args[0].toArray()\n                        : args;\n                },\n                function () {\n                    return this.yieldReturn(args[Math.floor(Math.random() * args.length)]);\n                },\n                Functions.Blank);\n        });\n    };\n\n    Enumerable.cycle = function () // variable argument\n    {\n        var args = arguments;\n\n        return new Enumerable(function () {\n            var index = 0;\n            return new IEnumerator(\n                function () {\n                    args = (args[0] instanceof Array) ? args[0]\n                        : (args[0].getEnumerator != null) ? args[0].toArray()\n                        : args;\n                },\n                function () {\n                    if (index >= args.length) index = 0;\n                    return this.yieldReturn(args[index++]);\n                },\n                Functions.Blank);\n        });\n    };\n\n    // private singleton\n    var emptyEnumerable = new Enumerable(function () {\n            return new IEnumerator(\n                Functions.Blank,\n                function () { return false; },\n                Functions.Blank);\n        });\n    Enumerable.empty = function () {\n        return emptyEnumerable;\n    };\n\n    Enumerable.from = function (obj) {\n        if (obj == null) {\n            return Enumerable.empty();\n        }\n        if (obj instanceof Enumerable) {\n            return obj;\n        }\n        if (typeof obj == Types.Number || typeof obj == Types.Boolean) {\n            return Enumerable.repeat(obj, 1);\n        }\n        if (typeof obj == Types.String) {\n            return new Enumerable(function () {\n                var index = 0;\n                return new IEnumerator(\n                    Functions.Blank,\n                    function () {\n                        return (index < obj.length) ? this.yieldReturn(obj.charCodeAt(index++)) : false;\n                    },\n                    Functions.Blank);\n            });\n        }\n        var ienum = Bridge.as(obj, System.Collections.IEnumerable);\n        if (ienum) {\n            return new Enumerable(function () {\n                var enumerator;\n                return new IEnumerator(\n                    function () { enumerator = Bridge.getEnumerator(ienum); },\n                    function () {\n                        var ok = enumerator.moveNext();\n                        return ok ? this.yieldReturn(enumerator.Current) : false;\n                    },\n                    function () {\n                        var disposable = Bridge.as(enumerator, System.IDisposable);\n                        if (disposable) {\n                            disposable.dispose();\n                        }\n                    }\n                );\n            });\n        }\n        if (typeof obj != Types.Function) {\n            // array or array like object\n            if (typeof obj.length == Types.Number) {\n                return new ArrayEnumerable(obj);\n            }\n\n            // JScript's IEnumerable\n            if (!(obj instanceof Object) && Utils.isIEnumerable(obj)) {\n                return new Enumerable(function () {\n                    var isFirst = true;\n                    var enumerator;\n                    return new IEnumerator(\n                        function () { enumerator = new Enumerator(obj); },\n                        function () {\n                            if (isFirst) isFirst = false;\n                            else enumerator.moveNext();\n\n                            return (enumerator.atEnd()) ? false : this.yieldReturn(enumerator.item());\n                        },\n                        Functions.Blank);\n                });\n            }\n\n            // WinMD IIterable<T>\n            if (typeof Windows === Types.Object && typeof obj.first === Types.Function) {\n                return new Enumerable(function () {\n                    var isFirst = true;\n                    var enumerator;\n                    return new IEnumerator(\n                        function () { enumerator = obj.first(); },\n                        function () {\n                            if (isFirst) isFirst = false;\n                            else enumerator.moveNext();\n\n                            return (enumerator.hasCurrent) ? this.yieldReturn(enumerator.current) : this.yieldBreak();\n                        },\n                        Functions.Blank);\n                });\n            }\n        }\n\n        // case function/object : Create keyValuePair[]\n        return new Enumerable(function () {\n            var array = [];\n            var index = 0;\n\n            return new IEnumerator(\n                function () {\n                    for (var key in obj) {\n                        var value = obj[key];\n                        if (!(value instanceof Function) && Object.prototype.hasOwnProperty.call(obj, key)) {\n                            array.push({ key: key, value: value });\n                        }\n                    }\n                },\n                function () {\n                    return (index < array.length)\n                        ? this.yieldReturn(array[index++])\n                        : false;\n                },\n                Functions.Blank);\n        });\n    },\n\n    Enumerable.make = function (element) {\n        return Enumerable.repeat(element, 1);\n    };\n\n    // Overload:function (input, pattern)\n    // Overload:function (input, pattern, flags)\n    Enumerable.matches = function (input, pattern, flags) {\n        if (flags == null) flags = \"\";\n        if (pattern instanceof RegExp) {\n            flags += (pattern.ignoreCase) ? \"i\" : \"\";\n            flags += (pattern.multiline) ? \"m\" : \"\";\n            pattern = pattern.source;\n        }\n        if (flags.indexOf(\"g\") === -1) flags += \"g\";\n\n        return new Enumerable(function () {\n            var regex;\n            return new IEnumerator(\n                function () { regex = new RegExp(pattern, flags); },\n                function () {\n                    var match = regex.exec(input);\n                    return (match) ? this.yieldReturn(match) : false;\n                },\n                Functions.Blank);\n        });\n    };\n\n    // Overload:function (start, count)\n    // Overload:function (start, count, step)\n    Enumerable.range = function (start, count, step) {\n        if (step == null) step = 1;\n\n        return new Enumerable(function () {\n            var value;\n            var index = 0;\n\n            return new IEnumerator(\n                function () { value = start - step; },\n                function () {\n                    return (index++ < count)\n                        ? this.yieldReturn(value += step)\n                        : this.yieldBreak();\n                },\n                Functions.Blank);\n        });\n    };\n\n    // Overload:function (start, count)\n    // Overload:function (start, count, step)\n    Enumerable.rangeDown = function (start, count, step) {\n        if (step == null) step = 1;\n\n        return new Enumerable(function () {\n            var value;\n            var index = 0;\n\n            return new IEnumerator(\n                function () { value = start + step; },\n                function () {\n                    return (index++ < count)\n                        ? this.yieldReturn(value -= step)\n                        : this.yieldBreak();\n                },\n                Functions.Blank);\n        });\n    };\n\n    // Overload:function (start, to)\n    // Overload:function (start, to, step)\n    Enumerable.rangeTo = function (start, to, step) {\n        if (step == null) step = 1;\n\n        if (start < to) {\n            return new Enumerable(function () {\n                var value;\n\n                return new IEnumerator(\n                function () { value = start - step; },\n                function () {\n                    var next = value += step;\n                    return (next <= to)\n                        ? this.yieldReturn(next)\n                        : this.yieldBreak();\n                },\n                Functions.Blank);\n            });\n        }\n        else {\n            return new Enumerable(function () {\n                var value;\n\n                return new IEnumerator(\n                function () { value = start + step; },\n                function () {\n                    var next = value -= step;\n                    return (next >= to)\n                        ? this.yieldReturn(next)\n                        : this.yieldBreak();\n                },\n                Functions.Blank);\n            });\n        }\n    };\n\n    // Overload:function (element)\n    // Overload:function (element, count)\n    Enumerable.repeat = function (element, count) {\n        if (count != null) return Enumerable.repeat(element).take(count);\n\n        return new Enumerable(function () {\n            return new IEnumerator(\n                Functions.Blank,\n                function () { return this.yieldReturn(element); },\n                Functions.Blank);\n        });\n    };\n\n    Enumerable.repeatWithFinalize = function (initializer, finalizer) {\n        initializer = Utils.createLambda(initializer);\n        finalizer = Utils.createLambda(finalizer);\n\n        return new Enumerable(function () {\n            var element;\n            return new IEnumerator(\n                function () { element = initializer(); },\n                function () { return this.yieldReturn(element); },\n                function () {\n                    if (element != null) {\n                        finalizer(element);\n                        element = null;\n                    }\n                });\n        });\n    };\n\n    // Overload:function (func)\n    // Overload:function (func, count)\n    Enumerable.generate = function (func, count) {\n        if (count != null) return Enumerable.generate(func).take(count);\n        func = Utils.createLambda(func);\n\n        return new Enumerable(function () {\n            return new IEnumerator(\n                Functions.Blank,\n                function () { return this.yieldReturn(func()); },\n                Functions.Blank);\n        });\n    };\n\n    // Overload:function ()\n    // Overload:function (start)\n    // Overload:function (start, step)\n    Enumerable.toInfinity = function (start, step) {\n        if (start == null) start = 0;\n        if (step == null) step = 1;\n\n        return new Enumerable(function () {\n            var value;\n            return new IEnumerator(\n                function () { value = start - step; },\n                function () { return this.yieldReturn(value += step); },\n                Functions.Blank);\n        });\n    };\n\n    // Overload:function ()\n    // Overload:function (start)\n    // Overload:function (start, step)\n    Enumerable.toNegativeInfinity = function (start, step) {\n        if (start == null) start = 0;\n        if (step == null) step = 1;\n\n        return new Enumerable(function () {\n            var value;\n            return new IEnumerator(\n                function () { value = start + step; },\n                function () { return this.yieldReturn(value -= step); },\n                Functions.Blank);\n        });\n    };\n\n    Enumerable.unfold = function (seed, func) {\n        func = Utils.createLambda(func);\n\n        return new Enumerable(function () {\n            var isFirst = true;\n            var value;\n            return new IEnumerator(\n                Functions.Blank,\n                function () {\n                    if (isFirst) {\n                        isFirst = false;\n                        value = seed;\n                        return this.yieldReturn(value);\n                    }\n                    value = func(value);\n                    return this.yieldReturn(value);\n                },\n                Functions.Blank);\n        });\n    };\n\n    Enumerable.defer = function (enumerableFactory) {\n        return new Enumerable(function () {\n            var enumerator;\n\n            return new IEnumerator(\n                function () { enumerator = Enumerable.from(enumerableFactory()).getEnumerator(); },\n                function () {\n                    return (enumerator.moveNext())\n                        ? this.yieldReturn(enumerator.Current)\n                        : this.yieldBreak();\n                },\n                function () {\n                    Utils.dispose(enumerator);\n                });\n        });\n    };\n\n    // Extension Methods\n\n    /* Projection and Filtering Methods */\n\n    // Overload:function (func)\n    // Overload:function (func, resultSelector<element>)\n    // Overload:function (func, resultSelector<element, nestLevel>)\n    Enumerable.prototype.traverseBreadthFirst = function (func, resultSelector) {\n        var source = this;\n        func = Utils.createLambda(func);\n        resultSelector = Utils.createLambda(resultSelector);\n\n        return new Enumerable(function () {\n            var enumerator;\n            var nestLevel = 0;\n            var buffer = [];\n\n            return new IEnumerator(\n                function () { enumerator = source.getEnumerator(); },\n                function () {\n                    while (true) {\n                        if (enumerator.moveNext()) {\n                            buffer.push(enumerator.Current);\n                            return this.yieldReturn(resultSelector(enumerator.Current, nestLevel));\n                        }\n\n                        var next = Enumerable.from(buffer).selectMany(function (x) { return func(x); });\n                        if (!next.any()) {\n                            return false;\n                        }\n                        else {\n                            nestLevel++;\n                            buffer = [];\n                            Utils.dispose(enumerator);\n                            enumerator = next.getEnumerator();\n                        }\n                    }\n                },\n                function () { Utils.dispose(enumerator); });\n        });\n    };\n\n    // Overload:function (func)\n    // Overload:function (func, resultSelector<element>)\n    // Overload:function (func, resultSelector<element, nestLevel>)\n    Enumerable.prototype.traverseDepthFirst = function (func, resultSelector) {\n        var source = this;\n        func = Utils.createLambda(func);\n        resultSelector = Utils.createLambda(resultSelector);\n\n        return new Enumerable(function () {\n            var enumeratorStack = [];\n            var enumerator;\n\n            return new IEnumerator(\n                function () { enumerator = source.getEnumerator(); },\n                function () {\n                    while (true) {\n                        if (enumerator.moveNext()) {\n                            var value = resultSelector(enumerator.Current, enumeratorStack.length);\n                            enumeratorStack.push(enumerator);\n                            enumerator = Enumerable.from(func(enumerator.Current)).getEnumerator();\n                            return this.yieldReturn(value);\n                        }\n\n                        if (enumeratorStack.length <= 0) return false;\n                        Utils.dispose(enumerator);\n                        enumerator = enumeratorStack.pop();\n                    }\n                },\n                function () {\n                    try {\n                        Utils.dispose(enumerator);\n                    }\n                    finally {\n                        Enumerable.from(enumeratorStack).forEach(function (s) { s.dispose(); });\n                    }\n                });\n        });\n    };\n\n    Enumerable.prototype.flatten = function () {\n        var source = this;\n\n        return new Enumerable(function () {\n            var enumerator;\n            var middleEnumerator = null;\n\n            return new IEnumerator(\n                function () { enumerator = source.getEnumerator(); },\n                function () {\n                    while (true) {\n                        if (middleEnumerator != null) {\n                            if (middleEnumerator.moveNext()) {\n                                return this.yieldReturn(middleEnumerator.Current);\n                            }\n                            else {\n                                middleEnumerator = null;\n                            }\n                        }\n\n                        if (enumerator.moveNext()) {\n                            if (enumerator.Current instanceof Array) {\n                                Utils.dispose(middleEnumerator);\n                                middleEnumerator = Enumerable.from(enumerator.Current)\n                                    .selectMany(Functions.Identity)\n                                    .flatten()\n                                    .getEnumerator();\n                                continue;\n                            }\n                            else {\n                                return this.yieldReturn(enumerator.Current);\n                            }\n                        }\n\n                        return false;\n                    }\n                },\n                function () {\n                    try {\n                        Utils.dispose(enumerator);\n                    }\n                    finally {\n                        Utils.dispose(middleEnumerator);\n                    }\n                });\n        });\n    };\n\n    Enumerable.prototype.pairwise = function (selector) {\n        var source = this;\n        selector = Utils.createLambda(selector);\n\n        return new Enumerable(function () {\n            var enumerator;\n\n            return new IEnumerator(\n                function () {\n                    enumerator = source.getEnumerator();\n                    enumerator.moveNext();\n                },\n                function () {\n                    var prev = enumerator.Current;\n                    return (enumerator.moveNext())\n                        ? this.yieldReturn(selector(prev, enumerator.Current))\n                        : false;\n                },\n                function () { Utils.dispose(enumerator); });\n        });\n    };\n\n    // Overload:function (func)\n    // Overload:function (seed,func<value,element>)\n    Enumerable.prototype.scan = function (seed, func) {\n        var isUseSeed;\n        if (func == null) {\n            func = Utils.createLambda(seed); // arguments[0]\n            isUseSeed = false;\n        } else {\n            func = Utils.createLambda(func);\n            isUseSeed = true;\n        }\n        var source = this;\n\n        return new Enumerable(function () {\n            var enumerator;\n            var value;\n            var isFirst = true;\n\n            return new IEnumerator(\n                function () { enumerator = source.getEnumerator(); },\n                function () {\n                    if (isFirst) {\n                        isFirst = false;\n                        if (!isUseSeed) {\n                            if (enumerator.moveNext()) {\n                                return this.yieldReturn(value = enumerator.Current);\n                            }\n                        }\n                        else {\n                            return this.yieldReturn(value = seed);\n                        }\n                    }\n\n                    return (enumerator.moveNext())\n                        ? this.yieldReturn(value = func(value, enumerator.Current))\n                        : false;\n                },\n                function () { Utils.dispose(enumerator); });\n        });\n    };\n\n    // Overload:function (selector<element>)\n    // Overload:function (selector<element,index>)\n    Enumerable.prototype.select = function (selector) {\n        selector = Utils.createLambda(selector);\n\n        if (selector.length <= 1) {\n            return new WhereSelectEnumerable(this, null, selector);\n        }\n        else {\n            var source = this;\n\n            return new Enumerable(function () {\n                var enumerator;\n                var index = 0;\n\n                return new IEnumerator(\n                    function () { enumerator = source.getEnumerator(); },\n                    function () {\n                        return (enumerator.moveNext())\n                            ? this.yieldReturn(selector(enumerator.Current, index++))\n                            : false;\n                    },\n                    function () { Utils.dispose(enumerator); });\n            });\n        }\n    };\n\n    // Overload:function (collectionSelector<element>)\n    // Overload:function (collectionSelector<element,index>)\n    // Overload:function (collectionSelector<element>,resultSelector)\n    // Overload:function (collectionSelector<element,index>,resultSelector)\n    Enumerable.prototype.selectMany = function (collectionSelector, resultSelector) {\n        var source = this;\n        collectionSelector = Utils.createLambda(collectionSelector);\n        if (resultSelector == null) resultSelector = function (a, b) { return b; };\n        resultSelector = Utils.createLambda(resultSelector);\n\n        return new Enumerable(function () {\n            var enumerator;\n            var middleEnumerator = undefined;\n            var index = 0;\n\n            return new IEnumerator(\n                function () { enumerator = source.getEnumerator(); },\n                function () {\n                    if (middleEnumerator === undefined) {\n                        if (!enumerator.moveNext()) return false;\n                    }\n                    do {\n                        if (middleEnumerator == null) {\n                            var middleSeq = collectionSelector(enumerator.Current, index++);\n                            middleEnumerator = Enumerable.from(middleSeq).getEnumerator();\n                        }\n                        if (middleEnumerator.moveNext()) {\n                            return this.yieldReturn(resultSelector(enumerator.Current, middleEnumerator.Current));\n                        }\n                        Utils.dispose(middleEnumerator);\n                        middleEnumerator = null;\n                    } while (enumerator.moveNext());\n                    return false;\n                },\n                function () {\n                    try {\n                        Utils.dispose(enumerator);\n                    }\n                    finally {\n                        Utils.dispose(middleEnumerator);\n                    }\n                });\n        });\n    };\n\n    // Overload:function (predicate<element>)\n    // Overload:function (predicate<element,index>)\n    Enumerable.prototype.where = function (predicate) {\n        predicate = Utils.createLambda(predicate);\n\n        if (predicate.length <= 1) {\n            return new WhereEnumerable(this, predicate);\n        }\n        else {\n            var source = this;\n\n            return new Enumerable(function () {\n                var enumerator;\n                var index = 0;\n\n                return new IEnumerator(\n                    function () { enumerator = source.getEnumerator(); },\n                    function () {\n                        while (enumerator.moveNext()) {\n                            if (predicate(enumerator.Current, index++)) {\n                                return this.yieldReturn(enumerator.Current);\n                            }\n                        }\n                        return false;\n                    },\n                    function () { Utils.dispose(enumerator); });\n            });\n        }\n    };\n\n    // Overload:function (selector<element>)\n    // Overload:function (selector<element,index>)\n    Enumerable.prototype.choose = function (selector) {\n        selector = Utils.createLambda(selector);\n        var source = this;\n\n        return new Enumerable(function () {\n            var enumerator;\n            var index = 0;\n\n            return new IEnumerator(\n                function () { enumerator = source.getEnumerator(); },\n                function () {\n                    while (enumerator.moveNext()) {\n                        var result = selector(enumerator.Current, index++);\n                        if (result != null) {\n                            return this.yieldReturn(result);\n                        }\n                    }\n                    return this.yieldBreak();\n                },\n                function () { Utils.dispose(enumerator); });\n        });\n    };\n\n    Enumerable.prototype.ofType = function (type) {\n        var source = this;\n\n        return new Enumerable(function () {\n            var enumerator;\n\n            return new IEnumerator(\n                function () {\n\t\t\t\t\tenumerator = Bridge.getEnumerator(source);\n\t\t\t\t},\n                function () {\n                    while (enumerator.moveNext()) {\n                        var v = Bridge.as(enumerator.Current, type);\n                        if (Bridge.hasValue(v)) {\n                            return this.yieldReturn(v);\n                        }\n                    }\n                    return false;\n                },\n                function () {\n\t\t\t\t\tUtils.dispose(enumerator);\n\t\t\t\t});\n        });\n    };\n\n    // mutiple arguments, last one is selector, others are enumerable\n    Enumerable.prototype.zip = function () {\n        var args = arguments;\n        var selector = Utils.createLambda(arguments[arguments.length - 1]);\n\n        var source = this;\n        // optimized case:argument is 2\n        if (arguments.length == 2) {\n            var second = arguments[0];\n\n            return new Enumerable(function () {\n                var firstEnumerator;\n                var secondEnumerator;\n                var index = 0;\n\n                return new IEnumerator(\n                function () {\n                    firstEnumerator = source.getEnumerator();\n                    secondEnumerator = Enumerable.from(second).getEnumerator();\n                },\n                function () {\n                    if (firstEnumerator.moveNext() && secondEnumerator.moveNext()) {\n                        return this.yieldReturn(selector(firstEnumerator.Current, secondEnumerator.Current, index++));\n                    }\n                    return false;\n                },\n                function () {\n                    try {\n                        Utils.dispose(firstEnumerator);\n                    } finally {\n                        Utils.dispose(secondEnumerator);\n                    }\n                });\n            });\n        }\n        else {\n            return new Enumerable(function () {\n                var enumerators;\n                var index = 0;\n\n                return new IEnumerator(\n                function () {\n                    var array = Enumerable.make(source)\n                        .concat(Enumerable.from(args).takeExceptLast().select(Enumerable.from))\n                        .select(function (x) { return x.getEnumerator() })\n                        .toArray();\n                    enumerators = Enumerable.from(array);\n                },\n                function () {\n                    if (enumerators.all(function (x) { return x.moveNext() })) {\n                        var array = enumerators\n                            .select(function (x) { return x.Current; })\n                            .toArray();\n                        array.push(index++);\n                        return this.yieldReturn(selector.apply(null, array));\n                    }\n                    else {\n                        return this.yieldBreak();\n                    }\n                },\n                function () {\n                    Enumerable.from(enumerators).forEach(Utils.dispose);\n                });\n            });\n        }\n    };\n\n    // mutiple arguments\n    Enumerable.prototype.merge = function () {\n        var args = arguments;\n        var source = this;\n\n        return new Enumerable(function () {\n            var enumerators;\n            var index = -1;\n\n            return new IEnumerator(\n                function () {\n                    enumerators = Enumerable.make(source)\n                        .concat(Enumerable.from(args).select(Enumerable.from))\n                        .select(function (x) { return x.getEnumerator() })\n                        .toArray();\n                },\n                function () {\n                    while (enumerators.length > 0) {\n                        index = (index >= enumerators.length - 1) ? 0 : index + 1;\n                        var enumerator = enumerators[index];\n\n                        if (enumerator.moveNext()) {\n                            return this.yieldReturn(enumerator.Current);\n                        }\n                        else {\n                            enumerator.dispose();\n                            enumerators.splice(index--, 1);\n                        }\n                    }\n                    return this.yieldBreak();\n                },\n                function () {\n                    Enumerable.from(enumerators).forEach(Utils.dispose);\n                });\n        });\n    };\n\n    /* Join Methods */\n\n    // Overload:function (inner, outerKeySelector, innerKeySelector, resultSelector)\n    // Overload:function (inner, outerKeySelector, innerKeySelector, resultSelector, compareSelector)\n    Enumerable.prototype.join = function (inner, outerKeySelector, innerKeySelector, resultSelector, comparer) {\n        outerKeySelector = Utils.createLambda(outerKeySelector);\n        innerKeySelector = Utils.createLambda(innerKeySelector);\n        resultSelector = Utils.createLambda(resultSelector);\n\n        var source = this;\n\n        return new Enumerable(function () {\n            var outerEnumerator;\n            var lookup;\n            var innerElements = null;\n            var innerCount = 0;\n\n            return new IEnumerator(\n                function () {\n                    outerEnumerator = source.getEnumerator();\n                    lookup = Enumerable.from(inner).toLookup(innerKeySelector, Functions.Identity, comparer);\n                },\n                function () {\n                    while (true) {\n                        if (innerElements != null) {\n                            var innerElement = innerElements[innerCount++];\n                            if (innerElement !== undefined) {\n                                return this.yieldReturn(resultSelector(outerEnumerator.Current, innerElement));\n                            }\n\n                            innerElement = null;\n                            innerCount = 0;\n                        }\n\n                        if (outerEnumerator.moveNext()) {\n                            var key = outerKeySelector(outerEnumerator.Current);\n                            innerElements = lookup.get(key).toArray();\n                        } else {\n                            return false;\n                        }\n                    }\n                },\n                function () { Utils.dispose(outerEnumerator); });\n        });\n    };\n\n    // Overload:function (inner, outerKeySelector, innerKeySelector, resultSelector)\n    // Overload:function (inner, outerKeySelector, innerKeySelector, resultSelector, compareSelector)\n    Enumerable.prototype.groupJoin = function (inner, outerKeySelector, innerKeySelector, resultSelector, comparer) {\n        outerKeySelector = Utils.createLambda(outerKeySelector);\n        innerKeySelector = Utils.createLambda(innerKeySelector);\n        resultSelector = Utils.createLambda(resultSelector);\n        var source = this;\n\n        return new Enumerable(function () {\n            var enumerator = source.getEnumerator();\n            var lookup = null;\n\n            return new IEnumerator(\n                function () {\n                    enumerator = source.getEnumerator();\n                    lookup = Enumerable.from(inner).toLookup(innerKeySelector, Functions.Identity, comparer);\n                },\n                function () {\n                    if (enumerator.moveNext()) {\n                        var innerElement = lookup.get(outerKeySelector(enumerator.Current));\n                        return this.yieldReturn(resultSelector(enumerator.Current, innerElement));\n                    }\n                    return false;\n                },\n                function () { Utils.dispose(enumerator); });\n        });\n    };\n\n    /* Set Methods */\n\n    Enumerable.prototype.all = function (predicate) {\n        predicate = Utils.createLambda(predicate);\n\n        var result = true;\n        this.forEach(function (x) {\n            if (!predicate(x)) {\n                result = false;\n                return false; // break\n            }\n        });\n        return result;\n    };\n\n    // Overload:function ()\n    // Overload:function (predicate)\n    Enumerable.prototype.any = function (predicate) {\n        predicate = Utils.createLambda(predicate);\n\n        var enumerator = this.getEnumerator();\n        try {\n            if (arguments.length == 0) return enumerator.moveNext(); // case:function ()\n\n            while (enumerator.moveNext()) // case:function (predicate)\n            {\n                if (predicate(enumerator.Current)) return true;\n            }\n            return false;\n        }\n        finally {\n            Utils.dispose(enumerator);\n        }\n    };\n\n    Enumerable.prototype.isEmpty = function () {\n        return !this.any();\n    };\n\n    // multiple arguments\n    Enumerable.prototype.concat = function () {\n        var source = this;\n\n        if (arguments.length == 1) {\n            var second = arguments[0];\n\n            return new Enumerable(function () {\n                var firstEnumerator;\n                var secondEnumerator;\n\n                return new IEnumerator(\n                function () { firstEnumerator = source.getEnumerator(); },\n                function () {\n                    if (secondEnumerator == null) {\n                        if (firstEnumerator.moveNext()) return this.yieldReturn(firstEnumerator.Current);\n                        secondEnumerator = Enumerable.from(second).getEnumerator();\n                    }\n                    if (secondEnumerator.moveNext()) return this.yieldReturn(secondEnumerator.Current);\n                    return false;\n                },\n                function () {\n                    try {\n                        Utils.dispose(firstEnumerator);\n                    }\n                    finally {\n                        Utils.dispose(secondEnumerator);\n                    }\n                });\n            });\n        }\n        else {\n            var args = arguments;\n\n            return new Enumerable(function () {\n                var enumerators;\n\n                return new IEnumerator(\n                    function () {\n                        enumerators = Enumerable.make(source)\n                            .concat(Enumerable.from(args).select(Enumerable.from))\n                            .select(function (x) { return x.getEnumerator() })\n                            .toArray();\n                    },\n                    function () {\n                        while (enumerators.length > 0) {\n                            var enumerator = enumerators[0];\n\n                            if (enumerator.moveNext()) {\n                                return this.yieldReturn(enumerator.Current);\n                            }\n                            else {\n                                enumerator.dispose();\n                                enumerators.splice(0, 1);\n                            }\n                        }\n                        return this.yieldBreak();\n                    },\n                    function () {\n                        Enumerable.from(enumerators).forEach(Utils.dispose);\n                    });\n            });\n        }\n    };\n\n    Enumerable.prototype.insert = function (index, second) {\n        var source = this;\n\n        return new Enumerable(function () {\n            var firstEnumerator;\n            var secondEnumerator;\n            var count = 0;\n            var isEnumerated = false;\n\n            return new IEnumerator(\n                function () {\n                    firstEnumerator = source.getEnumerator();\n                    secondEnumerator = Enumerable.from(second).getEnumerator();\n                },\n                function () {\n                    if (count == index && secondEnumerator.moveNext()) {\n                        isEnumerated = true;\n                        return this.yieldReturn(secondEnumerator.Current);\n                    }\n                    if (firstEnumerator.moveNext()) {\n                        count++;\n                        return this.yieldReturn(firstEnumerator.Current);\n                    }\n                    if (!isEnumerated && secondEnumerator.moveNext()) {\n                        return this.yieldReturn(secondEnumerator.Current);\n                    }\n                    return false;\n                },\n                function () {\n                    try {\n                        Utils.dispose(firstEnumerator);\n                    }\n                    finally {\n                        Utils.dispose(secondEnumerator);\n                    }\n                });\n        });\n    };\n\n    Enumerable.prototype.alternate = function (alternateValueOrSequence) {\n        var source = this;\n\n        return new Enumerable(function () {\n            var buffer;\n            var enumerator;\n            var alternateSequence;\n            var alternateEnumerator;\n\n            return new IEnumerator(\n                function () {\n                    if (alternateValueOrSequence instanceof Array || alternateValueOrSequence.getEnumerator != null) {\n                        alternateSequence = Enumerable.from(Enumerable.from(alternateValueOrSequence).toArray()); // freeze\n                    }\n                    else {\n                        alternateSequence = Enumerable.make(alternateValueOrSequence);\n                    }\n                    enumerator = source.getEnumerator();\n                    if (enumerator.moveNext()) buffer = enumerator.Current;\n                },\n                function () {\n                    while (true) {\n                        if (alternateEnumerator != null) {\n                            if (alternateEnumerator.moveNext()) {\n                                return this.yieldReturn(alternateEnumerator.Current);\n                            }\n                            else {\n                                alternateEnumerator = null;\n                            }\n                        }\n\n                        if (buffer == null && enumerator.moveNext()) {\n                            buffer = enumerator.Current; // hasNext\n                            alternateEnumerator = alternateSequence.getEnumerator();\n                            continue; // GOTO\n                        }\n                        else if (buffer != null) {\n                            var retVal = buffer;\n                            buffer = null;\n                            return this.yieldReturn(retVal);\n                        }\n\n                        return this.yieldBreak();\n                    }\n                },\n                function () {\n                    try {\n                        Utils.dispose(enumerator);\n                    }\n                    finally {\n                        Utils.dispose(alternateEnumerator);\n                    }\n                });\n        });\n    };\n\n    // Overload:function (value)\n    // Overload:function (value, compareSelector)\n    Enumerable.prototype.contains = function (value, comparer) {\n        comparer = comparer || System.Collections.Generic.EqualityComparer$1.$default;\n        var enumerator = this.getEnumerator();\n        try {\n            while (enumerator.moveNext()) {\n                if (comparer.equals2(enumerator.Current, value)) return true;\n            }\n            return false;\n        }\n        finally {\n            Utils.dispose(enumerator);\n        }\n    };\n\n    Enumerable.prototype.defaultIfEmpty = function (defaultValue) {\n        var source = this;\n        if (defaultValue === undefined) defaultValue = null;\n\n        return new Enumerable(function () {\n            var enumerator;\n            var isFirst = true;\n\n            return new IEnumerator(\n                function () { enumerator = source.getEnumerator(); },\n                function () {\n                    if (enumerator.moveNext()) {\n                        isFirst = false;\n                        return this.yieldReturn(enumerator.Current);\n                    }\n                    else if (isFirst) {\n                        isFirst = false;\n                        return this.yieldReturn(defaultValue);\n                    }\n                    return false;\n                },\n                function () { Utils.dispose(enumerator); });\n        });\n    };\n\n    // Overload:function ()\n    // Overload:function (compareSelector)\n    Enumerable.prototype.distinct = function (comparer) {\n        return this.except(Enumerable.empty(), comparer);\n    };\n\n    Enumerable.prototype.distinctUntilChanged = function (compareSelector) {\n        compareSelector = Utils.createLambda(compareSelector);\n        var source = this;\n\n        return new Enumerable(function () {\n            var enumerator;\n            var compareKey;\n            var initial;\n\n            return new IEnumerator(\n                function () {\n                    enumerator = source.getEnumerator();\n                },\n                function () {\n                    while (enumerator.moveNext()) {\n                        var key = compareSelector(enumerator.Current);\n\n                        if (initial) {\n                            initial = false;\n                            compareKey = key;\n                            return this.yieldReturn(enumerator.Current);\n                        }\n\n                        if (compareKey === key) {\n                            continue;\n                        }\n\n                        compareKey = key;\n                        return this.yieldReturn(enumerator.Current);\n                    }\n                    return this.yieldBreak();\n                },\n                function () { Utils.dispose(enumerator); });\n        });\n    };\n\n    // Overload:function (second)\n    // Overload:function (second, compareSelector)\n    Enumerable.prototype.except = function (second, comparer) {\n        var source = this;\n\n        return new Enumerable(function () {\n            var enumerator;\n            var keys;\n\n            return new IEnumerator(\n                function () {\n                    enumerator = source.getEnumerator();\n                    keys = new (System.Collections.Generic.Dictionary$2(System.Object, System.Object))(null, comparer);\n                    Enumerable.from(second).forEach(function (key) { if (!keys.containsKey(key)) { keys.add(key); } });\n                },\n                function () {\n                    while (enumerator.moveNext()) {\n                        var current = enumerator.Current;\n                        if (!keys.containsKey(current)) {\n                            keys.add(current);\n                            return this.yieldReturn(current);\n                        }\n                    }\n                    return false;\n                },\n                function () { Utils.dispose(enumerator); });\n        });\n    };\n\n    // Overload:function (second)\n    // Overload:function (second, compareSelector)\n    Enumerable.prototype.intersect = function (second, comparer) {\n        var source = this;\n\n        return new Enumerable(function () {\n            var enumerator;\n            var keys;\n            var outs;\n\n            return new IEnumerator(\n                function () {\n                    enumerator = source.getEnumerator();\n\n                    keys = new (System.Collections.Generic.Dictionary$2(System.Object, System.Object))(null, comparer);\n                    Enumerable.from(second).forEach(function (key) { if (!keys.containsKey(key)) { keys.add(key); } });\n                    outs = new (System.Collections.Generic.Dictionary$2(System.Object, System.Object))(null, comparer);\n                },\n                function () {\n                    while (enumerator.moveNext()) {\n                        var current = enumerator.Current;\n                        if (!outs.containsKey(current) && keys.containsKey(current)) {\n                            outs.add(current);\n                            return this.yieldReturn(current);\n                        }\n                    }\n                    return false;\n                },\n                function () { Utils.dispose(enumerator); });\n        });\n    };\n\n    // Overload:function (second)\n    // Overload:function (second, compareSelector)\n    Enumerable.prototype.sequenceEqual = function (second, comparer) {\n        comparer = comparer || System.Collections.Generic.EqualityComparer$1.$default;\n\n        var firstEnumerator = this.getEnumerator();\n        try {\n            var secondEnumerator = Enumerable.from(second).getEnumerator();\n            try {\n                while (firstEnumerator.moveNext()) {\n                    if (!secondEnumerator.moveNext()\n                    || !comparer.equals2(firstEnumerator.Current, secondEnumerator.Current)) {\n                        return false;\n                    }\n                }\n\n                if (secondEnumerator.moveNext()) return false;\n                return true;\n            }\n            finally {\n                Utils.dispose(secondEnumerator);\n            }\n        }\n        finally {\n            Utils.dispose(firstEnumerator);\n        }\n    };\n\n    Enumerable.prototype.union = function (second, comparer) {\n        var source = this;\n\n        return new Enumerable(function () {\n            var firstEnumerator;\n            var secondEnumerator;\n            var keys;\n\n            return new IEnumerator(\n                function () {\n                    firstEnumerator = source.getEnumerator();\n                    keys = new (System.Collections.Generic.Dictionary$2(System.Object, System.Object))(null, comparer);\n                },\n                function () {\n                    var current;\n                    if (secondEnumerator === undefined) {\n                        while (firstEnumerator.moveNext()) {\n                            current = firstEnumerator.Current;\n                            if (!keys.containsKey(current)) {\n                                keys.add(current);\n                                return this.yieldReturn(current);\n                            }\n                        }\n                        secondEnumerator = Enumerable.from(second).getEnumerator();\n                    }\n                    while (secondEnumerator.moveNext()) {\n                        current = secondEnumerator.Current;\n                        if (!keys.containsKey(current)) {\n                            keys.add(current);\n                            return this.yieldReturn(current);\n                        }\n                    }\n                    return false;\n                },\n                function () {\n                    try {\n                        Utils.dispose(firstEnumerator);\n                    }\n                    finally {\n                        Utils.dispose(secondEnumerator);\n                    }\n                });\n        });\n    };\n\n    /* Ordering Methods */\n\n    Enumerable.prototype.orderBy = function (keySelector, comparer) {\n        return new OrderedEnumerable(this, keySelector, comparer, false);\n    };\n\n    Enumerable.prototype.orderByDescending = function (keySelector, comparer) {\n        return new OrderedEnumerable(this, keySelector, comparer, true);\n    };\n\n    Enumerable.prototype.reverse = function () {\n        var source = this;\n\n        return new Enumerable(function () {\n            var buffer;\n            var index;\n\n            return new IEnumerator(\n                function () {\n                    buffer = source.toArray();\n                    index = buffer.length;\n                },\n                function () {\n                    return (index > 0)\n                        ? this.yieldReturn(buffer[--index])\n                        : false;\n                },\n                Functions.Blank);\n        });\n    };\n\n    Enumerable.prototype.shuffle = function () {\n        var source = this;\n\n        return new Enumerable(function () {\n            var buffer;\n\n            return new IEnumerator(\n                function () { buffer = source.toArray(); },\n                function () {\n                    if (buffer.length > 0) {\n                        var i = Math.floor(Math.random() * buffer.length);\n                        return this.yieldReturn(buffer.splice(i, 1)[0]);\n                    }\n                    return false;\n                },\n                Functions.Blank);\n        });\n    };\n\n    Enumerable.prototype.weightedSample = function (weightSelector) {\n        weightSelector = Utils.createLambda(weightSelector);\n        var source = this;\n\n        return new Enumerable(function () {\n            var sortedByBound;\n            var totalWeight = 0;\n\n            return new IEnumerator(\n                function () {\n                    sortedByBound = source\n                        .choose(function (x) {\n                            var weight = weightSelector(x);\n                            if (weight <= 0) return null; // ignore 0\n\n                            totalWeight += weight;\n                            return { value: x, bound: totalWeight };\n                        })\n                        .toArray();\n                },\n                function () {\n                    if (sortedByBound.length > 0) {\n                        var draw = Math.floor(Math.random() * totalWeight) + 1;\n\n                        var lower = -1;\n                        var upper = sortedByBound.length;\n                        while (upper - lower > 1) {\n                            var index = Math.floor((lower + upper) / 2);\n                            if (sortedByBound[index].bound >= draw) {\n                                upper = index;\n                            }\n                            else {\n                                lower = index;\n                            }\n                        }\n\n                        return this.yieldReturn(sortedByBound[upper].value);\n                    }\n\n                    return this.yieldBreak();\n                },\n                Functions.Blank);\n        });\n    };\n\n    /* Grouping Methods */\n\n    // Overload:function (keySelector)\n    // Overload:function (keySelector,elementSelector)\n    // Overload:function (keySelector,elementSelector,resultSelector)\n    // Overload:function (keySelector,elementSelector,resultSelector,compareSelector)\n    Enumerable.prototype.groupBy = function (keySelector, elementSelector, resultSelector, comparer) {\n        var source = this;\n        keySelector = Utils.createLambda(keySelector);\n        elementSelector = Utils.createLambda(elementSelector);\n        if (resultSelector != null) resultSelector = Utils.createLambda(resultSelector);\n\n        return new Enumerable(function () {\n            var enumerator;\n\n            return new IEnumerator(\n                function () {\n                    enumerator = source.toLookup(keySelector, elementSelector, comparer)\n                        .toEnumerable()\n                        .getEnumerator();\n                },\n                function () {\n                    while (enumerator.moveNext()) {\n                        return (resultSelector == null)\n                            ? this.yieldReturn(enumerator.Current)\n                            : this.yieldReturn(resultSelector(enumerator.Current.key(), enumerator.Current));\n                    }\n                    return false;\n                },\n                function () { Utils.dispose(enumerator); });\n        });\n    };\n\n    // Overload:function (keySelector)\n    // Overload:function (keySelector,elementSelector)\n    // Overload:function (keySelector,elementSelector,resultSelector)\n    // Overload:function (keySelector,elementSelector,resultSelector,compareSelector)\n    Enumerable.prototype.partitionBy = function (keySelector, elementSelector, resultSelector, comparer) {\n        var source = this;\n        keySelector = Utils.createLambda(keySelector);\n        elementSelector = Utils.createLambda(elementSelector);\n        comparer = comparer || System.Collections.Generic.EqualityComparer$1.$default;\n        var hasResultSelector;\n        if (resultSelector == null) {\n            hasResultSelector = false;\n            resultSelector = function (key, group) { return new Grouping(key, group); };\n        }\n        else {\n            hasResultSelector = true;\n            resultSelector = Utils.createLambda(resultSelector);\n        }\n\n        return new Enumerable(function () {\n            var enumerator;\n            var key;\n            var group = [];\n\n            return new IEnumerator(\n                function () {\n                    enumerator = source.getEnumerator();\n                    if (enumerator.moveNext()) {\n                        key = keySelector(enumerator.Current);\n                        group.push(elementSelector(enumerator.Current));\n                    }\n                },\n                function () {\n                    var hasNext;\n                    while ((hasNext = enumerator.moveNext()) == true) {\n                        if (comparer.equals2(key, keySelector(enumerator.Current))) {\n                            group.push(elementSelector(enumerator.Current));\n                        }\n                        else break;\n                    }\n\n                    if (group.length > 0) {\n                        var result = (hasResultSelector)\n                            ? resultSelector(key, Enumerable.from(group))\n                            : resultSelector(key, group);\n                        if (hasNext) {\n                            key = keySelector(enumerator.Current);\n                            group = [elementSelector(enumerator.Current)];\n                        }\n                        else group = [];\n\n                        return this.yieldReturn(result);\n                    }\n\n                    return false;\n                },\n                function () { Utils.dispose(enumerator); });\n        });\n    };\n\n    Enumerable.prototype.buffer = function (count) {\n        var source = this;\n\n        return new Enumerable(function () {\n            var enumerator;\n\n            return new IEnumerator(\n                function () { enumerator = source.getEnumerator(); },\n                function () {\n                    var array = [];\n                    var index = 0;\n                    while (enumerator.moveNext()) {\n                        array.push(enumerator.Current);\n                        if (++index >= count) return this.yieldReturn(array);\n                    }\n                    if (array.length > 0) return this.yieldReturn(array);\n                    return false;\n                },\n                function () { Utils.dispose(enumerator); });\n        });\n    };\n\n    /* Aggregate Methods */\n\n    // Overload:function (func)\n    // Overload:function (seed,func)\n    // Overload:function (seed,func,resultSelector)\n    Enumerable.prototype.aggregate = function (seed, func, resultSelector) {\n        resultSelector = Utils.createLambda(resultSelector);\n        return resultSelector(this.scan(seed, func, resultSelector).last());\n    };\n\n    // Overload:function ()\n    // Overload:function (selector)\n    Enumerable.prototype.average = function (selector, def) {\n        if (selector && !def && !Bridge.isFunction(selector)) {\n            def = selector;\n            selector = null;\n        }\n\n        selector = Utils.createLambda(selector);\n\n        var sum = def || 0;\n        var count = 0;\n        this.forEach(function (x) {\n            x = selector(x);\n\n            if (x instanceof System.Decimal || System.Int64.is64Bit(x)) {\n                sum = x.add(sum);\n            }\n            else if (sum instanceof System.Decimal || System.Int64.is64Bit(sum)) {\n                sum = sum.add(x);\n            } else {\n                sum += x;\n            }\n\n            ++count;\n        });\n\n        if (count === 0) {\n            throw new System.InvalidOperationException(\"Sequence contains no elements\");\n        }\n\n        return (sum instanceof System.Decimal || System.Int64.is64Bit(sum)) ? sum.div(count) : (sum / count);\n    };\n\n    Enumerable.prototype.nullableAverage = function (selector, def) {\n        if (this.any(Bridge.isNull)) {\n            return null;\n        }\n\n        return this.average(selector, def);\n    };\n\n    // Overload:function ()\n    // Overload:function (predicate)\n    Enumerable.prototype.count = function (predicate) {\n        predicate = (predicate == null) ? Functions.True : Utils.createLambda(predicate);\n\n        var count = 0;\n        this.forEach(function (x, i) {\n            if (predicate(x, i))++count;\n        });\n        return count;\n    };\n\n    // Overload:function ()\n    // Overload:function (selector)\n    Enumerable.prototype.max = function (selector) {\n        if (selector == null) selector = Functions.Identity;\n        return this.select(selector).aggregate(function (a, b) {\n            return (Bridge.compare(a, b, true) === 1) ? a : b;\n        });\n    };\n\n    Enumerable.prototype.nullableMax = function (selector) {\n        if (this.any(Bridge.isNull)) {\n            return null;\n        }\n\n        return this.max(selector);\n    };\n\n    // Overload:function ()\n    // Overload:function (selector)\n    Enumerable.prototype.min = function (selector) {\n        if (selector == null) selector = Functions.Identity;\n        return this.select(selector).aggregate(function (a, b) {\n            return (Bridge.compare(a, b, true) === -1) ? a : b;\n        });\n    };\n\n    Enumerable.prototype.nullableMin = function (selector) {\n        if (this.any(Bridge.isNull)) {\n            return null;\n        }\n\n        return this.min(selector);\n    };\n\n    Enumerable.prototype.maxBy = function (keySelector) {\n        keySelector = Utils.createLambda(keySelector);\n        return this.aggregate(function (a, b) {\n            return (Bridge.compare(keySelector(a), keySelector(b), true) === 1) ? a : b;\n        });\n    };\n\n    Enumerable.prototype.minBy = function (keySelector) {\n        keySelector = Utils.createLambda(keySelector);\n        return this.aggregate(function (a, b) {\n            return (Bridge.compare(keySelector(a), keySelector(b), true) === -1) ? a : b;\n        });\n    };\n\n    // Overload:function ()\n    // Overload:function (selector)\n    Enumerable.prototype.sum = function (selector, def) {\n        if (selector && !def && !Bridge.isFunction(selector)) {\n            def = selector;\n            selector = null;\n        }\n\n        if (selector == null) selector = Functions.Identity;\n        var s = this.select(selector).aggregate(0, function (a, b) {\n             if (a instanceof System.Decimal || System.Int64.is64Bit(a)) {\n                 return a.add(b);\n             }\n             if (b instanceof System.Decimal || System.Int64.is64Bit(b)) {\n                 return b.add(a);\n             }\n             return a + b;\n        });\n\n        if (s === 0 && def) {\n            return def;\n        }\n\n        return s;\n    };\n\n    Enumerable.prototype.nullableSum = function (selector, def) {\n        if (this.any(Bridge.isNull)) {\n            return null;\n        }\n\n        return this.sum(selector, def);\n    };\n\n    /* Paging Methods */\n\n    Enumerable.prototype.elementAt = function (index) {\n        var value;\n        var found = false;\n        this.forEach(function (x, i) {\n            if (i == index) {\n                value = x;\n                found = true;\n                return false;\n            }\n        });\n\n        if (!found) throw new Error(\"index is less than 0 or greater than or equal to the number of elements in source.\");\n        return value;\n    };\n\n    Enumerable.prototype.elementAtOrDefault = function (index, defaultValue) {\n        if (defaultValue === undefined) defaultValue = null;\n        var value;\n        var found = false;\n        this.forEach(function (x, i) {\n            if (i == index) {\n                value = x;\n                found = true;\n                return false;\n            }\n        });\n\n        return (!found) ? defaultValue : value;\n    };\n\n    // Overload:function ()\n    // Overload:function (predicate)\n    Enumerable.prototype.first = function (predicate) {\n        if (predicate != null) return this.where(predicate).first();\n\n        var value;\n        var found = false;\n        this.forEach(function (x) {\n            value = x;\n            found = true;\n            return false;\n        });\n\n        if (!found) throw new Error(\"first:No element satisfies the condition.\");\n        return value;\n    };\n\n    Enumerable.prototype.firstOrDefault = function (predicate, defaultValue) {\n        if (defaultValue === undefined) defaultValue = null;\n        if (predicate != null) return this.where(predicate).firstOrDefault(null, defaultValue);\n\n        var value;\n        var found = false;\n        this.forEach(function (x) {\n            value = x;\n            found = true;\n            return false;\n        });\n        return (!found) ? defaultValue : value;\n    };\n\n    // Overload:function ()\n    // Overload:function (predicate)\n    Enumerable.prototype.last = function (predicate) {\n        if (predicate != null) return this.where(predicate).last();\n\n        var value;\n        var found = false;\n        this.forEach(function (x) {\n            found = true;\n            value = x;\n        });\n\n        if (!found) throw new Error(\"last:No element satisfies the condition.\");\n        return value;\n    };\n\n    // Overload:function (defaultValue)\n    // Overload:function (defaultValue,predicate)\n    Enumerable.prototype.lastOrDefault = function (predicate, defaultValue) {\n        if (defaultValue === undefined) defaultValue = null;\n        if (predicate != null) return this.where(predicate).lastOrDefault(null, defaultValue);\n\n        var value;\n        var found = false;\n        this.forEach(function (x) {\n            found = true;\n            value = x;\n        });\n        return (!found) ? defaultValue : value;\n    };\n\n    // Overload:function ()\n    // Overload:function (predicate)\n    Enumerable.prototype.single = function (predicate) {\n        if (predicate != null) return this.where(predicate).single();\n\n        var value;\n        var found = false;\n        this.forEach(function (x) {\n            if (!found) {\n                found = true;\n                value = x;\n            } else throw new Error(\"single:sequence contains more than one element.\");\n        });\n\n        if (!found) throw new Error(\"single:No element satisfies the condition.\");\n        return value;\n    };\n\n    // Overload:function (defaultValue)\n    // Overload:function (defaultValue,predicate)\n    Enumerable.prototype.singleOrDefault = function (predicate, defaultValue) {\n        if (defaultValue === undefined) defaultValue = null;\n        if (predicate != null) return this.where(predicate).singleOrDefault(null, defaultValue);\n\n        var value;\n        var found = false;\n        this.forEach(function (x) {\n            if (!found) {\n                found = true;\n                value = x;\n            } else throw new Error(\"single:sequence contains more than one element.\");\n        });\n\n        return (!found) ? defaultValue : value;\n    };\n\n    Enumerable.prototype.skip = function (count) {\n        var source = this;\n\n        return new Enumerable(function () {\n            var enumerator;\n            var index = 0;\n\n            return new IEnumerator(\n                function () {\n                    enumerator = source.getEnumerator();\n                    while (index++ < count && enumerator.moveNext()) {\n                    }\n                    ;\n                },\n                function () {\n                    return (enumerator.moveNext())\n                        ? this.yieldReturn(enumerator.Current)\n                        : false;\n                },\n                function () { Utils.dispose(enumerator); });\n        });\n    };\n\n    // Overload:function (predicate<element>)\n    // Overload:function (predicate<element,index>)\n    Enumerable.prototype.skipWhile = function (predicate) {\n        predicate = Utils.createLambda(predicate);\n        var source = this;\n\n        return new Enumerable(function () {\n            var enumerator;\n            var index = 0;\n            var isSkipEnd = false;\n\n            return new IEnumerator(\n                function () { enumerator = source.getEnumerator(); },\n                function () {\n                    while (!isSkipEnd) {\n                        if (enumerator.moveNext()) {\n                            if (!predicate(enumerator.Current, index++)) {\n                                isSkipEnd = true;\n                                return this.yieldReturn(enumerator.Current);\n                            }\n                            continue;\n                        } else return false;\n                    }\n\n                    return (enumerator.moveNext())\n                        ? this.yieldReturn(enumerator.Current)\n                        : false;\n                },\n                function () { Utils.dispose(enumerator); });\n        });\n    };\n\n    Enumerable.prototype.take = function (count) {\n        var source = this;\n\n        return new Enumerable(function () {\n            var enumerator;\n            var index = 0;\n\n            return new IEnumerator(\n                function () { enumerator = source.getEnumerator(); },\n                function () {\n                    return (index++ < count && enumerator.moveNext())\n                        ? this.yieldReturn(enumerator.Current)\n                        : false;\n                },\n                function () { Utils.dispose(enumerator); }\n            );\n        });\n    };\n\n    // Overload:function (predicate<element>)\n    // Overload:function (predicate<element,index>)\n    Enumerable.prototype.takeWhile = function (predicate) {\n        predicate = Utils.createLambda(predicate);\n        var source = this;\n\n        return new Enumerable(function () {\n            var enumerator;\n            var index = 0;\n\n            return new IEnumerator(\n                function () { enumerator = source.getEnumerator(); },\n                function () {\n                    return (enumerator.moveNext() && predicate(enumerator.Current, index++))\n                        ? this.yieldReturn(enumerator.Current)\n                        : false;\n                },\n                function () { Utils.dispose(enumerator); });\n        });\n    };\n\n    // Overload:function ()\n    // Overload:function (count)\n    Enumerable.prototype.takeExceptLast = function (count) {\n        if (count == null) count = 1;\n        var source = this;\n\n        return new Enumerable(function () {\n            if (count <= 0) return source.getEnumerator(); // do nothing\n\n            var enumerator;\n            var q = [];\n\n            return new IEnumerator(\n                function () { enumerator = source.getEnumerator(); },\n                function () {\n                    while (enumerator.moveNext()) {\n                        if (q.length == count) {\n                            q.push(enumerator.Current);\n                            return this.yieldReturn(q.shift());\n                        }\n                        q.push(enumerator.Current);\n                    }\n                    return false;\n                },\n                function () { Utils.dispose(enumerator); });\n        });\n    };\n\n    Enumerable.prototype.takeFromLast = function (count) {\n        if (count <= 0 || count == null) return Enumerable.empty();\n        var source = this;\n\n        return new Enumerable(function () {\n            var sourceEnumerator;\n            var enumerator;\n            var q = [];\n\n            return new IEnumerator(\n                function () { sourceEnumerator = source.getEnumerator(); },\n                function () {\n                    if (enumerator == null) {\n\t                    while (sourceEnumerator.moveNext()) {\n\t                        if (q.length == count) q.shift();\n\t                        q.push(sourceEnumerator.Current);\n\t                    }\n                        enumerator = Enumerable.from(q).getEnumerator();\n                    }\n                    return (enumerator.moveNext())\n                        ? this.yieldReturn(enumerator.Current)\n                        : false;\n                },\n                function () { Utils.dispose(enumerator); });\n        });\n    };\n\n    // Overload:function (item)\n    // Overload:function (predicate)\n    Enumerable.prototype.indexOf = function (item, comparer) {\n        var found = null;\n\n        // item as predicate\n        if (typeof (item) === Types.Function) {\n            this.forEach(function (x, i) {\n                if (item(x, i)) {\n                    found = i;\n                    return false;\n                }\n            });\n        }\n        else {\n            comparer = comparer || System.Collections.Generic.EqualityComparer$1.$default;\n            this.forEach(function (x, i) {\n                if (comparer.equals2(x, item)) {\n                    found = i;\n                    return false;\n                }\n            });\n        }\n\n        return (found !== null) ? found : -1;\n    };\n\n    // Overload:function (item)\n    // Overload:function (predicate)\n    Enumerable.prototype.lastIndexOf = function (item, comparer) {\n        var result = -1;\n\n        // item as predicate\n        if (typeof (item) === Types.Function) {\n            this.forEach(function (x, i) {\n                if (item(x, i)) result = i;\n            });\n        }\n        else {\n            comparer = comparer || System.Collections.Generic.EqualityComparer$1.$default;\n            this.forEach(function (x, i) {\n                if (comparer.equals2(x, item)) result = i;\n            });\n        }\n\n        return result;\n    };\n\n    /* Convert Methods */\n\n    Enumerable.prototype.asEnumerable = function () {\n        return Enumerable.from(this);\n    };\n\n    Enumerable.prototype.toArray = function (T) {\n        var array = System.Array.init([], T || System.Object);\n        this.forEach(function (x) { array.push(x); });\n        return array;\n    };\n\n    Enumerable.prototype.toList = function (T) {\n        var array = [];\n        this.forEach(function (x) { array.push(x); });\n        return new (System.Collections.Generic.List$1(T || System.Object).$ctor1)(array);\n    };\n\n    // Overload:function (keySelector)\n    // Overload:function (keySelector, elementSelector)\n    // Overload:function (keySelector, elementSelector, compareSelector)\n    Enumerable.prototype.toLookup = function (keySelector, elementSelector, comparer) {\n        keySelector = Utils.createLambda(keySelector);\n        elementSelector = Utils.createLambda(elementSelector);\n\n        var dict = new (System.Collections.Generic.Dictionary$2(System.Object, System.Object))(null, comparer);\n        var order = [];\n        this.forEach(function (x) {\n            var key = keySelector(x);\n            var element = elementSelector(x);\n\n            var array = { v: null };\n            if (dict.tryGetValue(key, array)) {\n                array.v.push(element);\n            }\n            else {\n                order.push(key);\n                dict.add(key, [element]);\n            }\n        });\n        return new Lookup(dict, order);\n    };\n\n    Enumerable.prototype.toObject = function (keySelector, elementSelector) {\n        keySelector = Utils.createLambda(keySelector);\n        elementSelector = Utils.createLambda(elementSelector);\n\n        var obj = {};\n        this.forEach(function (x) {\n            obj[keySelector(x)] = elementSelector(x);\n        });\n        return obj;\n    };\n\n    // Overload:function (keySelector, elementSelector)\n    // Overload:function (keySelector, elementSelector, compareSelector)\n    Enumerable.prototype.toDictionary = function (keySelector, elementSelector, keyType, valueType, comparer) {\n        keySelector = Utils.createLambda(keySelector);\n        elementSelector = Utils.createLambda(elementSelector);\n\n        var dict = new (System.Collections.Generic.Dictionary$2(keyType, valueType))(null, comparer);\n        this.forEach(function (x) {\n            dict.add(keySelector(x), elementSelector(x));\n        });\n        return dict;\n    };\n\n    // Overload:function ()\n    // Overload:function (replacer)\n    // Overload:function (replacer, space)\n    Enumerable.prototype.toJSONString = function (replacer, space) {\n        if (typeof JSON === Types.Undefined || JSON.stringify == null) {\n            throw new Error(\"toJSONString can't find JSON.stringify. This works native JSON support Browser or include json2.js\");\n        }\n        return JSON.stringify(this.toArray(), replacer, space);\n    };\n\n    // Overload:function ()\n    // Overload:function (separator)\n    // Overload:function (separator,selector)\n    Enumerable.prototype.toJoinedString = function (separator, selector) {\n        if (separator == null) separator = \"\";\n        if (selector == null) selector = Functions.Identity;\n\n        return this.select(selector).toArray().join(separator);\n    };\n\n    /* Action Methods */\n\n    // Overload:function (action<element>)\n    // Overload:function (action<element,index>)\n    Enumerable.prototype.doAction = function (action) {\n        var source = this;\n        action = Utils.createLambda(action);\n\n        return new Enumerable(function () {\n            var enumerator;\n            var index = 0;\n\n            return new IEnumerator(\n                function () { enumerator = source.getEnumerator(); },\n                function () {\n                    if (enumerator.moveNext()) {\n                        action(enumerator.Current, index++);\n                        return this.yieldReturn(enumerator.Current);\n                    }\n                    return false;\n                },\n                function () { Utils.dispose(enumerator); });\n        });\n    };\n\n    // Overload:function (action<element>)\n    // Overload:function (action<element,index>)\n    // Overload:function (func<element,bool>)\n    // Overload:function (func<element,index,bool>)\n    Enumerable.prototype.forEach = function (action) {\n        action = Utils.createLambda(action);\n\n        var index = 0;\n        var enumerator = this.getEnumerator();\n        try {\n            while (enumerator.moveNext()) {\n                if (action(enumerator.Current, index++) === false) break;\n            }\n        } finally {\n            Utils.dispose(enumerator);\n        }\n    };\n\n    // Overload:function ()\n    // Overload:function (separator)\n    // Overload:function (separator,selector)\n    Enumerable.prototype.write = function (separator, selector) {\n        if (separator == null) separator = \"\";\n        selector = Utils.createLambda(selector);\n\n        var isFirst = true;\n        this.forEach(function (item) {\n            if (isFirst) isFirst = false;\n            else document.write(separator);\n            document.write(selector(item));\n        });\n    };\n\n    // Overload:function ()\n    // Overload:function (selector)\n    Enumerable.prototype.writeLine = function (selector) {\n        selector = Utils.createLambda(selector);\n\n        this.forEach(function (item) {\n            document.writeln(selector(item) + \"<br />\");\n        });\n    };\n\n    Enumerable.prototype.force = function () {\n        var enumerator = this.getEnumerator();\n\n        try {\n            while (enumerator.moveNext()) {\n            }\n        }\n        finally {\n            Utils.dispose(enumerator);\n        }\n    };\n\n    /* Functional Methods */\n\n    Enumerable.prototype.letBind = function (func) {\n        func = Utils.createLambda(func);\n        var source = this;\n\n        return new Enumerable(function () {\n            var enumerator;\n\n            return new IEnumerator(\n                function () {\n                    enumerator = Enumerable.from(func(source)).getEnumerator();\n                },\n                function () {\n                    return (enumerator.moveNext())\n                        ? this.yieldReturn(enumerator.Current)\n                        : false;\n                },\n                function () { Utils.dispose(enumerator); });\n        });\n    };\n\n    Enumerable.prototype.share = function () {\n        var source = this;\n        var sharedEnumerator;\n        var disposed = false;\n\n        return new DisposableEnumerable(function () {\n            return new IEnumerator(\n                function () {\n                    if (sharedEnumerator == null) {\n                        sharedEnumerator = source.getEnumerator();\n                    }\n                },\n                function () {\n                    if (disposed) throw new Error(\"enumerator is disposed\");\n\n                    return (sharedEnumerator.moveNext())\n                        ? this.yieldReturn(sharedEnumerator.Current)\n                        : false;\n                },\n                Functions.Blank\n            );\n        }, function () {\n            disposed = true;\n            Utils.dispose(sharedEnumerator);\n        });\n    };\n\n    Enumerable.prototype.memoize = function () {\n        var source = this;\n        var cache;\n        var enumerator;\n        var disposed = false;\n\n        return new DisposableEnumerable(function () {\n            var index = -1;\n\n            return new IEnumerator(\n                function () {\n                    if (enumerator == null) {\n                        enumerator = source.getEnumerator();\n                        cache = [];\n                    }\n                },\n                function () {\n                    if (disposed) throw new Error(\"enumerator is disposed\");\n\n                    index++;\n                    if (cache.length <= index) {\n                        return (enumerator.moveNext())\n                            ? this.yieldReturn(cache[index] = enumerator.Current)\n                            : false;\n                    }\n\n                    return this.yieldReturn(cache[index]);\n                },\n                Functions.Blank\n            );\n        }, function () {\n            disposed = true;\n            Utils.dispose(enumerator);\n            cache = null;\n        });\n    };\n\n    /* Error Handling Methods */\n\n    Enumerable.prototype.catchError = function (handler) {\n        handler = Utils.createLambda(handler);\n        var source = this;\n\n        return new Enumerable(function () {\n            var enumerator;\n\n            return new IEnumerator(\n                function () { enumerator = source.getEnumerator(); },\n                function () {\n                    try {\n                        return (enumerator.moveNext())\n                            ? this.yieldReturn(enumerator.Current)\n                            : false;\n                    } catch (e) {\n                        handler(e);\n                        return false;\n                    }\n                },\n                function () { Utils.dispose(enumerator); });\n        });\n    };\n\n    Enumerable.prototype.finallyAction = function (finallyAction) {\n        finallyAction = Utils.createLambda(finallyAction);\n        var source = this;\n\n        return new Enumerable(function () {\n            var enumerator;\n\n            return new IEnumerator(\n                function () { enumerator = source.getEnumerator(); },\n                function () {\n                    return (enumerator.moveNext())\n                        ? this.yieldReturn(enumerator.Current)\n                        : false;\n                },\n                function () {\n                    try {\n                        Utils.dispose(enumerator);\n                    } finally {\n                        finallyAction();\n                    }\n                });\n        });\n    };\n\n    /* For Debug Methods */\n\n    // Overload:function ()\n    // Overload:function (selector)\n    Enumerable.prototype.log = function (selector) {\n        selector = Utils.createLambda(selector);\n\n        return this.doAction(function (item) {\n            if (typeof console !== Types.Undefined) {\n                console.log(selector(item));\n            }\n        });\n    };\n\n    // Overload:function ()\n    // Overload:function (message)\n    // Overload:function (message,selector)\n    Enumerable.prototype.trace = function (message, selector) {\n        if (message == null) message = \"Trace\";\n        selector = Utils.createLambda(selector);\n\n        return this.doAction(function (item) {\n            if (typeof console !== Types.Undefined) {\n                console.log(message, selector(item));\n            }\n        });\n    };\n\n    // private\n\n    var OrderedEnumerable = function (source, keySelector, comparer, descending, parent) {\n        this.source = source;\n        this.keySelector = Utils.createLambda(keySelector);\n        this.comparer = comparer || System.Collections.Generic.Comparer$1.$default;\n        this.descending = descending;\n        this.parent = parent;\n    };\n    OrderedEnumerable.prototype = new Enumerable();\n    OrderedEnumerable.prototype.constructor = OrderedEnumerable;\n    Bridge.definei(\"System.Linq.IOrderedEnumerable$1\");\n    OrderedEnumerable.$$inherits = [];\n    Bridge.Class.addExtend(OrderedEnumerable, [System.Collections.IEnumerable, System.Linq.IOrderedEnumerable$1]);\n\n    OrderedEnumerable.prototype.createOrderedEnumerable = function (keySelector, comparer, descending) {\n        return new OrderedEnumerable(this.source, keySelector, comparer, descending, this);\n    };\n\n    OrderedEnumerable.prototype.thenBy = function (keySelector, comparer) {\n        return this.createOrderedEnumerable(keySelector, comparer, false);\n    };\n\n    OrderedEnumerable.prototype.thenByDescending = function (keySelector, comparer) {\n        return this.createOrderedEnumerable(keySelector, comparer, true);\n    };\n\n    OrderedEnumerable.prototype.getEnumerator = function () {\n        var self = this;\n        var buffer;\n        var indexes;\n        var index = 0;\n\n        return new IEnumerator(\n            function () {\n                buffer = [];\n                indexes = [];\n                self.source.forEach(function (item, index) {\n                    buffer.push(item);\n                    indexes.push(index);\n                });\n                var sortContext = SortContext.create(self, null);\n                sortContext.GenerateKeys(buffer);\n\n                indexes.sort(function (a, b) { return sortContext.compare(a, b); });\n            },\n            function () {\n                return (index < indexes.length)\n                    ? this.yieldReturn(buffer[indexes[index++]])\n                    : false;\n            },\n            Functions.Blank\n        );\n    };\n\n    var SortContext = function (keySelector, comparer, descending, child) {\n        this.keySelector = keySelector;\n        this.comparer = comparer;\n        this.descending = descending;\n        this.child = child;\n        this.keys = null;\n    };\n\n    SortContext.create = function (orderedEnumerable, currentContext) {\n        var context = new SortContext(orderedEnumerable.keySelector, orderedEnumerable.comparer, orderedEnumerable.descending, currentContext);\n        if (orderedEnumerable.parent != null) return SortContext.create(orderedEnumerable.parent, context);\n        return context;\n    };\n\n    SortContext.prototype.GenerateKeys = function (source) {\n        var len = source.length;\n        var keySelector = this.keySelector;\n        var keys = new Array(len);\n        for (var i = 0; i < len; i++) keys[i] = keySelector(source[i]);\n        this.keys = keys;\n\n        if (this.child != null) this.child.GenerateKeys(source);\n    };\n\n    SortContext.prototype.compare = function (index1, index2) {\n        var comparison = this.comparer.compare(this.keys[index1], this.keys[index2]);\n\n        if (comparison == 0) {\n            if (this.child != null) return this.child.compare(index1, index2);\n            return Utils.compare(index1, index2);\n        }\n\n        return (this.descending) ? -comparison : comparison;\n    };\n\n    var DisposableEnumerable = function (getEnumerator, dispose) {\n        this.dispose = dispose;\n        Enumerable.call(this, getEnumerator);\n    };\n    DisposableEnumerable.prototype = new Enumerable();\n\n    // optimize array or arraylike object\n\n    var ArrayEnumerable = function (source) {\n        this.getSource = function () { return source; };\n    };\n    ArrayEnumerable.prototype = new Enumerable();\n\n    ArrayEnumerable.prototype.any = function (predicate) {\n        return (predicate == null)\n            ? (this.getSource().length > 0)\n            : Enumerable.prototype.any.apply(this, arguments);\n    };\n\n    ArrayEnumerable.prototype.count = function (predicate) {\n        return (predicate == null)\n            ? this.getSource().length\n            : Enumerable.prototype.count.apply(this, arguments);\n    };\n\n    ArrayEnumerable.prototype.elementAt = function (index) {\n        var source = this.getSource();\n        return (0 <= index && index < source.length)\n            ? source[index]\n            : Enumerable.prototype.elementAt.apply(this, arguments);\n    };\n\n    ArrayEnumerable.prototype.elementAtOrDefault = function (index, defaultValue) {\n        if (defaultValue === undefined) defaultValue = null;\n        var source = this.getSource();\n        return (0 <= index && index < source.length)\n            ? source[index]\n            : defaultValue;\n    };\n\n    ArrayEnumerable.prototype.first = function (predicate) {\n        var source = this.getSource();\n        return (predicate == null && source.length > 0)\n            ? source[0]\n            : Enumerable.prototype.first.apply(this, arguments);\n    };\n\n    ArrayEnumerable.prototype.firstOrDefault = function (predicate, defaultValue) {\n        if (defaultValue === undefined) defaultValue = null;\n        if (predicate != null) {\n            return Enumerable.prototype.firstOrDefault.apply(this, arguments);\n        }\n\n        var source = this.getSource();\n        return source.length > 0 ? source[0] : defaultValue;\n    };\n\n    ArrayEnumerable.prototype.last = function (predicate) {\n        var source = this.getSource();\n        return (predicate == null && source.length > 0)\n            ? source[source.length - 1]\n            : Enumerable.prototype.last.apply(this, arguments);\n    };\n\n    ArrayEnumerable.prototype.lastOrDefault = function (predicate, defaultValue) {\n        if (defaultValue === undefined) defaultValue = null;\n        if (predicate != null) {\n            return Enumerable.prototype.lastOrDefault.apply(this, arguments);\n        }\n\n        var source = this.getSource();\n        return source.length > 0 ? source[source.length - 1] : defaultValue;\n    };\n\n    ArrayEnumerable.prototype.skip = function (count) {\n        var source = this.getSource();\n\n        return new Enumerable(function () {\n            var index;\n\n            return new IEnumerator(\n                function () { index = (count < 0) ? 0 : count; },\n                function () {\n                    return (index < source.length)\n                        ? this.yieldReturn(source[index++])\n                        : false;\n                },\n                Functions.Blank);\n        });\n    };\n\n    ArrayEnumerable.prototype.takeExceptLast = function (count) {\n        if (count == null) count = 1;\n        return this.take(this.getSource().length - count);\n    };\n\n    ArrayEnumerable.prototype.takeFromLast = function (count) {\n        return this.skip(this.getSource().length - count);\n    };\n\n    ArrayEnumerable.prototype.reverse = function () {\n        var source = this.getSource();\n\n        return new Enumerable(function () {\n            var index;\n\n            return new IEnumerator(\n                function () {\n                    index = source.length;\n                },\n                function () {\n                    return (index > 0)\n                        ? this.yieldReturn(source[--index])\n                        : false;\n                },\n                Functions.Blank);\n        });\n    };\n\n    ArrayEnumerable.prototype.sequenceEqual = function (second, comparer) {\n        if ((second instanceof ArrayEnumerable || second instanceof Array)\n            && comparer == null\n            && Enumerable.from(second).count() != this.count()) {\n            return false;\n        }\n\n        return Enumerable.prototype.sequenceEqual.apply(this, arguments);\n    };\n\n    ArrayEnumerable.prototype.toJoinedString = function (separator, selector) {\n        var source = this.getSource();\n        if (selector != null || !(source instanceof Array)) {\n            return Enumerable.prototype.toJoinedString.apply(this, arguments);\n        }\n\n        if (separator == null) separator = \"\";\n        return source.join(separator);\n    };\n\n    ArrayEnumerable.prototype.getEnumerator = function () {\n        return new Bridge.ArrayEnumerator(this.getSource());\n    };\n\n    // optimization for multiple where and multiple select and whereselect\n\n    var WhereEnumerable = function (source, predicate) {\n        this.prevSource = source;\n        this.prevPredicate = predicate; // predicate.length always <= 1\n    };\n    WhereEnumerable.prototype = new Enumerable();\n\n    WhereEnumerable.prototype.where = function (predicate) {\n        predicate = Utils.createLambda(predicate);\n\n        if (predicate.length <= 1) {\n            var prevPredicate = this.prevPredicate;\n            var composedPredicate = function (x) { return prevPredicate(x) && predicate(x); };\n            return new WhereEnumerable(this.prevSource, composedPredicate);\n        }\n        else {\n            // if predicate use index, can't compose\n            return Enumerable.prototype.where.call(this, predicate);\n        }\n    };\n\n    WhereEnumerable.prototype.select = function (selector) {\n        selector = Utils.createLambda(selector);\n\n        return (selector.length <= 1)\n            ? new WhereSelectEnumerable(this.prevSource, this.prevPredicate, selector)\n            : Enumerable.prototype.select.call(this, selector);\n    };\n\n    WhereEnumerable.prototype.getEnumerator = function () {\n        var predicate = this.prevPredicate;\n        var source = this.prevSource;\n        var enumerator;\n\n        return new IEnumerator(\n            function () { enumerator = source.getEnumerator(); },\n            function () {\n                while (enumerator.moveNext()) {\n                    if (predicate(enumerator.Current)) {\n                        return this.yieldReturn(enumerator.Current);\n                    }\n                }\n                return false;\n            },\n            function () { Utils.dispose(enumerator); });\n    };\n\n    var WhereSelectEnumerable = function (source, predicate, selector) {\n        this.prevSource = source;\n        this.prevPredicate = predicate; // predicate.length always <= 1 or null\n        this.prevSelector = selector; // selector.length always <= 1\n    };\n    WhereSelectEnumerable.prototype = new Enumerable();\n\n    WhereSelectEnumerable.prototype.where = function (predicate) {\n        predicate = Utils.createLambda(predicate);\n\n        return (predicate.length <= 1)\n            ? new WhereEnumerable(this, predicate)\n            : Enumerable.prototype.where.call(this, predicate);\n    };\n\n    WhereSelectEnumerable.prototype.select = function (selector) {\n        selector = Utils.createLambda(selector);\n\n        if (selector.length <= 1) {\n            var prevSelector = this.prevSelector;\n            var composedSelector = function (x) { return selector(prevSelector(x)); };\n            return new WhereSelectEnumerable(this.prevSource, this.prevPredicate, composedSelector);\n        }\n        else {\n            // if selector use index, can't compose\n            return Enumerable.prototype.select.call(this, selector);\n        }\n    };\n\n    WhereSelectEnumerable.prototype.getEnumerator = function () {\n        var predicate = this.prevPredicate;\n        var selector = this.prevSelector;\n        var source = this.prevSource;\n        var enumerator;\n\n        return new IEnumerator(\n            function () { enumerator = source.getEnumerator(); },\n            function () {\n                while (enumerator.moveNext()) {\n                    if (predicate == null || predicate(enumerator.Current)) {\n                        return this.yieldReturn(selector(enumerator.Current));\n                    }\n                }\n                return false;\n            },\n            function () { Utils.dispose(enumerator); });\n    };\n\n    // Collections\n\n    // dictionary = Dictionary<TKey, TValue[]>\n    var Lookup = function (dictionary, order) {\n        this.count = function () {\n            return dictionary.getCount();\n        };\n        this.get = function (key) {\n            var value = { v: null };\n            var success = dictionary.tryGetValue(key, value);\n            return Enumerable.from(success ? value.v : []);\n        };\n        this.contains = function (key) {\n            return dictionary.containsKey(key);\n        };\n        this.toEnumerable = function () {\n            return Enumerable.from(order).select(function (key) {\n                return new Grouping(key, dictionary.get(key));\n            });\n        };\n        this.getEnumerator = function () {\n            return this.toEnumerable().getEnumerator();\n        };\n    };\n\n    Bridge.definei(\"System.Linq.ILookup$2\");\n    Lookup.$$inherits = [];\n    Bridge.Class.addExtend(Lookup, [System.Collections.IEnumerable, System.Linq.ILookup$2]);\n\n    var Grouping = function (groupKey, elements) {\n        this.key = function () {\n            return groupKey;\n        };\n        ArrayEnumerable.call(this, elements);\n    };\n    Grouping.prototype = new ArrayEnumerable();\n    Bridge.definei(\"System.Linq.IGrouping$2\");\n    Grouping.prototype.constructor = Grouping;\n\n    Grouping.$$inherits = [];\n    Bridge.Class.addExtend(Grouping, [System.Collections.IEnumerable, System.Linq.IGrouping$2]);\n\n    // module export\n    /*if (typeof define === Types.Function && define.amd) { // AMD\n        define(\"linqjs\", [], function () { return Enumerable; });\n    } else if (typeof module !== Types.Undefined && module.exports) { // Node\n        module.exports = Enumerable;\n    } else {\n        root.Enumerable = Enumerable;\n    }*/\n\n    Bridge.Linq = {};\n    Bridge.Linq.Enumerable = Enumerable;\n\n    System.Linq = System.Linq || {};\n    System.Linq.Enumerable = Enumerable;\n    System.Linq.Grouping$2 = Grouping;\n    System.Linq.Lookup$2 = Lookup;\n    System.Linq.OrderedEnumerable$1 = OrderedEnumerable;\n})(Bridge.global);\n\n    // @source guid.js\n\n    Bridge.define(\"System.Guid\", {\n        inherits: function () { return [System.IEquatable$1(System.Guid),System.IComparable$1(System.Guid),System.IFormattable]; },\n        $kind: \"struct\",\n        statics: {\n            fields: {\n                error1: null,\n                valid: null,\n                split: null,\n                nonFormat: null,\n                replace: null,\n                rnd: null,\n                empty: null\n            },\n            ctors: {\n                init: function () {\n                    this.empty = new System.Guid();\n                    this.error1 = \"Byte array for GUID must be exactly {0} bytes long\";\n                    this.valid = new System.Text.RegularExpressions.Regex.ctor(\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\", 1);\n                    this.split = new System.Text.RegularExpressions.Regex.ctor(\"^(.{8})(.{4})(.{4})(.{4})(.{12})$\");\n                    this.nonFormat = new System.Text.RegularExpressions.Regex.ctor(\"^[{(]?([0-9a-f]{8})-?([0-9a-f]{4})-?([0-9a-f]{4})-?([0-9a-f]{4})-?([0-9a-f]{12})[)}]?$\", 1);\n                    this.replace = new System.Text.RegularExpressions.Regex.ctor(\"-\");\n                    this.rnd = new System.Random.ctor();\n                }\n            },\n            methods: {\n                parse: function (input) {\n                    return System.Guid.parseExact(input, null);\n                },\n                parseExact: function (input, format) {\n                    var r = new System.Guid.ctor();\n                    r.parseInternal(input, format, true);\n                    return r;\n                },\n                tryParse: function (input, result) {\n                    return System.Guid.tryParseExact(input, null, result);\n                },\n                tryParseExact: function (input, format, result) {\n                    result.v = new System.Guid.ctor();\n                    return result.v.parseInternal(input, format, false);\n                },\n                newGuid: function () {\n                    var a = System.Array.init(16, 0, System.Byte);\n\n                    System.Guid.rnd.nextBytes(a);\n\n                    a[System.Array.index(7, a)] = (a[System.Array.index(7, a)] & 15 | 64) & 255;\n                    a[System.Array.index(8, a)] = (a[System.Array.index(8, a)] & 191 | 128) & 255;\n\n                    return new System.Guid.$ctor1(a);\n                },\n                makeBinary: function (x) {\n                    return System.Int32.format((x & 255), \"x2\");\n                },\n                op_Equality: function (a, b) {\n                    if (Bridge.referenceEquals(a, null)) {\n                        return Bridge.referenceEquals(b, null);\n                    }\n\n                    return a.equalsT(b);\n                },\n                op_Inequality: function (a, b) {\n                    return !(System.Guid.op_Equality(a, b));\n                },\n                getDefaultValue: function () { return new System.Guid(); }\n            }\n        },\n        fields: {\n            _a: 0,\n            _b: 0,\n            _c: 0,\n            _d: 0,\n            _e: 0,\n            _f: 0,\n            _g: 0,\n            _h: 0,\n            _i: 0,\n            _j: 0,\n            _k: 0\n        },\n        alias: [\n            \"equalsT\", \"System$IEquatable$1$System$Guid$equalsT\",\n            \"compareTo\", [\"System$IComparable$1$System$Guid$compareTo\", \"System$IComparable$1$compareTo\"],\n            \"format\", \"System$IFormattable$format\"\n        ],\n        ctors: {\n            $ctor4: function (uuid) {\n                this.$initialize();\n                (new System.Guid.ctor()).$clone(this);\n\n                this.parseInternal(uuid, null, true);\n            },\n            $ctor1: function (b) {\n                this.$initialize();\n                if (b == null) {\n                    throw new System.ArgumentNullException(\"b\");\n                }\n\n                if (b.length !== 16) {\n                    throw new System.ArgumentException(System.String.format(System.Guid.error1, Bridge.box(16, System.Int32)));\n                }\n\n                this._a = (b[System.Array.index(3, b)] << 24) | (b[System.Array.index(2, b)] << 16) | (b[System.Array.index(1, b)] << 8) | b[System.Array.index(0, b)];\n                this._b = Bridge.Int.sxs(((b[System.Array.index(5, b)] << 8) | b[System.Array.index(4, b)]) & 65535);\n                this._c = Bridge.Int.sxs(((b[System.Array.index(7, b)] << 8) | b[System.Array.index(6, b)]) & 65535);\n                this._d = b[System.Array.index(8, b)];\n                this._e = b[System.Array.index(9, b)];\n                this._f = b[System.Array.index(10, b)];\n                this._g = b[System.Array.index(11, b)];\n                this._h = b[System.Array.index(12, b)];\n                this._i = b[System.Array.index(13, b)];\n                this._j = b[System.Array.index(14, b)];\n                this._k = b[System.Array.index(15, b)];\n            },\n            $ctor5: function (a, b, c, d, e, f, g, h, i, j, k) {\n                this.$initialize();\n                this._a = a | 0;\n                this._b = Bridge.Int.sxs(b & 65535);\n                this._c = Bridge.Int.sxs(c & 65535);\n                this._d = d;\n                this._e = e;\n                this._f = f;\n                this._g = g;\n                this._h = h;\n                this._i = i;\n                this._j = j;\n                this._k = k;\n            },\n            $ctor3: function (a, b, c, d) {\n                this.$initialize();\n                if (d == null) {\n                    throw new System.ArgumentNullException(\"d\");\n                }\n\n                if (d.length !== 8) {\n                    throw new System.ArgumentException(System.String.format(System.Guid.error1, Bridge.box(8, System.Int32)));\n                }\n\n                this._a = a;\n                this._b = b;\n                this._c = c;\n                this._d = d[System.Array.index(0, d)];\n                this._e = d[System.Array.index(1, d)];\n                this._f = d[System.Array.index(2, d)];\n                this._g = d[System.Array.index(3, d)];\n                this._h = d[System.Array.index(4, d)];\n                this._i = d[System.Array.index(5, d)];\n                this._j = d[System.Array.index(6, d)];\n                this._k = d[System.Array.index(7, d)];\n            },\n            $ctor2: function (a, b, c, d, e, f, g, h, i, j, k) {\n                this.$initialize();\n                this._a = a;\n                this._b = b;\n                this._c = c;\n                this._d = d;\n                this._e = e;\n                this._f = f;\n                this._g = g;\n                this._h = h;\n                this._i = i;\n                this._j = j;\n                this._k = k;\n            },\n            ctor: function () {\n                this.$initialize();\n            }\n        },\n        methods: {\n            getHashCode: function () {\n                return this._a ^ ((this._b << 16) | (this._c & 65535)) ^ ((this._f << 24) | this._k);\n            },\n            equals: function (o) {\n                if (!(Bridge.is(o, System.Guid))) {\n                    return false;\n                }\n\n                return this.equalsT(System.Nullable.getValue(Bridge.cast(Bridge.unbox(o), System.Guid)));\n            },\n            equalsT: function (o) {\n                if ((this._a !== o._a) || (this._b !== o._b) || (this._c !== o._c) || (this._d !== o._d) || (this._e !== o._e) || (this._f !== o._f) || (this._g !== o._g) || (this._h !== o._h) || (this._i !== o._i) || (this._j !== o._j) || (this._k !== o._k)) {\n                    return false;\n                }\n\n                return true;\n            },\n            compareTo: function (value) {\n                return System.String.compare(this.toString(), value.toString());\n            },\n            toString: function () {\n                return this.format$1(null);\n            },\n            toString$1: function (format) {\n                return this.format$1(format);\n            },\n            format: function (format, formatProvider) {\n                return this.format$1(format);\n            },\n            toByteArray: function () {\n                var g = System.Array.init(16, 0, System.Byte);\n\n                g[System.Array.index(0, g)] = this._a & 255;\n                g[System.Array.index(1, g)] = (this._a >> 8) & 255;\n                g[System.Array.index(2, g)] = (this._a >> 16) & 255;\n                g[System.Array.index(3, g)] = (this._a >> 24) & 255;\n                g[System.Array.index(4, g)] = this._b & 255;\n                g[System.Array.index(5, g)] = (this._b >> 8) & 255;\n                g[System.Array.index(6, g)] = this._c & 255;\n                g[System.Array.index(7, g)] = (this._c >> 8) & 255;\n                g[System.Array.index(8, g)] = this._d;\n                g[System.Array.index(9, g)] = this._e;\n                g[System.Array.index(10, g)] = this._f;\n                g[System.Array.index(11, g)] = this._g;\n                g[System.Array.index(12, g)] = this._h;\n                g[System.Array.index(13, g)] = this._i;\n                g[System.Array.index(14, g)] = this._j;\n                g[System.Array.index(15, g)] = this._k;\n\n                return g;\n            },\n            parseInternal: function (input, format, check) {\n                var r = null;\n\n                if (System.String.isNullOrEmpty(input)) {\n                    throw new System.ArgumentNullException(\"input\");\n                }\n\n                if (System.String.isNullOrEmpty(format)) {\n                    var m = System.Guid.nonFormat.match(input);\n\n                    if (m.getSuccess()) {\n                        var list = new (System.Collections.Generic.List$1(System.String)).ctor();\n                        for (var i = 1; i <= m.getGroups().getCount(); i = (i + 1) | 0) {\n                            if (m.getGroups().get(i).getSuccess()) {\n                                list.add(m.getGroups().get(i).getValue());\n                            }\n                        }\n\n                        r = list.toArray().join(\"-\").toLowerCase();\n                    }\n                } else {\n                    format = format.toUpperCase();\n\n                    var p = false;\n\n                    if (Bridge.referenceEquals(format, \"N\")) {\n                        var m1 = System.Guid.split.match(input);\n\n                        if (m1.getSuccess()) {\n                            var list1 = new (System.Collections.Generic.List$1(System.String)).ctor();\n                            for (var i1 = 1; i1 <= m1.getGroups().getCount(); i1 = (i1 + 1) | 0) {\n                                if (m1.getGroups().get(i1).getSuccess()) {\n                                    list1.add(m1.getGroups().get(i1).getValue());\n                                }\n                            }\n\n                            p = true;\n                            input = list1.toArray().join(\"-\");\n                        }\n                    } else if (Bridge.referenceEquals(format, \"B\") || Bridge.referenceEquals(format, \"P\")) {\n                        var b = Bridge.referenceEquals(format, \"B\") ? System.Array.init([123, 125], System.Char) : System.Array.init([40, 41], System.Char);\n\n                        if ((input.charCodeAt(0) === b[System.Array.index(0, b)]) && (input.charCodeAt(((input.length - 1) | 0)) === b[System.Array.index(1, b)])) {\n                            p = true;\n                            input = input.substr(1, ((input.length - 2) | 0));\n                        }\n                    } else {\n                        p = true;\n                    }\n\n                    if (p && System.Guid.valid.isMatch(input)) {\n                        r = input.toLowerCase();\n                    }\n                }\n\n                if (r != null) {\n                    this.fromString(r);\n                    return true;\n                }\n\n                if (check) {\n                    throw new System.FormatException(\"input is not in a recognized format\");\n                }\n\n                return false;\n            },\n            format$1: function (format) {\n                var s = (System.UInt32.format((this._a >>> 0), \"x8\") || \"\") + (System.UInt16.format((this._b & 65535), \"x4\") || \"\") + (System.UInt16.format((this._c & 65535), \"x4\") || \"\");\n                s = (s || \"\") + ((System.Array.init([this._d, this._e, this._f, this._g, this._h, this._i, this._j, this._k], System.Byte)).map(System.Guid.makeBinary).join(\"\") || \"\");\n\n                var m = System.Guid.split.match(s);\n                var list = new (System.Collections.Generic.List$1(System.String)).ctor();\n                for (var i = 1; i <= m.getGroups().getCount(); i = (i + 1) | 0) {\n                    if (m.getGroups().get(i).getSuccess()) {\n                        list.add(m.getGroups().get(i).getValue());\n                    }\n                }\n                s = list.toArray().join(\"-\");\n\n                switch (format) {\n                    case \"n\": \n                    case \"N\": \n                        return System.Guid.replace.replace(s, \"\");\n                    case \"b\": \n                    case \"B\": \n                        return String.fromCharCode(123) + (s || \"\") + String.fromCharCode(125);\n                    case \"p\": \n                    case \"P\": \n                        return String.fromCharCode(40) + (s || \"\") + String.fromCharCode(41);\n                    default: \n                        return s;\n                }\n            },\n            fromString: function (s) {\n                if (System.String.isNullOrEmpty(s)) {\n                    return;\n                }\n\n                s = System.Guid.replace.replace(s, \"\");\n\n                var r = System.Array.init(8, 0, System.Byte);\n\n                this._a = (System.UInt32.parse(s.substr(0, 8), 16)) | 0;\n                this._b = Bridge.Int.sxs((System.UInt16.parse(s.substr(8, 4), 16)) & 65535);\n                this._c = Bridge.Int.sxs((System.UInt16.parse(s.substr(12, 4), 16)) & 65535);\n                for (var i = 8; i < 16; i = (i + 1) | 0) {\n                    r[System.Array.index(((i - 8) | 0), r)] = System.Byte.parse(s.substr(Bridge.Int.mul(i, 2), 2), 16);\n                }\n\n                this._d = r[System.Array.index(0, r)];\n                this._e = r[System.Array.index(1, r)];\n                this._f = r[System.Array.index(2, r)];\n                this._g = r[System.Array.index(3, r)];\n                this._h = r[System.Array.index(4, r)];\n                this._i = r[System.Array.index(5, r)];\n                this._j = r[System.Array.index(6, r)];\n                this._k = r[System.Array.index(7, r)];\n            },\n            toJSON: function () {\n                return this.toString();\n            },\n            $clone: function (to) { return this; }\n        }\n    });\n\n    // @source environment.js\n\n    Bridge.define(\"System.Environment\", {\n        statics: {\n            fields: {\n                variables: null\n            },\n            props: {\n                Location: {\n                    get: function () {\n                        var g = Bridge.global;\n\n                        if (g && g.location) {\n                            return g.location;\n                        }\n\n                        return null;\n                    }\n                },\n                CommandLine: {\n                    get: function () {\n                        return System.Environment.getCommandLineArgs().join(\" \");\n                    }\n                },\n                CurrentDirectory: {\n                    get: function () {\n                        var l = System.Environment.Location;\n\n                        return l ? l.pathname : \"\";\n                    },\n                    set: function (value) {\n                        var l = System.Environment.Location;\n\n                        if (l) {\n                            l.pathname = value;\n                        }\n                    }\n                },\n                ExitCode: 0,\n                Is64BitOperatingSystem: {\n                    get: function () {\n                        var n = Bridge.global ? Bridge.global.navigator : null;\n\n                        if (n && (!Bridge.referenceEquals(n.userAgent.indexOf(\"WOW64\"), -1) || !Bridge.referenceEquals(n.userAgent.indexOf(\"Win64\"), -1))) {\n                            return true;\n                        }\n\n                        return false;\n                    }\n                },\n                ProcessorCount: {\n                    get: function () {\n                        var n = Bridge.global ? Bridge.global.navigator : null;\n\n                        if (n && n.hardwareConcurrency) {\n                            return n.hardwareConcurrency;\n                        }\n\n                        return 1;\n                    }\n                },\n                StackTrace: {\n                    get: function () {\n                        var err = new Error();\n                        var s = err.stack;\n\n                        if (!System.String.isNullOrEmpty(s)) {\n                            if (System.String.indexOf(s, \"at\") >= 0) {\n                                return s.substr(System.String.indexOf(s, \"at\"));\n                            }\n                        }\n\n                        return \"\";\n                    }\n                },\n                Version: {\n                    get: function () {\n                        var s = Bridge.SystemAssembly.compiler;\n\n                        var v = { };\n\n                        if (System.Version.tryParse(s, v)) {\n                            return v.v;\n                        }\n\n                        return new System.Version.ctor();\n                    }\n                }\n            },\n            ctors: {\n                init: function () {\n                    this.ExitCode = 0;\n                },\n                ctor: function () {\n                    System.Environment.variables = new (System.Collections.Generic.Dictionary$2(System.String,System.String))();\n                    System.Environment.patchDictionary(System.Environment.variables);\n                }\n            },\n            methods: {\n                patchDictionary: function (d) {\n                    d.noKeyCheck = true;\n\n                    return d;\n                },\n                exit: function (exitCode) {\n                    System.Environment.ExitCode = exitCode;\n                },\n                expandEnvironmentVariables: function (name) {\n                    var $t;\n                    if (name == null) {\n                        throw new System.ArgumentNullException(name);\n                    }\n\n                    // Case sensitive\n                    $t = Bridge.getEnumerator(System.Environment.variables);\n                    try {\n                        while ($t.moveNext()) {\n                            var pair = $t.Current;\n                            name = System.String.replaceAll(name, \"%\" + (pair.key || \"\") + \"%\", pair.value);\n                        }\n                    } finally {\n                        if (Bridge.is($t, System.IDisposable)) {\n                            $t.System$IDisposable$dispose();\n                        }\n                    }\n                    return name;\n                },\n                failFast: function (message) {\n                    throw new System.Exception(message);\n                },\n                failFast$1: function (message, exception) {\n                    throw new System.Exception(message, exception);\n                },\n                getCommandLineArgs: function () {\n                    var l = System.Environment.Location;\n\n                    if (l) {\n                        var args = new (System.Collections.Generic.List$1(System.String)).ctor();\n\n                        var path = l.pathname;\n\n                        if (!System.String.isNullOrEmpty(path)) {\n                            args.add(path);\n                        }\n\n                        var search = l.search;\n\n                        if (!System.String.isNullOrEmpty(search) && search.length > 1) {\n                            var query = System.String.split(search.substr(1), [38].map(function(i) {{ return String.fromCharCode(i); }}));\n\n                            for (var i = 0; i < query.length; i = (i + 1) | 0) {\n                                var param = System.String.split(query[System.Array.index(i, query)], [61].map(function(i) {{ return String.fromCharCode(i); }}));\n\n                                for (var j = 0; j < param.length; j = (j + 1) | 0) {\n                                    args.add(param[System.Array.index(j, param)]);\n                                }\n                            }\n                        }\n\n                        return args.toArray();\n                    }\n\n                    return System.Array.init(0, null, System.String);\n                },\n                getEnvironmentVariable: function (variable) {\n                    if (variable == null) {\n                        throw new System.ArgumentNullException(\"variable\");\n                    }\n\n                    var r = { };\n\n                    if (System.Environment.variables.tryGetValue(variable.toLowerCase(), r)) {\n                        return r.v;\n                    }\n\n                    return null;\n                },\n                getEnvironmentVariable$1: function (variable, target) {\n                    return System.Environment.getEnvironmentVariable(variable);\n                },\n                getEnvironmentVariables: function () {\n                    return System.Environment.patchDictionary(new (System.Collections.Generic.Dictionary$2(System.String,System.String))(System.Environment.variables));\n                },\n                getEnvironmentVariables$1: function (target) {\n                    return System.Environment.getEnvironmentVariables();\n                },\n                getLogicalDrives: function () {\n                    return System.Array.init(0, null, System.String);\n                },\n                setEnvironmentVariable: function (variable, value) {\n                    if (variable == null) {\n                        throw new System.ArgumentNullException(\"variable\");\n                    }\n\n                    if (System.String.isNullOrEmpty(variable) || System.String.startsWith(variable, String.fromCharCode(0)) || System.String.contains(variable,\"=\") || variable.length > 32767) {\n                        throw new System.ArgumentException(\"Incorrect variable (cannot be empty, contain zero character nor equal sign, be longer than 32767).\");\n                    }\n\n                    variable = variable.toLowerCase();\n\n                    if (System.String.isNullOrEmpty(value)) {\n                        if (System.Environment.variables.containsKey(variable)) {\n                            System.Environment.variables.remove(variable);\n                        }\n                    } else {\n                        System.Environment.variables.set(variable, value);\n                    }\n                },\n                setEnvironmentVariable$1: function (variable, value, target) {\n                    System.Environment.setEnvironmentVariable(variable, value);\n                }\n            }\n        }\n    });\n\n    // @source Regex.js\n\n    Bridge.define(\"System.Text.RegularExpressions.Regex\", {\n        statics: {\n            _cacheSize: 15,\n            _defaultMatchTimeout: System.TimeSpan.fromMilliseconds(-1),\n\n            getCacheSize: function () {\n                return System.Text.RegularExpressions.Regex._cacheSize;\n            },\n\n            setCacheSize: function (value) {\n                if (value < 0) {\n                    throw new System.ArgumentOutOfRangeException(\"value\");\n                }\n\n                System.Text.RegularExpressions.Regex._cacheSize = value;\n                //TODO: remove extra items from cache\n            },\n\n            escape: function (str) {\n                if (str == null) {\n                    throw new System.ArgumentNullException(\"str\");\n                }\n\n                return System.Text.RegularExpressions.RegexParser.escape(str);\n            },\n\n            unescape: function (str) {\n                if (str == null) {\n                    throw new System.ArgumentNullException(\"str\");\n                }\n\n                return System.Text.RegularExpressions.RegexParser.unescape(str);\n            },\n\n            isMatch: function (input, pattern, options, matchTimeout) {\n                var scope = System.Text.RegularExpressions;\n\n                if (!Bridge.isDefined(options)) {\n                    options = scope.RegexOptions.None;\n                }\n\n                if (!Bridge.isDefined(matchTimeout)) {\n                    matchTimeout = scope.Regex._defaultMatchTimeout;\n                }\n\n                var regex = new System.Text.RegularExpressions.Regex.ctor(pattern, options, matchTimeout, true);\n                return regex.isMatch(input);\n            },\n\n            match: function (input, pattern, options, matchTimeout) {\n                var scope = System.Text.RegularExpressions;\n\n                if (!Bridge.isDefined(options)) {\n                    options = scope.RegexOptions.None;\n                }\n\n                if (!Bridge.isDefined(matchTimeout)) {\n                    matchTimeout = scope.Regex._defaultMatchTimeout;\n                }\n\n                var regex = new System.Text.RegularExpressions.Regex.ctor(pattern, options, matchTimeout, true);\n                return regex.match(input);\n            },\n\n            matches: function (input, pattern, options, matchTimeout) {\n                var scope = System.Text.RegularExpressions;\n\n                if (!Bridge.isDefined(options)) {\n                    options = scope.RegexOptions.None;\n                }\n\n                if (!Bridge.isDefined(matchTimeout)) {\n                    matchTimeout = scope.Regex._defaultMatchTimeout;\n                }\n\n                var regex = new System.Text.RegularExpressions.Regex.ctor(pattern, options, matchTimeout, true);\n                return regex.matches(input);\n            },\n\n            replace: function (input, pattern, replacement, options, matchTimeout) {\n                var scope = System.Text.RegularExpressions;\n\n                if (!Bridge.isDefined(options)) {\n                    options = scope.RegexOptions.None;\n                }\n\n                if (!Bridge.isDefined(matchTimeout)) {\n                    matchTimeout = scope.Regex._defaultMatchTimeout;\n                }\n\n                var regex = new System.Text.RegularExpressions.Regex.ctor(pattern, options, matchTimeout, true);\n                return regex.replace(input, replacement);\n            },\n\n            split: function (input, pattern, options, matchTimeout) {\n                var scope = System.Text.RegularExpressions;\n\n                if (!Bridge.isDefined(options)) {\n                    options = scope.RegexOptions.None;\n                }\n\n                if (!Bridge.isDefined(matchTimeout)) {\n                    matchTimeout = scope.Regex._defaultMatchTimeout;\n                }\n\n                var regex = new System.Text.RegularExpressions.Regex.ctor(pattern, options, matchTimeout, true);\n                return regex.split(input);\n            }\n        },\n\n        _pattern: \"\",\n        _matchTimeout: System.TimeSpan.fromMilliseconds(-1),\n        _runner: null,\n        _caps: null,\n        _capsize: 0,\n        _capnames: null,\n        _capslist: null,\n\n        config: {\n            init: function () {\n                this._options = System.Text.RegularExpressions.RegexOptions.None;\n            }\n        },\n\n        ctor: function (pattern, options, matchTimeout, useCache) {\n            this.$initialize();\n            if (!Bridge.isDefined(options)) {\n                options = System.Text.RegularExpressions.RegexOptions.None;\n            }\n\n            if (!Bridge.isDefined(matchTimeout)) {\n                matchTimeout = System.TimeSpan.fromMilliseconds(-1);\n            }\n\n            if (!Bridge.isDefined(useCache)) {\n                useCache = false;\n            }\n            \n            var scope = System.Text.RegularExpressions;\n\n            if (pattern == null) {\n                throw new System.ArgumentNullException(\"pattern\");\n            }\n\n            if (options < scope.RegexOptions.None || ((options >> 10) !== 0)) {\n                throw new System.ArgumentOutOfRangeException(\"options\");\n            }\n\n            if (((options & scope.RegexOptions.ECMAScript) !== 0) &&\n                ((options & ~(scope.RegexOptions.ECMAScript |\n                    scope.RegexOptions.IgnoreCase |\n                    scope.RegexOptions.Multiline |\n                    scope.RegexOptions.CultureInvariant\n                )) !== 0)) {\n                throw new System.ArgumentOutOfRangeException(\"options\");\n            }\n\n            // Check if the specified options are supported.\n            var supportedOptions =\n                System.Text.RegularExpressions.RegexOptions.IgnoreCase |\n                System.Text.RegularExpressions.RegexOptions.Multiline |\n                System.Text.RegularExpressions.RegexOptions.Singleline |\n                System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace |\n                System.Text.RegularExpressions.RegexOptions.ExplicitCapture;\n\n            if ((options | supportedOptions) !== supportedOptions) {\n                throw new System.NotSupportedException(\"Specified Regex options are not supported.\");\n            }\n\n            this._validateMatchTimeout(matchTimeout);\n\n            this._pattern = pattern;\n            this._options = options;\n            this._matchTimeout = matchTimeout;\n            this._runner = new scope.RegexRunner(this);\n\n            //TODO: cache\n            var patternInfo = this._runner.parsePattern();\n\n            this._capnames = patternInfo.sparseSettings.sparseSlotNameMap;\n            this._capslist = patternInfo.sparseSettings.sparseSlotNameMap.keys;\n            this._capsize = this._capslist.length;\n        },\n\n        getMatchTimeout: function () {\n            return this._matchTimeout;\n        },\n\n        getOptions: function () {\n            return this._options;\n        },\n\n        getRightToLeft: function () {\n            return (this._options & System.Text.RegularExpressions.RegexOptions.RightToLeft) !== 0;\n        },\n\n        isMatch: function (input, startat) {\n            if (input == null) {\n                throw new System.ArgumentNullException(\"input\");\n            }\n\n            if (!Bridge.isDefined(startat)) {\n                startat = this.getRightToLeft() ? input.length : 0;\n            }\n\n            var match = this._runner.run(true, -1, input, 0, input.length, startat);\n\n            return match == null;\n        },\n\n        match: function (input, startat, arg3) {\n            if (input == null) {\n                throw new System.ArgumentNullException(\"input\");\n            }\n\n            var length = input.length,\n                beginning = 0;\n\n            if (arguments.length === 3) {\n                beginning = startat;\n                length = arg3;\n                startat = this.getRightToLeft() ? beginning + length : beginning;\n            } else if (!Bridge.isDefined(startat)) {\n                startat = this.getRightToLeft() ? length : 0;\n            }\n\n            return this._runner.run(false, -1, input, beginning, length, startat);\n        },\n\n        matches: function (input, startat) {\n            if (input == null) {\n                throw new System.ArgumentNullException(\"input\");\n            }\n\n            if (!Bridge.isDefined(startat)) {\n                startat = this.getRightToLeft() ? input.length : 0;\n            }\n\n            return new System.Text.RegularExpressions.MatchCollection(this, input, 0, input.length, startat);\n        },\n\n        getGroupNames: function () {\n            if (this._capslist == null) {\n                var invariantCulture = System.Globalization.CultureInfo.invariantCulture;\n\n                var result = [];\n                var max = this._capsize;\n                var i;\n\n                for (i = 0; i < max; i++) {\n                    result[i] = System.Convert.toString(i, invariantCulture, System.Convert.typeCodes.Int32);\n                }\n\n                return result;\n            } else {\n                return this._capslist.slice();\n            }\n        },\n\n        getGroupNumbers: function () {\n            var caps = this._caps;\n            var result;\n            var key;\n            var max;\n            var i;\n\n            if (caps == null) {\n                result = [];\n                max = this._capsize;\n                for (i = 0; i < max; i++) {\n                    result.push(i);\n                }\n            } else {\n                result = [];\n                for (key in caps) {\n                    if (caps.hasOwnProperty(key)) {\n                        result[caps[key]] = key;\n                    }\n                }\n            }\n\n            return result;\n        },\n\n        groupNameFromNumber: function (i) {\n            if (this._capslist == null) {\n                if (i >= 0 && i < this._capsize) {\n                    var invariantCulture = System.Globalization.CultureInfo.invariantCulture;\n\n                    return System.Convert.toString(i, invariantCulture, System.Convert.typeCodes.Int32);\n                }\n\n                return \"\";\n            } else {\n                if (this._caps != null) {\n                    var obj = this._caps[i];\n\n                    if (obj == null) {\n                        return \"\";\n                    }\n\n                    return parseInt(obj);\n                }\n\n                if (i >= 0 && i < this._capslist.length) {\n                    return this._capslist[i];\n                }\n\n                return \"\";\n            }\n        },\n\n        groupNumberFromName: function (name) {\n            if (name == null) {\n                throw new System.ArgumentNullException(\"name\");\n            }\n\n            // look up name if we have a hashtable of names\n            if (this._capnames != null) {\n                var ret = this._capnames[name];\n\n                if (ret == null) {\n                    return -1;\n                }\n\n                return parseInt(ret);\n            }\n\n            // convert to an int if it looks like a number\n            var result = 0;\n            var ch;\n            var i;\n\n            for (i = 0; i < name.Length; i++) {\n                ch = name[i];\n\n                if (ch > \"9\" || ch < \"0\") {\n                    return -1;\n                }\n\n                result *= 10;\n                result += (ch - \"0\");\n            }\n\n            // return int if it's in range\n            if (result >= 0 && result < this._capsize) {\n                return result;\n            }\n\n            return -1;\n        },\n\n        replace: function (input, evaluator, count, startat) {\n            if (input == null) {\n                throw new System.ArgumentNullException(\"input\");\n            }\n\n            if (!Bridge.isDefined(count)) {\n                count = -1;\n            }\n\n            if (!Bridge.isDefined(startat)) {\n                startat = this.getRightToLeft() ? input.length : 0;\n            }\n\n            if (evaluator == null) {\n                throw new System.ArgumentNullException(\"evaluator\");\n            }\n\n            if (Bridge.isFunction(evaluator)) {\n                return System.Text.RegularExpressions.RegexReplacement.replace(evaluator, this, input, count, startat);\n            }\n\n            var repl = System.Text.RegularExpressions.RegexParser.parseReplacement(evaluator, this._caps, this._capsize, this._capnames, this._options);\n            //TODO: Cache\n\n            return repl.replace(this, input, count, startat);\n        },\n\n        split: function (input, count, startat) {\n            if (input == null) {\n                throw new System.ArgumentNullException(\"input\");\n            }\n\n            if (!Bridge.isDefined(count)) {\n                count = 0;\n            }\n\n            if (!Bridge.isDefined(startat)) {\n                startat = this.getRightToLeft() ? input.length : 0;\n            }\n\n            return System.Text.RegularExpressions.RegexReplacement.split(this, input, count, startat);\n        },\n\n        _validateMatchTimeout: function (matchTimeout) {\n            var ms = matchTimeout.getTotalMilliseconds();\n\n            if (-1 === ms) {\n                return;\n            }\n\n            if (ms > 0 && ms <= 2147483646) {\n                return;\n            }\n\n            throw new System.ArgumentOutOfRangeException(\"matchTimeout\");\n        }\n    });\n\n    // @source RegexCapture.js\n\n    Bridge.define(\"System.Text.RegularExpressions.Capture\", {\n        _text: \"\",\n        _index: 0,\n        _length: 0,\n\n        ctor: function (text, i, l) {\n            this.$initialize();\n            this._text = text;\n            this._index = i;\n            this._length = l;\n        },\n\n        getIndex: function () {\n            return this._index;\n        },\n\n        getLength: function () {\n            return this._length;\n        },\n\n        getValue: function () {\n            return this._text.substr(this._index, this._length);\n        },\n\n        toString: function () {\n            return this.getValue();\n        },\n\n        _getOriginalString: function () {\n            return this._text;\n        },\n\n        _getLeftSubstring: function () {\n            return this._text.slice(0, _index);\n        },\n\n        _getRightSubstring: function () {\n            return this._text.slice(this._index + this._length, this._text.length);\n        }\n    });\n\n    // @source RegexCaptureCollection.js\n\n    Bridge.define(\"System.Text.RegularExpressions.CaptureCollection\", {\n        inherits: function () {\n            return [System.Collections.ICollection];\n        },\n\n        config: {\n            properties: {\n                Count: {\n                    get: function() {\n                        return this._capcount;\n                    }\n                }    \n            },\n\n            alias: [\n            \"getEnumerator\", \"System$Collections$IEnumerable$getEnumerator\",\n            \"getCount\", \"System$Collections$ICollection$getCount\",\n            \"Count\", \"System$Collections$ICollection$Count\",\n            \"copyTo\", \"System$Collections$ICollection$copyTo\"\n            ]\n        },\n\n        _group: null,\n        _capcount: 0,\n        _captures: null,\n\n        ctor: function (group) {\n            this.$initialize();\n            this._group = group;\n            this._capcount = group._capcount;\n        },\n\n        getSyncRoot: function () {\n            return this._group;\n        },\n\n        getIsSynchronized: function () {\n            return false;\n        },\n\n        getIsReadOnly: function () {\n            return true;\n        },\n\n        getCount: function () {\n            return this._capcount;\n        },\n\n        get: function (i) {\n            if (i === this._capcount - 1 && i >= 0) {\n                return this._group;\n            }\n\n            if (i >= this._capcount || i < 0) {\n                throw new System.ArgumentOutOfRangeException(\"i\");\n            }\n\n            this._ensureCapturesInited();\n\n            return this._captures[i];\n        },\n\n        copyTo: function (array, arrayIndex) {\n            if (array == null) {\n                throw new System.ArgumentNullException(\"array\");\n            }\n\n            if (array.length < arrayIndex + this._capcount) {\n                throw new System.IndexOutOfRangeException();\n            }\n\n            var capture;\n            var i;\n            var j;\n\n            for (i = arrayIndex, j = 0; j < this._capcount; i++, j++) {\n                capture = this.get(j);\n                System.Array.set(array, capture, [i]);\n            }\n        },\n\n        getEnumerator: function () {\n            return new System.Text.RegularExpressions.CaptureEnumerator(this);\n        },\n\n        _ensureCapturesInited: function () {\n            // first time a capture is accessed, compute them all\n            if (this._captures == null) {\n                var captures = [];\n                var j;\n\n                captures.length = this._capcount;\n                for (j = 0; j < this._capcount - 1; j++) {\n                    var index = this._group._caps[j * 2];\n                    var length = this._group._caps[j * 2 + 1];\n\n                    captures[j] = new System.Text.RegularExpressions.Capture(this._group._text, index, length);\n                }\n\n                if (this._capcount > 0) {\n                    captures[this._capcount - 1] = this._group;\n                }\n\n                this._captures = captures;\n            }\n        }\n    });\n\n    Bridge.define(\"System.Text.RegularExpressions.CaptureEnumerator\", {\n        inherits: function () {\n            return [System.Collections.IEnumerator];\n        },\n\n        config: {\n\t\t\tproperties: {\n\t\t\t\tCurrent: {\n\t\t\t\t\tget: function () {\n\t\t\t\t\t\treturn this.getCurrent();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n            alias: [\n                \"getCurrent\", \"System$Collections$IEnumerator$getCurrent\",\n                \"moveNext\", \"System$Collections$IEnumerator$moveNext\",\n                \"reset\", \"System$Collections$IEnumerator$reset\",\n\t\t\t\t\"Current\", \"System$Collections$IEnumerator$Current\"\n            ]\n        },\n\n        _captureColl: null,\n        _curindex: 0,\n\n        ctor: function (captureColl) {\n            this.$initialize();\n            this._curindex = -1;\n            this._captureColl = captureColl;\n        },\n\n        moveNext: function () {\n            var size = this._captureColl.getCount();\n\n            if (this._curindex >= size) {\n                return false;\n            }\n\n            this._curindex++;\n            return (this._curindex < size);\n        },\n\n        getCurrent: function () {\n            return this.getCapture();\n        },\n\n        getCapture: function () {\n            if (this._curindex < 0 || this._curindex >= this._captureColl.getCount()) {\n                throw new System.InvalidOperationException(\"Enumeration has either not started or has already finished.\");\n            }\n\n            return this._captureColl.get(this._curindex);\n        },\n\n        reset: function () {\n            this._curindex = -1;\n        }\n    });\n\n    // @source RegexGroup.js\n\n    Bridge.define(\"System.Text.RegularExpressions.Group\", {\n        inherits: function () {\n            return [System.Text.RegularExpressions.Capture];\n        },\n\n        statics: {\n            config: {\n                init: function () {\n                    var empty = new System.Text.RegularExpressions.Group(\"\", [], 0);\n\n                    this.getEmpty = function () {\n                        return empty;\n                    }\n                }\n            },\n\n            synchronized: function (group) {\n                if (group == null) {\n                    throw new System.ArgumentNullException(\"group\");\n                }\n\n                // force Captures to be computed.\n                var captures = group.getCaptures();\n\n                if (captures.getCount() > 0) {\n                    captures.get(0);\n                }\n\n                return group;\n            }\n        },\n\n        _caps: null,\n        _capcount: 0,\n        _capColl: null,\n\n        ctor: function (text, caps, capcount) {\n            this.$initialize();\n            var scope = System.Text.RegularExpressions;\n            var index = capcount === 0 ? 0 : caps[(capcount - 1) * 2];\n            var length = capcount === 0 ? 0 : caps[(capcount * 2) - 1];\n\n            scope.Capture.ctor.call(this, text, index, length);\n\n            this._caps = caps;\n            this._capcount = capcount;\n        },\n\n        getSuccess: function () {\n            return this._capcount !== 0;\n        },\n\n        getCaptures: function () {\n            if (this._capColl == null) {\n                this._capColl = new System.Text.RegularExpressions.CaptureCollection(this);\n            }\n\n            return this._capColl;\n        }\n    });\n\n    // @source RegexGroupCollection.js\n\n    Bridge.define(\"System.Text.RegularExpressions.GroupCollection\", {\n        inherits: function () {\n            return [System.Collections.ICollection];\n        },\n\n        config: {\n            properties: {\n                Count: {\n                    get: function () {\n                        return this._match._matchcount.length;\n                    }\n                }\n            },\n            alias: [\n            \"getEnumerator\", \"System$Collections$IEnumerable$getEnumerator\",\n            \"getCount\", \"System$Collections$ICollection$getCount\",\n            \"Count\", \"System$Collections$ICollection$Count\",\n            \"copyTo\", \"System$Collections$ICollection$copyTo\"\n            ]\n        },\n\n        _match: null,\n        _captureMap: null,\n        _groups: null,\n\n        ctor: function (match, caps) {\n            this.$initialize();\n            this._match = match;\n            this._captureMap = caps;\n        },\n\n        getSyncRoot: function () {\n            return this._match;\n        },\n\n        getIsSynchronized: function () {\n            return false;\n        },\n\n        getIsReadOnly: function () {\n            return true;\n        },\n\n        getCount: function () {\n            return this._match._matchcount.length;\n        },\n\n        get: function (groupnum) {\n            return this._getGroup(groupnum);\n        },\n\n        getByName: function (groupname) {\n            if (this._match._regex == null) {\n                return System.Text.RegularExpressions.Group.getEmpty();\n            }\n\n            var groupnum = this._match._regex.groupNumberFromName(groupname);\n\n            return this._getGroup(groupnum);\n        },\n\n        copyTo: function (array, arrayIndex) {\n            if (array == null) {\n                throw new System.ArgumentNullException(\"array\");\n            }\n\n            var count = this.getCount();\n\n            if (array.length < arrayIndex + count) {\n                throw new System.IndexOutOfRangeException();\n            }\n\n            var group;\n            var i;\n            var j;\n\n            for (i = arrayIndex, j = 0; j < count; i++, j++) {\n                group = this._getGroup(j);\n                System.Array.set(array, group, [i]);\n            }\n        },\n\n        getEnumerator: function () {\n            return new System.Text.RegularExpressions.GroupEnumerator(this);\n        },\n\n        _getGroup: function (groupnum) {\n            var group;\n\n            if (this._captureMap != null) {\n                var num = this._captureMap[groupnum];\n\n                if (num == null) {\n                    group = System.Text.RegularExpressions.Group.getEmpty();\n                } else {\n                    group = this._getGroupImpl(num);\n                }\n            } else {\n                if (groupnum >= this._match._matchcount.length || groupnum < 0) {\n                    group = System.Text.RegularExpressions.Group.getEmpty();\n                } else {\n                    group = this._getGroupImpl(groupnum);\n                }\n            }\n\n            return group;\n        },\n\n        _getGroupImpl: function (groupnum) {\n            if (groupnum === 0) {\n                return this._match;\n            }\n\n            this._ensureGroupsInited();\n\n            return this._groups[groupnum];\n        },\n\n        _ensureGroupsInited: function () {\n            // Construct all the Group objects the first time GetGroup is called\n            if (this._groups == null) {\n                var groups = [];\n\n                groups.length = this._match._matchcount.length;\n\n                if (groups.length > 0) {\n                    groups[0] = this._match;\n                }\n\n                var matchText;\n                var matchCaps;\n                var matchCapcount;\n                var i;\n\n                for (i = 0; i < groups.length - 1; i++) {\n                    matchText = this._match._text;\n                    matchCaps = this._match._matches[i + 1];\n                    matchCapcount = this._match._matchcount[i + 1];\n                    groups[i + 1] = new System.Text.RegularExpressions.Group(matchText, matchCaps, matchCapcount);\n                }\n                this._groups = groups;\n            }\n        }\n    });\n\n    Bridge.define(\"System.Text.RegularExpressions.GroupEnumerator\", {\n        inherits: function () {\n            return [System.Collections.IEnumerator];\n        },\n\n        config: {\n\t\t\tproperties: {\n\t\t\t\tCurrent: {\n\t\t\t\t\tget: function () {\n\t\t\t\t\t\treturn this.getCurrent();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\t\n            alias: [\n                \"getCurrent\", \"System$Collections$IEnumerator$getCurrent\",\n                \"moveNext\", \"System$Collections$IEnumerator$moveNext\",\n                \"reset\", \"System$Collections$IEnumerator$reset\",\n\t\t\t\t\"Current\", \"System$Collections$IEnumerator$Current\"\n            ]\n        },\n\n        _groupColl: null,\n        _curindex: 0,\n\n        ctor: function (groupColl) {\n            this.$initialize();\n            this._curindex = -1;\n            this._groupColl = groupColl;\n        },\n\n        moveNext: function () {\n            var size = this._groupColl.getCount();\n\n            if (this._curindex >= size) {\n                return false;\n            }\n\n            this._curindex++;\n\n            return (this._curindex < size);\n        },\n\n        getCurrent: function () {\n            return this.getCapture();\n        },\n\n        getCapture: function () {\n            if (this._curindex < 0 || this._curindex >= this._groupColl.getCount()) {\n                throw new System.InvalidOperationException(\"Enumeration has either not started or has already finished.\");\n            }\n\n            return this._groupColl.get(this._curindex);\n        },\n\n        reset: function () {\n            this._curindex = -1;\n        }\n    });\n\n    // @source RegexMatch.js\n\n    Bridge.define(\"System.Text.RegularExpressions.Match\", {\n        inherits: function () {\n            return [System.Text.RegularExpressions.Group];\n        },\n\n        statics: {\n            config: {\n                init: function () {\n                    var empty = new System.Text.RegularExpressions.Match(null, 1, \"\", 0, 0, 0);\n\n                    this.getEmpty = function () {\n                        return empty;\n                    }\n                }\n            },\n\n            synchronized: function (match) {\n                if (match == null) {\n                    throw new System.ArgumentNullException(\"match\");\n                }\n\n                // Populate all groups by looking at each one\n                var groups = match.getGroups();\n                var groupsCount = groups.getCount();\n                var group;\n                var i;\n\n                for (i = 0; i < groupsCount; i++) {\n                    group = groups.get(i);\n                    System.Text.RegularExpressions.Group.synchronized(group);\n                }\n\n                return match;\n            }\n        },\n\n        _regex: null,\n        _matchcount: null,\n        _matches: null,\n        _textbeg: 0,\n        _textend: 0,\n        _textstart: 0,\n        _groupColl: null,\n        _textpos: 0,\n\n        ctor: function (regex, capcount, text, begpos, len, startpos) {\n            this.$initialize();\n            var scope = System.Text.RegularExpressions;\n            var caps = [0, 0];\n\n            scope.Group.ctor.call(this, text, caps, 0);\n\n            this._regex = regex;\n\n            this._matchcount = [];\n            this._matchcount.length = capcount;\n\n            var i;\n            for (i = 0; i < capcount; i++) {\n                this._matchcount[i] = 0;\n            }\n\n            this._matches = [];\n            this._matches.length = capcount;\n            this._matches[0] = caps;\n\n            this._textbeg = begpos;\n            this._textend = begpos + len;\n            this._textstart = startpos;\n        },\n\n        getGroups: function () {\n            if (this._groupColl == null) {\n                this._groupColl = new System.Text.RegularExpressions.GroupCollection(this, null);\n            }\n\n            return this._groupColl;\n        },\n\n        nextMatch: function () {\n            if (this._regex == null) {\n                return this;\n            }\n\n            return this._regex._runner.run(false, this._length, this._text, this._textbeg, this._textend - this._textbeg, this._textpos);\n        },\n\n        result: function (replacement) {\n            if (replacement == null) {\n                throw new System.ArgumentNullException(\"replacement\");\n            }\n\n            if (this._regex == null) {\n                throw new System.NotSupportedException(\"Result cannot be called on a failed Match.\");\n            }\n\n            var repl = System.Text.RegularExpressions.RegexParser.parseReplacement(replacement, this._regex._caps, this._regex._capsize, this._regex._capnames, this._regex._options);\n            //TODO: cache\n\n            return repl.replacement(this);\n        },\n\n        _isMatched: function (cap) {\n            return cap < this._matchcount.length && this._matchcount[cap] > 0 && this._matches[cap][this._matchcount[cap] * 2 - 1] !== (-3 + 1);\n        },\n\n        _addMatch: function (cap, start, len) {\n            if (this._matches[cap] == null) {\n                this._matches[cap] = new Array(2);\n            }\n\n            var capcount = this._matchcount[cap];\n\n            if (capcount * 2 + 2 > this._matches[cap].length) {\n                var oldmatches = this._matches[cap];\n                var newmatches = new Array(capcount * 8);\n                var j;\n\n                for (j = 0; j < capcount * 2; j++) {\n                    newmatches[j] = oldmatches[j];\n                }\n\n                this._matches[cap] = newmatches;\n            }\n\n            this._matches[cap][capcount * 2] = start;\n            this._matches[cap][capcount * 2 + 1] = len;\n            this._matchcount[cap] = capcount + 1;\n        },\n\n        _tidy: function (textpos) {\n            var interval = this._matches[0];\n            this._index = interval[0];\n            this._length = interval[1];\n            this._textpos = textpos;\n            this._capcount = this._matchcount[0];\n        },\n\n        _groupToStringImpl: function (groupnum) {\n            var c = this._matchcount[groupnum];\n\n            if (c === 0) {\n                return \"\";\n            }\n\n            var matches = this._matches[groupnum];\n            var capIndex = matches[(c - 1) * 2];\n            var capLength = matches[(c * 2) - 1];\n\n            return this._text.slice(capIndex, capIndex + capLength);\n        },\n\n        _lastGroupToStringImpl: function () {\n            return this._groupToStringImpl(this._matchcount.length - 1);\n        }\n    });\n\n    Bridge.define(\"System.Text.RegularExpressions.MatchSparse\", {\n        inherits: function () {\n            return [System.Text.RegularExpressions.Match];\n        },\n\n        _caps: null,\n\n        ctor: function (regex, caps, capcount, text, begpos, len, startpos) {\n            this.$initialize();\n            var scope = System.Text.RegularExpressions;\n            scope.Match.ctor.call(this, regex, capcount, text, begpos, len, startpos);\n\n            this._caps = caps;\n        },\n\n        getGroups: function () {\n            if (this._groupColl == null) {\n                this._groupColl = new System.Text.RegularExpressions.GroupCollection(this, this._caps);\n            }\n            return this._groupColl;\n        },\n    });\n\n    // @source RegexMatchCollection.js\n\n    Bridge.define(\"System.Text.RegularExpressions.MatchCollection\", {\n        inherits: function () {\n            return [System.Collections.ICollection];\n        },\n\n        config: {\n            properties: {\n                Count: {\n                    get: function () {\n                        return this.getCount();\n                    }\n                }\n            },\n            alias: [\n            \"getEnumerator\", \"System$Collections$IEnumerable$getEnumerator\",\n            \"getCount\", \"System$Collections$ICollection$getCount\",\n            \"Count\", \"System$Collections$ICollection$Count\",\n            \"copyTo\", \"System$Collections$ICollection$copyTo\"\n            ]\n        },\n\n        _regex: null,\n        _input: null,\n        _beginning: 0,\n        _length: 0,\n        _startat: 0,\n        _prevlen: 0,\n        _matches: null,\n        _done: false,\n\n        ctor: function (regex, input, beginning, length, startat) {\n            this.$initialize();\n            if (startat < 0 || startat > input.Length) {\n                throw new System.ArgumentOutOfRangeException(\"startat\");\n            }\n\n            this._regex = regex;\n            this._input = input;\n            this._beginning = beginning;\n            this._length = length;\n            this._startat = startat;\n            this._prevlen = -1;\n            this._matches = [];\n        },\n\n        getCount: function () {\n            if (!this._done) {\n                this._getMatch(0x7FFFFFFF);\n            }\n\n            return this._matches.length;\n        },\n\n        getSyncRoot: function () {\n            return this;\n        },\n\n        getIsSynchronized: function () {\n            return false;\n        },\n\n        getIsReadOnly: function () {\n            return true;\n        },\n\n        get: function (i) {\n            var match = this._getMatch(i);\n\n            if (match == null) {\n                throw new System.ArgumentOutOfRangeException(\"i\");\n            }\n\n            return match;\n        },\n\n        copyTo: function (array, arrayIndex) {\n            if (array == null) {\n                throw new System.ArgumentNullException(\"array\");\n            }\n\n            var count = this.getCount();\n\n            if (array.length < arrayIndex + count) {\n                throw new System.IndexOutOfRangeException();\n            }\n\n            var match;\n            var i;\n            var j;\n\n            for (i = arrayIndex, j = 0; j < count; i++, j++) {\n                match = this._getMatch(j);\n                System.Array.set(array, match, [i]);\n            }\n        },\n\n        getEnumerator: function () {\n            return new System.Text.RegularExpressions.MatchEnumerator(this);\n        },\n\n        _getMatch: function (i) {\n            if (i < 0) {\n                return null;\n            }\n\n            if (this._matches.length > i) {\n                return this._matches[i];\n            }\n\n            if (this._done) {\n                return null;\n            }\n\n            var match;\n\n            do {\n                match = this._regex._runner.run(false, this._prevLen, this._input, this._beginning, this._length, this._startat);\n                if (!match.getSuccess()) {\n                    this._done = true;\n                    return null;\n                }\n\n                this._matches.push(match);\n\n                this._prevLen = match._length;\n                this._startat = match._textpos;\n            } while (this._matches.length <= i);\n\n            return match;\n        }\n    });\n\n    Bridge.define(\"System.Text.RegularExpressions.MatchEnumerator\", {\n        inherits: function () {\n            return [System.Collections.IEnumerator];\n        },\n\n        config: {\n\t\t\tproperties: {\n\t\t\t\tCurrent: {\n\t\t\t\t\tget: function () {\n\t\t\t\t\t\treturn this.getCurrent();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\t\n            alias: [\n                \"getCurrent\", \"System$Collections$IEnumerator$getCurrent\",\n                \"moveNext\", \"System$Collections$IEnumerator$moveNext\",\n                \"reset\", \"System$Collections$IEnumerator$reset\",\n\t\t\t\t\"Current\", \"System$Collections$IEnumerator$Current\"\n            ]\n        },\n\n        _matchcoll: null,\n        _match: null,\n        _curindex: 0,\n        _done: false,\n\n        ctor: function (matchColl) {\n            this.$initialize();\n            this._matchcoll = matchColl;\n        },\n\n        moveNext: function () {\n            if (this._done) {\n                return false;\n            }\n\n            this._match = this._matchcoll._getMatch(this._curindex);\n            this._curindex++;\n\n            if (this._match == null) {\n                this._done = true;\n\n                return false;\n            }\n\n            return true;\n        },\n\n        getCurrent: function () {\n            if (this._match == null) {\n                throw new System.InvalidOperationException(\"Enumeration has either not started or has already finished.\");\n            }\n\n            return this._match;\n        },\n\n        reset: function () {\n            this._curindex = 0;\n            this._done = false;\n            this._match = null;\n        }\n    });\n\n    // @source RegexOptions.js\n\n    Bridge.define(\"System.Text.RegularExpressions.RegexOptions\", {\n        statics: {\n            None: 0x0000,\n            IgnoreCase: 0x0001,\n            Multiline: 0x0002,\n            ExplicitCapture: 0x0004,\n            Compiled: 0x0008,\n            Singleline: 0x0010,\n            IgnorePatternWhitespace: 0x0020,\n            RightToLeft: 0x0040,\n            ECMAScript: 0x0100,\n            CultureInvariant: 0x0200\n        },\n\n        $kind: \"enum\",\n        $flags: true\n    });\n\n    // @source RegexRunner.js\n\n    Bridge.define(\"System.Text.RegularExpressions.RegexRunner\", {\n        statics: {},\n\n        _runregex: null,\n        _netEngine: null,\n\n        _runtext: \"\", // text to search\n        _runtextpos: 0, // current position in text\n\n        _runtextbeg: 0, // beginning of text to search\n        _runtextend: 0, // end of text to search\n        _runtextstart: 0, // starting point for search\n        _quick: false, // true value means IsMatch method call\n        _prevlen: 0,\n\n        ctor: function (regex) {\n            this.$initialize();\n            if (regex == null) {\n                throw new System.ArgumentNullException(\"regex\");\n            }\n\n            this._runregex = regex;\n\n            var options = regex.getOptions();\n            var optionsEnum = System.Text.RegularExpressions.RegexOptions;\n\n            var isCaseInsensitive = (options & optionsEnum.IgnoreCase) === optionsEnum.IgnoreCase;\n            var isMultiline = (options & optionsEnum.Multiline) === optionsEnum.Multiline;\n            var isSingleline = (options & optionsEnum.Singleline) === optionsEnum.Singleline;\n            var isIgnoreWhitespace = (options & optionsEnum.IgnorePatternWhitespace) === optionsEnum.IgnorePatternWhitespace;\n            var isExplicitCapture = (options & optionsEnum.ExplicitCapture) === optionsEnum.ExplicitCapture;\n\n            var timeoutMs = regex._matchTimeout.getTotalMilliseconds();\n\n            this._netEngine = new System.Text.RegularExpressions.RegexEngine(regex._pattern, isCaseInsensitive, isMultiline, isSingleline, isIgnoreWhitespace, isExplicitCapture, timeoutMs);\n        },\n\n        run: function (quick, prevlen, input, beginning, length, startat) {\n            if (startat < 0 || startat > input.Length) {\n                throw new System.ArgumentOutOfRangeException(\"start\", \"Start index cannot be less than 0 or greater than input length.\");\n            }\n\n            if (length < 0 || length > input.Length) {\n                throw new ArgumentOutOfRangeException(\"length\", \"Length cannot be less than 0 or exceed input length.\");\n            }\n\n            this._runtext = input;\n            this._runtextbeg = beginning;\n            this._runtextend = beginning + length;\n            this._runtextstart = startat;\n            this._quick = quick;\n            this._prevlen = prevlen;\n\n            var stoppos;\n            var bump;\n\n            if (this._runregex.getRightToLeft()) {\n                stoppos = this._runtextbeg;\n                bump = -1;\n            } else {\n                stoppos = this._runtextend;\n                bump = 1;\n            }\n\n            if (this._prevlen === 0) {\n                if (this._runtextstart === stoppos) {\n                    return System.Text.RegularExpressions.Match.getEmpty();\n                }\n\n                this._runtextstart += bump;\n            }\n\n            // Execute Regex:\n            var jsMatch = this._netEngine.match(this._runtext, this._runtextstart);\n\n            // Convert the results:\n            var result = this._convertNetEngineResults(jsMatch);\n            return result;\n        },\n\n        parsePattern: function () {\n            var result = this._netEngine.parsePattern();\n            return result;\n        },\n\n        _convertNetEngineResults: function (jsMatch) {\n            if (jsMatch.success && this._quick) {\n                return null; // in quick mode, a successful match returns null\n            }\n\n            if (!jsMatch.success) {\n                return System.Text.RegularExpressions.Match.getEmpty();\n            }\n\n            var patternInfo = this.parsePattern();\n            var match;\n\n            if (patternInfo.sparseSettings.isSparse) {\n                match = new System.Text.RegularExpressions.MatchSparse(this._runregex, patternInfo.sparseSettings.sparseSlotMap, jsMatch.groups.length, this._runtext, 0, this._runtext.length, this._runtextstart);\n            } else {\n                match = new System.Text.RegularExpressions.Match(this._runregex, jsMatch.groups.length, this._runtext, 0, this._runtext.length, this._runtextstart);\n            }\n\n            var jsGroup;\n            var jsCapture;\n            var grOrder;\n            var i;\n            var j;\n\n            for (i = 0; i < jsMatch.groups.length; i++) {\n                jsGroup = jsMatch.groups[i];\n\n                // Paste group index/length according to group ordering:\n                grOrder = 0;\n                if (jsGroup.descriptor != null) {\n                    grOrder = this._runregex.groupNumberFromName(jsGroup.descriptor.name);\n                }\n\n                for (j = 0; j < jsGroup.captures.length; j++) {\n                    jsCapture = jsGroup.captures[j];\n                    match._addMatch(grOrder, jsCapture.capIndex, jsCapture.capLength);\n                }\n            }\n\n            var textEndPos = jsMatch.capIndex + jsMatch.capLength;\n            match._tidy(textEndPos);\n\n            return match;\n        }\n    });\n\n    // @source RegexParser.js\n\nBridge.define(\"System.Text.RegularExpressions.RegexParser\", {\n    statics: {\n        _Q: 5, // quantifier\n        _S: 4, // ordinary stoppper\n        _Z: 3, // ScanBlank stopper\n        _X: 2, // whitespace\n        _E: 1, // should be escaped\n\n        _category: [\n            //0 1 2  3  4  5  6  7  8  9  A  B  C  D  E  F  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            //! \" #  $  %  &  '  (  )  *  +  ,  -  .  /  0  1  2  3  4  5  6  7  8  9  :  ;  <  =  >  ?\n            2, 0, 0, 3, 4, 0, 0, 0, 4, 4, 5, 5, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5,\n            //@ A B  C  D  E  F  G  H  I  J  K  L  M  N  O  P  Q  R  S  T  U  V  W  X  Y  Z  [  \\  ]  ^  _\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 4, 0,\n            //' a b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  {  |  }  ~\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 4, 0, 0, 0\n        ],\n\n        escape: function (input) {\n            var sb;\n            var ch;\n            var lastpos;\n            var i;\n\n            for (i = 0; i < input.length; i++) {\n                if (System.Text.RegularExpressions.RegexParser._isMetachar(input[i])) {\n                    sb = \"\";\n                    ch = input[i];\n\n                    sb += input.slice(0, i);\n\n                    do {\n                        sb += \"\\\\\";\n\n                        switch (ch) {\n                            case \"\\n\":\n                                ch = \"n\";\n                                break;\n                            case \"\\r\":\n                                ch = \"r\";\n                                break;\n                            case \"\\t\":\n                                ch = \"t\";\n                                break;\n                            case \"\\f\":\n                                ch = \"f\";\n                                break;\n                        }\n\n                        sb += ch;\n                        i++;\n                        lastpos = i;\n\n                        while (i < input.length) {\n                            ch = input[i];\n\n                            if (System.Text.RegularExpressions.RegexParser._isMetachar(ch)) {\n                                break;\n                            }\n\n                            i++;\n                        }\n\n                        sb += input.slice(lastpos, i);\n                    } while (i < input.length);\n\n                    return sb;\n                }\n            }\n\n            return input;\n        },\n\n        unescape: function (input) {\n            var culture = System.Globalization.CultureInfo.invariantCulture;\n            var sb;\n            var lastpos;\n            var i;\n            var p;\n\n            for (i = 0; i < input.length; i++) {\n                if (input[i] === \"\\\\\") {\n                    sb = \"\";\n                    p = new System.Text.RegularExpressions.RegexParser(culture);\n                    p._setPattern(input);\n\n                    sb += input.slice(0, i);\n\n                    do {\n                        i++;\n\n                        p._textto(i);\n\n                        if (i < input.length) {\n                            sb += p._scanCharEscape();\n                        }\n\n                        i = p._textpos();\n                        lastpos = i;\n\n                        while (i < input.length && input[i] !== \"\\\\\") {\n                            i++;\n                        }\n\n                        sb += input.slice(lastpos, i);\n                    } while (i < input.length);\n\n                    return sb;\n                }\n            }\n\n            return input;\n        },\n\n        parseReplacement: function (rep, caps, capsize, capnames, op) {\n            var culture = System.Globalization.CultureInfo.getCurrentCulture(); // TODO: InvariantCulture\n            var p = new System.Text.RegularExpressions.RegexParser(culture);\n\n            p._options = op;\n            p._noteCaptures(caps, capsize, capnames);\n            p._setPattern(rep);\n\n            var root = p._scanReplacement();\n\n            return new System.Text.RegularExpressions.RegexReplacement(rep, root, caps);\n        },\n\n        _isMetachar: function (ch) {\n            var code = ch.charCodeAt(0);\n\n            return (code <= \"|\".charCodeAt(0) && System.Text.RegularExpressions.RegexParser._category[code] >= System.Text.RegularExpressions.RegexParser._E);\n        }\n    },\n\n    _caps: null,\n    _capsize: 0,\n    _capnames: null,\n    _pattern: \"\",\n    _currentPos: 0,\n    _concatenation: null,\n    _culture: null,\n\n    config: {\n        init: function () {\n            this._options = System.Text.RegularExpressions.RegexOptions.None;\n        }\n    },\n\n    ctor: function (culture) {\n\t\tthis.$initialize();\n        this._culture = culture;\n        this._caps = {};\n    },\n\n    _noteCaptures: function (caps, capsize, capnames) {\n        this._caps = caps;\n        this._capsize = capsize;\n        this._capnames = capnames;\n    },\n\n    _setPattern: function (pattern) {\n        if (pattern == null) {\n            pattern = \"\";\n        }\n\n        this._pattern = pattern || \"\";\n        this._currentPos = 0;\n    },\n\n    _scanReplacement: function () {\n        this._concatenation = new System.Text.RegularExpressions.RegexNode(System.Text.RegularExpressions.RegexNode.Concatenate, this._options);\n        var c;\n        var startpos;\n        var dollarNode;\n\n        while (true) {\n            c = this._charsRight();\n            if (c === 0) {\n                break;\n            }\n\n            startpos = this._textpos();\n            while (c > 0 && this._rightChar() !== \"$\") {\n                this._moveRight();\n                c--;\n            }\n\n            this._addConcatenate(startpos, this._textpos() - startpos);\n\n            if (c > 0) {\n                if (this._moveRightGetChar() === \"$\") {\n                    dollarNode = this._scanDollar();\n                    this._concatenation.addChild(dollarNode);\n                }\n            }\n        }\n\n        return this._concatenation;\n    },\n\n    _addConcatenate: function (pos, cch /*, bool isReplacement*/ ) {\n        if (cch === 0) {\n            return;\n        }\n\n        var node;\n\n        if (cch > 1) {\n            var str = this._pattern.slice(pos, pos + cch);\n\n            node = new System.Text.RegularExpressions.RegexNode(System.Text.RegularExpressions.RegexNode.Multi, this._options, str);\n        } else {\n            var ch = this._pattern[pos];\n\n            node = new System.Text.RegularExpressions.RegexNode(System.Text.RegularExpressions.RegexNode.One, this._options, ch);\n        }\n\n        this._concatenation.addChild(node);\n    },\n\n    _useOptionE: function () {\n        return (this._options & System.Text.RegularExpressions.RegexOptions.ECMAScript) !== 0;\n    },\n\n    _makeException: function (message) {\n        return new System.ArgumentException(\"Incorrect pattern. \" + message);\n    },\n\n    _scanDollar: function () {\n        var maxValueDiv10 = 214748364; // Int32.MaxValue / 10;\n        var maxValueMod10 = 7; // Int32.MaxValue % 10;\n\n        if (this._charsRight() === 0) {\n            return new System.Text.RegularExpressions.RegexNode(System.Text.RegularExpressions.RegexNode.One, this._options, \"$\");\n        }\n\n        var ch = this._rightChar();\n        var angled;\n        var backpos = this._textpos();\n        var lastEndPos = backpos;\n\n        // Note angle\n        if (ch === \"{\" && this._charsRight() > 1) {\n            angled = true;\n            this._moveRight();\n            ch = this._rightChar();\n        } else {\n            angled = false;\n        }\n\n        // Try to parse backreference: \\1 or \\{1} or \\{cap}\n\n        var capnum;\n        var digit;\n\n        if (ch >= \"0\" && ch <= \"9\") {\n            if (!angled && this._useOptionE()) {\n                capnum = -1;\n                var newcapnum = ch - \"0\";\n\n                this._moveRight();\n\n                if (this._isCaptureSlot(newcapnum)) {\n                    capnum = newcapnum;\n                    lastEndPos = this._textpos();\n                }\n\n                while (this._charsRight() > 0 && (ch = this._rightChar()) >= \"0\" && ch <= \"9\") {\n                    digit = ch - \"0\";\n                    if (newcapnum > (maxValueDiv10) || (newcapnum === (maxValueDiv10) && digit > (maxValueMod10))) {\n                        throw this._makeException(\"Capture group is out of range.\");\n                    }\n\n                    newcapnum = newcapnum * 10 + digit;\n\n                    this._moveRight();\n\n                    if (this._isCaptureSlot(newcapnum)) {\n                        capnum = newcapnum;\n                        lastEndPos = this._textpos();\n                    }\n                }\n                this._textto(lastEndPos);\n\n                if (capnum >= 0) {\n                    return new System.Text.RegularExpressions.RegexNode(System.Text.RegularExpressions.RegexNode.Ref, this._options, capnum);\n                }\n            } else {\n                capnum = this._scanDecimal();\n                if (!angled || this._charsRight() > 0 && this._moveRightGetChar() === \"}\") {\n                    if (this._isCaptureSlot(capnum)) {\n                        return new System.Text.RegularExpressions.RegexNode(System.Text.RegularExpressions.RegexNode.Ref, this._options, capnum);\n                    }\n                }\n            }\n        } else if (angled && this._isWordChar(ch)) {\n            var capname = this._scanCapname();\n\n            if (this._charsRight() > 0 && this._moveRightGetChar() === \"}\") {\n                if (this._isCaptureName(capname)) {\n                    var captureSlot = this._captureSlotFromName(capname);\n\n                    return new System.Text.RegularExpressions.RegexNode(System.Text.RegularExpressions.RegexNode.Ref, this._options, captureSlot);\n                }\n            }\n        } else if (!angled) {\n            capnum = 1;\n\n            switch (ch) {\n                case \"$\":\n                    this._moveRight();\n                    return new System.Text.RegularExpressions.RegexNode(System.Text.RegularExpressions.RegexNode.One, this._options, \"$\");\n\n                case \"&\":\n                    capnum = 0;\n                    break;\n\n                case \"`\":\n                    capnum = System.Text.RegularExpressions.RegexReplacement.LeftPortion;\n                    break;\n\n                case \"\\'\":\n                    capnum = System.Text.RegularExpressions.RegexReplacement.RightPortion;\n                    break;\n\n                case \"+\":\n                    capnum = System.Text.RegularExpressions.RegexReplacement.LastGroup;\n                    break;\n\n                case \"_\":\n                    capnum = System.Text.RegularExpressions.RegexReplacement.WholeString;\n                    break;\n            }\n\n            if (capnum !== 1) {\n                this._moveRight();\n\n                return new System.Text.RegularExpressions.RegexNode(System.Text.RegularExpressions.RegexNode.Ref, this._options, capnum);\n            }\n        }\n\n        // unrecognized $: literalize\n\n        this._textto(backpos);\n\n        return new System.Text.RegularExpressions.RegexNode(System.Text.RegularExpressions.RegexNode.One, this._options, \"$\");\n    },\n\n    _scanDecimal: function () {\n        // Scans any number of decimal digits (pegs value at 2^31-1 if too large)\n\n        var maxValueDiv10 = 214748364; // Int32.MaxValue / 10;\n        var maxValueMod10 = 7; // Int32.MaxValue % 10;\n        var i = 0;\n        var ch;\n        var d;\n\n        while (this._charsRight() > 0) {\n            ch = this._rightChar();\n            if (ch < \"0\" || ch > \"9\") {\n                break;\n            }\n\n            d = ch - \"0\";\n\n            this._moveRight();\n\n            if (i > (maxValueDiv10) || (i === (maxValueDiv10) && d > (maxValueMod10))) {\n                throw this._makeException(\"Capture group is out of range.\");\n            }\n\n            i *= 10;\n            i += d;\n        }\n\n        return i;\n    },\n\n    _scanOctal: function () {\n        var d;\n        var i;\n        var c;\n\n        // Consume octal chars only up to 3 digits and value 0377\n\n        c = 3;\n\n        if (c > this._charsRight()) {\n            c = this._charsRight();\n        }\n\n        for (i = 0; c > 0 && (d = this._rightChar() - \"0\") <= 7; c -= 1) {\n            this._moveRight();\n\n            i *= 8;\n            i += d;\n\n            if (this._useOptionE() && i >= 0x20) {\n                break;\n            }\n        }\n\n        // Octal codes only go up to 255.  Any larger and the behavior that Perl follows\n        // is simply to truncate the high bits.\n        i &= 0xFF;\n\n        return String.fromCharCode(i);\n    },\n\n    _scanHex: function (c) {\n        var i;\n        var d;\n\n        i = 0;\n\n        if (this._charsRight() >= c) {\n            for (; c > 0 && ((d = this._hexDigit(this._moveRightGetChar())) >= 0); c -= 1) {\n                i *= 0x10;\n                i += d;\n            }\n        }\n\n        if (c > 0) {\n            throw this._makeException(\"Insufficient hexadecimal digits.\");\n        }\n\n        return i;\n    },\n\n    _hexDigit: function (ch) {\n        var d;\n\n        var code = ch.charCodeAt(0);\n\n        if ((d = code - \"0\".charCodeAt(0)) <= 9) {\n            return d;\n        }\n\n        if ((d = code - \"a\".charCodeAt(0)) <= 5) {\n            return d + 0xa;\n        }\n\n        if ((d = code - \"A\".charCodeAt(0)) <= 5) {\n            return d + 0xa;\n        }\n\n        return -1;\n    },\n\n    _scanControl: function () {\n        if (this._charsRight() <= 0) {\n            throw this._makeException(\"Missing control character.\");\n        }\n\n        var ch = this._moveRightGetChar();\n\n        // \\ca interpreted as \\cA\n\n        var code = ch.charCodeAt(0);\n\n        if (code >= \"a\".charCodeAt(0) && code <= \"z\".charCodeAt(0)) {\n            code = code - (\"a\".charCodeAt(0) - \"A\".charCodeAt(0));\n        }\n\n        if ((code = (code - \"@\".charCodeAt(0))) < \" \".charCodeAt(0)) {\n            return String.fromCharCode(code);\n        }\n\n        throw this._makeException(\"Unrecognized control character.\");\n    },\n\n    _scanCapname: function () {\n        var startpos = this._textpos();\n\n        while (this._charsRight() > 0) {\n            if (!this._isWordChar(this._moveRightGetChar())) {\n                this._moveLeft();\n\n                break;\n            }\n        }\n\n        return _pattern.slice(startpos, this._textpos());\n    },\n\n    _scanCharEscape: function () {\n        var ch = this._moveRightGetChar();\n\n        if (ch >= \"0\" && ch <= \"7\") {\n            this._moveLeft();\n\n            return this._scanOctal();\n        }\n\n        switch (ch) {\n            case \"x\":\n                return this._scanHex(2);\n            case \"u\":\n                return this._scanHex(4);\n            case \"a\":\n                return \"\\u0007\";\n            case \"b\":\n                return \"\\b\";\n            case \"e\":\n                return \"\\u001B\";\n            case \"f\":\n                return \"\\f\";\n            case \"n\":\n                return \"\\n\";\n            case \"r\":\n                return \"\\r\";\n            case \"t\":\n                return \"\\t\";\n            case \"v\":\n                return \"\\u000B\";\n            case \"c\":\n                return this._scanControl();\n            default:\n                var isInvalidBasicLatin = ch === '8' || ch === '9' || ch === '_';\n                if (isInvalidBasicLatin || (!this._useOptionE() && this._isWordChar(ch))) {\n                    throw this._makeException(\"Unrecognized escape sequence \\\\\" + ch + \".\");\n                }\n                return ch;\n        }\n    },\n\n    _captureSlotFromName: function (capname) {\n        return this._capnames[capname];\n    },\n\n    _isCaptureSlot: function (i) {\n        if (this._caps != null) {\n            return this._caps[i] != null;\n        }\n\n        return (i >= 0 && i < this._capsize);\n    },\n\n    _isCaptureName: function (capname) {\n        if (this._capnames == null) {\n            return false;\n        }\n\n        return _capnames[capname] != null;\n    },\n\n    _isWordChar: function (ch) {\n        // Partial implementation,\n        // see the link for more details (http://referencesource.microsoft.com/#System/regex/system/text/regularexpressions/RegexParser.cs,1156)\n        return System.Char.isLetter(ch.charCodeAt(0));\n    },\n\n    _charsRight: function () {\n        return this._pattern.length - this._currentPos;\n    },\n\n    _rightChar: function () {\n        return this._pattern[this._currentPos];\n    },\n\n    _moveRightGetChar: function () {\n        return this._pattern[this._currentPos++];\n    },\n\n    _moveRight: function () {\n        this._currentPos++;\n    },\n\n    _textpos: function () {\n        return this._currentPos;\n    },\n\n    _textto: function (pos) {\n        this._currentPos = pos;\n    },\n\n    _moveLeft: function () {\n        this._currentPos--;\n    }\n});\n\n    // @source RegexNode.js\n\n    Bridge.define(\"System.Text.RegularExpressions.RegexNode\", {\n        statics: {\n            One: 9, // char     a\n            Multi: 12, // string   abcdef\n            Ref: 13, // index    \\1\n            Empty: 23, //          ()\n            Concatenate: 25 //          ab\n        },\n\n        _type: 0,\n        _str: null,\n        _children: null,\n        _next: null,\n        _m: 0,\n\n        config: {\n            init: function () {\n                this._options = System.Text.RegularExpressions.RegexOptions.None;\n            }\n        },\n\n        ctor: function (type, options, arg) {\n            this.$initialize();\n            this._type = type;\n            this._options = options;\n\n            if (type === System.Text.RegularExpressions.RegexNode.Ref) {\n                this._m = arg;\n            } else {\n                this._str = arg || null;\n            }\n        },\n\n        addChild: function (newChild) {\n            if (this._children == null) {\n                this._children = [];\n            }\n\n            var reducedChild = newChild._reduce();\n            this._children.push(reducedChild);\n            reducedChild._next = this;\n        },\n\n        childCount: function () {\n            return this._children == null ? 0 : this._children.length;\n        },\n\n        child: function (i) {\n            return this._children[i];\n        },\n\n        _reduce: function () {\n            // Warning: current implementation is just partial (for Replacement servicing)\n\n            var n;\n\n            switch (this._type) {\n                case System.Text.RegularExpressions.RegexNode.Concatenate:\n                    n = this._reduceConcatenation();\n                    break;\n\n                default:\n                    n = this;\n                    break;\n            }\n\n            return n;\n        },\n\n        _reduceConcatenation: function () {\n            var wasLastString = false;\n            var optionsLast = 0;\n            var optionsAt;\n            var at;\n            var prev;\n            var i;\n            var j;\n            var k;\n\n            if (this._children == null) {\n                return new System.Text.RegularExpressions.RegexNode(System.Text.RegularExpressions.RegexNode.Empty, this._options);\n            }\n\n            for (i = 0, j = 0; i < this._children.length; i++, j++) {\n                at = this._children[i];\n\n                if (j < i) {\n                    this._children[j] = at;\n                }\n\n                if (at._type === System.Text.RegularExpressions.RegexNode.Concatenate && at._isRightToLeft()) {\n                    for (k = 0; k < at._children.length; k++) {\n                        at._children[k]._next = this;\n                    }\n\n                    this._children.splice.apply(this._children, [i + 1, 0].concat(at._children)); // _children.InsertRange(i + 1, at._children);\n                    j--;\n                } else if (at._type === System.Text.RegularExpressions.RegexNode.Multi || at._type === System.Text.RegularExpressions.RegexNode.One) {\n                    // Cannot merge strings if L or I options differ\n                    optionsAt = at._options & (System.Text.RegularExpressions.RegexOptions.RightToLeft | System.Text.RegularExpressions.RegexOptions.IgnoreCase);\n\n                    if (!wasLastString || optionsLast !== optionsAt) {\n                        wasLastString = true;\n                        optionsLast = optionsAt;\n                        continue;\n                    }\n\n                    prev = this._children[--j];\n\n                    if (prev._type === System.Text.RegularExpressions.RegexNode.One) {\n                        prev._type = System.Text.RegularExpressions.RegexNode.Multi;\n                        prev._str = prev._str;\n                    }\n\n                    if ((optionsAt & System.Text.RegularExpressions.RegexOptions.RightToLeft) === 0) {\n                        prev._str += at._str;\n                    } else {\n                        prev._str = at._str + prev._str;\n                    }\n                } else if (at._type === System.Text.RegularExpressions.RegexNode.Empty) {\n                    j--;\n                } else {\n                    wasLastString = false;\n                }\n            }\n\n            if (j < i) {\n                this._children.splice(j, i - j);\n            }\n\n            return this._stripEnation(System.Text.RegularExpressions.RegexNode.Empty);\n        },\n\n        _stripEnation: function (emptyType) {\n            switch (this.childCount()) {\n                case 0:\n                    return new scope.RegexNode(emptyType, this._options);\n                case 1:\n                    return this.child(0);\n                default:\n                    return this;\n            }\n        },\n\n        _isRightToLeft: function () {\n            if ((this._options & System.Text.RegularExpressions.RegexOptions.RightToLeft) > 0) {\n                return true;\n            }\n\n            return false;\n        },\n    });\n\n    // @source RegexReplacement.js\n\n    Bridge.define(\"System.Text.RegularExpressions.RegexReplacement\", {\n        statics: {\n            replace: function (evaluator, regex, input, count, startat) {\n                if (evaluator == null) {\n                    throw new System.ArgumentNullException(\"evaluator\");\n                }\n\n                if (count < -1) {\n                    throw new System.ArgumentOutOfRangeException(\"count\", \"Count cannot be less than -1.\");\n                }\n\n                if (startat < 0 || startat > input.length) {\n                    throw new System.ArgumentOutOfRangeException(\"startat\", \"Start index cannot be less than 0 or greater than input length.\");\n                }\n\n                if (count === 0) {\n                    return input;\n                }\n\n                var match = regex.match(input, startat);\n\n                if (!match.getSuccess()) {\n                    return input;\n                } else {\n                    var sb = \"\";\n                    var prevat;\n                    var matchIndex;\n                    var matchLength;\n\n                    if (!regex.getRightToLeft()) {\n                        prevat = 0;\n\n                        do {\n                            matchIndex = match.getIndex();\n                            matchLength = match.getLength();\n\n                            if (matchIndex !== prevat) {\n                                sb += input.slice(prevat, matchIndex);\n                            }\n\n                            prevat = matchIndex + matchLength;\n                            sb += evaluator(match);\n\n                            if (--count === 0) {\n                                break;\n                            }\n\n                            match = match.nextMatch();\n                        } while (match.getSuccess());\n\n                        if (prevat < input.length) {\n                            sb += input.slice(prevat, input.length);\n                        }\n                    } else {\n                        var al = [];\n\n                        prevat = input.length;\n\n                        do {\n                            matchIndex = match.getIndex();\n                            matchLength = match.getLength();\n\n                            if (matchIndex + matchLength !== prevat) {\n                                al.push(input.slice(matchIndex + matchLength, prevat));\n                            }\n\n                            prevat = matchIndex;\n                            al.push(evaluator(match));\n\n                            if (--count === 0) {\n                                break;\n                            }\n\n                            match = match.nextMatch();\n                        } while (match.getSuccess());\n\n                        sb = new StringBuilder();\n\n                        if (prevat > 0) {\n                            sb += sb.slice(0, prevat);\n                        }\n\n                        var i;\n                        for (i = al.length - 1; i >= 0; i--) {\n                            sb += al[i];\n                        }\n                    }\n\n                    return sb;\n                }\n            },\n\n            split: function (regex, input, count, startat) {\n                if (count < 0) {\n                    throw new System.ArgumentOutOfRangeException(\"count\", \"Count can't be less than 0.\");\n                }\n\n                if (startat < 0 || startat > input.length) {\n                    throw new System.ArgumentOutOfRangeException(\"startat\", \"Start index cannot be less than 0 or greater than input length.\");\n                }\n\n                var result = [];\n\n                if (count === 1) {\n                    result.push(input);\n\n                    return result;\n                }\n\n                --count;\n                var match = regex.match(input, startat);\n\n                if (!match.getSuccess()) {\n                    result.push(input);\n                } else {\n                    var i;\n                    var prevat;\n                    var matchIndex;\n                    var matchLength;\n                    var matchGroups;\n                    var matchGroupsCount;\n\n                    if (!regex.getRightToLeft()) {\n                        prevat = 0;\n\n                        for (;;) {\n                            matchIndex = match.getIndex();\n                            matchLength = match.getLength();\n                            matchGroups = match.getGroups();\n                            matchGroupsCount = matchGroups.getCount();\n\n                            result.push(input.slice(prevat, matchIndex));\n                            prevat = matchIndex + matchLength;\n\n                            // add all matched capture groups to the list.\n                            for (i = 1; i < matchGroupsCount; i++) {\n                                if (match._isMatched(i)) {\n                                    result.push(matchGroups.get(i).toString());\n                                }\n                            }\n\n                            --count;\n                            if (count === 0) {\n                                break;\n                            }\n\n                            match = match.nextMatch();\n\n                            if (!match.getSuccess()) {\n                                break;\n                            }\n                        }\n\n                        result.push(input.slice(prevat, input.length));\n                    } else {\n                        prevat = input.length;\n\n                        for (;;) {\n                            matchIndex = match.getIndex();\n                            matchLength = match.getLength();\n                            matchGroups = match.getGroups();\n                            matchGroupsCount = matchGroups.getCount();\n\n                            result.push(input.slice(matchIndex + matchLength, prevat));\n                            prevat = matchIndex;\n\n                            // add all matched capture groups to the list.\n                            for (i = 1; i < matchGroupsCount; i++) {\n                                if (match._isMatched(i)) {\n                                    result.push(matchGroups.get(i).toString());\n                                }\n                            }\n\n                            --count;\n                            if (count === 0) {\n                                break;\n                            }\n\n                            match = match.nextMatch();\n                            if (!match.getSuccess()) {\n                                break;\n                            }\n                        }\n\n                        result.push(input.slice(0, prevat));\n                        result.reverse();\n                    }\n                }\n\n                return result;\n            },\n\n            Specials: 4,\n            LeftPortion: -1,\n            RightPortion: -2,\n            LastGroup: -3,\n            WholeString: -4\n        },\n\n        _rep: \"\",\n        _strings: [], // table of string constants\n        _rules: [], // negative -> group #, positive -> string #\n\n        ctor: function (rep, concat, caps) {\n            this.$initialize();\n            this._rep = rep;\n\n            if (concat._type !== System.Text.RegularExpressions.RegexNode.Concatenate) {\n                throw new System.ArgumentException(\"Replacement error.\");\n            }\n\n            var sb = \"\";\n            var strings = [];\n            var rules = [];\n            var slot;\n            var child;\n            var i;\n\n            for (i = 0; i < concat.childCount(); i++) {\n                child = concat.child(i);\n\n                switch (child._type) {\n                    case System.Text.RegularExpressions.RegexNode.Multi:\n                    case System.Text.RegularExpressions.RegexNode.One:\n                        sb += child._str;\n                        break;\n\n                    case System.Text.RegularExpressions.RegexNode.Ref:\n                        if (sb.length > 0) {\n                            rules.push(strings.length);\n                            strings.push(sb);\n                            sb = \"\";\n                        }\n\n                        slot = child._m;\n\n                        if (caps != null && slot >= 0) {\n                            slot = caps[slot];\n                        }\n\n                        rules.push(-System.Text.RegularExpressions.RegexReplacement.Specials - 1 - slot);\n                        break;\n                    default:\n                        throw new System.ArgumentException(\"Replacement error.\");\n                }\n            }\n\n            if (sb.length > 0) {\n                rules.push(strings.length);\n                strings.push(sb);\n            }\n\n            this._strings = strings;\n            this._rules = rules;\n        },\n\n        getPattern: function () {\n            return _rep;\n        },\n\n        replacement: function (match) {\n            return this._replacementImpl(\"\", match);\n        },\n\n        replace: function (regex, input, count, startat) {\n            if (count < -1) {\n                throw new System.ArgumentOutOfRangeException(\"count\", \"Count cannot be less than -1.\");\n            }\n            if (startat < 0 || startat > input.length) {\n                throw new System.ArgumentOutOfRangeException(\"startat\", \"Start index cannot be less than 0 or greater than input length.\");\n            }\n\n            if (count === 0) {\n                return input;\n            }\n\n            var match = regex.match(input, startat);\n\n            if (!match.getSuccess()) {\n                return input;\n            } else {\n                var sb = \"\";\n                var prevat;\n                var matchIndex;\n                var matchLength;\n\n                if (!regex.getRightToLeft()) {\n                    prevat = 0;\n\n                    do {\n                        matchIndex = match.getIndex();\n                        matchLength = match.getLength();\n\n                        if (matchIndex !== prevat) {\n                            sb += input.slice(prevat, matchIndex);\n                        }\n\n                        prevat = matchIndex + matchLength;\n                        sb = this._replacementImpl(sb, match);\n\n                        if (--count === 0) {\n                            break;\n                        }\n\n                        match = match.nextMatch();\n                    } while (match.getSuccess());\n\n                    if (prevat < input.length) {\n                        sb += input.slice(prevat, input.length);\n                    }\n                } else {\n                    var al = [];\n                    prevat = input.length;\n\n                    do {\n                        matchIndex = match.getIndex();\n                        matchLength = match.getLength();\n\n                        if (matchIndex + matchLength !== prevat) {\n                            al.push(input.slice(matchIndex + matchLength, prevat));\n                        }\n\n                        prevat = matchIndex;\n                        this._replacementImplRTL(al, match);\n\n                        if (--count === 0) {\n                            break;\n                        }\n\n                        match = match.nextMatch();\n                    } while (match.getSuccess());\n\n                    if (prevat > 0) {\n                        sb += sb.slice(0, prevat);\n                    }\n\n                    var i;\n                    for (i = al.length - 1; i >= 0; i--) {\n                        sb += al[i];\n                    }\n                }\n\n                return sb;\n            }\n        },\n\n        _replacementImpl: function (sb, match) {\n            var specials = System.Text.RegularExpressions.RegexReplacement.Specials;\n            var r;\n            var i;\n\n            for (i = 0; i < this._rules.length; i++) {\n                r = this._rules[i];\n\n                if (r >= 0) {\n                    // string lookup\n                    sb += this._strings[r];\n                } else if (r < -specials) {\n                    // group lookup\n                    sb += match._groupToStringImpl(-specials - 1 - r);\n                } else {\n                    // special insertion patterns\n                    switch (-specials - 1 - r) {\n                        case System.Text.RegularExpressions.RegexReplacement.LeftPortion:\n                            sb += match._getLeftSubstring();\n                            break;\n                        case System.Text.RegularExpressions.RegexReplacement.RightPortion:\n                            sb += match._getRightSubstring();\n                            break;\n                        case System.Text.RegularExpressions.RegexReplacement.LastGroup:\n                            sb += match._lastGroupToStringImpl();\n                            break;\n                        case System.Text.RegularExpressions.RegexReplacement.WholeString:\n                            sb += match._getOriginalString();\n                            break;\n                    }\n                }\n            }\n\n            return sb;\n        },\n\n        _replacementImplRTL: function (al, match) {\n            var specials = System.Text.RegularExpressions.RegexReplacement.Specials;\n            var r;\n            var i;\n\n            for (i = _rules.length - 1; i >= 0; i--) {\n                r = this._rules[i];\n\n                if (r >= 0) {\n                    // string lookup\n                    al.push(this._strings[r]);\n                } else if (r < -specials) {\n                    // group lookup\n                    al.push(match._groupToStringImpl(-specials - 1 - r));\n                } else {\n                    // special insertion patterns\n                    switch (-specials - 1 - r) {\n                        case System.Text.RegularExpressions.RegexReplacement.LeftPortion:\n                            al.push(match._getLeftSubstring());\n                            break;\n                        case System.Text.RegularExpressions.RegexReplacement.RightPortion:\n                            al.push(match._getRightSubstring());\n                            break;\n                        case System.Text.RegularExpressions.RegexReplacement.LastGroup:\n                            al.push(match._lastGroupToStringImpl());\n                            break;\n                        case System.Text.RegularExpressions.RegexReplacement.WholeString:\n                            al.push(match._getOriginalString());\n                            break;\n                    }\n                }\n            }\n        }\n    });\n\n    // @source RegexEngine.js\n\n    Bridge.define(\"System.Text.RegularExpressions.RegexEngine\", {\n        _pattern: \"\",\n        _patternInfo: null,\n\n        _text: \"\",\n        _textStart: 0,\n        _timeoutMs: -1,\n        _timeoutTime: -1,\n        _settings: null,\n\n        _branchType: {\n            base: 0,\n            offset: 1,\n            lazy: 2,\n            greedy: 3,\n            or: 4\n        },\n\n        _branchResultKind: {\n            ok: 1,\n            endPass: 2,\n            nextPass: 3,\n            nextBranch: 4\n        },\n\n        // ============================================================================================\n        // Public functions\n        // ============================================================================================\n        ctor: function (pattern, isCaseInsensitive, isMultiLine, isSingleline, isIgnoreWhitespace, isExplicitCapture, timeoutMs) {\n            this.$initialize();\n\n            if (pattern == null) {\n                throw new System.ArgumentNullException(\"pattern\");\n            }\n\n            this._pattern = pattern;\n            this._timeoutMs = timeoutMs;\n            this._settings = {\n                ignoreCase: isCaseInsensitive,\n                multiline: isMultiLine,\n                singleline: isSingleline,\n                ignoreWhitespace: isIgnoreWhitespace,\n                explicitCapture: isExplicitCapture\n            };\n        },\n\n        match: function (text, textStart) {\n            if (text == null) {\n                throw new System.ArgumentNullException(\"text\");\n            }\n\n            if (textStart != null && (textStart < 0 || textStart > text.length)) {\n                throw new System.ArgumentOutOfRangeException(\"textStart\", \"Start index cannot be less than 0 or greater than input length.\");\n            }\n\n            this._text = text;\n            this._textStart = textStart;\n            this._timeoutTime = this._timeoutMs > 0 ? new Date().getTime() + System.Convert.toInt32(this._timeoutMs + 0.5) : -1;\n\n            // Get group descriptors\n            var patternInfo = this.parsePattern();\n            if (patternInfo.shouldFail) {\n                return this._getEmptyMatch();\n            }\n\n            this._checkTimeout();\n\n            var scanRes = this._scanAndTransformResult(textStart, patternInfo.tokens, false, null);\n            return scanRes;\n        },\n\n        parsePattern: function () {\n            if (this._patternInfo == null) {\n                var parser = System.Text.RegularExpressions.RegexEngineParser;\n                var patternInfo = parser.parsePattern(this._pattern, this._cloneSettings(this._settings));\n                this._patternInfo = patternInfo;\n            }\n            return this._patternInfo;\n        },\n\n        // ============================================================================================\n        // Engine main logic\n        // ============================================================================================\n        _scanAndTransformResult: function (textPos, tokens, noOffset, desiredLen) {\n            var state = this._scan(textPos, this._text.length, tokens, noOffset, desiredLen);\n            var transformedRes = this._collectScanResults(state, textPos);\n            return transformedRes;\n        },\n\n        _scan: function (textPos, textEndPos, tokens, noOffset, desiredLen) {\n            var resKind = this._branchResultKind;\n            var branches = [];\n            branches.grCaptureCache = {};\n\n            var branch = null;\n            var res = null;\n\n            // Empty pattern case:\n            if (tokens.length === 0) {\n                var state = new System.Text.RegularExpressions.RegexEngineState();\n                state.capIndex = textPos;\n                state.txtIndex = textPos;\n                state.capLength = 0;\n                return state;\n            }\n\n            // Init base branch:\n            var baseBranchType = noOffset ? this._branchType.base : this._branchType.offset;\n\n            var endPos = this._patternInfo.isContiguous ? textPos : textEndPos;\n            var baseBranch = new System.Text.RegularExpressions.RegexEngineBranch(baseBranchType, textPos, textPos, endPos);\n            baseBranch.pushPass(0, tokens, this._cloneSettings(this._settings));\n            baseBranch.started = true;\n            baseBranch.state.txtIndex = textPos;\n            branches.push(baseBranch);\n\n            while (branches.length) {\n                branch = branches[branches.length - 1];\n\n                res = this._scanBranch(textEndPos, branches, branch);\n                if (res === resKind.ok && (desiredLen == null || branch.state.capLength === desiredLen)) {\n                    return branch.state;\n                }\n\n                //if (!this.branchLimit) {\n                //    this.branchLimit = 1;\n                //} else {\n                //    this.branchLimit++;\n                //    if (this.branchLimit > 200000) {\n                //        alert(\"Too many branches :(\");\n                //        break;\n                //    }\n                //}\n\n                this._advanceToNextBranch(branches, branch);\n                this._checkTimeout();\n            }\n\n            return null;\n        },\n\n        _scanBranch: function (textEndPos, branches, branch) {\n            var resKind = this._branchResultKind;\n            var pass;\n            var res;\n\n            if (branch.mustFail) {\n                branch.mustFail = false;\n                return resKind.nextBranch;\n            }\n\n            while (branch.hasPass()) {\n                pass = branch.peekPass();\n\n                if (pass.tokens == null || pass.tokens.length === 0) {\n                    res = resKind.endPass;\n                } else {\n                    // Add alternation branches before scanning:\n                    if (this._addAlternationBranches(branches, branch, pass) === resKind.nextBranch) {\n                        return resKind.nextBranch;\n                    }\n\n                    // Scan:\n                    res = this._scanPass(textEndPos, branches, branch, pass);\n                }\n\n                switch (res) {\n                    case resKind.nextBranch:\n                        // Move to the next branch:\n                        return res;\n\n                    case resKind.nextPass:\n                        // switch to the recently added pass\n                        continue;\n\n                    case resKind.endPass:\n                    case resKind.ok:\n                        // End of pass has been reached:\n                        branch.popPass();\n                        break;\n\n                    default:\n                        throw new System.InvalidOperationException(\"Unexpected branch result.\");\n                }\n            }\n\n            return resKind.ok;\n        },\n\n        _scanPass: function (textEndPos, branches, branch, pass) {\n            var resKind = this._branchResultKind;\n            var passEndIndex = pass.tokens.length;\n            var token;\n            var probe;\n            var res;\n\n            while (pass.index < passEndIndex) {\n                token = pass.tokens[pass.index];\n                probe = pass.probe;\n\n                // Add probing:\n                if (probe == null) {\n                    if (this._addBranchBeforeProbing(branches, branch, pass, token)) {\n                        return resKind.nextBranch;\n                    }\n                } else {\n                    if (probe.value < probe.min || probe.forced) {\n                        res = this._scanToken(textEndPos, branches, branch, pass, token);\n                        if (res !== resKind.ok) {\n                            return res;\n                        }\n                        probe.value += 1;\n                        probe.forced = false;\n                        continue;\n                    }\n\n                    this._addBranchAfterProbing(branches, branch, pass, probe);\n                    if (probe.forced) {\n                        continue;\n                    }\n\n                    pass.probe = null;\n                    pass.index++;\n                    continue;\n                }\n\n                // Process the token:\n                res = this._scanToken(textEndPos, branches, branch, pass, token);\n\n                // Process the result of the token scan:\n                switch (res) {\n                    case resKind.nextBranch:\n                    case resKind.nextPass:\n                    case resKind.endPass:\n                        return res;\n\n                    case resKind.ok:\n                        // Advance to the next token within the current pass:\n                        pass.index++;\n                        break;\n\n                    default:\n                        throw new System.InvalidOperationException(\"Unexpected branch-pass result.\");\n                }\n            }\n\n            return resKind.ok;\n        },\n\n        _addAlternationBranches: function (branches, branch, pass) {\n            var tokenTypes = System.Text.RegularExpressions.RegexEngineParser.tokenTypes;\n            var branchTypes = this._branchType;\n            var passEndIndex = pass.tokens.length;\n            var resKind = this._branchResultKind;\n            var orIndexes;\n            var newBranch;\n            var newPass;\n            var token;\n            var i;\n\n            // Scan potential alternations:\n            if (!pass.alternationHandled && !pass.tokens.noAlternation) {\n                orIndexes = [-1];\n                for (i = 0; i < passEndIndex; i++) {\n                    token = pass.tokens[i];\n                    if (token.type === tokenTypes.alternation) {\n                        orIndexes.push(i);\n                    }\n                }\n\n                if (orIndexes.length > 1) {\n                    for (i = 0; i < orIndexes.length; i++) {\n                        newBranch = new System.Text.RegularExpressions.RegexEngineBranch(branchTypes.or, i, 0, orIndexes.length, branch.state);\n                        newBranch.isNotFailing = true;\n                        newPass = newBranch.peekPass();\n                        newPass.alternationHandled = true;\n                        newPass.index = orIndexes[i] + 1;\n                        branches.splice(branches.length - i, 0, newBranch);\n                    }\n\n                    // The last branch must fail:\n                    branches[branches.length - orIndexes.length].isNotFailing = false;\n\n                    // The parent branch must be ended up immediately:\n                    branch.mustFail = true;\n\n                    pass.alternationHandled = true;\n                    return resKind.nextBranch;\n                } else {\n                    pass.tokens.noAlternation = true;\n                }\n            }\n\n            return resKind.ok;\n        },\n\n        _addBranchBeforeProbing: function (branches, branch, pass, token) {\n            // Add +, *, ? branches:\n            var probe = this._tryGetTokenProbe(token);\n            if (probe == null) {\n                return false;\n            }\n\n            pass.probe = probe;\n\n            var branchType = probe.isLazy ? this._branchType.lazy : this._branchType.greedy;\n            var newBranch = new System.Text.RegularExpressions.RegexEngineBranch(branchType, probe.value, probe.min, probe.max, branch.state);\n            branches.push(newBranch);\n            return true;\n        },\n\n        _addBranchAfterProbing: function (branches, branch, pass, probe) {\n            if (probe.isLazy) {\n                if (probe.value + 1 <= probe.max) {\n                    var lazyBranch = branch.clone();\n                    var lazyProbe = lazyBranch.peekPass().probe;\n                    lazyBranch.value += 1;\n                    lazyProbe.forced = true;\n\n                    // add to the left from the current branch\n                    branches.splice(branches.length - 1, 0, lazyBranch);\n                    branch.isNotFailing = true;\n                }\n            } else {\n                if (probe.value + 1 <= probe.max) {\n                    var greedyBranch = branch.clone();\n                    greedyBranch.started = true;\n                    greedyBranch.peekPass().probe = null;\n                    greedyBranch.peekPass().index++;\n                    branches.splice(branches.length - 1, 0, greedyBranch);\n\n                    probe.forced = true;\n                    branch.value += 1;\n                    branch.isNotFailing = true;\n                }\n            }\n        },\n\n        _tryGetTokenProbe: function (token) {\n            var qtoken = token.qtoken;\n            if (qtoken == null) {\n                return null;\n            }\n\n            var tokenTypes = System.Text.RegularExpressions.RegexEngineParser.tokenTypes;\n            var min;\n            var max;\n\n            if (qtoken.type === tokenTypes.quantifier) {\n                switch (qtoken.value) {\n                    case \"*\":\n                    case \"*?\":\n                        min = 0;\n                        max = 2147483647;\n                        break;\n\n                    case \"+\":\n                    case \"+?\":\n                        min = 1;\n                        max = 2147483647;\n                        break;\n\n                    case \"?\":\n                    case \"??\":\n                        min = 0;\n                        max = 1;\n                        break;\n\n                    default:\n                        throw new System.InvalidOperationException(\"Unexpected quantifier value.\");\n                }\n            } else if (qtoken.type === tokenTypes.quantifierN) {\n                min = qtoken.data.n;\n                max = qtoken.data.n;\n            } else if (qtoken.type === tokenTypes.quantifierNM) {\n                min = qtoken.data.n;\n                max = qtoken.data.m != null ? qtoken.data.m : 2147483647;\n            } else {\n                return null;\n            }\n\n            var probe = new System.Text.RegularExpressions.RegexEngineProbe(min, max, 0, qtoken.data.isLazy);\n            return probe;\n        },\n\n        _advanceToNextBranch: function (branches, branch) {\n            if (branches.length === 0) {\n                return;\n            }\n\n            var lastBranch = branches[branches.length - 1];\n            if (!lastBranch.started) {\n                lastBranch.started = true;\n                return;\n            }\n\n            if (branch !== lastBranch) {\n                throw new System.InvalidOperationException(\"Current branch is supposed to be the last one.\");\n            }\n\n            if (branches.length === 1 && branch.type === this._branchType.offset) {\n                branch.value++;\n                branch.state.txtIndex = branch.value;\n                branch.mustFail = false;\n\n                // clear state:\n                branch.state.capIndex = null;\n                branch.state.capLength = 0;\n                branch.state.groups.length = 0;\n                branch.state.passes.length = 1;\n                branch.state.passes[0].clearState(this._cloneSettings(this._settings));\n\n                if (branch.value > branch.max) {\n                    branches.pop();\n                }\n            } else {\n                branches.pop();\n\n                if (!branch.isNotFailing) {\n                    lastBranch = branches[branches.length - 1];\n                    this._advanceToNextBranch(branches, lastBranch);\n                    return;\n                }\n            }\n        },\n\n        _collectScanResults: function (state, textPos) {\n            var groupDescs = this._patternInfo.groups;\n            var text = this._text;\n            var processedGroupNames = {};\n            var capGroups;\n            var capGroup;\n            var groupsMap = {};\n            var groupDesc;\n            var capture;\n            var group;\n            var i;\n\n            // Create Empty match object:\n            var match = this._getEmptyMatch();\n\n            if (state != null) {\n                capGroups = state.groups;\n\n                // For successful match fill Match object:\n                this._fillMatch(match, state.capIndex, state.capLength, textPos);\n\n                // Fill group captures:\n                for (i = 0; i < capGroups.length; i++) {\n                    capGroup = capGroups[i];\n                    groupDesc = groupDescs[capGroup.rawIndex - 1];\n                    if (groupDesc.constructs.skipCapture) {\n                        continue;\n                    }\n\n                    capture = {\n                        capIndex: capGroup.capIndex,\n                        capLength: capGroup.capLength,\n                        value: text.slice(capGroup.capIndex, capGroup.capIndex + capGroup.capLength)\n                    };\n\n                    group = groupsMap[groupDesc.name];\n                    if (group == null) {\n                        group = {\n                            capIndex: 0,\n                            capLength: 0,\n                            value: \"\",\n                            success: false,\n                            captures: [capture]\n                        };\n\n                        groupsMap[groupDesc.name] = group;\n                    } else {\n                        group.captures.push(capture);\n                    }\n                }\n\n                // Add groups to Match in the required order:\n                for (i = 0; i < groupDescs.length; i++) {\n                    groupDesc = groupDescs[i];\n                    if (groupDesc.constructs.skipCapture) {\n                        continue;\n                    }\n\n                    if (processedGroupNames[groupDesc.name] === true) {\n                        continue;\n                    }\n\n                    group = groupsMap[groupDesc.name];\n                    if (group == null) {\n                        group = {\n                            capIndex: 0,\n                            capLength: 0,\n                            value: \"\",\n                            success: false,\n                            captures: []\n                        };\n                    } else {\n                        // Update group values with the last capture info:\n                        if (group.captures.length > 0) {\n                            capture = group.captures[group.captures.length - 1];\n\n                            group.capIndex = capture.capIndex;\n                            group.capLength = capture.capLength;\n                            group.value = capture.value;\n                            group.success = true;\n                        }\n                    }\n\n                    processedGroupNames[groupDesc.name] = true;\n                    group.descriptor = groupDesc; // TODO: check if we can get rid of this\n                    match.groups.push(group);\n                }\n            }\n\n            return match;\n        },\n\n        // ============================================================================================\n        // Token processing\n        // ============================================================================================\n        _scanToken: function (textEndPos, branches, branch, pass, token) {\n            var tokenTypes = System.Text.RegularExpressions.RegexEngineParser.tokenTypes;\n            var resKind = this._branchResultKind;\n\n            switch (token.type) {\n                case tokenTypes.group:\n                case tokenTypes.groupImnsx:\n                case tokenTypes.alternationGroup:\n                    return this._scanGroupToken(textEndPos, branches, branch, pass, token);\n\n                case tokenTypes.groupImnsxMisc:\n                    return this._scanGroupImnsxToken(token.group.constructs, pass.settings);\n\n                case tokenTypes.charGroup:\n                    return this._scanCharGroupToken(branches, branch, pass, token, false);\n\n                case tokenTypes.charNegativeGroup:\n                    return this._scanCharNegativeGroupToken(branches, branch, pass, token, false);\n\n                case tokenTypes.escChar:\n                case tokenTypes.escCharOctal:\n                case tokenTypes.escCharHex:\n                case tokenTypes.escCharUnicode:\n                case tokenTypes.escCharCtrl:\n                    return this._scanLiteral(textEndPos, branches, branch, pass, token.data.ch);\n\n                case tokenTypes.escCharOther:\n                case tokenTypes.escCharClass:\n                    return this._scanEscapeToken(branches, branch, pass, token);\n\n                case tokenTypes.escCharClassCategory:\n                    throw new System.NotSupportedException(\"Unicode Category constructions are not supported.\");\n\n                case tokenTypes.escCharClassBlock:\n                    throw new System.NotSupportedException(\"Unicode Named block constructions are not supported.\");\n\n                case tokenTypes.escCharClassDot:\n                    return this._scanDotToken(textEndPos, branches, branch, pass);\n\n                case tokenTypes.escBackrefNumber:\n                    return this._scanBackrefNumberToken(textEndPos, branches, branch, pass, token);\n\n                case tokenTypes.escBackrefName:\n                    return this._scanBackrefNameToken(textEndPos, branches, branch, pass, token);\n\n                case tokenTypes.anchor:\n                case tokenTypes.escAnchor:\n                    return this._scanAnchorToken(textEndPos, branches, branch, pass, token);\n\n                case tokenTypes.groupConstruct:\n                case tokenTypes.groupConstructName:\n                case tokenTypes.groupConstructImnsx:\n                case tokenTypes.groupConstructImnsxMisc:\n                    return resKind.ok;\n\n                case tokenTypes.alternationGroupCondition:\n                case tokenTypes.alternationGroupRefNameCondition:\n                case tokenTypes.alternationGroupRefNumberCondition:\n                    return this._scanAlternationConditionToken(textEndPos, branches, branch, pass, token);\n\n                case tokenTypes.alternation:\n                    return resKind.endPass;\n\n                case tokenTypes.commentInline:\n                case tokenTypes.commentXMode:\n                    return resKind.ok;\n\n                default:\n                    return this._scanLiteral(textEndPos, branches, branch, pass, token.value);\n            }\n        },\n\n        _scanGroupToken: function (textEndPos, branches, branch, pass, token) {\n            var tokenTypes = System.Text.RegularExpressions.RegexEngineParser.tokenTypes;\n            var resKind = this._branchResultKind;\n            var textIndex = branch.state.txtIndex;\n\n            if (pass.onHold) {\n                if (token.type === tokenTypes.group) {\n                    var rawIndex = token.group.rawIndex;\n                    var capIndex = pass.onHoldTextIndex;\n                    var capLength = textIndex - capIndex;\n\n                    // Cache value to avoid proceeding with the already checked route:\n                    var tokenCache = branches.grCaptureCache[rawIndex];\n                    if (tokenCache == null) {\n                        tokenCache = {};\n                        branches.grCaptureCache[rawIndex] = tokenCache;\n                    }\n\n                    var key = capIndex.toString() + \"_\" + capLength.toString();\n                    if (tokenCache[key] == null) {\n                        tokenCache[key] = true;\n                    } else {\n                        return resKind.nextBranch;\n                    }\n\n                    if (!token.group.constructs.emptyCapture) {\n                        if (token.group.isBalancing) {\n                            branch.state.logCaptureGroupBalancing(token.group, capIndex);\n                        } else {\n                            branch.state.logCaptureGroup(token.group, capIndex, capLength);\n                        }\n                    }\n                }\n\n                pass.onHold = false;\n                pass.onHoldTextIndex = -1;\n                return resKind.ok;\n            }\n\n            if (token.type === tokenTypes.group ||\n                token.type === tokenTypes.groupImnsx) {\n                var constructs = token.group.constructs;\n\n                // Update Pass settings:\n                this._scanGroupImnsxToken(constructs, pass.settings);\n\n                // Scan Grouping constructs:\n                if (constructs.isPositiveLookahead || constructs.isNegativeLookahead ||\n                    constructs.isPositiveLookbehind || constructs.isNegativeLookbehind) {\n                    var scanLookRes = this._scanLook(branch, textIndex, textEndPos, token);\n                    return scanLookRes;\n                } else if (constructs.isNonbacktracking) {\n                    var scanNonBacktrackingRes = this._scanNonBacktracking(branch, textIndex, textEndPos, token);\n                    return scanNonBacktrackingRes;\n                }\n            }\n\n            // Continue scanning a regular group:\n            pass.onHoldTextIndex = textIndex;\n            pass.onHold = true;\n\n            branch.pushPass(0, token.children, this._cloneSettings(pass.settings));\n            return resKind.nextPass;\n        },\n\n        _scanGroupImnsxToken: function (constructs, settings) {\n            var resKind = this._branchResultKind;\n\n            if (constructs.isIgnoreCase != null) {\n                settings.ignoreCase = constructs.isIgnoreCase;\n            }\n\n            if (constructs.isMultiline != null) {\n                settings.multiline = constructs.isMultiline;\n            }\n\n            if (constructs.isSingleLine != null) {\n                settings.singleline = constructs.isSingleLine;\n            }\n\n            if (constructs.isIgnoreWhitespace != null) {\n                settings.ignoreWhitespace = constructs.isIgnoreWhitespace;\n            }\n\n            if (constructs.isExplicitCapture != null) {\n                settings.explicitCapture = constructs.isExplicitCapture;\n            }\n\n            return resKind.ok;\n        },\n\n        _scanAlternationConditionToken: function (textEndPos, branches, branch, pass, token) {\n            var tokenTypes = System.Text.RegularExpressions.RegexEngineParser.tokenTypes;\n            var resKind = this._branchResultKind;\n            var children = token.children;\n            var textIndex = branch.state.txtIndex;\n            var res = resKind.nextBranch;\n\n            if (token.type === tokenTypes.alternationGroupRefNameCondition ||\n                token.type === tokenTypes.alternationGroupRefNumberCondition) {\n                var grCapture = branch.state.resolveBackref(token.data.packedSlotId);\n                if (grCapture != null) {\n                    res = resKind.ok;\n                } else {\n                    res = resKind.nextBranch;\n                }\n            } else {\n                // Resolve expression:\n                var state = this._scan(textIndex, textEndPos, children, true, null);\n                if (this._combineScanResults(branch, state)) {\n                    res = resKind.ok;\n                }\n            }\n\n            if (res === resKind.nextBranch && pass.tokens.noAlternation) {\n                res = resKind.endPass;\n            }\n\n            return res;\n        },\n\n        _scanLook: function (branch, textIndex, textEndPos, token) {\n            var constructs = token.group.constructs;\n            var resKind = this._branchResultKind;\n            var children = token.children;\n            var expectedRes;\n            var actualRes;\n\n            var isLookahead = constructs.isPositiveLookahead || constructs.isNegativeLookahead;\n            var isLookbehind = constructs.isPositiveLookbehind || constructs.isNegativeLookbehind;\n\n            if (isLookahead || isLookbehind) {\n                children = children.slice(1, children.length); // remove constructs\n\n                expectedRes = constructs.isPositiveLookahead || constructs.isPositiveLookbehind;\n                if (isLookahead) {\n                    actualRes = this._scanLookAhead(branch, textIndex, textEndPos, children);\n                } else {\n                    actualRes = this._scanLookBehind(branch, textIndex, textEndPos, children);\n                }\n\n                if (expectedRes === actualRes) {\n                    return resKind.ok;\n                } else {\n                    return resKind.nextBranch;\n                }\n            }\n\n            return null;\n        },\n\n        _scanLookAhead: function (branch, textIndex, textEndPos, tokens) {\n            var state = this._scan(textIndex, textEndPos, tokens, true, null);\n            return this._combineScanResults(branch, state);\n        },\n\n        _scanLookBehind: function (branch, textIndex, textEndPos, tokens) {\n            var currIndex = textIndex;\n            var strLen;\n            var state;\n\n            while (currIndex >= 0) {\n                strLen = textIndex - currIndex;\n                state = this._scan(currIndex, textEndPos, tokens, true, strLen);\n\n                if (this._combineScanResults(branch, state)) {\n                    return true;\n                }\n\n                --currIndex;\n            }\n\n            return false;\n        },\n\n        _scanNonBacktracking: function (branch, textIndex, textEndPos, token) {\n            var resKind = this._branchResultKind;\n            var children = token.children;\n            children = children.slice(1, children.length); // remove constructs\n\n            var state = this._scan(textIndex, textEndPos, children, true, null);\n            if (!state) {\n                return resKind.nextBranch;\n            }\n\n            branch.state.logCapture(state.capLength);\n\n            return resKind.ok;\n        },\n\n        _scanLiteral: function (textEndPos, branches, branch, pass, literal) {\n            var resKind = this._branchResultKind;\n            var index = branch.state.txtIndex;\n\n            if (index + literal.length > textEndPos) {\n                return resKind.nextBranch;\n            }\n\n            var i;\n            if (pass.settings.ignoreCase) {\n                for (i = 0; i < literal.length; i++) {\n                    if (this._text[index + i].toLowerCase() !== literal[i].toLowerCase()) {\n                        return resKind.nextBranch;\n                    }\n                }\n            } else {\n                for (i = 0; i < literal.length; i++) {\n                    if (this._text[index + i] !== literal[i]) {\n                        return resKind.nextBranch;\n                    }\n                }\n            }\n\n            branch.state.logCapture(literal.length);\n            return resKind.ok;\n        },\n\n        _scanWithJsRegex: function (branches, branch, pass, token, tokenValue) {\n            var resKind = this._branchResultKind;\n            var index = branch.state.txtIndex;\n            var ch = this._text[index];\n            if (ch == null) {\n                ch = \"\";\n            }\n\n            var options = pass.settings.ignoreCase ? \"i\" : \"\";\n\n            var rgx = token.rgx;\n            if (rgx == null) {\n                if (tokenValue == null) {\n                    tokenValue = token.value;\n                }\n                rgx = new RegExp(tokenValue, options);\n                token.rgx = rgx;\n            }\n\n            if (rgx.test(ch)) {\n                branch.state.logCapture(ch.length);\n                return resKind.ok;\n            }\n\n            return resKind.nextBranch;\n        },\n\n        _scanWithJsRegex2: function (textIndex, pattern) {\n            var resKind = this._branchResultKind;\n            var ch = this._text[textIndex];\n            if (ch == null) {\n                ch = \"\";\n            }\n\n            var rgx = new RegExp(pattern, \"\");\n            if (rgx.test(ch)) {\n                return resKind.ok;\n            }\n\n            return resKind.nextBranch;\n        },\n\n        _scanCharGroupToken: function (branches, branch, pass, token, skipLoggingCapture) {\n            var tokenTypes = System.Text.RegularExpressions.RegexEngineParser.tokenTypes;\n            var resKind = this._branchResultKind;\n            var index = branch.state.txtIndex;\n            var ch = this._text[index];\n            if (ch == null) {\n                return resKind.nextBranch;\n            }\n\n            var i;\n            var j;\n            var n = ch.charCodeAt(0);\n            var ranges = token.data.ranges;\n            var range;\n            var upperCh;\n\n            // Check susbstruct group:\n            if (token.data.substractToken != null) {\n                var substractRes;\n                if (token.data.substractToken.type === tokenTypes.charGroup) {\n                    substractRes = this._scanCharGroupToken(branches, branch, pass, token.data.substractToken, true);\n                } else if (token.data.substractToken.type === tokenTypes.charNegativeGroup) {\n                    substractRes = this._scanCharNegativeGroupToken(branches, branch, pass, token.data.substractToken, true);\n                } else {\n                    throw new System.InvalidOperationException(\"Unexpected substuct group token.\");\n                }\n\n                if (substractRes === resKind.ok) {\n                    return token.type === tokenTypes.charGroup ? resKind.nextBranch : resKind.ok;\n                }\n            }\n\n            // Try CharClass tokens like: \\s \\S \\d \\D\n            if (ranges.charClassToken != null) {\n                var charClassRes = this._scanWithJsRegex(branches, branch, pass, ranges.charClassToken);\n                if (charClassRes === resKind.ok) {\n                    return resKind.ok;\n                }\n            }\n\n            // 2 iterations - to handle both cases: upper and lower\n            for (j = 0; j < 2; j++) {\n                //TODO: [Performance] Use binary search\n                for (i = 0; i < ranges.length; i++) {\n                    range = ranges[i];\n\n                    if (range.n > n) {\n                        break;\n                    }\n\n                    if (n <= range.m) {\n                        if (!skipLoggingCapture) {\n                            branch.state.logCapture(1);\n                        }\n                        return resKind.ok;\n                    }\n                }\n\n                if (upperCh == null && pass.settings.ignoreCase) {\n                    upperCh = ch.toUpperCase();\n\n                    // Invert case for the 2nd attempt;\n                    if (ch === upperCh) {\n                        ch = ch.toLowerCase();\n                    } else {\n                        ch = upperCh;\n                    }\n\n                    n = ch.charCodeAt(0);\n                }\n            }\n\n            return resKind.nextBranch;\n        },\n\n        _scanCharNegativeGroupToken: function (branches, branch, pass, token, skipLoggingCapture) {\n            var resKind = this._branchResultKind;\n            var index = branch.state.txtIndex;\n            var ch = this._text[index];\n            if (ch == null) {\n                return resKind.nextBranch;\n            }\n\n            // Get result for positive group:\n            var positiveRes = this._scanCharGroupToken(branches, branch, pass, token, true);\n\n            // Inverse the positive result:\n            if (positiveRes === resKind.ok) {\n                return resKind.nextBranch;\n            }\n\n            if (!skipLoggingCapture) {\n                branch.state.logCapture(1);\n            }\n\n            return resKind.ok;\n        },\n\n        _scanEscapeToken: function (branches, branch, pass, token) {\n            return this._scanWithJsRegex(branches, branch, pass, token);\n        },\n\n        _scanDotToken: function (textEndPos, branches, branch, pass) {\n            var resKind = this._branchResultKind;\n            var index = branch.state.txtIndex;\n\n            if (pass.settings.singleline) {\n                if (index < textEndPos) {\n                    branch.state.logCapture(1);\n                    return resKind.ok;\n                }\n            } else {\n                if (index < textEndPos && this._text[index] !== \"\\n\") {\n                    branch.state.logCapture(1);\n                    return resKind.ok;\n                }\n            }\n\n            return resKind.nextBranch;\n        },\n\n        _scanBackrefNumberToken: function (textEndPos, branches, branch, pass, token) {\n            var resKind = this._branchResultKind;\n\n            var grCapture = branch.state.resolveBackref(token.data.slotId);\n            if (grCapture == null) {\n                return resKind.nextBranch;\n            }\n\n            var grCaptureTxt = this._text.slice(grCapture.capIndex, grCapture.capIndex + grCapture.capLength);\n            return this._scanLiteral(textEndPos, branches, branch, pass, grCaptureTxt);\n        },\n\n        _scanBackrefNameToken: function (textEndPos, branches, branch, pass, token) {\n            var resKind = this._branchResultKind;\n\n            var grCapture = branch.state.resolveBackref(token.data.slotId);\n            if (grCapture == null) {\n                return resKind.nextBranch;\n            }\n\n            var grCaptureTxt = this._text.slice(grCapture.capIndex, grCapture.capIndex + grCapture.capLength);\n            return this._scanLiteral(textEndPos, branches, branch, pass, grCaptureTxt);\n        },\n\n        _scanAnchorToken: function (textEndPos, branches, branch, pass, token) {\n            var resKind = this._branchResultKind;\n            var index = branch.state.txtIndex;\n\n            if (token.value === \"\\\\b\" || token.value === \"\\\\B\") {\n                var prevIsWord = index > 0 && this._scanWithJsRegex2(index - 1, \"\\\\w\") === resKind.ok;\n                var currIsWord = this._scanWithJsRegex2(index, \"\\\\w\") === resKind.ok;\n                if ((prevIsWord === currIsWord) === (token.value === \"\\\\B\")) {\n                    return resKind.ok;\n                }\n            } else if (token.value === \"^\") {\n                if (index === 0) {\n                    return resKind.ok;\n                }\n                if (pass.settings.multiline && this._text[index - 1] === \"\\n\") {\n                    return resKind.ok;\n                }\n            } else if (token.value === \"$\") {\n                if (index === textEndPos) {\n                    return resKind.ok;\n                }\n                if (pass.settings.multiline && this._text[index] === \"\\n\") {\n                    return resKind.ok;\n                }\n            } else if (token.value === \"\\\\A\") {\n                if (index === 0) {\n                    return resKind.ok;\n                }\n            } else if (token.value === \"\\\\z\") {\n                if (index === textEndPos) {\n                    return resKind.ok;\n                }\n            } else if (token.value === \"\\\\Z\") {\n                if (index === textEndPos) {\n                    return resKind.ok;\n                }\n                if (index === textEndPos - 1 && this._text[index] === \"\\n\") {\n                    return resKind.ok;\n                }\n            } else if (token.value === \"\\\\G\") {\n                return resKind.ok;\n            }\n\n            return resKind.nextBranch;\n        },\n\n        // ============================================================================================\n        // Auxiliary functions\n        // ============================================================================================\n        _cloneSettings: function (settings) {\n            var cloned = {\n                ignoreCase: settings.ignoreCase,\n                multiline: settings.multiline,\n                singleline: settings.singleline,\n                ignoreWhitespace: settings.ignoreWhitespace,\n                explicitCapture: settings.explicitCapture\n            };\n            return cloned;\n        },\n\n        _combineScanResults: function (branch, srcState) {\n            if (srcState != null) {\n                var dstGroups = branch.state.groups;\n                var srcGroups = srcState.groups;\n                var srcGroupsLen = srcGroups.length;\n                var i;\n\n                for (i = 0; i < srcGroupsLen; ++i) {\n                    dstGroups.push(srcGroups[i]);\n                    }\n\n                return true;\n            }\n            return false;\n        },\n\n        _getEmptyMatch: function () {\n            var match = {\n                capIndex: 0,    // start index of total capture\n                capLength: 0,   // length of total capture\n                success: false,\n                value: \"\",\n                groups: [],\n                captures: []\n            };\n\n            return match;\n        },\n\n        _fillMatch: function (match, capIndex, capLength, textPos) {\n            if (capIndex == null) {\n                capIndex = textPos;\n            }\n\n            match.capIndex = capIndex;\n            match.capLength = capLength;\n            match.success = true;\n            match.value = this._text.slice(capIndex, capIndex + capLength);\n\n            match.groups.push({\n                capIndex: capIndex,\n                capLength: capLength,\n                value: match.value,\n                success: true,\n                captures: [\n                    {\n                        capIndex: capIndex,\n                        capLength: capLength,\n                        value: match.value\n                    }\n                ]\n            });\n\n            match.captures.push(match.groups[0].captures[0]);\n        },\n\n        _checkTimeout: function () {\n            if (this._timeoutTime < 0) {\n                return;\n            }\n\n            var time = new Date().getTime();\n\n            if (time >= this._timeoutTime) {\n                throw new System.RegexMatchTimeoutException(this._text, this._pattern, System.TimeSpan.fromMilliseconds(this._timeoutMs));\n            }\n        }\n    });\n\n    // @source RegexEngineBranch.js\n\n    Bridge.define(\"System.Text.RegularExpressions.RegexEngineBranch\", {\n        type: 0,\n        value: 0,\n        min: 0,\n        max: 0,\n\n        isStarted: false,\n        isNotFailing: false,\n\n        state: null,\n\n        ctor: function (branchType, currVal, minVal, maxVal, parentState) {\n            this.$initialize();\n\n            this.type = branchType;\n\n            this.value = currVal;\n            this.min = minVal;\n            this.max = maxVal;\n\n            this.state = parentState != null ? parentState.clone() : new System.Text.RegularExpressions.RegexEngineState();\n        },\n\n        pushPass: function (index, tokens, settings) {\n            var pass = new System.Text.RegularExpressions.RegexEnginePass(index, tokens, settings);\n            this.state.passes.push(pass);\n        },\n\n        peekPass: function () {\n            return this.state.passes[this.state.passes.length - 1];\n        },\n\n        popPass: function () {\n            return this.state.passes.pop();\n        },\n\n        hasPass: function () {\n            return this.state.passes.length > 0;\n        },\n\n        clone: function () {\n            var cloned = new System.Text.RegularExpressions.RegexEngineBranch(this.type, this.value, this.min, this.max, this.state);\n            cloned.isNotFailing = this.isNotFailing;\n            return cloned;\n        }\n    });\n\n    // @source RegexEngineState.js\n\n    Bridge.define(\"System.Text.RegularExpressions.RegexEngineState\", {\n        txtIndex: 0, // current index\n        capIndex: null, // first index of captured text\n        capLength: 0, // current length\n        passes: null,\n        groups: null, // captured groups\n\n        ctor: function () {\n            this.$initialize();\n\n            this.passes = [];\n            this.groups = [];\n        },\n\n        logCapture: function (length) {\n            if (this.capIndex == null) {\n                this.capIndex = this.txtIndex;\n            }\n\n            this.txtIndex += length;\n            this.capLength += length;\n        },\n\n        logCaptureGroup: function (group, index, length) {\n            this.groups.push({ rawIndex: group.rawIndex, slotId: group.packedSlotId, capIndex: index, capLength: length });\n        },\n\n        logCaptureGroupBalancing: function (group, capIndex) {\n            var balancingSlotId = group.balancingSlotId;\n            var groups = this.groups;\n            var index = groups.length - 1;\n            var group2;\n            var group2Index;\n\n            while (index >= 0) {\n                if (groups[index].slotId === balancingSlotId) {\n                    group2 = groups[index];\n                    group2Index = index;\n                    break;\n                }\n                --index;\n            }\n\n            if (group2 != null && group2Index != null) {\n                groups.splice(group2Index, 1); // remove group2 from the collection\n\n                // Add balancing group value:\n                if (group.constructs.name1 != null) {\n                    var balCapIndex = group2.capIndex + group2.capLength;\n                    var balCapLength = capIndex - balCapIndex;\n\n                    this.logCaptureGroup(group, balCapIndex, balCapLength);\n                }\n\n                return true;\n            }\n\n            return false;\n        },\n\n        resolveBackref: function (packedSlotId) {\n            var groups = this.groups;\n            var index = groups.length - 1;\n\n            while (index >= 0) {\n                if (groups[index].slotId === packedSlotId) {\n                    return groups[index];\n                }\n                --index;\n            }\n\n            return null;\n        },\n\n        clone: function () {\n            var cloned = new System.Text.RegularExpressions.RegexEngineState();\n            cloned.txtIndex = this.txtIndex;\n            cloned.capIndex = this.capIndex;\n            cloned.capLength = this.capLength;\n\n            // Clone passes:\n            var clonedPasses = cloned.passes;\n            var thisPasses = this.passes;\n            var len = thisPasses.length;\n            var clonedItem;\n            var i;\n\n            for (i = 0; i < len; i++) {\n                clonedItem = thisPasses[i].clone();\n                clonedPasses.push(clonedItem);\n            }\n\n            // Clone groups:\n            var clonedGroups = cloned.groups;\n            var thisGroups = this.groups;\n            len = thisGroups.length;\n\n            for (i = 0; i < len; i++) {\n                clonedItem = thisGroups[i];\n                clonedGroups.push(clonedItem);\n            }\n\n            return cloned;\n        }\n    });\n\n    // @source RegexEnginePass.js\n\n    Bridge.define(\"System.Text.RegularExpressions.RegexEnginePass\", {\n        index: 0,\n        tokens: null,\n        probe: null,\n\n        onHold: false,\n        onHoldTextIndex: -1,\n        alternationHandled: false,\n\n        settings: null,\n\n        ctor: function (index, tokens, settings) {\n            this.$initialize();\n\n            this.index = index;\n            this.tokens = tokens;\n            this.settings = settings;\n        },\n\n        clearState: function (settings) {\n            this.index = 0;\n            this.probe = null;\n            this.onHold = false;\n            this.onHoldTextIndex = -1;\n            this.alternationHandled = false;\n            this.settings = settings;\n        },\n\n        clone: function () {\n            var cloned = new System.Text.RegularExpressions.RegexEnginePass(this.index, this.tokens, this.settings);\n            cloned.onHold = this.onHold;\n            cloned.onHoldTextIndex = this.onHoldTextIndex;\n            cloned.alternationHandled = this.alternationHandled;\n            cloned.probe = this.probe != null ? this.probe.clone() : null;\n            return cloned;\n        }\n    });\n\n    // @source RegexEngineProbe.js\n\n    Bridge.define(\"System.Text.RegularExpressions.RegexEngineProbe\", {\n        min: 0,\n        max: 0,\n        value: 0,\n        isLazy: false,\n        forced: false,\n\n        ctor: function (min, max, value, isLazy) {\n            this.$initialize();\n\n            this.min = min;\n            this.max = max;\n            this.value = value;\n            this.isLazy = isLazy;\n            this.forced = false;\n        },\n\n        clone: function () {\n            var cloned = new System.Text.RegularExpressions.RegexEngineProbe(this.min, this.max, this.value, this.isLazy);\n            cloned.forced = this.forced;\n            return cloned;\n        }\n    });\n\n    // @source RegexEngineParser.js\n\n    Bridge.define(\"System.Text.RegularExpressions.RegexEngineParser\", {\n        statics: {\n            _hexSymbols: \"0123456789abcdefABCDEF\",\n            _octSymbols: \"01234567\",\n            _decSymbols: \"0123456789\",\n\n            _escapedChars: \"abtrvfnexcu\",\n            _escapedCharClasses: \"pPwWsSdD\",\n            _escapedAnchors: \"AZzGbB\",\n            _escapedSpecialSymbols: \" .,$^{}[]()|*+-=?\\\\|/\\\"':;~!@#%&\",\n\n            _whiteSpaceChars: \" \\r\\n\\t\\v\\f\\u00A0\\uFEFF\", //TODO: This is short version of .NET WhiteSpace category.\n            _unicodeCategories: [\"Lu\", \"Ll\", \"Lt\", \"Lm\", \"Lo\", \"L\", \"Mn\", \"Mc\", \"Me\", \"M\", \"Nd\", \"Nl\", \"No\", \"N\", \"Pc\", \"Pd\", \"Ps\", \"Pe\", \"Pi\", \"Pf\", \"Po\", \"P\", \"Sm\", \"Sc\", \"Sk\", \"So\", \"S\", \"Zs\", \"Zl\", \"Zp\", \"Z\", \"Cc\", \"Cf\", \"Cs\", \"Co\", \"Cn\", \"C\"],\n            _namedCharBlocks: [\"IsBasicLatin\", \"IsLatin-1Supplement\", \"IsLatinExtended-A\", \"IsLatinExtended-B\", \"IsIPAExtensions\", \"IsSpacingModifierLetters\", \"IsCombiningDiacriticalMarks\", \"IsGreek\", \"IsGreekandCoptic\", \"IsCyrillic\", \"IsCyrillicSupplement\", \"IsArmenian\", \"IsHebrew\", \"IsArabic\", \"IsSyriac\", \"IsThaana\", \"IsDevanagari\", \"IsBengali\", \"IsGurmukhi\", \"IsGujarati\", \"IsOriya\", \"IsTamil\", \"IsTelugu\", \"IsKannada\", \"IsMalayalam\", \"IsSinhala\", \"IsThai\", \"IsLao\", \"IsTibetan\", \"IsMyanmar\", \"IsGeorgian\", \"IsHangulJamo\", \"IsEthiopic\", \"IsCherokee\", \"IsUnifiedCanadianAboriginalSyllabics\", \"IsOgham\", \"IsRunic\", \"IsTagalog\", \"IsHanunoo\", \"IsBuhid\", \"IsTagbanwa\", \"IsKhmer\", \"IsMongolian\", \"IsLimbu\", \"IsTaiLe\", \"IsKhmerSymbols\", \"IsPhoneticExtensions\", \"IsLatinExtendedAdditional\", \"IsGreekExtended\", \"IsGeneralPunctuation\", \"IsSuperscriptsandSubscripts\", \"IsCurrencySymbols\", \"IsCombiningDiacriticalMarksforSymbols\", \"IsCombiningMarksforSymbols\", \"IsLetterlikeSymbols\", \"IsNumberForms\", \"IsArrows\", \"IsMathematicalOperators\", \"IsMiscellaneousTechnical\", \"IsControlPictures\", \"IsOpticalCharacterRecognition\", \"IsEnclosedAlphanumerics\", \"IsBoxDrawing\", \"IsBlockElements\", \"IsGeometricShapes\", \"IsMiscellaneousSymbols\", \"IsDingbats\", \"IsMiscellaneousMathematicalSymbols-A\", \"IsSupplementalArrows-A\", \"IsBraillePatterns\", \"IsSupplementalArrows-B\", \"IsMiscellaneousMathematicalSymbols-B\", \"IsSupplementalMathematicalOperators\", \"IsMiscellaneousSymbolsandArrows\", \"IsCJKRadicalsSupplement\", \"IsKangxiRadicals\", \"IsIdeographicDescriptionCharacters\", \"IsCJKSymbolsandPunctuation\", \"IsHiragana\", \"IsKatakana\", \"IsBopomofo\", \"IsHangulCompatibilityJamo\", \"IsKanbun\", \"IsBopomofoExtended\", \"IsKatakanaPhoneticExtensions\", \"IsEnclosedCJKLettersandMonths\", \"IsCJKCompatibility\", \"IsCJKUnifiedIdeographsExtensionA\", \"IsYijingHexagramSymbols\", \"IsCJKUnifiedIdeographs\", \"IsYiSyllables\", \"IsYiRadicals\", \"IsHangulSyllables\", \"IsHighSurrogates\", \"IsHighPrivateUseSurrogates\", \"IsLowSurrogates\", \"IsPrivateUse or IsPrivateUseArea\", \"IsCJKCompatibilityIdeographs\", \"IsAlphabeticPresentationForms\", \"IsArabicPresentationForms-A\", \"IsVariationSelectors\", \"IsCombiningHalfMarks\", \"IsCJKCompatibilityForms\", \"IsSmallFormVariants\", \"IsArabicPresentationForms-B\", \"IsHalfwidthandFullwidthForms\", \"IsSpecials\"],\n            _controlChars: [\"@\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\", \"[\", \"\\\\\", \"]\", \"^\", \"_\"],\n\n            tokenTypes: {\n                literal: 0,\n\n                escChar: 110,\n                escCharOctal: 111,\n                escCharHex: 112,\n                escCharCtrl: 113,\n                escCharUnicode: 114,\n                escCharOther: 115,\n\n                escCharClass: 120,\n                escCharClassCategory: 121,\n                escCharClassBlock: 122,\n                escCharClassDot: 123,\n\n                escAnchor: 130,\n\n                escBackrefNumber: 140,\n                escBackrefName: 141,\n\n                charGroup: 200,\n                charNegativeGroup: 201,\n                charInterval: 202,\n\n                anchor: 300,\n\n                group: 400,\n                groupImnsx: 401,\n                groupImnsxMisc: 402,\n\n                groupConstruct: 403,\n                groupConstructName: 404,\n                groupConstructImnsx: 405,\n                groupConstructImnsxMisc: 406,\n\n                quantifier: 500,\n                quantifierN: 501,\n                quantifierNM: 502,\n\n                alternation: 600,\n                alternationGroup: 601,\n                alternationGroupCondition: 602,\n                alternationGroupRefNumberCondition: 603,\n                alternationGroupRefNameCondition: 604,\n\n                commentInline: 700,\n                commentXMode: 701\n            },\n\n            parsePattern: function (pattern, settings) {\n                var scope = System.Text.RegularExpressions.RegexEngineParser;\n\n                // Parse tokens in the original pattern:\n                var tokens = scope._parsePatternImpl(pattern, settings, 0, pattern.length);\n\n                // Collect and fill group descriptors into Group tokens.\n                // We need do it before any token modification.\n                var groups = [];\n                scope._fillGroupDescriptors(tokens, groups);\n\n                // Fill Sparse Info:\n                var sparseSettings = scope._getGroupSparseInfo(groups);\n\n                // Fill balancing info for the groups with \"name2\":\n                scope._fillBalancingGroupInfo(groups, sparseSettings);\n\n                // Transform tokens for usage in JS RegExp:\n                scope._preTransformBackrefTokens(pattern, tokens, sparseSettings);\n                scope._transformRawTokens(settings, tokens, sparseSettings, [], [], 0);\n\n                // Update group descriptors as tokens have been transformed (at least indexes were changed):\n                scope._updateGroupDescriptors(tokens);\n\n                var result = {\n                    groups: groups,\n                    sparseSettings: sparseSettings,\n                    isContiguous: settings.isContiguous || false,\n                    shouldFail: settings.shouldFail || false,\n                    tokens: tokens\n                };\n\n                return result;\n            },\n\n            _transformRawTokens: function (settings, tokens, sparseSettings, allowedPackedSlotIds, nestedGroupIds, nestingLevel) {\n                var scope = System.Text.RegularExpressions.RegexEngineParser;\n                var tokenTypes = scope.tokenTypes;\n                var prevToken;\n                var token;\n                var value;\n                var packedSlotId;\n                var groupNumber;\n                var matchRes;\n                var localNestedGroupIds;\n                var localSettings;\n                var qtoken;\n                var i;\n\n                // Transform/adjust tokens collection to work with JS RegExp:\n                for (i = 0; i < tokens.length; i++) {\n                    token = tokens[i];\n\n                    if (i < tokens.length - 1) {\n                        qtoken = tokens[i + 1];\n                        switch (qtoken.type) {\n                            case tokenTypes.quantifier:\n                            case tokenTypes.quantifierN:\n                            case tokenTypes.quantifierNM:\n                                token.qtoken = qtoken;\n                                tokens.splice(i + 1, 1);\n                                --i;\n                        }\n                    }\n\n                    if (token.type === tokenTypes.escBackrefNumber) {\n                        groupNumber = token.data.number;\n                        packedSlotId = sparseSettings.getPackedSlotIdBySlotNumber(groupNumber);\n                        if (packedSlotId == null) {\n                            throw new System.ArgumentException(\"Reference to undefined group number \" + groupNumber.toString() + \".\");\n                        }\n                        if (allowedPackedSlotIds.indexOf(packedSlotId) < 0) {\n                            settings.shouldFail = true; // Backreferences to unreachable group number lead to an empty match.\n                            continue;\n                        }\n\n                        token.data.slotId = packedSlotId;\n                    } else if (token.type === tokenTypes.escBackrefName) {\n                        value = token.data.name;\n                        packedSlotId = sparseSettings.getPackedSlotIdBySlotName(value);\n                        if (packedSlotId == null) {\n                            // TODO: Move this code to earlier stages\n                            // If the name is number, treat the backreference as a numbered:\n                            matchRes = scope._matchChars(value, 0, value.length, scope._decSymbols);\n                            if (matchRes.matchLength === value.length) {\n                                value = \"\\\\\" + value;\n                                scope._updatePatternToken(token, tokenTypes.escBackrefNumber, token.index, value.length, value);\n                                --i; // process the token again\n                                continue;\n                            }\n                            throw new System.ArgumentException(\"Reference to undefined group name '\" + value + \"'.\");\n                        }\n\n                        if (allowedPackedSlotIds.indexOf(packedSlotId) < 0) {\n                            settings.shouldFail = true; // Backreferences to unreachable group number lead to an empty match.\n                            continue;\n                        }\n\n                        token.data.slotId = packedSlotId;\n                    } else if (token.type === tokenTypes.anchor || token.type === tokenTypes.escAnchor) {\n                        if (token.value === \"\\\\G\") {\n                            if (nestingLevel === 0 && i === 0) {\n                                settings.isContiguous = true;\n                            } else {\n                                settings.shouldFail = true;\n                            }\n\n                            tokens.splice(i, 1);\n                            --i;\n                            continue;\n                        }\n                    } else if (token.type === tokenTypes.commentInline || token.type === tokenTypes.commentXMode) {\n                        // We can safely remove comments from the pattern\n                        tokens.splice(i, 1);\n                        --i;\n                        continue;\n                    } else if (token.type === tokenTypes.literal) {\n                        // Combine literal tokens for better performance:\n                        if (i > 0 && !token.qtoken) {\n                            prevToken = tokens[i - 1];\n                            if (prevToken.type === tokenTypes.literal && !prevToken.qtoken) {\n                                prevToken.value += token.value;\n                                prevToken.length += token.length;\n\n                                tokens.splice(i, 1);\n                                --i;\n                                continue;\n                            }\n                        }\n                    } else if (token.type === tokenTypes.alternationGroupCondition) {\n                        if (token.data != null) {\n                            if (token.data.number != null) {\n                                packedSlotId = sparseSettings.getPackedSlotIdBySlotNumber(token.data.number);\n                                if (packedSlotId == null) {\n                                    throw new System.ArgumentException(\"Reference to undefined group number \" + value + \".\");\n                                }\n                                token.data.packedSlotId = packedSlotId;\n                                scope._updatePatternToken(token, tokenTypes.alternationGroupRefNumberCondition, token.index, token.length, token.value);\n                            } else {\n                                packedSlotId = sparseSettings.getPackedSlotIdBySlotName(token.data.name);\n                                if (packedSlotId != null) {\n                                    token.data.packedSlotId = packedSlotId;\n                                    scope._updatePatternToken(token, tokenTypes.alternationGroupRefNameCondition, token.index, token.length, token.value);\n                                } else {\n                                    delete token.data;\n                                }\n                            }\n                        }\n                    }\n\n                    // Update children tokens:\n                    if (token.children && token.children.length) {\n                        localNestedGroupIds = token.type === tokenTypes.group ? [token.group.rawIndex] : [];\n                        localNestedGroupIds = localNestedGroupIds.concat(nestedGroupIds);\n\n                        localSettings = token.localSettings || settings;\n                        scope._transformRawTokens(localSettings, token.children, sparseSettings, allowedPackedSlotIds, localNestedGroupIds, nestingLevel + 1);\n                        settings.shouldFail = settings.shouldFail || localSettings.shouldFail;\n                        settings.isContiguous = settings.isContiguous || localSettings.isContiguous;\n                    }\n\n                    // Group is processed. Now it can be referenced with Backref:\n                    if (token.type === tokenTypes.group) {\n                        allowedPackedSlotIds.push(token.group.packedSlotId);\n                    }\n                }\n            },\n\n            _fillGroupDescriptors: function (tokens, groups) {\n                var scope = System.Text.RegularExpressions.RegexEngineParser;\n                var group;\n                var i;\n\n                // Fill group structure:\n                scope._fillGroupStructure(groups, tokens, null);\n\n                // Assign name or id:\n                var groupId = 1;\n                for (i = 0; i < groups.length; i++) {\n                    group = groups[i];\n\n                    if (group.constructs.name1 != null) {\n                        group.name = group.constructs.name1;\n                        group.hasName = true;\n                    } else {\n                        group.hasName = false;\n                        group.name = groupId.toString();\n                        ++groupId;\n                    }\n                }\n            },\n\n            _fillGroupStructure: function (groups, tokens, parentGroup) {\n                var scope = System.Text.RegularExpressions.RegexEngineParser;\n                var tokenTypes = scope.tokenTypes;\n                var group;\n                var token;\n                var constructs;\n                var constructCandidateToken;\n                var hasChildren;\n                var i;\n\n                for (i = 0; i < tokens.length; i++) {\n                    token = tokens[i];\n                    hasChildren = token.children && token.children.length;\n\n                    if (token.type === tokenTypes.group || token.type === tokenTypes.groupImnsx || token.type === tokenTypes.groupImnsxMisc) {\n                        group = {\n                            rawIndex: groups.length + 1,\n                            number: -1,\n\n                            parentGroup: null,\n                            innerGroups: [],\n\n                            name: null,\n                            hasName: false,\n\n                            constructs: null,\n                            quantifier: null,\n\n                            exprIndex: -1,\n                            exprLength: 0,\n                            expr: null,\n                            exprFull: null\n                        };\n\n                        token.group = group;\n\n                        if (token.type === tokenTypes.group) {\n                            groups.push(group);\n\n                            if (parentGroup != null) {\n                                token.group.parentGroup = parentGroup;\n                                parentGroup.innerGroups.push(group);\n                            }\n                        }\n\n                        // fill group constructs:\n                        constructCandidateToken = hasChildren ? token.children[0] : null;\n                        group.constructs = scope._fillGroupConstructs(constructCandidateToken);\n                        constructs = group.constructs;\n\n                        if (token.isNonCapturingExplicit) {\n                            delete token.isNonCapturingExplicit;\n                            constructs.isNonCapturingExplicit = true;\n                        }\n\n                        if (token.isEmptyCapturing) {\n                            delete token.isEmptyCapturing;\n                            constructs.emptyCapture = true;\n                        }\n\n                        constructs.skipCapture =\n                            constructs.isNonCapturing ||\n                            constructs.isNonCapturingExplicit ||\n                            constructs.isNonbacktracking ||\n                            constructs.isPositiveLookahead ||\n                            constructs.isNegativeLookahead ||\n                            constructs.isPositiveLookbehind ||\n                            constructs.isNegativeLookbehind ||\n                            (constructs.name1 == null && constructs.name2 != null);\n                    }\n\n                    // fill group descriptors for inner tokens:\n                    if (hasChildren) {\n                        scope._fillGroupStructure(groups, token.children, token.group);\n                    }\n                }\n            },\n\n            _getGroupSparseInfo: function (groups) {\n                var scope = System.Text.RegularExpressions.RegexEngineParser;\n\n                var explNumberedGroups = {};\n                var explNumberedGroupKeys = [];\n                var explNamedGroups = {};\n                var explGroups;\n\n                var numberedGroups;\n                var slotNumber;\n                var slotName;\n                var group;\n                var i;\n                var j;\n\n                var sparseSlotMap = { 0: 0 };\n                sparseSlotMap.lastSlot = 0;\n\n                var sparseSlotNameMap = { \"0\": 0 };\n                sparseSlotNameMap.keys = [\"0\"];\n\n                // Fill Explicit Numbers:\n                for (i = 0; i < groups.length; i++) {\n                    group = groups[i];\n                    if (group.constructs.skipCapture) {\n                        continue;\n                    }\n\n                    if (group.constructs.isNumberName1) {\n                        slotNumber = parseInt(group.constructs.name1);\n                        explNumberedGroupKeys.push(slotNumber);\n\n                        if (explNumberedGroups[slotNumber]) {\n                            explNumberedGroups[slotNumber].push(group);\n                        } else {\n                            explNumberedGroups[slotNumber] = [group];\n                        }\n                    } else {\n                        slotName = group.constructs.name1;\n\n                        if (explNamedGroups[slotName]) {\n                            explNamedGroups[slotName].push(group);\n                        } else {\n                            explNamedGroups[slotName] = [group];\n                        }\n                    }\n                }\n\n                // Sort explicitly set Number names:\n                var sortNum = function (a, b) {\n                    return a - b;\n                };\n                explNumberedGroupKeys.sort(sortNum);\n\n                // Add group without names first (emptyCapture = false first, than emptyCapture = true):\n                var allowEmptyCapture = false;\n                for (j = 0; j < 2; j++) {\n                    for (i = 0; i < groups.length; i++) {\n                        group = groups[i];\n                        if (group.constructs.skipCapture) {\n                            continue;\n                        }\n\n                        if ((group.constructs.emptyCapture === true) !== allowEmptyCapture) {\n                            continue;\n                        }\n\n                        slotNumber = sparseSlotNameMap.keys.length;\n                        if (!group.hasName) {\n                            numberedGroups = [group];\n                            explGroups = explNumberedGroups[slotNumber];\n                            if (explGroups != null) {\n                                numberedGroups = numberedGroups.concat(explGroups);\n                                explNumberedGroups[slotNumber] = null;\n                            }\n\n                            scope._addSparseSlotForSameNamedGroups(numberedGroups, slotNumber, sparseSlotMap, sparseSlotNameMap);\n                        }\n                    }\n                    allowEmptyCapture = true;\n                }\n\n                // Then add named groups:\n                for (i = 0; i < groups.length; i++) {\n                    group = groups[i];\n                    if (group.constructs.skipCapture) {\n                        continue;\n                    }\n\n                    if (!group.hasName || group.constructs.isNumberName1) {\n                        continue;\n                    }\n\n                    // If the slot is already occupied by an explicitly numbered group,\n                    // add this group to the slot:\n                    slotNumber = sparseSlotNameMap.keys.length;\n                    explGroups = explNumberedGroups[slotNumber];\n                    while (explGroups != null) {\n                        scope._addSparseSlotForSameNamedGroups(explGroups, slotNumber, sparseSlotMap, sparseSlotNameMap);\n\n                        explNumberedGroups[slotNumber] = null; // Group is processed.\n                        slotNumber = sparseSlotNameMap.keys.length;\n                        explGroups = explNumberedGroups[slotNumber];\n                    }\n\n                    if (!group.constructs.isNumberName1) {\n                        slotNumber = sparseSlotNameMap.keys.length;\n                        explGroups = explNumberedGroups[slotNumber];\n                        while (explGroups != null) {\n                            scope._addSparseSlotForSameNamedGroups(explGroups, slotNumber, sparseSlotMap, sparseSlotNameMap);\n\n                            explNumberedGroups[slotNumber] = null; // Group is processed.\n                            slotNumber = sparseSlotNameMap.keys.length;\n                            explGroups = explNumberedGroups[slotNumber];\n                        }\n                    }\n\n                    // Add the named group(s) to the 1st free slot:\n                    slotName = group.constructs.name1;\n                    explGroups = explNamedGroups[slotName];\n                    if (explGroups != null) {\n                        scope._addSparseSlotForSameNamedGroups(explGroups, slotNumber, sparseSlotMap, sparseSlotNameMap);\n                        explNamedGroups[slotName] = null;  // Group is processed.\n                    }\n                }\n\n                // Add the rest explicitly numbered groups:\n                for (i = 0; i < explNumberedGroupKeys.length; i++) {\n                    slotNumber = explNumberedGroupKeys[i];\n                    explGroups = explNumberedGroups[slotNumber];\n                    if (explGroups != null) {\n                        scope._addSparseSlotForSameNamedGroups(explGroups, slotNumber, sparseSlotMap, sparseSlotNameMap);\n\n                        explNumberedGroups[slotNumber] = null; // Group is processed.\n                    }\n                }\n\n                return {\n                    isSparse: sparseSlotMap.isSparse || false, //sparseSlotNumbers.length !== (1 + sparseSlotNumbers[sparseSlotNumbers.length - 1]),\n                    sparseSlotMap: sparseSlotMap,           // <SlotNumber, PackedSlotId>\n                    sparseSlotNameMap: sparseSlotNameMap,   // <SlotName, PackedSlotId>\n\n                    getPackedSlotIdBySlotNumber: function(slotNumber) {\n                        return this.sparseSlotMap[slotNumber];\n                    },\n\n                    getPackedSlotIdBySlotName: function (slotName) {\n                        return this.sparseSlotNameMap[slotName];\n                    }\n                };\n            },\n\n            _addSparseSlot: function (group, slotNumber, sparseSlotMap, sparseSlotNameMap) {\n                var packedSlotId = sparseSlotNameMap.keys.length; // 0-based index. Raw Slot number, 0,1..n (without gaps)\n\n                group.packedSlotId = packedSlotId;\n\n                sparseSlotMap[slotNumber] = packedSlotId;\n                sparseSlotNameMap[group.name] = packedSlotId;\n                sparseSlotNameMap.keys.push(group.name);\n\n                if (!sparseSlotMap.isSparse && ((slotNumber - sparseSlotMap.lastSlot) > 1)) {\n                    sparseSlotMap.isSparse = true;\n                }\n\n                sparseSlotMap.lastSlot = slotNumber;\n            },\n\n            _addSparseSlotForSameNamedGroups: function (groups, slotNumber, sparseSlotMap, sparseSlotNameMap) {\n                var scope = System.Text.RegularExpressions.RegexEngineParser;\n                var i;\n\n                scope._addSparseSlot(groups[0], slotNumber, sparseSlotMap, sparseSlotNameMap);\n                var sparseSlotId = groups[0].sparseSlotId;\n                var packedSlotId = groups[0].packedSlotId;\n\n                // Assign SlotID for all expl. named groups in this slot.\n                if (groups.length > 1) {\n                    for (i = 1; i < groups.length; i++) {\n                        groups[i].sparseSlotId = sparseSlotId;\n                        groups[i].packedSlotId = packedSlotId;\n                    }\n                }\n            },\n\n            _fillGroupConstructs: function (childToken) {\n                var scope = System.Text.RegularExpressions.RegexEngineParser;\n                var tokenTypes = scope.tokenTypes;\n                var constructs = {\n                    name1: null,\n                    name2: null,\n\n                    isNumberName1: false,\n                    isNumberName2: false,\n\n                    isNonCapturing: false,\n                    isNonCapturingExplicit: false,\n\n                    isIgnoreCase: null,\n                    isMultiline: null,\n                    isExplicitCapture: null,\n                    isSingleLine: null,\n                    isIgnoreWhitespace: null,\n\n                    isPositiveLookahead: false,\n                    isNegativeLookahead: false,\n                    isPositiveLookbehind: false,\n                    isNegativeLookbehind: false,\n\n                    isNonbacktracking: false\n                };\n\n                if (childToken == null) {\n                    return constructs;\n                }\n\n                if (childToken.type === tokenTypes.groupConstruct) {\n                    // ?:\n                    // ?=\n                    // ?!\n                    // ?<=\n                    // ?<!\n                    // ?>\n\n                    switch (childToken.value) {\n                        case \"?:\":\n                            constructs.isNonCapturing = true;\n                            break;\n\n                        case \"?=\":\n                            constructs.isPositiveLookahead = true;\n                            break;\n\n                        case \"?!\":\n                            constructs.isNegativeLookahead = true;\n                            break;\n\n                        case \"?>\":\n                            constructs.isNonbacktracking = true;\n                            break;\n\n                        case \"?<=\":\n                            constructs.isPositiveLookbehind = true;\n                            break;\n\n                        case \"?<!\":\n                            constructs.isNegativeLookbehind = true;\n                            break;\n\n                        default:\n                            throw new System.ArgumentException(\"Unrecognized grouping construct.\");\n                    }\n                } else if (childToken.type === tokenTypes.groupConstructName) {\n                    // ?<name1>\n                    // ?'name1'\n                    // ?<name1-name2>\n                    // ?'name1-name2'\n\n                    var nameExpr = childToken.value.slice(2, childToken.length - 1);\n                    var groupNames = nameExpr.split(\"-\");\n                    if (groupNames.length === 0 || groupNames.length > 2) {\n                        throw new System.ArgumentException(\"Invalid group name.\");\n                    }\n\n                    if (groupNames[0].length) {\n                        constructs.name1 = groupNames[0];\n                        var nameRes1 = scope._validateGroupName(groupNames[0]);\n                        constructs.isNumberName1 = nameRes1.isNumberName;\n                    }\n\n                    if (groupNames.length === 2) {\n                        constructs.name2 = groupNames[1];\n                        var nameRes2 = scope._validateGroupName(groupNames[1]);\n                        constructs.isNumberName2 = nameRes2.isNumberName;\n                    }\n                } else if (childToken.type === tokenTypes.groupConstructImnsx || childToken.type === tokenTypes.groupConstructImnsxMisc) {\n                    // ?imnsx-imnsx:\n                    var imnsxPostfixLen = childToken.type === tokenTypes.groupConstructImnsx ? 1 : 0;\n                    var imnsxExprLen = childToken.length - 1 - imnsxPostfixLen; // - prefix - postfix\n                    var imnsxVal = true;\n                    var ch;\n                    var i;\n\n                    for (i = 1; i <= imnsxExprLen; i++) {\n                        ch = childToken.value[i];\n\n                        if (ch === \"-\") {\n                            imnsxVal = false;\n                        } else if (ch === \"i\") {\n                            constructs.isIgnoreCase = imnsxVal;\n                        } else if (ch === \"m\") {\n                            constructs.isMultiline = imnsxVal;\n                        } else if (ch === \"n\") {\n                            constructs.isExplicitCapture = imnsxVal;\n                        } else if (ch === \"s\") {\n                            constructs.isSingleLine = imnsxVal;\n                        } else if (ch === \"x\") {\n                            constructs.isIgnoreWhitespace = imnsxVal;\n                        }\n                    }\n                }\n\n                return constructs;\n            },\n\n            _validateGroupName: function (name) {\n                if (!name || !name.length) {\n                    throw new System.ArgumentException(\"Invalid group name: Group names must begin with a word character.\");\n                }\n\n                var isDigit = name[0] >= \"0\" && name[0] <= \"9\";\n                if (isDigit) {\n                    var scope = System.Text.RegularExpressions.RegexEngineParser;\n                    var res = scope._matchChars(name, 0, name.length, scope._decSymbols);\n                    if (res.matchLength !== name.length) {\n                        throw new System.ArgumentException(\"Invalid group name: Group names must begin with a word character.\");\n                    }\n                }\n\n                return {\n                    isNumberName: isDigit\n                };\n            },\n\n            _fillBalancingGroupInfo: function (groups, sparseSettings) {\n                var group;\n                var i;\n\n                // Assign name or id:\n                for (i = 0; i < groups.length; i++) {\n                    group = groups[i];\n\n                    if (group.constructs.name2 != null) {\n                        group.isBalancing = true;\n\n                        group.balancingSlotId = sparseSettings.getPackedSlotIdBySlotName(group.constructs.name2);\n                        if (group.balancingSlotId == null) {\n                            throw new System.ArgumentException(\"Reference to undefined group name '\" + group.constructs.name2 + \"'.\");\n                        }\n                    }\n                }\n            },\n\n            _preTransformBackrefTokens: function (pattern, tokens, sparseSettings) {\n                var scope = System.Text.RegularExpressions.RegexEngineParser;\n                var tokenTypes = scope.tokenTypes;\n\n                var groupNumber;\n                var octalCharToken;\n                var extraLength;\n                var literalToken;\n                var token;\n                var i;\n\n                for (i = 0; i < tokens.length; i++) {\n                    token = tokens[i];\n                    if (token.type === tokenTypes.escBackrefNumber) {\n                        groupNumber = token.data.number;\n\n                        if (groupNumber >= 1 && sparseSettings.getPackedSlotIdBySlotNumber(groupNumber) != null) {\n                            // Expressions from \\10 and greater are considered backreferences\n                            // if there is a group corresponding to that number;\n                            // otherwise, they are interpreted as octal codes.\n                            continue; // validated\n                        }\n\n                        if (groupNumber <= 9) {\n                            // The expressions \\1 through \\9 are always interpreted as backreferences, and not as octal codes.\n                            throw new System.ArgumentException(\"Reference to undefined group number \" + groupNumber.toString() + \".\");\n                        }\n\n                        // Otherwise, transform the token to OctalNumber:\n                        octalCharToken = scope._parseOctalCharToken(token.value, 0, token.length);\n                        if (octalCharToken == null) {\n                            throw new System.ArgumentException(\"Unrecognized escape sequence \" + token.value.slice(0, 2) + \".\");\n                        }\n\n                        extraLength = token.length - octalCharToken.length;\n                        scope._modifyPatternToken(token, pattern, tokenTypes.escCharOctal, null, octalCharToken.length);\n                        token.data = octalCharToken.data;\n\n                        if (extraLength > 0) {\n                            literalToken = scope._createPatternToken(pattern, tokenTypes.literal, token.index + token.length, extraLength);\n                            tokens.splice(i + 1, 0, literalToken);\n                        }\n                    }\n\n                    if (token.children && token.children.length) {\n                        scope._preTransformBackrefTokens(pattern, token.children, sparseSettings);\n                    }\n                }\n            },\n\n            _updateGroupDescriptors: function (tokens, parentIndex) {\n                var scope = System.Text.RegularExpressions.RegexEngineParser;\n                var tokenTypes = scope.tokenTypes;\n                var group;\n                var token;\n                var quantCandidateToken;\n                var childrenValue;\n                var childrenIndex;\n                var i;\n\n                var index = parentIndex || 0;\n                for (i = 0; i < tokens.length; i++) {\n                    token = tokens[i];\n                    token.index = index;\n\n                    // Calculate children indexes/lengths to update parent length:\n                    if (token.children) {\n                        childrenIndex = token.childrenPostfix.length;\n                        scope._updateGroupDescriptors(token.children, index + childrenIndex);\n\n                        // Update parent value if children have been changed:\n                        childrenValue = scope._constructPattern(token.children);\n                        token.value = token.childrenPrefix + childrenValue + token.childrenPostfix;\n                        token.length = token.value.length;\n                    }\n\n                    // Update group information:\n                    if (token.type === tokenTypes.group && token.group) {\n                        group = token.group;\n                        group.exprIndex = token.index;\n                        group.exprLength = token.length;\n\n                        if (i + 1 < tokens.length) {\n                            quantCandidateToken = tokens[i + 1];\n                            if (quantCandidateToken.type === tokenTypes.quantifier ||\n                                quantCandidateToken.type === tokenTypes.quantifierN ||\n                                quantCandidateToken.type === tokenTypes.quantifierNM) {\n                                group.quantifier = quantCandidateToken.value;\n                            }\n                        }\n\n                        group.expr = token.value;\n                        group.exprFull = group.expr + (group.quantifier != null ? group.quantifier : \"\");\n                    }\n\n                    // Update current index:\n                    index += token.length;\n                }\n            },\n\n            _constructPattern: function (tokens) {\n                var pattern = \"\";\n                var token;\n                var i;\n\n                for (i = 0; i < tokens.length; i++) {\n                    token = tokens[i];\n                    pattern += token.value;\n                }\n\n                return pattern;\n            },\n\n            _parsePatternImpl: function (pattern, settings, startIndex, endIndex) {\n                if (pattern == null) {\n                    throw new System.ArgumentNullException(\"pattern\");\n                }\n                if (startIndex < 0 || startIndex > pattern.length) {\n                    throw new System.ArgumentOutOfRangeException(\"startIndex\");\n                }\n                if (endIndex < startIndex || endIndex > pattern.length) {\n                    throw new System.ArgumentOutOfRangeException(\"endIndex\");\n                }\n\n                var scope = System.Text.RegularExpressions.RegexEngineParser;\n                var tokenTypes = scope.tokenTypes;\n                var tokens = [];\n                var token;\n                var ch;\n                var i;\n\n                i = startIndex;\n                while (i < endIndex) {\n                    ch = pattern[i];\n\n                    // Ignore whitespaces (if it was requested):\n                    if (settings.ignoreWhitespace && scope._whiteSpaceChars.indexOf(ch) >= 0) {\n                        ++i;\n                        continue;\n                    }\n\n                    if (ch === \".\") {\n                        token = scope._parseDotToken(pattern, i, endIndex);\n                    } else if (ch === \"\\\\\") {\n                        token = scope._parseEscapeToken(pattern, i, endIndex);\n                    } else if (ch === \"[\") {\n                        token = scope._parseCharRangeToken(pattern, i, endIndex);\n                    } else if (ch === \"^\" || ch === \"$\") {\n                        token = scope._parseAnchorToken(pattern, i);\n                    } else if (ch === \"(\") {\n                        token = scope._parseGroupToken(pattern, settings, i, endIndex);\n                    } else if (ch === \"|\") {\n                        token = scope._parseAlternationToken(pattern, i);\n                    } else if (ch === \"#\" && settings.ignoreWhitespace) {\n                        token = scope._parseXModeCommentToken(pattern, i, endIndex);\n                    } else {\n                        token = scope._parseQuantifierToken(pattern, i, endIndex);\n                    }\n\n                    if (token == null) {\n                        token = scope._createPatternToken(pattern, tokenTypes.literal, i, 1);\n                    }\n\n                    if (token != null) {\n                        tokens.push(token);\n                        i += token.length;\n                    }\n                }\n\n                return tokens;\n            },\n\n            _parseEscapeToken: function (pattern, i, endIndex) {\n                var scope = System.Text.RegularExpressions.RegexEngineParser;\n                var tokenTypes = scope.tokenTypes;\n\n                var ch = pattern[i];\n                if (ch !== \"\\\\\") {\n                    return null;\n                }\n                if (i + 1 >= endIndex) {\n                    throw new System.ArgumentException(\"Illegal \\\\ at end of pattern.\");\n                }\n\n                ch = pattern[i + 1];\n\n                // Parse a sequence for a numbered reference (\"Backreference Constructs\")\n                if (ch >= \"1\" && ch <= \"9\") {\n                    // check if the number is a group backreference\n                    var groupDigits = scope._matchChars(pattern, i + 1, endIndex, scope._decSymbols, 3); // assume: there are not more than 999 groups\n                    var backrefNumberToken = scope._createPatternToken(pattern, tokenTypes.escBackrefNumber, i, 1 + groupDigits.matchLength); // \"\\nnn\"\n                    backrefNumberToken.data = { number: parseInt(groupDigits.match, 10) };\n                    return backrefNumberToken;\n                }\n\n                // Parse a sequence for \"Anchors\"\n                if (scope._escapedAnchors.indexOf(ch) >= 0) {\n                    return scope._createPatternToken(pattern, tokenTypes.escAnchor, i, 2); // \"\\A\" or \"\\Z\" or \"\\z\" or \"\\G\" or \"\\b\" or \"\\B\"\n                }\n\n                // Parse a sequence for \"Character Escapes\" or \"Character Classes\"\n                var escapedCharToken = scope._parseEscapedChar(pattern, i, endIndex);\n                if (escapedCharToken != null) {\n                    return escapedCharToken;\n                }\n\n                // Parse a sequence for a named backreference (\"Backreference Constructs\")\n                if (ch === \"k\") {\n                    if (i + 2 < endIndex) {\n                        var nameQuoteCh = pattern[i + 2];\n                        if (nameQuoteCh === \"'\" || nameQuoteCh === \"<\") {\n                            var closingCh = nameQuoteCh === \"<\" ? \">\" : \"'\";\n                            var refNameChars = scope._matchUntil(pattern, i + 3, endIndex, closingCh);\n                            if (refNameChars.unmatchLength === 1 && refNameChars.matchLength > 0) {\n                                var backrefNameToken = scope._createPatternToken(pattern, tokenTypes.escBackrefName, i, 3 + refNameChars.matchLength + 1); // \"\\k<Name>\" or \"\\k'Name'\"\n                                backrefNameToken.data = { name: refNameChars.match };\n                                return backrefNameToken;\n                            }\n                        }\n                    }\n\n                    throw new System.ArgumentException(\"Malformed \\\\k<...> named back reference.\");\n                }\n\n                // Temp fix (until IsWordChar is not supported):\n                // See more: https://referencesource.microsoft.com/#System/regex/system/text/regularexpressions/RegexParser.cs,1414\n                // Unescaping of any of the following ASCII characters results in the character itself\n                var code = ch.charCodeAt(0);\n                if ((code >= 0 && code < 48) ||\n                    (code > 57 && code < 65) ||\n                    (code > 90 && code < 95) ||\n                    (code === 96) ||\n                    (code > 122 && code < 128)) {\n                    var token = scope._createPatternToken(pattern, tokenTypes.escChar, i, 2);\n                    token.data = { n: code, ch: ch };\n                    return token;\n                }\n\n                // Unrecognized escape sequence:\n                throw new System.ArgumentException(\"Unrecognized escape sequence \\\\\" + ch + \".\");\n            },\n\n            _parseOctalCharToken: function (pattern, i, endIndex) {\n                var scope = System.Text.RegularExpressions.RegexEngineParser;\n                var tokenTypes = scope.tokenTypes;\n\n                var ch = pattern[i];\n                if (ch === \"\\\\\" && i + 1 < endIndex) {\n                    ch = pattern[i + 1];\n\n                    if (ch >= \"0\" && ch <= \"7\") {\n                        var octalDigits = scope._matchChars(pattern, i + 1, endIndex, scope._octSymbols, 3);\n                        var octalVal = parseInt(octalDigits.match, 8);\n                        var token = scope._createPatternToken(pattern, tokenTypes.escCharOctal, i, 1 + octalDigits.matchLength); // \"\\0\" or \"\\nn\" or \"\\nnn\"\n                        token.data = { n: octalVal, ch: String.fromCharCode(octalVal) };\n                        return token;\n                    }\n                }\n\n                return null;\n            },\n\n            _parseEscapedChar: function (pattern, i, endIndex) {\n                var scope = System.Text.RegularExpressions.RegexEngineParser;\n                var tokenTypes = scope.tokenTypes;\n                var token;\n\n                var ch = pattern[i];\n                if (ch !== \"\\\\\" || i + 1 >= endIndex) {\n                    return null;\n                }\n\n                ch = pattern[i + 1];\n\n                // Parse a sequence for \"Character Escapes\"\n                if (scope._escapedChars.indexOf(ch) >= 0) {\n                    if (ch === \"x\") {\n                        var hexDigits = scope._matchChars(pattern, i + 2, endIndex, scope._hexSymbols, 2);\n                        if (hexDigits.matchLength !== 2) {\n                            throw new System.ArgumentException(\"Insufficient hexadecimal digits.\");\n                        }\n\n                        var hexVal = parseInt(hexDigits.match, 16);\n                        token = scope._createPatternToken(pattern, tokenTypes.escCharHex, i, 4); // \"\\xnn\"\n                        token.data = { n: hexVal, ch: String.fromCharCode(hexVal) };\n                        return token;\n                    } else if (ch === \"c\") {\n                        if (i + 2 >= endIndex) {\n                            throw new System.ArgumentException(\"Missing control character.\");\n                        }\n\n                        var ctrlCh = pattern[i + 2];\n                        ctrlCh = ctrlCh.toUpperCase();\n                        var ctrlIndex = this._controlChars.indexOf(ctrlCh);\n                        if (ctrlIndex >= 0) {\n                            token = scope._createPatternToken(pattern, tokenTypes.escCharCtrl, i, 3); // \"\\cx\" or \"\\cX\"\n                            token.data = { n: ctrlIndex, ch: String.fromCharCode(ctrlIndex) };\n                            return token;\n                        }\n\n                        throw new System.ArgumentException(\"Unrecognized control character.\");\n                    } else if (ch === \"u\") {\n                        var ucodeDigits = scope._matchChars(pattern, i + 2, endIndex, scope._hexSymbols, 4);\n                        if (ucodeDigits.matchLength !== 4) {\n                            throw new System.ArgumentException(\"Insufficient hexadecimal digits.\");\n                        }\n\n                        var ucodeVal = parseInt(ucodeDigits.match, 16);\n                        token = scope._createPatternToken(pattern, tokenTypes.escCharUnicode, i, 6); // \"\\unnnn\"\n                        token.data = { n: ucodeVal, ch: String.fromCharCode(ucodeVal) };\n                        return token;\n                    }\n\n                    token = scope._createPatternToken(pattern, tokenTypes.escChar, i, 2); // \"\\a\" or \"\\b\" or \"\\t\" or \"\\r\" or \"\\v\" or \"f\" or \"n\" or \"e\"-\n                    var escVal;\n                    switch (ch) {\n                        case \"a\":\n                            escVal = 7;\n                            break;\n                        case \"b\":\n                            escVal = 8;\n                            break;\n                        case \"t\":\n                            escVal = 9;\n                            break;\n                        case \"r\":\n                            escVal = 13;\n                            break;\n                        case \"v\":\n                            escVal = 11;\n                            break;\n                        case \"f\":\n                            escVal = 12;\n                            break;\n                        case \"n\":\n                            escVal = 10;\n                            break;\n                        case \"e\":\n                            escVal = 27;\n                            break;\n\n                        default:\n                            throw new System.ArgumentException(\"Unexpected escaped char: '\" + ch + \"'.\");\n                    }\n\n                    token.data = { n: escVal, ch: String.fromCharCode(escVal) };\n                    return token;\n                }\n\n                // Parse a sequence for an octal character(\"Character Escapes\")\n                if (ch >= \"0\" && ch <= \"7\") {\n                    var octalCharToken = scope._parseOctalCharToken(pattern, i, endIndex);\n                    return octalCharToken;\n                }\n\n                // Parse a sequence for \"Character Classes\"\n                if (scope._escapedCharClasses.indexOf(ch) >= 0) {\n                    if (ch === \"p\" || ch === \"P\") {\n                        var catNameChars = scope._matchUntil(pattern, i + 2, endIndex, \"}\"); // the longest category name is 37 + 2 brackets, but .NET does not limit the value on this step\n                        if (catNameChars.matchLength < 2 || catNameChars.match[0] !== \"{\" || catNameChars.unmatchLength !== 1) {\n                            throw new System.ArgumentException(\"Incomplete \\p{X} character escape.\");\n                        }\n\n                        var catName = catNameChars.match.slice(1);\n\n                        if (scope._unicodeCategories.indexOf(catName) >= 0) {\n                            return scope._createPatternToken(pattern, tokenTypes.escCharClassCategory, i, 2 + catNameChars.matchLength + 1); // \"\\p{Name}\" or \"\\P{Name}\"\n                        }\n\n                        if (scope._namedCharBlocks.indexOf(catName) >= 0) {\n                            return scope._createPatternToken(pattern, tokenTypes.escCharClassBlock, i, 2 + catNameChars.matchLength + 1); // \"\\p{Name}\" or \"\\P{Name}\"\n                        }\n\n                        throw new System.ArgumentException(\"Unknown property '\" + catName + \"'.\");\n                    }\n\n                    return scope._createPatternToken(pattern, tokenTypes.escCharClass, i, 2); // \"\\w\" or \"\\W\" or \"\\s\" or \"\\S\" or \"\\d\" or \"\\D\"\n                }\n\n                // Some other literal\n                if (scope._escapedSpecialSymbols.indexOf(ch) >= 0) {\n                    token = scope._createPatternToken(pattern, tokenTypes.escCharOther, i, 2); // \"\\.\" or \"\\$\" or ... \"\\\\\"\n                    token.data = { n: ch.charCodeAt(0), ch: ch };\n                    return token;\n                }\n\n                return null;\n            },\n\n            _parseCharRangeToken: function (pattern, i, endIndex) {\n                var scope = System.Text.RegularExpressions.RegexEngineParser;\n                var tokenTypes = scope.tokenTypes;\n                var tokens = [];\n                var intervalToken;\n                var substractToken;\n                var token;\n                var isNegative = false;\n                var noMoreTokenAllowed = false;\n                var hasSubstractToken = false;\n\n                var ch = pattern[i];\n                if (ch !== \"[\") {\n                    return null;\n                }\n\n                var index = i + 1;\n                var closeBracketIndex = -1;\n                var toInc;\n\n                if (index < endIndex && pattern[index] === \"^\") {\n                    isNegative = true;\n                    index ++;\n                }\n\n                var startIndex = index;\n                while (index < endIndex) {\n                    ch = pattern[index];\n\n                    noMoreTokenAllowed = hasSubstractToken;\n\n                    if (ch === \"-\" && index + 1 < endIndex && pattern[index + 1] === \"[\") {\n                        substractToken = scope._parseCharRangeToken(pattern, index + 1, endIndex);\n                        substractToken.childrenPrefix = \"-\" + substractToken.childrenPrefix;\n                        substractToken.length ++;\n                        token = substractToken;\n                        toInc = substractToken.length;\n                        hasSubstractToken = true;\n                    } else if (ch === \"\\\\\") {\n                        token = scope._parseEscapedChar(pattern, index, endIndex);\n                        if (token == null) {\n                            throw new System.ArgumentException(\"Unrecognized escape sequence \\\\\" + ch + \".\");\n                        }\n                        toInc = token.length;\n                    } else if (ch === \"]\" && index > startIndex) {\n                        closeBracketIndex = index;\n                        break;\n                    } else {\n                        token = scope._createPatternToken(pattern, tokenTypes.literal, index, 1);\n                        toInc = 1;\n                    }\n\n                    if (noMoreTokenAllowed) {\n                        throw new System.ArgumentException(\"A subtraction must be the last element in a character class.\");\n                    }\n\n                    // Check for interval:\n                    if (tokens.length > 1) {\n                        intervalToken = scope._parseCharIntervalToken(pattern, tokens[tokens.length - 2], tokens[tokens.length - 1], token);\n                        if (intervalToken != null) {\n                            tokens.pop(); //pop Dush\n                            tokens.pop(); //pop Interval start\n                            token = intervalToken;\n                        }\n                    }\n\n                    // Add token:\n                    if (token != null) {\n                        tokens.push(token);\n                        index += toInc;\n                    }\n                }\n\n                if (closeBracketIndex < 0 || tokens.length < 1) {\n                    throw new System.ArgumentException(\"Unterminated [] set.\");\n                }\n\n                var groupToken;\n                if (!isNegative) {\n                    groupToken = scope._createPatternToken(pattern, tokenTypes.charGroup, i, 1 + closeBracketIndex - i, tokens, \"[\", \"]\");\n                } else {\n                    groupToken = scope._createPatternToken(pattern, tokenTypes.charNegativeGroup, i, 1 + closeBracketIndex - i, tokens, \"[^\", \"]\");\n                }\n\n                // Create full range data:\n                var ranges = scope._tidyCharRange(tokens);\n                groupToken.data = { ranges: ranges };\n                if (substractToken != null) {\n                    groupToken.data.substractToken = substractToken;\n                }\n\n                return groupToken;\n            },\n\n            _parseCharIntervalToken: function (pattern, intervalStartToken, dashToken, intervalEndToken) {\n                var scope = System.Text.RegularExpressions.RegexEngineParser;\n                var tokenTypes = scope.tokenTypes;\n\n                if (dashToken.type !== tokenTypes.literal || dashToken.value !== \"-\") {\n                    return null;\n                }\n\n                if (intervalStartToken.type !== tokenTypes.literal &&\n                    intervalStartToken.type !== tokenTypes.escChar &&\n                    intervalStartToken.type !== tokenTypes.escCharOctal &&\n                    intervalStartToken.type !== tokenTypes.escCharHex &&\n                    intervalStartToken.type !== tokenTypes.escCharCtrl &&\n                    intervalStartToken.type !== tokenTypes.escCharUnicode &&\n                    intervalStartToken.type !== tokenTypes.escCharOther) {\n                    return null;\n                }\n\n                if (intervalEndToken.type !== tokenTypes.literal &&\n                    intervalEndToken.type !== tokenTypes.escChar &&\n                    intervalEndToken.type !== tokenTypes.escCharOctal &&\n                    intervalEndToken.type !== tokenTypes.escCharHex &&\n                    intervalEndToken.type !== tokenTypes.escCharCtrl &&\n                    intervalEndToken.type !== tokenTypes.escCharUnicode &&\n                    intervalEndToken.type !== tokenTypes.escCharOther) {\n                    return null;\n                }\n\n                var startN;\n                var startCh;\n                if (intervalStartToken.type === tokenTypes.literal) {\n                    startN = intervalStartToken.value.charCodeAt(0);\n                    startCh = intervalStartToken.value;\n                } else {\n                    startN = intervalStartToken.data.n;\n                    startCh = intervalStartToken.data.ch;\n                }\n\n                var endN;\n                var endCh;\n                if (intervalEndToken.type === tokenTypes.literal) {\n                    endN = intervalEndToken.value.charCodeAt(0);\n                    endCh = intervalEndToken.value;\n                } else {\n                    endN = intervalEndToken.data.n;\n                    endCh = intervalEndToken.data.ch;\n                }\n\n                if (startN > endN) {\n                    throw new System.NotSupportedException(\"[x-y] range in reverse order.\");\n                }\n\n                var index = intervalStartToken.index;\n                var length = intervalStartToken.length + dashToken.length + intervalEndToken.length;\n                var intervalToken = scope._createPatternToken(pattern, tokenTypes.charInterval, index, length, [intervalStartToken, dashToken, intervalEndToken], \"\", \"\");\n\n                intervalToken.data = {\n                    startN: startN,\n                    startCh: startCh,\n                    endN: endN,\n                    endCh: endCh\n                };\n\n                return intervalToken;\n            },\n\n            _tidyCharRange: function (tokens) {\n                var scope = System.Text.RegularExpressions.RegexEngineParser;\n                var tokenTypes = scope.tokenTypes;\n\n                var j;\n                var k;\n                var n;\n                var m;\n                var token;\n                var ranges = [];\n                var classTokens = [];\n\n                var range;\n                var nextRange;\n                var toSkip;\n\n                for (j = 0; j < tokens.length; j++) {\n                    token = tokens[j];\n\n                    if (token.type === tokenTypes.literal) {\n                        n = token.value.charCodeAt(0);\n                        m = n;\n                    } else if (token.type === tokenTypes.charInterval) {\n                        n = token.data.startN;\n                        m = token.data.endN;\n                    } else if (token.type === tokenTypes.literal ||\n                        token.type === tokenTypes.escChar ||\n                        token.type === tokenTypes.escCharOctal ||\n                        token.type === tokenTypes.escCharHex ||\n                        token.type === tokenTypes.escCharCtrl ||\n                        token.type === tokenTypes.escCharUnicode ||\n                        token.type === tokenTypes.escCharOther) {\n                        n = token.data.n;\n                        m = n;\n                    } else if (\n                        token.type === tokenTypes.charGroup ||\n                        token.type === tokenTypes.charNegativeGroup) {\n                        continue;\n                    } else {\n                        classTokens.push(token);\n                        continue;\n                    }\n\n                    if (ranges.length === 0) {\n                        ranges.push({ n: n, m: m });\n                        continue;\n                    }\n\n                    //TODO: [Performance] Use binary search\n                    for (k = 0; k < ranges.length; k++) {\n                        if (ranges[k].n > n) {\n                            break;\n                        }\n                    }\n\n                    ranges.splice(k, 0, { n: n, m: m });\n                }\n\n                // Combine ranges:\n                for (j = 0; j < ranges.length; j++) {\n                    range = ranges[j];\n\n                    toSkip = 0;\n                    for (k = j + 1; k < ranges.length; k++) {\n                        nextRange = ranges[k];\n                        if (nextRange.n > 1 + range.m) {\n                            break;\n                        }\n                        toSkip++;\n                        if (nextRange.m > range.m) {\n                            range.m = nextRange.m;\n                        }\n                    }\n                    if (toSkip > 0) {\n                        ranges.splice(j + 1, toSkip);\n                    }\n                }\n\n                if (classTokens.length > 0) {\n                    var charClassStr = \"[\" + scope._constructPattern(classTokens) + \"]\";\n                    ranges.charClassToken = scope._createPatternToken(charClassStr, tokenTypes.charGroup, 0, charClassStr.length, tokens, \"[\", \"]\");\n                }\n\n                return ranges;\n            },\n\n            _parseDotToken: function (pattern, i) {\n                var scope = System.Text.RegularExpressions.RegexEngineParser;\n                var tokenTypes = scope.tokenTypes;\n\n                var ch = pattern[i];\n                if (ch !== \".\") {\n                    return null;\n                }\n\n                return scope._createPatternToken(pattern, tokenTypes.escCharClassDot, i, 1);\n            },\n\n            _parseAnchorToken: function (pattern, i) {\n                var scope = System.Text.RegularExpressions.RegexEngineParser;\n                var tokenTypes = scope.tokenTypes;\n\n                var ch = pattern[i];\n                if (ch !== \"^\" && ch !== \"$\") {\n                    return null;\n                }\n\n                return scope._createPatternToken(pattern, tokenTypes.anchor, i, 1);\n            },\n\n            _updateSettingsFromConstructs: function (settings, constructs) {\n                if (constructs.isIgnoreWhitespace != null) {\n                    settings.ignoreWhitespace = constructs.isIgnoreWhitespace;\n                }\n                if (constructs.isExplicitCapture != null) {\n                    settings.explicitCapture = constructs.isExplicitCapture;\n                }\n            },\n\n            _parseGroupToken: function (pattern, settings, i, endIndex) {\n                var scope = System.Text.RegularExpressions.RegexEngineParser;\n                var tokenTypes = scope.tokenTypes;\n                var groupSettings = {\n                    ignoreWhitespace: settings.ignoreWhitespace,\n                    explicitCapture: settings.explicitCapture\n                };\n\n                var ch = pattern[i];\n                if (ch !== \"(\") {\n                    return null;\n                }\n\n                var bracketLvl = 1;\n                var sqBracketCtx = false;\n                var bodyIndex = i + 1;\n                var closeBracketIndex = -1;\n\n                var isComment = false;\n                var isAlternation = false;\n                var isInlineOptions = false;\n                var isImnsxConstructed = false;\n                var isNonCapturingExplicit = false;\n\n                var grConstructs = null;\n\n                // Parse the Group construct, if any:\n                var constructToken = scope._parseGroupConstructToken(pattern, groupSettings, i + 1, endIndex);\n                if (constructToken != null) {\n                    grConstructs = this._fillGroupConstructs(constructToken);\n\n                    bodyIndex += constructToken.length;\n                    if (constructToken.type === tokenTypes.commentInline) {\n                        isComment = true;\n                    } else if (constructToken.type === tokenTypes.alternationGroupCondition) {\n                        isAlternation = true;\n                    } else if (constructToken.type === tokenTypes.groupConstructImnsx) {\n                        this._updateSettingsFromConstructs(groupSettings, grConstructs);\n                        isImnsxConstructed = true;\n                    } else if (constructToken.type === tokenTypes.groupConstructImnsxMisc) {\n                        this._updateSettingsFromConstructs(settings, grConstructs); // parent settings!\n                        isInlineOptions = true;\n                    }\n                }\n\n                if (groupSettings.explicitCapture && (grConstructs == null || grConstructs.name1 == null)) {\n                    isNonCapturingExplicit = true;\n                }\n\n                var index = bodyIndex;\n                while (index < endIndex) {\n                    ch = pattern[index];\n\n                    if (ch === \"\\\\\") {\n                        index ++; // skip the escaped char\n                    } else if (ch === \"[\") {\n                        sqBracketCtx = true;\n                    } else if (ch === \"]\" && sqBracketCtx) {\n                        sqBracketCtx = false;\n                    } else if (!sqBracketCtx) {\n                        if (ch === \"(\" && !isComment) {\n                            ++bracketLvl;\n                        } else if (ch === \")\") {\n                            --bracketLvl;\n                            if (bracketLvl === 0) {\n                                closeBracketIndex = index;\n                                break;\n                            }\n                        }\n                    }\n\n                    ++index;\n                }\n\n                var result = null;\n\n                if (isComment) {\n                    if (closeBracketIndex < 0) {\n                        throw new System.ArgumentException(\"Unterminated (?#...) comment.\");\n                    }\n\n                    result = scope._createPatternToken(pattern, tokenTypes.commentInline, i, 1 + closeBracketIndex - i);\n                } else {\n                    if (closeBracketIndex < 0) {\n                        throw new System.ArgumentException(\"Not enough )'s.\");\n                    }\n\n                    // Parse the \"Body\" of the group\n                    var innerTokens = scope._parsePatternImpl(pattern, groupSettings, bodyIndex, closeBracketIndex);\n                    if (constructToken != null) {\n                        innerTokens.splice(0, 0, constructToken);\n                    }\n\n                    // If there is an Alternation expression, treat the group as Alternation group\n                    if (isAlternation) {\n                        var innerTokensLen = innerTokens.length;\n                        var innerToken;\n                        var j;\n\n                        // Check that there is only 1 alternation symbol:\n                        var altCount = 0;\n                        for (j = 0; j < innerTokensLen; j++) {\n                            innerToken = innerTokens[j];\n                            if (innerToken.type === tokenTypes.alternation) {\n                                ++altCount;\n                                if (altCount > 1) {\n                                    throw new System.ArgumentException(\"Too many | in (?()|).\");\n                                }\n                            }\n                        }\n                        if (altCount === 0) {\n                            // Though .NET works with this case, it ends up with unexpected result. Let's avoid this behaviour.\n                            throw new System.NotSupportedException(\"Alternation group without | is not supported.\");\n                        }\n\n                        var altGroupToken = scope._createPatternToken(pattern, tokenTypes.alternationGroup, i, 1 + closeBracketIndex - i, innerTokens, \"(\", \")\");\n                        result = altGroupToken;\n                    } else {\n                        // Create Group token:\n                        var tokenType = tokenTypes.group;\n                        if (isInlineOptions) {\n                            tokenType = tokenTypes.groupImnsxMisc;\n                        } else if (isImnsxConstructed) {\n                            tokenType = tokenTypes.groupImnsx;\n                        }\n\n                        var groupToken = scope._createPatternToken(pattern, tokenType, i, 1 + closeBracketIndex - i, innerTokens, \"(\", \")\");\n                        groupToken.localSettings = groupSettings;\n                        result = groupToken;\n                    }\n                }\n\n                if (isNonCapturingExplicit) {\n                    result.isNonCapturingExplicit = true;\n                }\n\n                return result;\n            },\n\n            _parseGroupConstructToken: function (pattern, settings, i, endIndex) {\n                // ?<name1>\n                // ?'name1'\n                // ?<name1-name2>\n                // ?'name1-name2'\n                // ?:\n                // ?imnsx-imnsx\n                // ?=\n                // ?!\n                // ?<=\n                // ?<!\n                // ?>\n                // ?#\n\n                var scope = System.Text.RegularExpressions.RegexEngineParser;\n                var tokenTypes = scope.tokenTypes;\n\n                var ch = pattern[i];\n                if (ch !== \"?\" || i + 1 >= endIndex) {\n                    return null;\n                }\n\n                ch = pattern[i + 1];\n                if (ch === \":\" || ch === \"=\" || ch === \"!\" || ch === \">\") {\n                    return scope._createPatternToken(pattern, tokenTypes.groupConstruct, i, 2);\n                }\n\n                if (ch === \"#\") {\n                    return scope._createPatternToken(pattern, tokenTypes.commentInline, i, 2);\n                }\n\n                if (ch === \"(\") {\n                    return scope._parseAlternationGroupConditionToken(pattern, settings, i, endIndex);\n                }\n\n                if (ch === \"<\" && i + 2 < endIndex) {\n                    var ch3 = pattern[i + 2];\n                    if (ch3 === \"=\" || ch3 === \"!\") {\n                        return scope._createPatternToken(pattern, tokenTypes.groupConstruct, i, 3);\n                    }\n                }\n\n                if (ch === \"<\" || ch === \"'\") {\n                    var closingCh = ch === \"<\" ? \">\" : ch;\n                    var nameChars = scope._matchUntil(pattern, i + 2, endIndex, closingCh);\n                    if (nameChars.unmatchLength !== 1 || nameChars.matchLength === 0) {\n                        throw new System.ArgumentException(\"Unrecognized grouping construct.\");\n                    }\n\n                    var nameFirstCh = nameChars.match.slice(0, 1);\n                    if (\"`~@#$%^&*()+{}[]|\\\\/|'\\\";:,.?\".indexOf(nameFirstCh) >= 0) {\n                        // TODO: replace the \"black list\" of wrong characters with char class check:\n                        // According to UTS#18 Unicode Regular Expressions (http://www.unicode.org/reports/tr18/)\n                        // RL 1.4 Simple Word Boundaries  The class of <word_character> includes all Alphabetic\n                        // values from the Unicode character database, from UnicodeData.txt [UData], plus the U+200C\n                        // ZERO WIDTH NON-JOINER and U+200D ZERO WIDTH JOINER.\n                        throw new System.ArgumentException(\"Invalid group name: Group names must begin with a word character.\");\n                    }\n\n                    return scope._createPatternToken(pattern, tokenTypes.groupConstructName, i, 2 + nameChars.matchLength + 1);\n                }\n\n                var imnsxChars = scope._matchChars(pattern, i + 1, endIndex, \"imnsx-\");\n                if (imnsxChars.matchLength > 0 && (imnsxChars.unmatchCh === \":\" || imnsxChars.unmatchCh === \")\")) {\n                    var imnsxTokenType = imnsxChars.unmatchCh === \":\" ? tokenTypes.groupConstructImnsx : tokenTypes.groupConstructImnsxMisc;\n                    var imnsxPostfixLen = imnsxChars.unmatchCh === \":\" ? 1 : 0;\n                    return scope._createPatternToken(pattern, imnsxTokenType, i, 1 + imnsxChars.matchLength + imnsxPostfixLen);\n                }\n\n                throw new System.ArgumentException(\"Unrecognized grouping construct.\");\n            },\n\n            _parseQuantifierToken: function (pattern, i, endIndex) {\n                var scope = System.Text.RegularExpressions.RegexEngineParser;\n                var tokenTypes = scope.tokenTypes;\n                var token = null;\n\n                var ch = pattern[i];\n\n                if (ch === \"*\" || ch === \"+\" || ch === \"?\") {\n                    token = scope._createPatternToken(pattern, tokenTypes.quantifier, i, 1);\n                    token.data = { val: ch };\n                } else if (ch === \"{\") {\n                    var dec1Chars = scope._matchChars(pattern, i + 1, endIndex, scope._decSymbols);\n                    if (dec1Chars.matchLength !== 0) {\n                        if (dec1Chars.unmatchCh === \"}\") {\n                            token = scope._createPatternToken(pattern, tokenTypes.quantifierN, i, 1 + dec1Chars.matchLength + 1);\n                            token.data = {\n                                n: parseInt(dec1Chars.match, 10)\n                            };\n                        } else if (dec1Chars.unmatchCh === \",\") {\n                            var dec2Chars = scope._matchChars(pattern, dec1Chars.unmatchIndex + 1, endIndex, scope._decSymbols);\n                            if (dec2Chars.unmatchCh === \"}\") {\n                                token = scope._createPatternToken(pattern, tokenTypes.quantifierNM, i, 1 + dec1Chars.matchLength + 1 + dec2Chars.matchLength + 1);\n                                token.data = {\n                                    n: parseInt(dec1Chars.match, 10),\n                                    m: null\n                                };\n                                if (dec2Chars.matchLength !== 0) {\n                                    token.data.m = parseInt(dec2Chars.match, 10);\n                                    if (token.data.n > token.data.m) {\n                                        throw new System.ArgumentException(\"Illegal {x,y} with x > y.\");\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n\n                if (token != null) {\n                    var nextChIndex = i + token.length;\n                    if (nextChIndex < endIndex) {\n                        var nextCh = pattern[nextChIndex];\n                        if (nextCh === \"?\") {\n                            this._modifyPatternToken(token, pattern, token.type, token.index, token.length + 1);\n                            token.data.isLazy = true;\n                        }\n                    }\n                }\n\n                return token;\n            },\n\n            _parseAlternationToken: function (pattern, i) {\n                var scope = System.Text.RegularExpressions.RegexEngineParser;\n                var tokenTypes = scope.tokenTypes;\n\n                var ch = pattern[i];\n                if (ch !== \"|\") {\n                    return null;\n                }\n\n                return scope._createPatternToken(pattern, tokenTypes.alternation, i, 1);\n            },\n\n            _parseAlternationGroupConditionToken: function (pattern, settings, i, endIndex) {\n                var scope = System.Text.RegularExpressions.RegexEngineParser;\n                var tokenTypes = scope.tokenTypes;\n                var constructToken;\n                var childToken;\n                var data = null;\n\n                var ch = pattern[i];\n                if (ch !== \"?\" || i + 1 >= endIndex || pattern[i + 1] !== \"(\") {\n                    return null;\n                }\n\n                // Parse Alternation condition as a group:\n                var expr = scope._parseGroupToken(pattern, settings, i + 1, endIndex);\n                if (expr == null) {\n                    return null;\n                }\n                if (expr.type === tokenTypes.commentInline) {\n                    throw new System.ArgumentException(\"Alternation conditions cannot be comments.\");\n                }\n\n                var children = expr.children;\n                if (children && children.length) {\n                    constructToken = children[0];\n                    if (constructToken.type === tokenTypes.groupConstructName) {\n                        throw new System.ArgumentException(\"Alternation conditions do not capture and cannot be named.\");\n                    }\n\n                    if (constructToken.type === tokenTypes.groupConstruct || constructToken.type === tokenTypes.groupConstructImnsx) {\n                        childToken = scope._findFirstGroupWithoutConstructs(children);\n                        if (childToken != null) {\n                            childToken.isEmptyCapturing = true;\n                        }\n                    }\n\n                    if (constructToken.type === tokenTypes.literal) {\n                        var literalVal = expr.value.slice(1, expr.value.length - 1);\n                        var isDigit = literalVal[0] >= \"0\" && literalVal[0] <= \"9\";\n                        if (isDigit) {\n                            var res = scope._matchChars(literalVal, 0, literalVal.length, scope._decSymbols);\n                            if (res.matchLength !== literalVal.length) {\n                                throw new System.ArgumentException(\"Malformed Alternation group number: \" + literalVal + \".\");\n                            }\n\n                            var number = parseInt(literalVal, 10);\n                            data = { number: number };\n                        } else {\n                            data = { name: literalVal };\n                        }\n                    }\n                }\n\n                // Add \"Noncapturing\" construct if there are no other ones.\n                if (!children.length || (children[0].type !== tokenTypes.groupConstruct && children[0].type !== tokenTypes.groupConstructImnsx)) {\n                    constructToken = scope._createPatternToken(\"?:\", tokenTypes.groupConstruct, 0, 2);\n                    children.splice(0, 0, constructToken);\n                }\n\n                // Transform Group token to Alternation expression token:\n                var token = scope._createPatternToken(pattern, tokenTypes.alternationGroupCondition, expr.index - 1, 1 + expr.length, [expr], \"?\", \"\");\n                if (data != null) {\n                    token.data = data;\n                }\n                return token;\n            },\n\n            _findFirstGroupWithoutConstructs: function (tokens) {\n                var scope = System.Text.RegularExpressions.RegexEngineParser;\n                var tokenTypes = scope.tokenTypes;\n                var result = null;\n                var token;\n                var i;\n\n                for (i = 0; i < tokens.length; ++i) {\n                    token = tokens[i];\n                    if (token.type === tokenTypes.group && token.children && token.children.length) {\n                        if (token.children[0].type !== tokenTypes.groupConstruct && token.children[0].type !== tokenTypes.groupConstructImnsx) {\n                            result = token;\n                            break;\n                        }\n\n                        if (token.children && token.children.length) {\n                            result = scope._findFirstGroupWithoutConstructs(token.children);\n                            if (result != null) {\n                                break;\n                            }\n                        }\n                    }\n                }\n\n                return result;\n            },\n\n            _parseXModeCommentToken: function (pattern, i, endIndex) {\n                var scope = System.Text.RegularExpressions.RegexEngineParser;\n                var tokenTypes = scope.tokenTypes;\n\n                var ch = pattern[i];\n                if (ch !== \"#\") {\n                    return null;\n                }\n\n                var index = i + 1;\n                while (index < endIndex) {\n                    ch = pattern[index];\n                    ++index; // index should be changed before breaking\n\n                    if (ch === \"\\n\") {\n                        break;\n                    }\n                }\n\n                return scope._createPatternToken(pattern, tokenTypes.commentXMode, i, index - i);\n            },\n\n            _createLiteralToken: function (body) {\n                var scope = System.Text.RegularExpressions.RegexEngineParser;\n                var token = scope._createPatternToken(body, scope.tokenTypes.literal, 0, body.length);\n                return token;\n            },\n\n            _createPositiveLookaheadToken: function (body, settings) {\n                var scope = System.Text.RegularExpressions.RegexEngineParser;\n\n                var pattern = \"(?=\" + body + \")\";\n                var groupToken = scope._parseGroupToken(pattern, settings, 0, pattern.length);\n\n                return groupToken;\n            },\n\n            _createPatternToken: function (pattern, type, i, len, innerTokens, innerTokensPrefix, innerTokensPostfix) {\n                var token = {\n                    type: type,\n                    index: i,\n                    length: len,\n                    value: pattern.slice(i, i + len)\n                };\n\n                if (innerTokens != null && innerTokens.length > 0) {\n                    token.children = innerTokens;\n                    token.childrenPrefix = innerTokensPrefix;\n                    token.childrenPostfix = innerTokensPostfix;\n                }\n\n                return token;\n            },\n\n            _modifyPatternToken: function (token, pattern, type, i, len) {\n                if (type != null) {\n                    token.type = type;\n                }\n\n                if (i != null || len != null) {\n                    if (i != null) {\n                        token.index = i;\n                    }\n                    if (len != null) {\n                        token.length = len;\n                    }\n\n                    token.value = pattern.slice(token.index, token.index + token.length);\n                }\n            },\n\n            _updatePatternToken: function (token, type, i, len, value) {\n                token.type = type;\n                token.index = i;\n                token.length = len;\n                token.value = value;\n            },\n\n            _matchChars: function (str, startIndex, endIndex, allowedChars, maxLength) {\n                var res = {\n                    match: \"\",\n                    matchIndex: -1,\n                    matchLength: 0,\n                    unmatchCh: \"\",\n                    unmatchIndex: -1,\n                    unmatchLength: 0\n                };\n\n                var index = startIndex;\n                var ch;\n\n                if (maxLength != null && maxLength >= 0) {\n                    endIndex = startIndex + maxLength;\n                }\n\n                while (index < endIndex) {\n                    ch = str[index];\n\n                    if (allowedChars.indexOf(ch) < 0) {\n                        res.unmatchCh = ch;\n                        res.unmatchIndex = index;\n                        res.unmatchLength = 1;\n                        break;\n                    }\n\n                    index++;\n                }\n\n                if (index > startIndex) {\n                    res.match = str.slice(startIndex, index);\n                    res.matchIndex = startIndex;\n                    res.matchLength = index - startIndex;\n                }\n\n                return res;\n            },\n\n            _matchUntil: function (str, startIndex, endIndex, unallowedChars, maxLength) {\n                var res = {\n                    match: \"\",\n                    matchIndex: -1,\n                    matchLength: 0,\n                    unmatchCh: \"\",\n                    unmatchIndex: -1,\n                    unmatchLength: 0\n                };\n\n                var index = startIndex;\n                var ch;\n\n                if (maxLength != null && maxLength >= 0) {\n                    endIndex = startIndex + maxLength;\n                }\n\n                while (index < endIndex) {\n                    ch = str[index];\n\n                    if (unallowedChars.indexOf(ch) >= 0) {\n                        res.unmatchCh = ch;\n                        res.unmatchIndex = index;\n                        res.unmatchLength = 1;\n                        break;\n                    }\n\n                    index++;\n                }\n\n                if (index > startIndex) {\n                    res.match = str.slice(startIndex, index);\n                    res.matchIndex = startIndex;\n                    res.matchLength = index - startIndex;\n                }\n\n                return res;\n            }\n        }\n    });\n\n    // @source encoding.js\n\n    Bridge.define(\"System.Text.Encoding\", {\n        statics: {\n            fields: {\n                _encodings: null\n            },\n            props: {\n                Default: null,\n                Unicode: null,\n                ASCII: null,\n                BigEndianUnicode: null,\n                UTF7: null,\n                UTF8: null,\n                UTF32: null\n            },\n            ctors: {\n                init: function () {\n                    this.Default = new System.Text.UnicodeEncoding.$ctor1(false, true);\n                    this.Unicode = new System.Text.UnicodeEncoding.$ctor1(false, true);\n                    this.ASCII = new System.Text.ASCIIEncoding();\n                    this.BigEndianUnicode = new System.Text.UnicodeEncoding.$ctor1(true, true);\n                    this.UTF7 = new System.Text.UTF7Encoding.ctor();\n                    this.UTF8 = new System.Text.UTF8Encoding.ctor();\n                    this.UTF32 = new System.Text.UTF32Encoding.$ctor1(false, true);\n                }\n            },\n            methods: {\n                Convert: function (srcEncoding, dstEncoding, bytes) {\n                    return System.Text.Encoding.Convert$1(srcEncoding, dstEncoding, bytes, 0, bytes.length);\n                },\n                Convert$1: function (srcEncoding, dstEncoding, bytes, index, count) {\n                    if (srcEncoding == null || dstEncoding == null) {\n                        throw new System.ArgumentNullException(srcEncoding == null ? \"srcEncoding\" : \"dstEncoding\");\n                    }\n\n                    if (bytes == null) {\n                        throw new System.ArgumentNullException(\"bytes\");\n                    }\n\n                    return dstEncoding.GetBytes(srcEncoding.GetChars$1(bytes, index, count));\n                },\n                GetEncoding: function (codepage) {\n                    switch (codepage) {\n                        case 1200: \n                            return System.Text.Encoding.Unicode;\n                        case 20127: \n                            return System.Text.Encoding.ASCII;\n                        case 1201: \n                            return System.Text.Encoding.BigEndianUnicode;\n                        case 65000: \n                            return System.Text.Encoding.UTF7;\n                        case 65001: \n                            return System.Text.Encoding.UTF8;\n                        case 12000: \n                            return System.Text.Encoding.UTF32;\n                    }\n                    throw new System.NotSupportedException();\n                },\n                GetEncoding$1: function (codepage) {\n                    switch (codepage) {\n                        case \"utf-16\": \n                            return System.Text.Encoding.Unicode;\n                        case \"us-ascii\": \n                            return System.Text.Encoding.ASCII;\n                        case \"utf-16BE\": \n                            return System.Text.Encoding.BigEndianUnicode;\n                        case \"utf-7\": \n                            return System.Text.Encoding.UTF7;\n                        case \"utf-8\": \n                            return System.Text.Encoding.UTF8;\n                        case \"utf-32\": \n                            return System.Text.Encoding.UTF32;\n                    }\n                    throw new System.NotSupportedException();\n                },\n                GetEncodings: function () {\n                    if (System.Text.Encoding._encodings != null) {\n                        return System.Text.Encoding._encodings;\n                    }\n                    System.Text.Encoding._encodings = System.Array.init(6, null, System.Text.EncodingInfo);\n                    var result = System.Text.Encoding._encodings;\n\n                    result[System.Array.index(0, result)] = new System.Text.EncodingInfo(20127, \"us-ascii\", \"US-ASCII\");\n                    result[System.Array.index(1, result)] = new System.Text.EncodingInfo(1200, \"utf-16\", \"Unicode\");\n                    result[System.Array.index(2, result)] = new System.Text.EncodingInfo(1201, \"utf-16BE\", \"Unicode (Big-Endian)\");\n                    result[System.Array.index(3, result)] = new System.Text.EncodingInfo(65000, \"utf-7\", \"Unicode (UTF-7)\");\n                    result[System.Array.index(4, result)] = new System.Text.EncodingInfo(65001, \"utf-8\", \"Unicode (UTF-8)\");\n                    result[System.Array.index(5, result)] = new System.Text.EncodingInfo(1200, \"utf-32\", \"Unicode (UTF-32)\");\n                    return result;\n                }\n            }\n        },\n        fields: {\n            _hasError: false,\n            fallbackCharacter: 0\n        },\n        props: {\n            CodePage: {\n                get: function () {\n                    return 0;\n                }\n            },\n            EncodingName: {\n                get: function () {\n                    return null;\n                }\n            }\n        },\n        ctors: {\n            init: function () {\n                this.fallbackCharacter = 63;\n            }\n        },\n        methods: {\n            Encode$1: function (chars, index, count) {\n                var writtenCount = { };\n                return this.Encode$3(System.String.fromCharArray(chars, index, count), null, 0, writtenCount);\n            },\n            Encode$5: function (s, index, count, outputBytes, outputIndex) {\n                var writtenBytes = { };\n                this.Encode$3(s.substr(index, count), outputBytes, outputIndex, writtenBytes);\n                return writtenBytes.v;\n            },\n            Encode$4: function (chars, index, count, outputBytes, outputIndex) {\n                var writtenBytes = { };\n                this.Encode$3(System.String.fromCharArray(chars, index, count), outputBytes, outputIndex, writtenBytes);\n                return writtenBytes.v;\n            },\n            Encode: function (chars) {\n                var count = { };\n                return this.Encode$3(System.String.fromCharArray(chars), null, 0, count);\n            },\n            Encode$2: function (str) {\n                var count = { };\n                return this.Encode$3(str, null, 0, count);\n            },\n            Decode$1: function (bytes, index, count) {\n                return this.Decode$2(bytes, index, count, null, 0);\n            },\n            Decode: function (bytes) {\n                return this.Decode$2(bytes, 0, bytes.length, null, 0);\n            },\n            GetByteCount: function (chars) {\n                return this.GetByteCount$1(chars, 0, chars.length);\n            },\n            GetByteCount$2: function (s) {\n                return this.Encode$2(s).length;\n            },\n            GetByteCount$1: function (chars, index, count) {\n                return this.Encode$1(chars, index, count).length;\n            },\n            GetBytes: function (chars) {\n                return this.GetBytes$1(chars, 0, chars.length);\n            },\n            GetBytes$1: function (chars, index, count) {\n                return this.Encode$2(System.String.fromCharArray(chars, index, count));\n            },\n            GetBytes$3: function (chars, charIndex, charCount, bytes, byteIndex) {\n                return this.Encode$4(chars, charIndex, charCount, bytes, byteIndex);\n            },\n            GetBytes$2: function (s) {\n                return this.Encode$2(s);\n            },\n            GetBytes$4: function (s, charIndex, charCount, bytes, byteIndex) {\n                return this.Encode$5(s, charIndex, charCount, bytes, byteIndex);\n            },\n            GetCharCount: function (bytes) {\n                return this.Decode(bytes).length;\n            },\n            GetCharCount$1: function (bytes, index, count) {\n                return this.Decode$1(bytes, index, count).length;\n            },\n            GetChars: function (bytes) {\n                var $t;\n                return ($t = this.Decode(bytes), System.String.toCharArray($t, 0, $t.length));\n            },\n            GetChars$1: function (bytes, index, count) {\n                var $t;\n                return ($t = this.Decode$1(bytes, index, count), System.String.toCharArray($t, 0, $t.length));\n            },\n            GetChars$2: function (bytes, byteIndex, byteCount, chars, charIndex) {\n                var s = this.Decode$1(bytes, byteIndex, byteCount);\n                var arr = System.String.toCharArray(s, 0, s.length);\n\n                if (chars.length < (((arr.length + charIndex) | 0))) {\n                    throw new System.ArgumentException(null, \"chars\");\n                }\n\n                for (var i = 0; i < arr.length; i = (i + 1) | 0) {\n                    chars[System.Array.index(((charIndex + i) | 0), chars)] = arr[System.Array.index(i, arr)];\n                }\n\n                return arr.length;\n            },\n            GetString: function (bytes) {\n                return this.Decode(bytes);\n            },\n            GetString$1: function (bytes, index, count) {\n                return this.Decode$1(bytes, index, count);\n            }\n        }\n    });\n\n    Bridge.define(\"System.Text.EncodingInfo\", {\n        props: {\n            CodePage: 0,\n            Name: null,\n            DisplayName: null\n        },\n        ctors: {\n            ctor: function (codePage, name, displayName) {\n                var $t;\n                this.$initialize();\n                this.CodePage = codePage;\n                this.Name = name;\n                this.DisplayName = ($t = displayName, $t != null ? $t : name);\n            }\n        },\n        methods: {\n            GetEncoding: function () {\n                return System.Text.Encoding.GetEncoding(this.CodePage);\n            },\n            GetHashCode: function () {\n                return this.CodePage;\n            },\n            Equals: function (o) {\n                var that = Bridge.as(o, System.Text.EncodingInfo);\n                return System.Nullable.eq(this.CodePage, (that != null ? that.CodePage : null));\n            }\n        }\n    });\n\n    Bridge.define(\"System.Text.ASCIIEncoding\", {\n        inherits: [System.Text.Encoding],\n        props: {\n            CodePage: {\n                get: function () {\n                    return 20127;\n                }\n            },\n            EncodingName: {\n                get: function () {\n                    return \"US-ASCII\";\n                }\n            }\n        },\n        methods: {\n            Encode$3: function (s, outputBytes, outputIndex, writtenBytes) {\n                var hasBuffer = outputBytes != null;\n\n                if (!hasBuffer) {\n                    outputBytes = System.Array.init(0, 0, System.Byte);\n                }\n\n                var recorded = 0;\n                for (var i = 0; i < s.length; i = (i + 1) | 0) {\n                    var ch = s.charCodeAt(i);\n                    var byteCode = (ch <= 127 ? ch : this.fallbackCharacter) & 255;\n\n                    if (hasBuffer) {\n                        if ((((i + outputIndex) | 0)) >= outputBytes.length) {\n                            throw new System.ArgumentException(\"bytes\");\n                        }\n                        outputBytes[System.Array.index(((i + outputIndex) | 0), outputBytes)] = byteCode;\n                    } else {\n                        outputBytes.push(byteCode);\n                    }\n                    recorded = (recorded + 1) | 0;\n                }\n\n                writtenBytes.v = recorded;\n\n                if (hasBuffer) {\n                    return null;\n                }\n\n                return outputBytes;\n            },\n            Decode$2: function (bytes, index, count, chars, charIndex) {\n                var position = index;\n                var result = \"\";\n                var endpoint = (position + count) | 0;\n\n                for (; position < endpoint; position = (position + 1) | 0) {\n                    var byteCode = bytes[System.Array.index(position, bytes)];\n\n                    if (byteCode > 127) {\n                        result = (result || \"\") + String.fromCharCode(this.fallbackCharacter);\n                    } else {\n                        result = (result || \"\") + ((String.fromCharCode(byteCode)) || \"\");\n                    }\n                }\n\n                return result;\n            },\n            GetMaxByteCount: function (charCount) {\n                if (charCount < 0) {\n                    throw new System.ArgumentOutOfRangeException(\"charCount\");\n                }\n\n                var byteCount = System.Int64(charCount).add(System.Int64(1));\n\n                if (byteCount.gt(System.Int64(2147483647))) {\n                    throw new System.ArgumentOutOfRangeException(\"charCount\");\n                }\n\n                return System.Int64.clip32(byteCount);\n            },\n            GetMaxCharCount: function (byteCount) {\n                if (byteCount < 0) {\n                    throw new System.ArgumentOutOfRangeException(\"byteCount\");\n                }\n\n                var charCount = System.Int64(byteCount);\n\n                if (charCount.gt(System.Int64(2147483647))) {\n                    throw new System.ArgumentOutOfRangeException(\"byteCount\");\n                }\n\n                return System.Int64.clip32(charCount);\n            }\n        }\n    });\n\n    Bridge.define(\"System.Text.UnicodeEncoding\", {\n        inherits: [System.Text.Encoding],\n        fields: {\n            bigEndian: false,\n            byteOrderMark: false,\n            throwOnInvalid: false\n        },\n        props: {\n            CodePage: {\n                get: function () {\n                    return this.bigEndian ? 1201 : 1200;\n                }\n            },\n            EncodingName: {\n                get: function () {\n                    return this.bigEndian ? \"Unicode (Big-Endian)\" : \"Unicode\";\n                }\n            }\n        },\n        ctors: {\n            ctor: function () {\n                System.Text.UnicodeEncoding.$ctor1.call(this, false, true);\n            },\n            $ctor1: function (bigEndian, byteOrderMark) {\n                System.Text.UnicodeEncoding.$ctor2.call(this, bigEndian, byteOrderMark, false);\n            },\n            $ctor2: function (bigEndian, byteOrderMark, throwOnInvalidBytes) {\n                this.$initialize();\n                System.Text.Encoding.ctor.call(this);\n                this.bigEndian = bigEndian;\n                this.byteOrderMark = byteOrderMark;\n                this.throwOnInvalid = throwOnInvalidBytes;\n                this.fallbackCharacter = 65533;\n            }\n        },\n        methods: {\n            Encode$3: function (s, outputBytes, outputIndex, writtenBytes) {\n                var hasBuffer = outputBytes != null;\n                var recorded = 0;\n                var surrogate_1st = 0;\n                var fallbackCharacterCode = this.fallbackCharacter;\n\n                var write = function (ch) {\n                    if (hasBuffer) {\n                        if (outputIndex >= outputBytes.length) {\n                            throw new System.ArgumentException(\"bytes\");\n                        }\n\n                        outputBytes[System.Array.index(Bridge.identity(outputIndex, (outputIndex = (outputIndex + 1) | 0)), outputBytes)] = ch;\n                    } else {\n                        outputBytes.push(ch);\n                    }\n                    recorded = (recorded + 1) | 0;\n                };\n\n                var writePair = function (a, b) {\n                    write(a);\n                    write(b);\n                };\n\n                var swap = $asm.$.System.Text.UnicodeEncoding.f1;\n\n                var fallback = Bridge.fn.bind(this, function () {\n                    if (this.throwOnInvalid) {\n                        throw new System.Exception(\"Invalid character in UTF16 text\");\n                    }\n\n                    writePair((fallbackCharacterCode & 255), ((fallbackCharacterCode >> 8) & 255));\n                });\n\n                if (!hasBuffer) {\n                    outputBytes = System.Array.init(0, 0, System.Byte);\n                }\n\n                if (this.bigEndian) {\n                    fallbackCharacterCode = swap(fallbackCharacterCode);\n                }\n\n                for (var i = 0; i < s.length; i = (i + 1) | 0) {\n                    var ch = s.charCodeAt(i);\n\n                    if (surrogate_1st !== 0) {\n                        if (ch >= 56320 && ch <= 57343) {\n                            if (this.bigEndian) {\n                                surrogate_1st = swap(surrogate_1st);\n                                ch = swap(ch);\n                            }\n                            writePair((surrogate_1st & 255), ((surrogate_1st >> 8) & 255));\n                            writePair((ch & 255), ((ch >> 8) & 255));\n                            surrogate_1st = 0;\n                            continue;\n                        }\n                        fallback();\n                        surrogate_1st = 0;\n                    }\n\n                    if (55296 <= ch && ch <= 56319) {\n                        surrogate_1st = ch;\n                        continue;\n                    } else if (56320 <= ch && ch <= 57343) {\n                        fallback();\n                        surrogate_1st = 0;\n                        continue;\n                    }\n\n                    if (ch < 65536) {\n                        if (this.bigEndian) {\n                            ch = swap(ch);\n                        }\n                        writePair((ch & 255), ((ch >> 8) & 255));\n                    } else if (ch <= 1114111) {\n                        ch = ch - 0x10000; //?????\n\n                        var lowBits = ((ch & 1023) | 56320) & 65535;\n                        var highBits = (((ch >> 10) & 1023) | 55296) & 65535;\n\n                        if (this.bigEndian) {\n                            highBits = swap(highBits);\n                            lowBits = swap(lowBits);\n                        }\n                        writePair((highBits & 255), ((highBits >> 8) & 255));\n                        writePair((lowBits & 255), ((lowBits >> 8) & 255));\n                    } else {\n                        fallback();\n                    }\n                }\n\n                if (surrogate_1st !== 0) {\n                    fallback();\n                }\n\n                writtenBytes.v = recorded;\n\n                if (hasBuffer) {\n                    return null;\n                }\n\n                return outputBytes;\n            },\n            Decode$2: function (bytes, index, count, chars, charIndex) {\n                var position = index;\n                var result = \"\";\n                var endpoint = (position + count) | 0;\n                this._hasError = false;\n\n                var fallback = Bridge.fn.bind(this, function () {\n                    if (this.throwOnInvalid) {\n                        throw new System.Exception(\"Invalid character in UTF16 text\");\n                    }\n\n                    result = (result || \"\") + String.fromCharCode(this.fallbackCharacter);\n                });\n\n                var swap = $asm.$.System.Text.UnicodeEncoding.f2;\n\n                var readPair = Bridge.fn.bind(this, function () {\n                    if ((((position + 2) | 0)) > endpoint) {\n                        position = (position + 2) | 0;\n                        return null;\n                    }\n\n                    var a = bytes[System.Array.index(Bridge.identity(position, (position = (position + 1) | 0)), bytes)];\n                    var b = bytes[System.Array.index(Bridge.identity(position, (position = (position + 1) | 0)), bytes)];\n\n                    var point = ((a << 8) | b) & 65535;\n                    if (!this.bigEndian) {\n                        point = swap(point);\n                    }\n\n                    return point;\n                });\n\n                while (position < endpoint) {\n                    var firstWord = readPair();\n\n                    if (!System.Nullable.hasValue(firstWord)) {\n                        fallback();\n                        this._hasError = true;\n                    } else if ((System.Nullable.lt(firstWord, 55296)) || (System.Nullable.gt(firstWord, 57343))) {\n                        result = (result || \"\") + ((System.String.fromCharCode(System.Nullable.getValue(firstWord))) || \"\");\n                    } else if ((System.Nullable.gte(firstWord, 55296)) && (System.Nullable.lte(firstWord, 56319))) {\n                        var end = position >= endpoint;\n                        var secondWord = readPair();\n                        if (end) {\n                            fallback();\n                            this._hasError = true;\n                        } else if (!System.Nullable.hasValue(secondWord)) {\n                            fallback();\n                            fallback();\n                        } else if ((System.Nullable.gte(secondWord, 56320)) && (System.Nullable.lte(secondWord, 57343))) {\n                            var highBits = System.Nullable.band(firstWord, 1023);\n                            var lowBits = System.Nullable.band(secondWord, 1023);\n\n                            var charCode = Bridge.Int.clip32(System.Nullable.add((System.Nullable.bor((System.Nullable.sl(highBits, 10)), lowBits)), 65536));\n\n                            result = (result || \"\") + ((System.String.fromCharCode(System.Nullable.getValue(charCode))) || \"\");\n                        } else {\n                            fallback();\n                            position = (position - 2) | 0;\n                        }\n                    } else {\n                        fallback();\n                    }\n                }\n\n                return result;\n            },\n            GetMaxByteCount: function (charCount) {\n                if (charCount < 0) {\n                    throw new System.ArgumentOutOfRangeException(\"charCount\");\n                }\n\n                var byteCount = System.Int64(charCount).add(System.Int64(1));\n                byteCount = byteCount.shl(1);\n\n                if (byteCount.gt(System.Int64(2147483647))) {\n                    throw new System.ArgumentOutOfRangeException(\"charCount\");\n                }\n\n                return System.Int64.clip32(byteCount);\n            },\n            GetMaxCharCount: function (byteCount) {\n                if (byteCount < 0) {\n                    throw new System.ArgumentOutOfRangeException(\"byteCount\");\n                }\n\n                var charCount = System.Int64((byteCount >> 1)).add(System.Int64((byteCount & 1))).add(System.Int64(1));\n\n                if (charCount.gt(System.Int64(2147483647))) {\n                    throw new System.ArgumentOutOfRangeException(\"byteCount\");\n                }\n\n                return System.Int64.clip32(charCount);\n            }\n        }\n    });\n\n    Bridge.ns(\"System.Text.UnicodeEncoding\", $asm.$);\n\n    Bridge.apply($asm.$.System.Text.UnicodeEncoding, {\n        f1: function (ch) {\n            return ((((ch & 255) << 8) | ((ch >> 8) & 255)) & 65535);\n        },\n        f2: function (ch) {\n            return ((((ch & 255) << 8) | (((ch >> 8)) & 255)) & 65535);\n        }\n    });\n\n    Bridge.define(\"System.Text.UTF32Encoding\", {\n        inherits: [System.Text.Encoding],\n        fields: {\n            bigEndian: false,\n            byteOrderMark: false,\n            throwOnInvalid: false\n        },\n        props: {\n            CodePage: {\n                get: function () {\n                    return this.bigEndian ? 1201 : 1200;\n                }\n            },\n            EncodingName: {\n                get: function () {\n                    return this.bigEndian ? \"Unicode (UTF-32 Big-Endian)\" : \"Unicode (UTF-32)\";\n                }\n            }\n        },\n        ctors: {\n            ctor: function () {\n                System.Text.UTF32Encoding.$ctor2.call(this, false, true, false);\n            },\n            $ctor1: function (bigEndian, byteOrderMark) {\n                System.Text.UTF32Encoding.$ctor2.call(this, bigEndian, byteOrderMark, false);\n            },\n            $ctor2: function (bigEndian, byteOrderMark, throwOnInvalidBytes) {\n                this.$initialize();\n                System.Text.Encoding.ctor.call(this);\n                this.bigEndian = bigEndian;\n                this.byteOrderMark = byteOrderMark;\n                this.throwOnInvalid = throwOnInvalidBytes;\n                this.fallbackCharacter = 65533;\n            }\n        },\n        methods: {\n            ToCodePoints: function (str) {\n                var surrogate_1st = 0;\n                var unicode_codes = System.Array.init(0, 0, System.Char);\n                var fallback = Bridge.fn.bind(this, function () {\n                    if (this.throwOnInvalid) {\n                        throw new System.Exception(\"Invalid character in UTF32 text\");\n                    }\n                    unicode_codes.push(this.fallbackCharacter);\n                });\n\n                for (var i = 0; i < str.length; i = (i + 1) | 0) {\n                    var utf16_code = str.charCodeAt(i);\n\n                    if (surrogate_1st !== 0) {\n                        if (utf16_code >= 56320 && utf16_code <= 57343) {\n                            var surrogate_2nd = utf16_code;\n                            var unicode_code = (((Bridge.Int.mul((((surrogate_1st - 55296) | 0)), (1024)) + (65536)) | 0) + (((surrogate_2nd - 56320) | 0))) | 0;\n                            unicode_codes.push(unicode_code);\n                        } else {\n                            fallback();\n                            i = (i - 1) | 0;\n                        }\n                        surrogate_1st = 0;\n                    } else if (utf16_code >= 55296 && utf16_code <= 56319) {\n                        surrogate_1st = utf16_code;\n                    } else if ((utf16_code >= 56320) && (utf16_code <= 57343)) {\n                        fallback();\n                    } else {\n                        unicode_codes.push(utf16_code);\n                    }\n                }\n\n                if (surrogate_1st !== 0) {\n                    fallback();\n                }\n\n                return unicode_codes;\n            },\n            Encode$3: function (s, outputBytes, outputIndex, writtenBytes) {\n                var hasBuffer = outputBytes != null;\n                var recorded = 0;\n\n                var write = function (ch) {\n                    if (hasBuffer) {\n                        if (outputIndex >= outputBytes.length) {\n                            throw new System.ArgumentException(\"bytes\");\n                        }\n\n                        outputBytes[System.Array.index(Bridge.identity(outputIndex, (outputIndex = (outputIndex + 1) | 0)), outputBytes)] = ch;\n                    } else {\n                        outputBytes.push(ch);\n                    }\n                    recorded = (recorded + 1) | 0;\n                };\n\n                var write32 = Bridge.fn.bind(this, function (a) {\n                    var r = System.Array.init(4, 0, System.Byte);\n                    r[System.Array.index(0, r)] = (((a & 255) >>> 0));\n                    r[System.Array.index(1, r)] = ((((a & 65280) >>> 0)) >>> 8);\n                    r[System.Array.index(2, r)] = ((((a & 16711680) >>> 0)) >>> 16);\n                    r[System.Array.index(3, r)] = ((((a & 4278190080) >>> 0)) >>> 24);\n\n                    if (this.bigEndian) {\n                        r.reverse();\n                    }\n\n                    write(r[System.Array.index(0, r)]);\n                    write(r[System.Array.index(1, r)]);\n                    write(r[System.Array.index(2, r)]);\n                    write(r[System.Array.index(3, r)]);\n                });\n\n                if (!hasBuffer) {\n                    outputBytes = System.Array.init(0, 0, System.Byte);\n                }\n\n                var unicode_codes = this.ToCodePoints(s);\n                for (var i = 0; i < unicode_codes.length; i = (i + 1) | 0) {\n                    write32(unicode_codes[System.Array.index(i, unicode_codes)]);\n                }\n\n                writtenBytes.v = recorded;\n\n                if (hasBuffer) {\n                    return null;\n                }\n\n                return outputBytes;\n            },\n            Decode$2: function (bytes, index, count, chars, charIndex) {\n                var position = index;\n                var result = \"\";\n                var endpoint = (position + count) | 0;\n                this._hasError = false;\n\n                var fallback = Bridge.fn.bind(this, function () {\n                    if (this.throwOnInvalid) {\n                        throw new System.Exception(\"Invalid character in UTF32 text\");\n                    }\n\n                    result = (result || \"\") + ((String.fromCharCode(this.fallbackCharacter)) || \"\");\n                });\n\n                var read32 = Bridge.fn.bind(this, function () {\n                    if ((((position + 4) | 0)) > endpoint) {\n                        position = (position + 4) | 0;\n                        return null;\n                    }\n\n                    var a = bytes[System.Array.index(Bridge.identity(position, (position = (position + 1) | 0)), bytes)];\n                    var b = bytes[System.Array.index(Bridge.identity(position, (position = (position + 1) | 0)), bytes)];\n                    var c = bytes[System.Array.index(Bridge.identity(position, (position = (position + 1) | 0)), bytes)];\n                    var d = bytes[System.Array.index(Bridge.identity(position, (position = (position + 1) | 0)), bytes)];\n\n                    if (this.bigEndian) {\n                        var tmp = b;\n                        b = c;\n                        c = tmp;\n\n                        tmp = a;\n                        a = d;\n                        d = tmp;\n                    }\n\n                    return ((d << 24) | (c << 16) | (b << 8) | a);\n                });\n\n                while (position < endpoint) {\n                    var unicode_code = read32();\n\n                    if (unicode_code == null) {\n                        fallback();\n                        this._hasError = true;\n                        continue;\n                    }\n\n                    if (System.Nullable.lt(unicode_code, 65536) || System.Nullable.gt(unicode_code, 1114111)) {\n                        if (System.Nullable.lt(unicode_code, 0) || System.Nullable.gt(unicode_code, 1114111) || (System.Nullable.gte(unicode_code, 55296) && System.Nullable.lte(unicode_code, 57343))) {\n                            fallback();\n                        } else {\n                            result = (result || \"\") + ((String.fromCharCode(unicode_code)) || \"\");\n                        }\n                    } else {\n                        result = (result || \"\") + ((String.fromCharCode((Bridge.Int.clipu32(System.Nullable.add((Bridge.Int.clipu32(Bridge.Int.div((Bridge.Int.clipu32(System.Nullable.sub(unicode_code, (65536)))), (1024)))), 55296))))) || \"\");\n                        result = (result || \"\") + ((String.fromCharCode((Bridge.Int.clipu32(System.Nullable.add((System.Nullable.mod(unicode_code, (1024))), 56320))))) || \"\");\n                    }\n                }\n\n                return result;\n            },\n            GetMaxByteCount: function (charCount) {\n                if (charCount < 0) {\n                    throw new System.ArgumentOutOfRangeException(\"charCount\");\n                }\n\n                var byteCount = System.Int64(charCount).add(System.Int64(1));\n                byteCount = byteCount.mul(System.Int64(4));\n\n                if (byteCount.gt(System.Int64(2147483647))) {\n                    throw new System.ArgumentOutOfRangeException(\"charCount\");\n                }\n\n                return System.Int64.clip32(byteCount);\n            },\n            GetMaxCharCount: function (byteCount) {\n                if (byteCount < 0) {\n                    throw new System.ArgumentOutOfRangeException(\"byteCount\");\n                }\n\n                var charCount = (((Bridge.Int.div(byteCount, 2)) | 0) + 2) | 0;\n\n                if (charCount > 2147483647) {\n                    throw new System.ArgumentOutOfRangeException(\"byteCount\");\n                }\n\n                return charCount;\n            }\n        }\n    });\n\n    Bridge.define(\"System.Text.UTF7Encoding\", {\n        inherits: [System.Text.Encoding],\n        statics: {\n            methods: {\n                Escape: function (chars) {\n                    return chars.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n                }\n            }\n        },\n        fields: {\n            allowOptionals: false\n        },\n        props: {\n            CodePage: {\n                get: function () {\n                    return 65000;\n                }\n            },\n            EncodingName: {\n                get: function () {\n                    return \"Unicode (UTF-7)\";\n                }\n            }\n        },\n        ctors: {\n            ctor: function () {\n                System.Text.UTF7Encoding.$ctor1.call(this, false);\n            },\n            $ctor1: function (allowOptionals) {\n                this.$initialize();\n                System.Text.Encoding.ctor.call(this);\n                this.allowOptionals = allowOptionals;\n                this.fallbackCharacter = 65533;\n            }\n        },\n        methods: {\n            Encode$3: function (s, outputBytes, outputIndex, writtenBytes) {\n                var setD = \"A-Za-z0-9\" + (System.Text.UTF7Encoding.Escape(\"'(),-./:?\") || \"\");\n\n                var encode = $asm.$.System.Text.UTF7Encoding.f1;\n\n                var setO = System.Text.UTF7Encoding.Escape(\"!\\\"#$%&*;<=>@[]^_`{|}\");\n                var setW = System.Text.UTF7Encoding.Escape(\" \\r\\n\\t\");\n\n                s = s.replace(new RegExp(\"[^\" + setW + setD + (this.allowOptionals ? setO : \"\") + \"]+\", 'g'), function(chunk) {return '+' + (chunk === '+' ? '' : encode(chunk)) + '-';});\n\n                var arr = System.String.toCharArray(s, 0, s.length);\n\n                if (outputBytes != null) {\n                    var recorded = 0;\n\n                    if (arr.length > (((outputBytes.length - outputIndex) | 0))) {\n                        throw new System.ArgumentException(\"bytes\");\n                    }\n\n                    for (var j = 0; j < arr.length; j = (j + 1) | 0) {\n                        outputBytes[System.Array.index(((j + outputIndex) | 0), outputBytes)] = arr[System.Array.index(j, arr)];\n                        recorded = (recorded + 1) | 0;\n                    }\n\n                    writtenBytes.v = recorded;\n                    return null;\n                }\n\n                writtenBytes.v = arr.length;\n\n                return arr;\n            },\n            Decode$2: function (bytes, index, count, chars, charIndex) {\n                var _base64ToArrayBuffer = $asm.$.System.Text.UTF7Encoding.f2;\n\n                var decode = function (s) {\n                    var b = _base64ToArrayBuffer(s);\n                    var r = System.Array.init(0, 0, System.Char);\n                    for (var i = 0; i < b.length; ) {\n                        r.push(((b[System.Array.index(Bridge.identity(i, (i = (i + 1) | 0)), b)] << 8 | b[System.Array.index(Bridge.identity(i, (i = (i + 1) | 0)), b)]) & 65535));\n                    }\n                    return System.String.fromCharArray(r);\n                };\n\n                var str = System.String.fromCharArray(bytes, index, count);\n                return str.replace(/\\+([A-Za-z0-9\\/]*)-?/gi, function (_, chunk) {if (chunk === '') {return _ == '+-' ? '+' : '';}return decode(chunk);});\n            },\n            GetMaxByteCount: function (charCount) {\n                if (charCount < 0) {\n                    throw new System.ArgumentOutOfRangeException(\"charCount\");\n                }\n\n                var byteCount = System.Int64(charCount).mul(System.Int64(3)).add(System.Int64(2));\n\n                if (byteCount.gt(System.Int64(2147483647))) {\n                    throw new System.ArgumentOutOfRangeException(\"charCount\");\n                }\n\n                return System.Int64.clip32(byteCount);\n            },\n            GetMaxCharCount: function (byteCount) {\n                if (byteCount < 0) {\n                    throw new System.ArgumentOutOfRangeException(\"byteCount\");\n                }\n\n                var charCount = byteCount;\n                if (charCount === 0) {\n                    charCount = 1;\n                }\n\n                return charCount | 0;\n            }\n        }\n    });\n\n    Bridge.ns(\"System.Text.UTF7Encoding\", $asm.$);\n\n    Bridge.apply($asm.$.System.Text.UTF7Encoding, {\n        f1: function (str) {\n            var b = System.Array.init(Bridge.Int.mul(str.length, 2), 0, System.Byte);\n            var bi = 0;\n            for (var i = 0; i < str.length; i = (i + 1) | 0) {\n                var c = str.charCodeAt(i);\n                b[System.Array.index(Bridge.identity(bi, (bi = (bi + 1) | 0)), b)] = (c >> 8);\n                b[System.Array.index(Bridge.identity(bi, (bi = (bi + 1) | 0)), b)] = (c & 255);\n            }\n            var base64Str = System.Convert.toBase64String(b, null, null, null);\n            return base64Str.replace(/=+$/, '');\n        },\n        f2: function (base64) {\n            try {\n                var binary_string = window.atob(base64);\n                var len = binary_string.length;\n                var arr = System.Array.init(len, 0, System.Char);\n\n                if (len === 1 && binary_string.charCodeAt(0) === 0) {\n                    return System.Array.init(0, 0, System.Char);\n                }\n\n                for (var i = 0; i < len; i = (i + 1) | 0) {\n                    arr[System.Array.index(i, arr)] = binary_string.charCodeAt(i);\n                }\n                return arr;\n            }\n            catch ($e1) {\n                $e1 = System.Exception.create($e1);\n                return System.Array.init(0, 0, System.Char);\n            }\n        }\n    });\n\n    Bridge.define(\"System.Text.UTF8Encoding\", {\n        inherits: [System.Text.Encoding],\n        fields: {\n            encoderShouldEmitUTF8Identifier: false,\n            throwOnInvalid: false\n        },\n        props: {\n            CodePage: {\n                get: function () {\n                    return 65001;\n                }\n            },\n            EncodingName: {\n                get: function () {\n                    return \"Unicode (UTF-8)\";\n                }\n            }\n        },\n        ctors: {\n            ctor: function () {\n                System.Text.UTF8Encoding.$ctor1.call(this, false);\n            },\n            $ctor1: function (encoderShouldEmitUTF8Identifier) {\n                System.Text.UTF8Encoding.$ctor2.call(this, encoderShouldEmitUTF8Identifier, false);\n            },\n            $ctor2: function (encoderShouldEmitUTF8Identifier, throwOnInvalidBytes) {\n                this.$initialize();\n                System.Text.Encoding.ctor.call(this);\n                this.encoderShouldEmitUTF8Identifier = encoderShouldEmitUTF8Identifier;\n                this.throwOnInvalid = throwOnInvalidBytes;\n                this.fallbackCharacter = 65533;\n            }\n        },\n        methods: {\n            Encode$3: function (s, outputBytes, outputIndex, writtenBytes) {\n                var hasBuffer = outputBytes != null;\n                var record = 0;\n\n                var write = function (args) {\n                    var len = args.length;\n                    for (var j = 0; j < len; j = (j + 1) | 0) {\n                        var code = args[System.Array.index(j, args)];\n                        if (hasBuffer) {\n                            if (outputIndex >= outputBytes.length) {\n                                throw new System.ArgumentException(\"bytes\");\n                            }\n\n                            outputBytes[System.Array.index(Bridge.identity(outputIndex, (outputIndex = (outputIndex + 1) | 0)), outputBytes)] = code;\n                        } else {\n                            outputBytes.push(code);\n                        }\n                        record = (record + 1) | 0;\n                    }\n                };\n\n                var fallback = Bridge.fn.bind(this, $asm.$.System.Text.UTF8Encoding.f1);\n\n                if (!hasBuffer) {\n                    outputBytes = System.Array.init(0, 0, System.Byte);\n                }\n\n                for (var i = 0; i < s.length; i = (i + 1) | 0) {\n                    var charcode = s.charCodeAt(i);\n\n                    if ((charcode >= 55296) && (charcode <= 56319)) {\n                        var next = s.charCodeAt(((i + 1) | 0));\n                        if (!((next >= 56320) && (next <= 57343))) {\n                            charcode = fallback();\n                        }\n                    } else if ((charcode >= 56320) && (charcode <= 57343)) {\n                        charcode = fallback();\n                    }\n\n                    if (charcode < 128) {\n                        write(System.Array.init([charcode], System.Byte));\n                    } else if (charcode < 2048) {\n                        write(System.Array.init([(192 | (charcode >> 6)), (128 | (charcode & 63))], System.Byte));\n                    } else if (charcode < 55296 || charcode >= 57344) {\n                        write(System.Array.init([(224 | (charcode >> 12)), (128 | ((charcode >> 6) & 63)), (128 | (charcode & 63))], System.Byte));\n                    } else {\n                        i = (i + 1) | 0;\n                        var code = (65536 + (((charcode & 1023) << 10) | (s.charCodeAt(i) & 1023))) | 0;\n                        write(System.Array.init([(240 | (code >> 18)), (128 | ((code >> 12) & 63)), (128 | ((code >> 6) & 63)), (128 | (code & 63))], System.Byte));\n                    }\n                }\n\n                writtenBytes.v = record;\n\n                if (hasBuffer) {\n                    return null;\n                }\n\n                return outputBytes;\n            },\n            Decode$2: function (bytes, index, count, chars, charIndex) {\n                this._hasError = false;\n                var position = index;\n                var result = \"\";\n                var surrogate1 = 0;\n                var addFallback = false;\n                var endpoint = (position + count) | 0;\n\n                for (; position < endpoint; position = (position + 1) | 0) {\n                    var accumulator = 0;\n                    var extraBytes = 0;\n                    var hasError = false;\n                    var firstByte = bytes[System.Array.index(position, bytes)];\n\n                    if (firstByte <= 127) {\n                        accumulator = firstByte;\n                    } else if ((firstByte & 64) === 0) {\n                        hasError = true;\n                    } else if ((firstByte & 224) === 192) {\n                        accumulator = firstByte & 31;\n                        extraBytes = 1;\n                    } else if ((firstByte & 240) === 224) {\n                        accumulator = firstByte & 15;\n                        extraBytes = 2;\n                    } else if ((firstByte & 248) === 240) {\n                        accumulator = firstByte & 7;\n                        extraBytes = 3;\n                    } else if ((firstByte & 252) === 248) {\n                        accumulator = firstByte & 3;\n                        extraBytes = 4;\n                        hasError = true;\n                    } else if ((firstByte & 254) === 252) {\n                        accumulator = firstByte & 3;\n                        extraBytes = 5;\n                        hasError = true;\n                    } else {\n                        accumulator = firstByte;\n                        hasError = false;\n                    }\n\n                    while (extraBytes > 0) {\n                        position = (position + 1) | 0;\n\n                        if (position >= endpoint) {\n                            hasError = true;\n                            break;\n                        }\n\n                        var extraByte = bytes[System.Array.index(position, bytes)];\n                        extraBytes = (extraBytes - 1) | 0;\n\n                        if ((extraByte & 192) !== 128) {\n                            position = (position - 1) | 0;\n                            hasError = true;\n                            break;\n                        }\n\n                        accumulator = (accumulator << 6) | (extraByte & 63);\n                    }\n\n                    /* if ((accumulator == 0xFFFE) || (accumulator == 0xFFFF)) {\n                       hasError = true;\n                    }*/\n\n                    var characters = null;\n                    addFallback = false;\n                    if (!hasError) {\n                        if (surrogate1 > 0 && !((accumulator >= 56320) && (accumulator <= 57343))) {\n                            hasError = true;\n                            surrogate1 = 0;\n                        } else if ((accumulator >= 55296) && (accumulator <= 56319)) {\n                            surrogate1 = accumulator & 65535;\n                        } else if ((accumulator >= 56320) && (accumulator <= 57343)) {\n                            hasError = true;\n                            addFallback = true;\n                            surrogate1 = 0;\n                        } else {\n                            characters = System.String.fromCharCode(accumulator);\n                            surrogate1 = 0;\n                        }\n                    }\n\n                    if (hasError) {\n                        if (this.throwOnInvalid) {\n                            throw new System.Exception(\"Invalid character in UTF8 text\");\n                        }\n\n                        result = (result || \"\") + String.fromCharCode(this.fallbackCharacter);\n                        this._hasError = true;\n                    } else if (surrogate1 === 0) {\n                        result = (result || \"\") + (characters || \"\");\n                    }\n                }\n\n                if (surrogate1 > 0 || addFallback) {\n                    if (this.throwOnInvalid) {\n                        throw new System.Exception(\"Invalid character in UTF8 text\");\n                    }\n\n                    if (result.length > 0 && result.charCodeAt(((result.length - 1) | 0)) === this.fallbackCharacter) {\n                        result = (result || \"\") + String.fromCharCode(this.fallbackCharacter);\n                    } else {\n                        result = (result || \"\") + (((this.fallbackCharacter + this.fallbackCharacter) | 0));\n                    }\n\n                    this._hasError = true;\n                }\n\n                return result;\n            },\n            GetMaxByteCount: function (charCount) {\n                if (charCount < 0) {\n                    throw new System.ArgumentOutOfRangeException(\"charCount\");\n                }\n\n\n                var byteCount = System.Int64(charCount).add(System.Int64(1));\n                byteCount = byteCount.mul(System.Int64(3));\n\n                if (byteCount.gt(System.Int64(2147483647))) {\n                    throw new System.ArgumentOutOfRangeException(\"charCount\");\n                }\n\n                return System.Int64.clip32(byteCount);\n            },\n            GetMaxCharCount: function (byteCount) {\n                if (byteCount < 0) {\n                    throw new System.ArgumentOutOfRangeException(\"byteCount\");\n                }\n\n                var charCount = System.Int64(byteCount).add(System.Int64(1));\n\n                if (charCount.gt(System.Int64(2147483647))) {\n                    throw new System.ArgumentOutOfRangeException(\"byteCount\");\n                }\n\n                return System.Int64.clip32(charCount);\n            }\n        }\n    });\n\n    Bridge.ns(\"System.Text.UTF8Encoding\", $asm.$);\n\n    Bridge.apply($asm.$.System.Text.UTF8Encoding, {\n        f1: function () {\n            if (this.throwOnInvalid) {\n                throw new System.Exception(\"Invalid character in UTF8 text\");\n            }\n\n            return this.fallbackCharacter;\n        }\n    });\n\n    // @source io.js\n\n    Bridge.define(\"System.IO.__Error\", {\n        statics: {\n            methods: {\n                EndOfFile: function () {\n                    throw new System.IO.EndOfStreamException.$ctor1(\"IO.EOF_ReadBeyondEOF\");\n                },\n                FileNotOpen: function () {\n                    throw new System.Exception(\"ObjectDisposed_FileClosed\");\n                },\n                StreamIsClosed: function () {\n                    throw new System.Exception(\"ObjectDisposed_StreamClosed\");\n                },\n                MemoryStreamNotExpandable: function () {\n                    throw new System.NotSupportedException(\"NotSupported_MemStreamNotExpandable\");\n                },\n                ReaderClosed: function () {\n                    throw new System.Exception(\"ObjectDisposed_ReaderClosed\");\n                },\n                ReadNotSupported: function () {\n                    throw new System.NotSupportedException(\"NotSupported_UnreadableStream\");\n                },\n                SeekNotSupported: function () {\n                    throw new System.NotSupportedException(\"NotSupported_UnseekableStream\");\n                },\n                WrongAsyncResult: function () {\n                    throw new System.ArgumentException(\"Arg_WrongAsyncResult\");\n                },\n                EndReadCalledTwice: function () {\n                    // Should ideally be InvalidOperationExc but we can't maitain parity with Stream and FileStream without some work\n                    throw new System.ArgumentException(\"InvalidOperation_EndReadCalledMultiple\");\n                },\n                EndWriteCalledTwice: function () {\n                    // Should ideally be InvalidOperationExc but we can't maintain parity with Stream and FileStream without some work\n                    throw new System.ArgumentException(\"InvalidOperation_EndWriteCalledMultiple\");\n                },\n                WriteNotSupported: function () {\n                    throw new System.NotSupportedException(\"NotSupported_UnwritableStream\");\n                },\n                WriterClosed: function () {\n                    throw new System.Exception(\"ObjectDisposed_WriterClosed\");\n                }\n            }\n        }\n    });\n\n    Bridge.define(\"System.IO.BinaryReader\", {\n        inherits: [System.IDisposable],\n        statics: {\n            fields: {\n                MaxCharBytesSize: 0\n            },\n            ctors: {\n                init: function () {\n                    this.MaxCharBytesSize = 128;\n                }\n            }\n        },\n        fields: {\n            m_stream: null,\n            m_buffer: null,\n            m_encoding: null,\n            m_charBytes: null,\n            m_singleChar: null,\n            m_charBuffer: null,\n            m_maxCharsSize: 0,\n            m_2BytesPerChar: false,\n            m_isMemoryStream: false,\n            m_leaveOpen: false,\n            lastCharsRead: 0\n        },\n        props: {\n            BaseStream: {\n                get: function () {\n                    return this.m_stream;\n                }\n            }\n        },\n        alias: [\"Dispose\", \"System$IDisposable$dispose\"],\n        ctors: {\n            init: function () {\n                this.lastCharsRead = 0;\n            },\n            ctor: function (input) {\n                System.IO.BinaryReader.$ctor2.call(this, input, new System.Text.UTF8Encoding.ctor(), false);\n            },\n            $ctor1: function (input, encoding) {\n                System.IO.BinaryReader.$ctor2.call(this, input, encoding, false);\n            },\n            $ctor2: function (input, encoding, leaveOpen) {\n                this.$initialize();\n                if (input == null) {\n                    throw new System.ArgumentNullException(\"input\");\n                }\n                if (encoding == null) {\n                    throw new System.ArgumentNullException(\"encoding\");\n                }\n                if (!input.CanRead) {\n                    throw new System.ArgumentException(\"Argument_StreamNotReadable\");\n                }\n                this.m_stream = input;\n                this.m_encoding = encoding;\n                this.m_maxCharsSize = encoding.GetMaxCharCount(System.IO.BinaryReader.MaxCharBytesSize);\n                var minBufferSize = encoding.GetMaxByteCount(1); // max bytes per one char\n                if (minBufferSize < 23) {\n                    minBufferSize = 23;\n                }\n                this.m_buffer = System.Array.init(minBufferSize, 0, System.Byte);\n                // m_charBuffer and m_charBytes will be left null.\n\n                // For Encodings that always use 2 bytes per char (or more),\n                // special case them here to make Read() & Peek() faster.\n                this.m_2BytesPerChar = Bridge.is(encoding, System.Text.UnicodeEncoding);\n                // check if BinaryReader is based on MemoryStream, and keep this for it's life\n                // we cannot use \"as\" operator, since derived classes are not allowed\n                this.m_isMemoryStream = (Bridge.referenceEquals(Bridge.getType(this.m_stream), System.IO.MemoryStream));\n                this.m_leaveOpen = leaveOpen;\n\n            }\n        },\n        methods: {\n            Close: function () {\n                this.Dispose$1(true);\n            },\n            Dispose$1: function (disposing) {\n                if (disposing) {\n                    var copyOfStream = this.m_stream;\n                    this.m_stream = null;\n                    if (copyOfStream != null && !this.m_leaveOpen) {\n                        copyOfStream.Close();\n                    }\n                }\n                this.m_stream = null;\n                this.m_buffer = null;\n                this.m_encoding = null;\n                this.m_charBytes = null;\n                this.m_singleChar = null;\n                this.m_charBuffer = null;\n            },\n            Dispose: function () {\n                this.Dispose$1(true);\n            },\n            PeekChar: function () {\n\n                if (this.m_stream == null) {\n                    System.IO.__Error.FileNotOpen();\n                }\n\n                if (!this.m_stream.CanSeek) {\n                    return -1;\n                }\n                var origPos = this.m_stream.Position;\n                var ch = this.Read();\n                this.m_stream.Position = origPos;\n                return ch;\n            },\n            Read: function () {\n\n                if (this.m_stream == null) {\n                    System.IO.__Error.FileNotOpen();\n                }\n                return this.InternalReadOneChar();\n            },\n            Read$2: function (buffer, index, count) {\n                if (buffer == null) {\n                    throw new System.ArgumentNullException(\"buffer\", \"ArgumentNull_Buffer\");\n                }\n                if (index < 0) {\n                    throw new System.ArgumentOutOfRangeException(\"index\", \"ArgumentOutOfRange_NeedNonNegNum\");\n                }\n                if (count < 0) {\n                    throw new System.ArgumentOutOfRangeException(\"count\", \"ArgumentOutOfRange_NeedNonNegNum\");\n                }\n                if (((buffer.length - index) | 0) < count) {\n                    throw new System.ArgumentException(\"Argument_InvalidOffLen\");\n                }\n\n                if (this.m_stream == null) {\n                    System.IO.__Error.FileNotOpen();\n                }\n\n                // SafeCritical: index and count have already been verified to be a valid range for the buffer\n                return this.InternalReadChars(buffer, index, count);\n            },\n            Read$1: function (buffer, index, count) {\n                if (buffer == null) {\n                    throw new System.ArgumentNullException(\"buffer\", \"ArgumentNull_Buffer\");\n                }\n                if (index < 0) {\n                    throw new System.ArgumentOutOfRangeException(\"index\", \"ArgumentOutOfRange_NeedNonNegNum\");\n                }\n                if (count < 0) {\n                    throw new System.ArgumentOutOfRangeException(\"count\", \"ArgumentOutOfRange_NeedNonNegNum\");\n                }\n                if (((buffer.length - index) | 0) < count) {\n                    throw new System.ArgumentException(\"Argument_InvalidOffLen\");\n                }\n\n                if (this.m_stream == null) {\n                    System.IO.__Error.FileNotOpen();\n                }\n                return this.m_stream.Read(buffer, index, count);\n            },\n            ReadBoolean: function () {\n                this.FillBuffer(1);\n                return (this.m_buffer[System.Array.index(0, this.m_buffer)] !== 0);\n            },\n            ReadByte: function () {\n                // Inlined to avoid some method call overhead with FillBuffer.\n                if (this.m_stream == null) {\n                    System.IO.__Error.FileNotOpen();\n                }\n\n                var b = this.m_stream.ReadByte();\n                if (b === -1) {\n                    System.IO.__Error.EndOfFile();\n                }\n                return (b & 255);\n            },\n            ReadSByte: function () {\n                this.FillBuffer(1);\n                return Bridge.Int.sxb((this.m_buffer[System.Array.index(0, this.m_buffer)]) & 255);\n            },\n            ReadChar: function () {\n                var value = this.Read();\n                if (value === -1) {\n                    System.IO.__Error.EndOfFile();\n                }\n                return (value & 65535);\n            },\n            ReadInt16: function () {\n                this.FillBuffer(2);\n                return Bridge.Int.sxs((this.m_buffer[System.Array.index(0, this.m_buffer)] | this.m_buffer[System.Array.index(1, this.m_buffer)] << 8) & 65535);\n            },\n            ReadUInt16: function () {\n                this.FillBuffer(2);\n                return ((this.m_buffer[System.Array.index(0, this.m_buffer)] | this.m_buffer[System.Array.index(1, this.m_buffer)] << 8) & 65535);\n            },\n            ReadInt32: function () {\n                if (this.m_isMemoryStream) {\n                    if (this.m_stream == null) {\n                        System.IO.__Error.FileNotOpen();\n                    }\n                    // read directly from MemoryStream buffer\n                    var mStream = Bridge.as(this.m_stream, System.IO.MemoryStream);\n\n                    return mStream.InternalReadInt32();\n                } else {\n                    this.FillBuffer(4);\n                    return this.m_buffer[System.Array.index(0, this.m_buffer)] | this.m_buffer[System.Array.index(1, this.m_buffer)] << 8 | this.m_buffer[System.Array.index(2, this.m_buffer)] << 16 | this.m_buffer[System.Array.index(3, this.m_buffer)] << 24;\n                }\n            },\n            ReadUInt32: function () {\n                this.FillBuffer(4);\n                return ((this.m_buffer[System.Array.index(0, this.m_buffer)] | this.m_buffer[System.Array.index(1, this.m_buffer)] << 8 | this.m_buffer[System.Array.index(2, this.m_buffer)] << 16 | this.m_buffer[System.Array.index(3, this.m_buffer)] << 24) >>> 0);\n            },\n            ReadInt64: function () {\n                this.FillBuffer(8);\n                var lo = (this.m_buffer[System.Array.index(0, this.m_buffer)] | this.m_buffer[System.Array.index(1, this.m_buffer)] << 8 | this.m_buffer[System.Array.index(2, this.m_buffer)] << 16 | this.m_buffer[System.Array.index(3, this.m_buffer)] << 24) >>> 0;\n                var hi = (this.m_buffer[System.Array.index(4, this.m_buffer)] | this.m_buffer[System.Array.index(5, this.m_buffer)] << 8 | this.m_buffer[System.Array.index(6, this.m_buffer)] << 16 | this.m_buffer[System.Array.index(7, this.m_buffer)] << 24) >>> 0;\n                return System.Int64.clip64(System.UInt64(hi)).shl(32).or(System.Int64(lo));\n            },\n            ReadUInt64: function () {\n                this.FillBuffer(8);\n                var lo = (this.m_buffer[System.Array.index(0, this.m_buffer)] | this.m_buffer[System.Array.index(1, this.m_buffer)] << 8 | this.m_buffer[System.Array.index(2, this.m_buffer)] << 16 | this.m_buffer[System.Array.index(3, this.m_buffer)] << 24) >>> 0;\n                var hi = (this.m_buffer[System.Array.index(4, this.m_buffer)] | this.m_buffer[System.Array.index(5, this.m_buffer)] << 8 | this.m_buffer[System.Array.index(6, this.m_buffer)] << 16 | this.m_buffer[System.Array.index(7, this.m_buffer)] << 24) >>> 0;\n                return System.UInt64(hi).shl(32).or(System.UInt64(lo));\n            },\n            ReadSingle: function () {\n                this.FillBuffer(4);\n                var tmpBuffer = (this.m_buffer[System.Array.index(0, this.m_buffer)] | this.m_buffer[System.Array.index(1, this.m_buffer)] << 8 | this.m_buffer[System.Array.index(2, this.m_buffer)] << 16 | this.m_buffer[System.Array.index(3, this.m_buffer)] << 24) >>> 0;\n                return System.BitConverter.toSingle(System.BitConverter.getBytes$8(tmpBuffer), 0);\n            },\n            ReadDouble: function () {\n                this.FillBuffer(8);\n                var lo = (this.m_buffer[System.Array.index(0, this.m_buffer)] | this.m_buffer[System.Array.index(1, this.m_buffer)] << 8 | this.m_buffer[System.Array.index(2, this.m_buffer)] << 16 | this.m_buffer[System.Array.index(3, this.m_buffer)] << 24) >>> 0;\n                var hi = (this.m_buffer[System.Array.index(4, this.m_buffer)] | this.m_buffer[System.Array.index(5, this.m_buffer)] << 8 | this.m_buffer[System.Array.index(6, this.m_buffer)] << 16 | this.m_buffer[System.Array.index(7, this.m_buffer)] << 24) >>> 0;\n\n                var tmpBuffer = System.UInt64(hi).shl(32).or(System.UInt64(lo));\n                return System.BitConverter.toDouble(System.BitConverter.getBytes$9(tmpBuffer), 0);\n            },\n            ReadDecimal: function () {\n                this.FillBuffer(23);\n                try {\n                    return System.Decimal.fromBytes(this.m_buffer);\n                }\n                catch ($e1) {\n                    $e1 = System.Exception.create($e1);\n                    var e;\n                    if (Bridge.is($e1, System.ArgumentException)) {\n                        e = $e1;\n                        // ReadDecimal cannot leak out ArgumentException\n                        throw new System.IO.IOException.$ctor2(\"Arg_DecBitCtor\", e);\n                    } else {\n                        throw $e1;\n                    }\n                }\n            },\n            ReadString: function () {\n\n                if (this.m_stream == null) {\n                    System.IO.__Error.FileNotOpen();\n                }\n\n                var currPos = 0;\n                var n;\n                var stringLength;\n                var readLength;\n                var charsRead;\n\n                // Length of the string in bytes, not chars\n                stringLength = this.Read7BitEncodedInt();\n                if (stringLength < 0) {\n                    throw new System.IO.IOException.$ctor1(\"IO.IO_InvalidStringLen_Len\");\n                }\n\n                if (stringLength === 0) {\n                    return \"\";\n                }\n\n                if (this.m_charBytes == null) {\n                    this.m_charBytes = System.Array.init(System.IO.BinaryReader.MaxCharBytesSize, 0, System.Byte);\n                }\n\n                if (this.m_charBuffer == null) {\n                    this.m_charBuffer = System.Array.init(this.m_maxCharsSize, 0, System.Char);\n                }\n\n                var sb = null;\n                do {\n                    readLength = ((((stringLength - currPos) | 0)) > System.IO.BinaryReader.MaxCharBytesSize) ? System.IO.BinaryReader.MaxCharBytesSize : (((stringLength - currPos) | 0));\n\n                    n = this.m_stream.Read(this.m_charBytes, 0, readLength);\n                    if (n === 0) {\n                        System.IO.__Error.EndOfFile();\n                    }\n\n                    charsRead = this.m_encoding.GetChars$2(this.m_charBytes, 0, n, this.m_charBuffer, 0);\n\n                    if (currPos === 0 && n === stringLength) {\n                        return System.String.fromCharArray(this.m_charBuffer, 0, charsRead);\n                    }\n\n                    if (sb == null) {\n                        sb = new System.Text.StringBuilder(\"\", stringLength);\n                    }\n\n                    for (var i = 0; i < charsRead; i = (i + 1) | 0) {\n                        sb.append(String.fromCharCode(this.m_charBuffer[System.Array.index(i, this.m_charBuffer)]));\n                    }\n\n                    currPos = (currPos + n) | 0;\n\n                } while (currPos < stringLength);\n\n                return sb.toString();\n            },\n            InternalReadChars: function (buffer, index, count) {\n\n                var charsRemaining = count;\n\n                if (this.m_charBytes == null) {\n                    this.m_charBytes = System.Array.init(System.IO.BinaryReader.MaxCharBytesSize, 0, System.Byte);\n                }\n\n                if (index < 0 || charsRemaining < 0 || ((index + charsRemaining) | 0) > buffer.length) {\n                    throw new System.ArgumentOutOfRangeException(\"charsRemaining\");\n                }\n\n                while (charsRemaining > 0) {\n\n                    var ch = this.InternalReadOneChar(true);\n\n                    if (ch === -1) {\n                        break;\n                    }\n\n                    buffer[System.Array.index(index, buffer)] = ch & 65535;\n\n                    if (this.lastCharsRead === 2) {\n                        buffer[System.Array.index(((index = (index + 1) | 0)), buffer)] = this.m_singleChar[System.Array.index(1, this.m_singleChar)];\n                        charsRemaining = (charsRemaining - 1) | 0;\n                    }\n\n                    charsRemaining = (charsRemaining - 1) | 0;\n                    index = (index + 1) | 0;\n                }\n\n                // this should never fail\n\n                // we may have read fewer than the number of characters requested if end of stream reached\n                // or if the encoding makes the char count too big for the buffer (e.g. fallback sequence)\n                return (((count - charsRemaining) | 0));\n            },\n            InternalReadOneChar: function (allowSurrogate) {\n                if (allowSurrogate === void 0) { allowSurrogate = false; }\n                // I know having a separate InternalReadOneChar method seems a little\n                // redundant, but this makes a scenario like the security parser code\n                // 20% faster, in addition to the optimizations for UnicodeEncoding I\n                // put in InternalReadChars.\n                var charsRead = 0;\n                var numBytes = 0;\n                var posSav = System.Int64(0);\n\n                if (this.m_stream.CanSeek) {\n                    posSav = this.m_stream.Position;\n                }\n\n                if (this.m_charBytes == null) {\n                    this.m_charBytes = System.Array.init(System.IO.BinaryReader.MaxCharBytesSize, 0, System.Byte); //\n                }\n                if (this.m_singleChar == null) {\n                    this.m_singleChar = System.Array.init(2, 0, System.Char);\n                }\n\n                var addByte = false;\n                var internalPos = 0;\n                while (charsRead === 0) {\n                    numBytes = this.m_2BytesPerChar ? 2 : 1;\n\n                    if (Bridge.is(this.m_encoding, System.Text.UTF32Encoding)) {\n                        numBytes = 4;\n                    }\n\n                    if (addByte) {\n                        var r = this.m_stream.ReadByte();\n                        this.m_charBytes[System.Array.index(((internalPos = (internalPos + 1) | 0)), this.m_charBytes)] = r & 255;\n                        if (r === -1) {\n                            numBytes = 0;\n                        }\n\n                        if (numBytes === 2) {\n                            r = this.m_stream.ReadByte();\n                            this.m_charBytes[System.Array.index(((internalPos = (internalPos + 1) | 0)), this.m_charBytes)] = r & 255;\n                            if (r === -1) {\n                                numBytes = 1;\n                            }\n                        }\n                    } else {\n                        var r1 = this.m_stream.ReadByte();\n                        this.m_charBytes[System.Array.index(0, this.m_charBytes)] = r1 & 255;\n                        internalPos = 0;\n                        if (r1 === -1) {\n                            numBytes = 0;\n                        }\n\n                        if (numBytes === 2) {\n                            r1 = this.m_stream.ReadByte();\n                            this.m_charBytes[System.Array.index(1, this.m_charBytes)] = r1 & 255;\n                            if (r1 === -1) {\n                                numBytes = 1;\n                            }\n                            internalPos = 1;\n                        } else if (numBytes === 4) {\n                            r1 = this.m_stream.ReadByte();\n                            this.m_charBytes[System.Array.index(1, this.m_charBytes)] = r1 & 255;\n                            if (r1 === -1) {\n                                return -1;\n                            }\n\n                            r1 = this.m_stream.ReadByte();\n                            this.m_charBytes[System.Array.index(2, this.m_charBytes)] = r1 & 255;\n                            if (r1 === -1) {\n                                return -1;\n                            }\n\n                            r1 = this.m_stream.ReadByte();\n                            this.m_charBytes[System.Array.index(3, this.m_charBytes)] = r1 & 255;\n                            if (r1 === -1) {\n                                return -1;\n                            }\n\n                            internalPos = 3;\n                        }\n                    }\n\n\n                    if (numBytes === 0) {\n                        return -1;\n                    }\n\n                    addByte = false;\n                    try {\n                        charsRead = this.m_encoding.GetChars$2(this.m_charBytes, 0, ((internalPos + 1) | 0), this.m_singleChar, 0);\n\n                        if (!allowSurrogate && charsRead === 2) {\n                            throw new System.ArgumentException();\n                        }\n                    }\n                    catch ($e1) {\n                        $e1 = System.Exception.create($e1);\n                        // Handle surrogate char\n\n                        if (this.m_stream.CanSeek) {\n                            this.m_stream.Seek((posSav.sub(this.m_stream.Position)), System.IO.SeekOrigin.Current);\n                        }\n                        // else - we can't do much here\n\n                        throw $e1;\n                    }\n\n                    if (this.m_encoding._hasError) {\n                        charsRead = 0;\n                        addByte = true;\n                    }\n\n                    if (!allowSurrogate) {\n                    }\n                }\n\n                this.lastCharsRead = charsRead;\n\n                if (charsRead === 0) {\n                    return -1;\n                }\n\n                return this.m_singleChar[System.Array.index(0, this.m_singleChar)];\n            },\n            ReadChars: function (count) {\n                if (count < 0) {\n                    throw new System.ArgumentOutOfRangeException(\"count\", \"ArgumentOutOfRange_NeedNonNegNum\");\n                }\n                if (this.m_stream == null) {\n                    System.IO.__Error.FileNotOpen();\n                }\n\n                if (count === 0) {\n                    return System.Array.init(0, 0, System.Char);\n                }\n\n                // SafeCritical: we own the chars buffer, and therefore can guarantee that the index and count are valid\n                var chars = System.Array.init(count, 0, System.Char);\n                var n = this.InternalReadChars(chars, 0, count);\n                if (n !== count) {\n                    var copy = System.Array.init(n, 0, System.Char);\n                    System.Array.copy(chars, 0, copy, 0, Bridge.Int.mul(2, n)); // sizeof(char)\n                    chars = copy;\n                }\n\n                return chars;\n            },\n            ReadBytes: function (count) {\n                if (count < 0) {\n                    throw new System.ArgumentOutOfRangeException(\"count\", \"ArgumentOutOfRange_NeedNonNegNum\");\n                }\n                if (this.m_stream == null) {\n                    System.IO.__Error.FileNotOpen();\n                }\n\n                if (count === 0) {\n                    return System.Array.init(0, 0, System.Byte);\n                }\n\n                var result = System.Array.init(count, 0, System.Byte);\n\n                var numRead = 0;\n                do {\n                    var n = this.m_stream.Read(result, numRead, count);\n                    if (n === 0) {\n                        break;\n                    }\n                    numRead = (numRead + n) | 0;\n                    count = (count - n) | 0;\n                } while (count > 0);\n\n                if (numRead !== result.length) {\n                    // Trim array.  This should happen on EOF & possibly net streams.\n                    var copy = System.Array.init(numRead, 0, System.Byte);\n                    System.Array.copy(result, 0, copy, 0, numRead);\n                    result = copy;\n                }\n\n                return result;\n            },\n            FillBuffer: function (numBytes) {\n                if (this.m_buffer != null && (numBytes < 0 || numBytes > this.m_buffer.length)) {\n                    throw new System.ArgumentOutOfRangeException(\"numBytes\", \"ArgumentOutOfRange_BinaryReaderFillBuffer\");\n                }\n                var bytesRead = 0;\n                var n = 0;\n\n                if (this.m_stream == null) {\n                    System.IO.__Error.FileNotOpen();\n                }\n\n                // Need to find a good threshold for calling ReadByte() repeatedly\n                // vs. calling Read(byte[], int, int) for both buffered & unbuffered\n                // streams.\n                if (numBytes === 1) {\n                    n = this.m_stream.ReadByte();\n                    if (n === -1) {\n                        System.IO.__Error.EndOfFile();\n                    }\n                    this.m_buffer[System.Array.index(0, this.m_buffer)] = n & 255;\n                    return;\n                }\n\n                do {\n                    n = this.m_stream.Read(this.m_buffer, bytesRead, ((numBytes - bytesRead) | 0));\n                    if (n === 0) {\n                        System.IO.__Error.EndOfFile();\n                    }\n                    bytesRead = (bytesRead + n) | 0;\n                } while (bytesRead < numBytes);\n            },\n            Read7BitEncodedInt: function () {\n                // Read out an Int32 7 bits at a time.  The high bit\n                // of the byte when on means to continue reading more bytes.\n                var count = 0;\n                var shift = 0;\n                var b;\n                do {\n                    // Check for a corrupted stream.  Read a max of 5 bytes.\n                    // In a future version, add a DataFormatException.\n                    if (shift === 35) {\n                        throw new System.FormatException(\"Format_Bad7BitInt32\");\n                    }\n\n                    // ReadByte handles end of stream cases for us.\n                    b = this.ReadByte();\n                    count = count | ((b & 127) << shift);\n                    shift = (shift + 7) | 0;\n                } while ((b & 128) !== 0);\n                return count;\n            }\n        }\n    });\n\n    Bridge.define(\"System.IO.BinaryWriter\", {\n        inherits: [System.IDisposable],\n        statics: {\n            fields: {\n                Null: null,\n                LargeByteBufferSize: 0\n            },\n            ctors: {\n                init: function () {\n                    this.Null = new System.IO.BinaryWriter.ctor();\n                    this.LargeByteBufferSize = 256;\n                }\n            }\n        },\n        fields: {\n            OutStream: null,\n            _buffer: null,\n            _encoding: null,\n            _leaveOpen: false,\n            _tmpOneCharBuffer: null\n        },\n        props: {\n            BaseStream: {\n                get: function () {\n                    this.Flush();\n                    return this.OutStream;\n                }\n            }\n        },\n        alias: [\"Dispose\", \"System$IDisposable$dispose\"],\n        ctors: {\n            ctor: function () {\n                this.$initialize();\n                this.OutStream = System.IO.Stream.Null;\n                this._buffer = System.Array.init(16, 0, System.Byte);\n                this._encoding = new System.Text.UTF8Encoding.$ctor2(false, true);\n            },\n            $ctor1: function (output) {\n                System.IO.BinaryWriter.$ctor3.call(this, output, new System.Text.UTF8Encoding.$ctor2(false, true), false);\n            },\n            $ctor2: function (output, encoding) {\n                System.IO.BinaryWriter.$ctor3.call(this, output, encoding, false);\n            },\n            $ctor3: function (output, encoding, leaveOpen) {\n                this.$initialize();\n                if (output == null) {\n                    throw new System.ArgumentNullException(\"output\");\n                }\n                if (encoding == null) {\n                    throw new System.ArgumentNullException(\"encoding\");\n                }\n                if (!output.CanWrite) {\n                    throw new System.ArgumentException(\"Argument_StreamNotWritable\");\n                }\n\n                this.OutStream = output;\n                this._buffer = System.Array.init(16, 0, System.Byte);\n                this._encoding = encoding;\n                this._leaveOpen = leaveOpen;\n            }\n        },\n        methods: {\n            Close: function () {\n                this.Dispose$1(true);\n            },\n            Dispose$1: function (disposing) {\n                if (disposing) {\n                    if (this._leaveOpen) {\n                        this.OutStream.Flush();\n                    } else {\n                        this.OutStream.Close();\n                    }\n                }\n            },\n            Dispose: function () {\n                this.Dispose$1(true);\n            },\n            Flush: function () {\n                this.OutStream.Flush();\n            },\n            Seek: function (offset, origin) {\n                return this.OutStream.Seek(System.Int64(offset), origin);\n            },\n            Write: function (value) {\n                this._buffer[System.Array.index(0, this._buffer)] = (value ? 1 : 0) & 255;\n                this.OutStream.Write(this._buffer, 0, 1);\n            },\n            Write$1: function (value) {\n                this.OutStream.WriteByte(value);\n            },\n            Write$12: function (value) {\n                this.OutStream.WriteByte((value & 255));\n            },\n            Write$2: function (buffer) {\n                if (buffer == null) {\n                    throw new System.ArgumentNullException(\"buffer\");\n                }\n                this.OutStream.Write(buffer, 0, buffer.length);\n            },\n            Write$3: function (buffer, index, count) {\n                this.OutStream.Write(buffer, index, count);\n            },\n            Write$4: function (ch) {\n                if (System.Char.isSurrogate(ch)) {\n                    throw new System.ArgumentException(\"Arg_SurrogatesNotAllowedAsSingleChar\");\n                }\n\n                var numBytes = 0;\n                numBytes = this._encoding.GetBytes$3(System.Array.init([ch], System.Char), 0, 1, this._buffer, 0);\n\n                this.OutStream.Write(this._buffer, 0, numBytes);\n            },\n            Write$5: function (chars) {\n                if (chars == null) {\n                    throw new System.ArgumentNullException(\"chars\");\n                }\n\n                var bytes = this._encoding.GetBytes$1(chars, 0, chars.length);\n                this.OutStream.Write(bytes, 0, bytes.length);\n            },\n            Write$6: function (chars, index, count) {\n                var bytes = this._encoding.GetBytes$1(chars, index, count);\n                this.OutStream.Write(bytes, 0, bytes.length);\n            },\n            Write$8: function (value) {\n                var TmpValue = System.Int64.clipu64(System.BitConverter.doubleToInt64Bits(value));\n                this._buffer[System.Array.index(0, this._buffer)] = System.Int64.clipu8(TmpValue);\n                this._buffer[System.Array.index(1, this._buffer)] = System.Int64.clipu8(TmpValue.shru(8));\n                this._buffer[System.Array.index(2, this._buffer)] = System.Int64.clipu8(TmpValue.shru(16));\n                this._buffer[System.Array.index(3, this._buffer)] = System.Int64.clipu8(TmpValue.shru(24));\n                this._buffer[System.Array.index(4, this._buffer)] = System.Int64.clipu8(TmpValue.shru(32));\n                this._buffer[System.Array.index(5, this._buffer)] = System.Int64.clipu8(TmpValue.shru(40));\n                this._buffer[System.Array.index(6, this._buffer)] = System.Int64.clipu8(TmpValue.shru(48));\n                this._buffer[System.Array.index(7, this._buffer)] = System.Int64.clipu8(TmpValue.shru(56));\n                this.OutStream.Write(this._buffer, 0, 8);\n            },\n            Write$7: function (value) {\n                var buf = value.getBytes();\n                this.OutStream.Write(buf, 0, 23);\n            },\n            Write$9: function (value) {\n                this._buffer[System.Array.index(0, this._buffer)] = value & 255;\n                this._buffer[System.Array.index(1, this._buffer)] = (value >> 8) & 255;\n                this.OutStream.Write(this._buffer, 0, 2);\n            },\n            Write$15: function (value) {\n                this._buffer[System.Array.index(0, this._buffer)] = value & 255;\n                this._buffer[System.Array.index(1, this._buffer)] = (value >> 8) & 255;\n                this.OutStream.Write(this._buffer, 0, 2);\n            },\n            Write$10: function (value) {\n                this._buffer[System.Array.index(0, this._buffer)] = value & 255;\n                this._buffer[System.Array.index(1, this._buffer)] = (value >> 8) & 255;\n                this._buffer[System.Array.index(2, this._buffer)] = (value >> 16) & 255;\n                this._buffer[System.Array.index(3, this._buffer)] = (value >> 24) & 255;\n                this.OutStream.Write(this._buffer, 0, 4);\n            },\n            Write$16: function (value) {\n                this._buffer[System.Array.index(0, this._buffer)] = value & 255;\n                this._buffer[System.Array.index(1, this._buffer)] = (value >>> 8) & 255;\n                this._buffer[System.Array.index(2, this._buffer)] = (value >>> 16) & 255;\n                this._buffer[System.Array.index(3, this._buffer)] = (value >>> 24) & 255;\n                this.OutStream.Write(this._buffer, 0, 4);\n            },\n            Write$11: function (value) {\n                this._buffer[System.Array.index(0, this._buffer)] = System.Int64.clipu8(value);\n                this._buffer[System.Array.index(1, this._buffer)] = System.Int64.clipu8(value.shr(8));\n                this._buffer[System.Array.index(2, this._buffer)] = System.Int64.clipu8(value.shr(16));\n                this._buffer[System.Array.index(3, this._buffer)] = System.Int64.clipu8(value.shr(24));\n                this._buffer[System.Array.index(4, this._buffer)] = System.Int64.clipu8(value.shr(32));\n                this._buffer[System.Array.index(5, this._buffer)] = System.Int64.clipu8(value.shr(40));\n                this._buffer[System.Array.index(6, this._buffer)] = System.Int64.clipu8(value.shr(48));\n                this._buffer[System.Array.index(7, this._buffer)] = System.Int64.clipu8(value.shr(56));\n                this.OutStream.Write(this._buffer, 0, 8);\n            },\n            Write$17: function (value) {\n                this._buffer[System.Array.index(0, this._buffer)] = System.Int64.clipu8(value);\n                this._buffer[System.Array.index(1, this._buffer)] = System.Int64.clipu8(value.shru(8));\n                this._buffer[System.Array.index(2, this._buffer)] = System.Int64.clipu8(value.shru(16));\n                this._buffer[System.Array.index(3, this._buffer)] = System.Int64.clipu8(value.shru(24));\n                this._buffer[System.Array.index(4, this._buffer)] = System.Int64.clipu8(value.shru(32));\n                this._buffer[System.Array.index(5, this._buffer)] = System.Int64.clipu8(value.shru(40));\n                this._buffer[System.Array.index(6, this._buffer)] = System.Int64.clipu8(value.shru(48));\n                this._buffer[System.Array.index(7, this._buffer)] = System.Int64.clipu8(value.shru(56));\n                this.OutStream.Write(this._buffer, 0, 8);\n            },\n            Write$13: function (value) {\n                var TmpValue = System.BitConverter.toUInt32(System.BitConverter.getBytes$6(value), 0);\n                this._buffer[System.Array.index(0, this._buffer)] = TmpValue & 255;\n                this._buffer[System.Array.index(1, this._buffer)] = (TmpValue >>> 8) & 255;\n                this._buffer[System.Array.index(2, this._buffer)] = (TmpValue >>> 16) & 255;\n                this._buffer[System.Array.index(3, this._buffer)] = (TmpValue >>> 24) & 255;\n                this.OutStream.Write(this._buffer, 0, 4);\n            },\n            Write$14: function (value) {\n                if (value == null) {\n                    throw new System.ArgumentNullException(\"value\");\n                }\n\n                var buffer = this._encoding.GetBytes$2(value);\n                var len = buffer.length;\n                this.Write7BitEncodedInt(len);\n                this.OutStream.Write(buffer, 0, len);\n            },\n            Write7BitEncodedInt: function (value) {\n                // Write out an int 7 bits at a time.  The high bit of the byte,\n                // when on, tells reader to continue reading more bytes.\n                var v = value >>> 0; // support negative numbers\n                while (v >= 128) {\n                    this.Write$1(((((v | 128) >>> 0)) & 255));\n                    v = v >>> 7;\n                }\n                this.Write$1((v & 255));\n            }\n        }\n    });\n\n    Bridge.define(\"System.IO.Stream\", {\n        inherits: [System.IDisposable],\n        statics: {\n            fields: {\n                Null: null,\n                _DefaultCopyBufferSize: 0\n            },\n            ctors: {\n                init: function () {\n                    this.Null = new System.IO.Stream.NullStream();\n                    this._DefaultCopyBufferSize = 81920;\n                }\n            },\n            methods: {\n                Synchronized: function (stream) {\n                    if (stream == null) {\n                        throw new System.ArgumentNullException(\"stream\");\n                    }\n\n                    return stream;\n                },\n                BlockingEndRead: function (asyncResult) {\n\n                    return System.IO.Stream.SynchronousAsyncResult.EndRead(asyncResult);\n                },\n                BlockingEndWrite: function (asyncResult) {\n                    System.IO.Stream.SynchronousAsyncResult.EndWrite(asyncResult);\n                }\n            }\n        },\n        props: {\n            CanTimeout: {\n                get: function () {\n                    return false;\n                }\n            },\n            ReadTimeout: {\n                get: function () {\n                    throw new System.InvalidOperationException();\n                },\n                set: function (value) {\n                    throw new System.InvalidOperationException();\n                }\n            },\n            WriteTimeout: {\n                get: function () {\n                    throw new System.InvalidOperationException();\n                },\n                set: function (value) {\n                    throw new System.InvalidOperationException();\n                }\n            }\n        },\n        alias: [\"Dispose\", \"System$IDisposable$dispose\"],\n        methods: {\n            CopyTo: function (destination) {\n                if (destination == null) {\n                    throw new System.ArgumentNullException(\"destination\");\n                }\n                if (!this.CanRead && !this.CanWrite) {\n                    throw new System.Exception();\n                }\n                if (!destination.CanRead && !destination.CanWrite) {\n                    throw new System.Exception(\"destination\");\n                }\n                if (!this.CanRead) {\n                    throw new System.NotSupportedException();\n                }\n                if (!destination.CanWrite) {\n                    throw new System.NotSupportedException();\n                }\n\n                this.InternalCopyTo(destination, System.IO.Stream._DefaultCopyBufferSize);\n            },\n            CopyTo$1: function (destination, bufferSize) {\n                if (destination == null) {\n                    throw new System.ArgumentNullException(\"destination\");\n                }\n                if (bufferSize <= 0) {\n                    throw new System.ArgumentOutOfRangeException(\"bufferSize\");\n                }\n                if (!this.CanRead && !this.CanWrite) {\n                    throw new System.Exception();\n                }\n                if (!destination.CanRead && !destination.CanWrite) {\n                    throw new System.Exception(\"destination\");\n                }\n                if (!this.CanRead) {\n                    throw new System.NotSupportedException();\n                }\n                if (!destination.CanWrite) {\n                    throw new System.NotSupportedException();\n                }\n\n                this.InternalCopyTo(destination, bufferSize);\n            },\n            InternalCopyTo: function (destination, bufferSize) {\n\n                var buffer = System.Array.init(bufferSize, 0, System.Byte);\n                var read;\n                while (((read = this.Read(buffer, 0, buffer.length))) !== 0) {\n                    destination.Write(buffer, 0, read);\n                }\n            },\n            Close: function () {\n                /* These are correct, but we'd have to fix PipeStream & NetworkStream very carefully.\n                Contract.Ensures(CanRead == false);\n                Contract.Ensures(CanWrite == false);\n                Contract.Ensures(CanSeek == false);\n                */\n\n                this.Dispose$1(true);\n            },\n            Dispose: function () {\n                /* These are correct, but we'd have to fix PipeStream & NetworkStream very carefully.\n                Contract.Ensures(CanRead == false);\n                Contract.Ensures(CanWrite == false);\n                Contract.Ensures(CanSeek == false);\n                */\n\n                this.Close();\n            },\n            Dispose$1: function (disposing) {\n                // Note: Never change this to call other virtual methods on Stream\n                // like Write, since the state on subclasses has already been\n                // torn down.  This is the last code to run on cleanup for a stream.\n            },\n            BeginRead: function (buffer, offset, count, callback, state) {\n                return this.BeginReadInternal(buffer, offset, count, callback, state, false);\n            },\n            BeginReadInternal: function (buffer, offset, count, callback, state, serializeAsynchronously) {\n                if (!this.CanRead) {\n                    System.IO.__Error.ReadNotSupported();\n                }\n\n                return this.BlockingBeginRead(buffer, offset, count, callback, state);\n            },\n            EndRead: function (asyncResult) {\n                if (asyncResult == null) {\n                    throw new System.ArgumentNullException(\"asyncResult\");\n                }\n\n                return System.IO.Stream.BlockingEndRead(asyncResult);\n            },\n            BeginWrite: function (buffer, offset, count, callback, state) {\n                return this.BeginWriteInternal(buffer, offset, count, callback, state, false);\n            },\n            BeginWriteInternal: function (buffer, offset, count, callback, state, serializeAsynchronously) {\n                if (!this.CanWrite) {\n                    System.IO.__Error.WriteNotSupported();\n                }\n                return this.BlockingBeginWrite(buffer, offset, count, callback, state);\n            },\n            EndWrite: function (asyncResult) {\n                if (asyncResult == null) {\n                    throw new System.ArgumentNullException(\"asyncResult\");\n                }\n\n                System.IO.Stream.BlockingEndWrite(asyncResult);\n            },\n            ReadByte: function () {\n\n                var oneByteArray = System.Array.init(1, 0, System.Byte);\n                var r = this.Read(oneByteArray, 0, 1);\n                if (r === 0) {\n                    return -1;\n                }\n                return oneByteArray[System.Array.index(0, oneByteArray)];\n            },\n            WriteByte: function (value) {\n                var oneByteArray = System.Array.init(1, 0, System.Byte);\n                oneByteArray[System.Array.index(0, oneByteArray)] = value;\n                this.Write(oneByteArray, 0, 1);\n            },\n            BlockingBeginRead: function (buffer, offset, count, callback, state) {\n\n                // To avoid a race with a stream's position pointer & generating ----\n                // conditions with internal buffer indexes in our own streams that\n                // don't natively support async IO operations when there are multiple\n                // async requests outstanding, we will block the application's main\n                // thread and do the IO synchronously.\n                // This can't perform well - use a different approach.\n                var asyncResult;\n                try {\n                    var numRead = this.Read(buffer, offset, count);\n                    asyncResult = new System.IO.Stream.SynchronousAsyncResult.$ctor1(numRead, state);\n                }\n                catch ($e1) {\n                    $e1 = System.Exception.create($e1);\n                    var ex;\n                    if (Bridge.is($e1, System.IO.IOException)) {\n                        ex = $e1;\n                        asyncResult = new System.IO.Stream.SynchronousAsyncResult.ctor(ex, state, false);\n                    } else {\n                        throw $e1;\n                    }\n                }\n\n                if (!Bridge.staticEquals(callback, null)) {\n                    callback(asyncResult);\n                }\n\n                return asyncResult;\n            },\n            BlockingBeginWrite: function (buffer, offset, count, callback, state) {\n\n                // To avoid a race with a stream's position pointer & generating ----\n                // conditions with internal buffer indexes in our own streams that\n                // don't natively support async IO operations when there are multiple\n                // async requests outstanding, we will block the application's main\n                // thread and do the IO synchronously.\n                // This can't perform well - use a different approach.\n                var asyncResult;\n                try {\n                    this.Write(buffer, offset, count);\n                    asyncResult = new System.IO.Stream.SynchronousAsyncResult.$ctor2(state);\n                }\n                catch ($e1) {\n                    $e1 = System.Exception.create($e1);\n                    var ex;\n                    if (Bridge.is($e1, System.IO.IOException)) {\n                        ex = $e1;\n                        asyncResult = new System.IO.Stream.SynchronousAsyncResult.ctor(ex, state, true);\n                    } else {\n                        throw $e1;\n                    }\n                }\n\n                if (!Bridge.staticEquals(callback, null)) {\n                    callback(asyncResult);\n                }\n\n                return asyncResult;\n            }\n        }\n    });\n\n    Bridge.define(\"System.IO.IOException\", {\n        inherits: [System.Exception],\n        fields: {\n            _maybeFullPath: null\n        },\n        ctors: {\n            ctor: function () {\n                this.$initialize();\n                System.Exception.ctor.call(this, \"Arg_IOException\");\n            },\n            $ctor1: function (message) {\n                this.$initialize();\n                System.Exception.ctor.call(this, message);\n            },\n            $ctor3: function (message, hresult) {\n                this.$initialize();\n                System.Exception.ctor.call(this, message);\n            },\n            $ctor4: function (message, hresult, maybeFullPath) {\n                this.$initialize();\n                System.Exception.ctor.call(this, message);\n                this._maybeFullPath = maybeFullPath;\n            },\n            $ctor2: function (message, innerException) {\n                this.$initialize();\n                System.Exception.ctor.call(this, message, innerException);\n            }\n        }\n    });\n\n    Bridge.define(\"System.IO.File\", {\n        statics: {\n            methods: {\n                OpenText: function (path) {\n                    if (path == null) {\n                        throw new System.ArgumentNullException(\"path\");\n                    }\n                    return new System.IO.StreamReader.$ctor7(path);\n                },\n                OpenRead: function (path) {\n                    return new System.IO.FileStream.$ctor1(path, System.IO.FileMode.Open);\n                },\n                ReadAllText: function (path) {\n                    if (path == null) {\n                        throw new System.ArgumentNullException(\"path\");\n                    }\n                    if (path.length === 0) {\n                        throw new System.ArgumentException(\"Argument_EmptyPath\");\n                    }\n\n                    return System.IO.File.InternalReadAllText(path, System.Text.Encoding.UTF8, true);\n                },\n                ReadAllText$1: function (path, encoding) {\n                    if (path == null) {\n                        throw new System.ArgumentNullException(\"path\");\n                    }\n                    if (encoding == null) {\n                        throw new System.ArgumentNullException(\"encoding\");\n                    }\n                    if (path.length === 0) {\n                        throw new System.ArgumentException(\"Argument_EmptyPath\");\n                    }\n\n                    return System.IO.File.InternalReadAllText(path, encoding, true);\n                },\n                InternalReadAllText: function (path, encoding, checkHost) {\n\n                    var sr = new System.IO.StreamReader.$ctor12(path, encoding, true, System.IO.StreamReader.DefaultBufferSize, checkHost);\n                    try {\n                        return sr.ReadToEnd();\n                    }\n                    finally {\n                        if (Bridge.hasValue(sr)) {\n                            sr.System$IDisposable$dispose();\n                        }\n                    }\n                },\n                ReadAllBytes: function (path) {\n                    return System.IO.File.InternalReadAllBytes(path, true);\n                },\n                InternalReadAllBytes: function (path, checkHost) {\n                    var bytes;\n                    var fs = new System.IO.FileStream.$ctor1(path, System.IO.FileMode.Open);\n                    try {\n                        // Do a blocking read\n                        var index = 0;\n                        var fileLength = fs.Length;\n                        if (fileLength.gt(System.Int64(2147483647))) {\n                            throw new System.IO.IOException.$ctor1(\"IO.IO_FileTooLong2GB\");\n                        }\n                        var count = System.Int64.clip32(fileLength);\n                        bytes = System.Array.init(count, 0, System.Byte);\n                        while (count > 0) {\n                            var n = fs.Read(bytes, index, count);\n                            if (n === 0) {\n                                System.IO.__Error.EndOfFile();\n                            }\n                            index = (index + n) | 0;\n                            count = (count - n) | 0;\n                        }\n                    }\n                    finally {\n                        if (Bridge.hasValue(fs)) {\n                            fs.System$IDisposable$dispose();\n                        }\n                    }\n                    return bytes;\n                },\n                ReadAllLines: function (path) {\n                    if (path == null) {\n                        throw new System.ArgumentNullException(\"path\");\n                    }\n                    if (path.length === 0) {\n                        throw new System.ArgumentException(\"Argument_EmptyPath\");\n                    }\n\n                    return System.IO.File.InternalReadAllLines(path, System.Text.Encoding.UTF8);\n                },\n                ReadAllLines$1: function (path, encoding) {\n                    if (path == null) {\n                        throw new System.ArgumentNullException(\"path\");\n                    }\n                    if (encoding == null) {\n                        throw new System.ArgumentNullException(\"encoding\");\n                    }\n                    if (path.length === 0) {\n                        throw new System.ArgumentException(\"Argument_EmptyPath\");\n                    }\n\n                    return System.IO.File.InternalReadAllLines(path, encoding);\n                },\n                InternalReadAllLines: function (path, encoding) {\n\n                    var line;\n                    var lines = new (System.Collections.Generic.List$1(System.String)).ctor();\n\n                    var sr = new System.IO.StreamReader.$ctor9(path, encoding);\n                    try {\n                        while (((line = sr.ReadLine())) != null) {\n                            lines.add(line);\n                        }\n                    }\n                    finally {\n                        if (Bridge.hasValue(sr)) {\n                            sr.System$IDisposable$dispose();\n                        }\n                    }\n\n                    return lines.toArray();\n                },\n                ReadLines: function (path) {\n                    if (path == null) {\n                        throw new System.ArgumentNullException(\"path\");\n                    }\n                    if (path.length === 0) {\n                        throw new System.ArgumentException(\"Argument_EmptyPath\", \"path\");\n                    }\n\n                    return System.IO.ReadLinesIterator.CreateIterator(path, System.Text.Encoding.UTF8);\n                },\n                ReadLines$1: function (path, encoding) {\n                    if (path == null) {\n                        throw new System.ArgumentNullException(\"path\");\n                    }\n                    if (encoding == null) {\n                        throw new System.ArgumentNullException(\"encoding\");\n                    }\n                    if (path.length === 0) {\n                        throw new System.ArgumentException(\"Argument_EmptyPath\", \"path\");\n                    }\n\n                    return System.IO.ReadLinesIterator.CreateIterator(path, encoding);\n                }\n            }\n        }\n    });\n\n    Bridge.define(\"System.IO.FileMode\", {\n        $kind: \"enum\",\n        statics: {\n            fields: {\n                CreateNew: 1,\n                Create: 2,\n                Open: 3,\n                OpenOrCreate: 4,\n                Truncate: 5,\n                Append: 6\n            }\n        }\n    });\n\n    Bridge.define(\"System.IO.Iterator$1\", function (TSource) { return {\n        inherits: [System.Collections.Generic.IEnumerable$1(TSource),System.Collections.Generic.IEnumerator$1(TSource)],\n        fields: {\n            state: 0,\n            current: Bridge.getDefaultValue(TSource)\n        },\n        props: {\n            Current: {\n                get: function () {\n                    return this.current;\n                }\n            },\n            System$Collections$IEnumerator$Current: {\n                get: function () {\n                    return this.Current;\n                }\n            }\n        },\n        alias: [\n            \"Current\", [\"System$Collections$Generic$IEnumerator$1$\" + Bridge.getTypeAlias(TSource) + \"$Current$1\", \"System$Collections$Generic$IEnumerator$1$Current$1\"],\n            \"Dispose\", \"System$IDisposable$dispose\",\n            \"GetEnumerator\", [\"System$Collections$Generic$IEnumerable$1$\" + Bridge.getTypeAlias(TSource) + \"$getEnumerator\", \"System$Collections$Generic$IEnumerable$1$getEnumerator\"]\n        ],\n        ctors: {\n            ctor: function () {\n                this.$initialize();\n            }\n        },\n        methods: {\n            Dispose: function () {\n                this.Dispose$1(true);\n            },\n            Dispose$1: function (disposing) {\n                this.current = Bridge.getDefaultValue(TSource);\n                this.state = -1;\n            },\n            GetEnumerator: function () {\n                if (this.state === 0) {\n                    this.state = 1;\n                    return this;\n                }\n\n                var duplicate = this.Clone();\n                duplicate.state = 1;\n                return duplicate;\n            },\n            System$Collections$IEnumerable$getEnumerator: function () {\n                return this.GetEnumerator();\n            },\n            System$Collections$IEnumerator$reset: function () {\n                throw new System.NotSupportedException();\n            }\n        }\n    }; });\n\n    Bridge.define(\"System.IO.SeekOrigin\", {\n        $kind: \"enum\",\n        statics: {\n            fields: {\n                Begin: 0,\n                Current: 1,\n                End: 2\n            }\n        }\n    });\n\n    Bridge.define(\"System.IO.Stream.SynchronousAsyncResult\", {\n        inherits: [System.IAsyncResult],\n        statics: {\n            methods: {\n                EndRead: function (asyncResult) {\n\n                    var ar = Bridge.as(asyncResult, System.IO.Stream.SynchronousAsyncResult);\n                    if (ar == null || ar._isWrite) {\n                        System.IO.__Error.WrongAsyncResult();\n                    }\n\n                    if (ar._endXxxCalled) {\n                        System.IO.__Error.EndReadCalledTwice();\n                    }\n\n                    ar._endXxxCalled = true;\n\n                    ar.ThrowIfError();\n                    return ar._bytesRead;\n                },\n                EndWrite: function (asyncResult) {\n\n                    var ar = Bridge.as(asyncResult, System.IO.Stream.SynchronousAsyncResult);\n                    if (ar == null || !ar._isWrite) {\n                        System.IO.__Error.WrongAsyncResult();\n                    }\n\n                    if (ar._endXxxCalled) {\n                        System.IO.__Error.EndWriteCalledTwice();\n                    }\n\n                    ar._endXxxCalled = true;\n\n                    ar.ThrowIfError();\n                }\n            }\n        },\n        fields: {\n            _stateObject: null,\n            _isWrite: false,\n            _exceptionInfo: null,\n            _endXxxCalled: false,\n            _bytesRead: 0\n        },\n        props: {\n            IsCompleted: {\n                get: function () {\n                    return true;\n                }\n            },\n            AsyncState: {\n                get: function () {\n                    return this._stateObject;\n                }\n            },\n            CompletedSynchronously: {\n                get: function () {\n                    return true;\n                }\n            }\n        },\n        alias: [\n            \"IsCompleted\", \"System$IAsyncResult$IsCompleted\",\n            \"AsyncState\", \"System$IAsyncResult$AsyncState\",\n            \"CompletedSynchronously\", \"System$IAsyncResult$CompletedSynchronously\"\n        ],\n        ctors: {\n            $ctor1: function (bytesRead, asyncStateObject) {\n                this.$initialize();\n                this._bytesRead = bytesRead;\n                this._stateObject = asyncStateObject;\n                //_isWrite = false;\n            },\n            $ctor2: function (asyncStateObject) {\n                this.$initialize();\n                this._stateObject = asyncStateObject;\n                this._isWrite = true;\n            },\n            ctor: function (ex, asyncStateObject, isWrite) {\n                this.$initialize();\n                this._exceptionInfo = ex;\n                this._stateObject = asyncStateObject;\n                this._isWrite = isWrite;\n            }\n        },\n        methods: {\n            ThrowIfError: function () {\n                if (this._exceptionInfo != null) {\n                    throw this._exceptionInfo;\n                }\n            }\n        }\n    });\n\n    Bridge.define(\"System.IO.TextReader\", {\n        inherits: [System.IDisposable],\n        statics: {\n            fields: {\n                Null: null\n            },\n            ctors: {\n                init: function () {\n                    this.Null = new System.IO.TextReader.NullTextReader();\n                }\n            },\n            methods: {\n                Synchronized: function (reader) {\n                    if (reader == null) {\n                        throw new System.ArgumentNullException(\"reader\");\n                    }\n\n                    return reader;\n                }\n            }\n        },\n        alias: [\"Dispose\", \"System$IDisposable$dispose\"],\n        ctors: {\n            ctor: function () {\n                this.$initialize();\n            }\n        },\n        methods: {\n            Close: function () {\n                this.Dispose$1(true);\n            },\n            Dispose: function () {\n                this.Dispose$1(true);\n            },\n            Dispose$1: function (disposing) { },\n            Peek: function () {\n\n                return -1;\n            },\n            Read: function () {\n                return -1;\n            },\n            Read$1: function (buffer, index, count) {\n                if (buffer == null) {\n                    throw new System.ArgumentNullException(\"buffer\");\n                }\n                if (index < 0) {\n                    throw new System.ArgumentOutOfRangeException(\"index\");\n                }\n                if (count < 0) {\n                    throw new System.ArgumentOutOfRangeException(\"count\");\n                }\n                if (((buffer.length - index) | 0) < count) {\n                    throw new System.ArgumentException();\n                }\n\n                var n = 0;\n                do {\n                    var ch = this.Read();\n                    if (ch === -1) {\n                        break;\n                    }\n                    buffer[System.Array.index(((index + Bridge.identity(n, (n = (n + 1) | 0))) | 0), buffer)] = ch & 65535;\n                } while (n < count);\n                return n;\n            },\n            ReadToEnd: function () {\n\n                var chars = System.Array.init(4096, 0, System.Char);\n                var len;\n                var sb = new System.Text.StringBuilder(\"\", 4096);\n                while (((len = this.Read$1(chars, 0, chars.length))) !== 0) {\n                    sb.append(System.String.fromCharArray(chars, 0, len));\n                }\n                return sb.toString();\n            },\n            ReadBlock: function (buffer, index, count) {\n\n                var i, n = 0;\n                do {\n                    n = (n + ((i = this.Read$1(buffer, ((index + n) | 0), ((count - n) | 0))))) | 0;\n                } while (i > 0 && n < count);\n                return n;\n            },\n            ReadLine: function () {\n                var sb = new System.Text.StringBuilder();\n                while (true) {\n                    var ch = this.Read();\n                    if (ch === -1) {\n                        break;\n                    }\n                    if (ch === 13 || ch === 10) {\n                        if (ch === 13 && this.Peek() === 10) {\n                            this.Read();\n                        }\n                        return sb.toString();\n                    }\n                    sb.append(String.fromCharCode((ch & 65535)));\n                }\n                if (sb.getLength() > 0) {\n                    return sb.toString();\n                }\n                return null;\n            }\n        }\n    });\n\n    Bridge.define(\"System.IO.TextWriter\", {\n        inherits: [System.IDisposable],\n        statics: {\n            fields: {\n                Null: null,\n                InitialNewLine: null\n            },\n            ctors: {\n                init: function () {\n                    this.Null = new System.IO.TextWriter.NullTextWriter();\n                    this.InitialNewLine = \"\\r\\n\";\n                }\n            },\n            methods: {\n                Synchronized: function (writer) {\n                    if (writer == null) {\n                        throw new System.ArgumentNullException(\"writer\");\n                    }\n\n                    return writer;\n                }\n            }\n        },\n        fields: {\n            CoreNewLine: null,\n            InternalFormatProvider: null\n        },\n        props: {\n            FormatProvider: {\n                get: function () {\n                    if (this.InternalFormatProvider == null) {\n                        return System.Globalization.CultureInfo.getCurrentCulture();\n                    } else {\n                        return this.InternalFormatProvider;\n                    }\n                }\n            },\n            NewLine: {\n                get: function () {\n                    return System.String.fromCharArray(this.CoreNewLine);\n                },\n                set: function (value) {\n                    if (value == null) {\n                        value = System.IO.TextWriter.InitialNewLine;\n                    }\n                    this.CoreNewLine = System.String.toCharArray(value, 0, value.length);\n                }\n            }\n        },\n        alias: [\"Dispose\", \"System$IDisposable$dispose\"],\n        ctors: {\n            init: function () {\n                this.CoreNewLine = System.Array.init([13, 10], System.Char);\n            },\n            ctor: function () {\n                this.$initialize();\n                this.InternalFormatProvider = null; // Ask for CurrentCulture all the time.\n            },\n            $ctor1: function (formatProvider) {\n                this.$initialize();\n                this.InternalFormatProvider = formatProvider;\n            }\n        },\n        methods: {\n            Close: function () {\n                this.Dispose$1(true);\n            },\n            Dispose$1: function (disposing) { },\n            Dispose: function () {\n                this.Dispose$1(true);\n            },\n            Flush: function () { },\n            Write$1: function (value) { },\n            Write$2: function (buffer) {\n                if (buffer != null) {\n                    this.Write$3(buffer, 0, buffer.length);\n                }\n            },\n            Write$3: function (buffer, index, count) {\n                if (buffer == null) {\n                    throw new System.ArgumentNullException(\"buffer\");\n                }\n                if (index < 0) {\n                    throw new System.ArgumentOutOfRangeException(\"index\");\n                }\n                if (count < 0) {\n                    throw new System.ArgumentOutOfRangeException(\"count\");\n                }\n                if (((buffer.length - index) | 0) < count) {\n                    throw new System.ArgumentException();\n                }\n\n                for (var i = 0; i < count; i = (i + 1) | 0) {\n                    this.Write$1(buffer[System.Array.index(((index + i) | 0), buffer)]);\n                }\n            },\n            Write: function (value) {\n                this.Write$10(value ? System.Boolean.trueString : System.Boolean.falseString);\n            },\n            Write$6: function (value) {\n                this.Write$10(System.Int32.format(value, \"G\", this.FormatProvider));\n            },\n            Write$15: function (value) {\n                this.Write$10(System.UInt32.format(value, \"G\", this.FormatProvider));\n            },\n            Write$7: function (value) {\n                this.Write$10(value.format(\"G\", this.FormatProvider));\n            },\n            Write$16: function (value) {\n                this.Write$10(value.format(\"G\", this.FormatProvider));\n            },\n            Write$9: function (value) {\n                this.Write$10(System.Single.format(value, \"G\", this.FormatProvider));\n            },\n            Write$5: function (value) {\n                this.Write$10(System.Double.format(value, \"G\", this.FormatProvider));\n            },\n            Write$4: function (value) {\n                this.Write$10(Bridge.Int.format(value, \"G\", this.FormatProvider));\n            },\n            Write$10: function (value) {\n                if (value != null) {\n                    this.Write$2(System.String.toCharArray(value, 0, value.length));\n                }\n            },\n            Write$8: function (value) {\n                if (value != null) {\n                    var f = Bridge.as(value, System.IFormattable);\n                    if (f != null) {\n                        this.Write$10(Bridge.format(f, null, this.FormatProvider));\n                    } else {\n                        this.Write$10(value.toString());\n                    }\n                }\n            },\n            Write$11: function (format, arg0) {\n                this.Write$10(System.String.formatProvider(this.FormatProvider, format, arg0));\n            },\n            Write$12: function (format, arg0, arg1) {\n                this.Write$10(System.String.formatProvider(this.FormatProvider, format, arg0, arg1));\n            },\n            Write$13: function (format, arg0, arg1, arg2) {\n                this.Write$10(System.String.formatProvider(this.FormatProvider, format, arg0, arg1, arg2));\n            },\n            Write$14: function (format, arg) {\n                if (arg === void 0) { arg = []; }\n                this.Write$10(System.String.formatProvider.apply(System.String, [this.FormatProvider, format].concat(arg)));\n            },\n            WriteLine: function () {\n                this.Write$2(this.CoreNewLine);\n            },\n            WriteLine$2: function (value) {\n                this.Write$1(value);\n                this.WriteLine();\n            },\n            WriteLine$3: function (buffer) {\n                this.Write$2(buffer);\n                this.WriteLine();\n            },\n            WriteLine$4: function (buffer, index, count) {\n                this.Write$3(buffer, index, count);\n                this.WriteLine();\n            },\n            WriteLine$1: function (value) {\n                this.Write(value);\n                this.WriteLine();\n            },\n            WriteLine$7: function (value) {\n                this.Write$6(value);\n                this.WriteLine();\n            },\n            WriteLine$16: function (value) {\n                this.Write$15(value);\n                this.WriteLine();\n            },\n            WriteLine$8: function (value) {\n                this.Write$7(value);\n                this.WriteLine();\n            },\n            WriteLine$17: function (value) {\n                this.Write$16(value);\n                this.WriteLine();\n            },\n            WriteLine$10: function (value) {\n                this.Write$9(value);\n                this.WriteLine();\n            },\n            WriteLine$6: function (value) {\n                this.Write$5(value);\n                this.WriteLine();\n            },\n            WriteLine$5: function (value) {\n                this.Write$4(value);\n                this.WriteLine();\n            },\n            WriteLine$11: function (value) {\n\n                if (value == null) {\n                    this.WriteLine();\n                } else {\n                    // We'd ideally like WriteLine to be atomic, in that one call\n                    // to WriteLine equals one call to the OS (ie, so writing to\n                    // console while simultaneously calling printf will guarantee we\n                    // write out a string and new line chars, without any interference).\n                    // Additionally, we need to call ToCharArray on Strings anyways,\n                    // so allocating a char[] here isn't any worse than what we were\n                    // doing anyways.  We do reduce the number of calls to the\n                    // backing store this way, potentially.\n                    var vLen = value.length;\n                    var nlLen = this.CoreNewLine.length;\n                    var chars = System.Array.init(((vLen + nlLen) | 0), 0, System.Char);\n                    System.String.copyTo(value, 0, chars, 0, vLen);\n                    // CoreNewLine will almost always be 2 chars, and possibly 1.\n                    if (nlLen === 2) {\n                        chars[System.Array.index(vLen, chars)] = this.CoreNewLine[System.Array.index(0, this.CoreNewLine)];\n                        chars[System.Array.index(((vLen + 1) | 0), chars)] = this.CoreNewLine[System.Array.index(1, this.CoreNewLine)];\n                    } else if (nlLen === 1) {\n                        chars[System.Array.index(vLen, chars)] = this.CoreNewLine[System.Array.index(0, this.CoreNewLine)];\n                    } else {\n                        System.Array.copy(this.CoreNewLine, 0, chars, Bridge.Int.mul(vLen, 2), Bridge.Int.mul(nlLen, 2));\n                    }\n                    this.Write$3(chars, 0, ((vLen + nlLen) | 0));\n                }\n                /* \n                Write(value);  // We could call Write(String) on StreamWriter...\n                WriteLine();\n                */\n            },\n            WriteLine$9: function (value) {\n                if (value == null) {\n                    this.WriteLine();\n                } else {\n                    // Call WriteLine(value.ToString), not Write(Object), WriteLine().\n                    // This makes calls to WriteLine(Object) atomic.\n                    var f = Bridge.as(value, System.IFormattable);\n                    if (f != null) {\n                        this.WriteLine$11(Bridge.format(f, null, this.FormatProvider));\n                    } else {\n                        this.WriteLine$11(value.toString());\n                    }\n                }\n            },\n            WriteLine$12: function (format, arg0) {\n                this.WriteLine$11(System.String.formatProvider(this.FormatProvider, format, arg0));\n            },\n            WriteLine$13: function (format, arg0, arg1) {\n                this.WriteLine$11(System.String.formatProvider(this.FormatProvider, format, arg0, arg1));\n            },\n            WriteLine$14: function (format, arg0, arg1, arg2) {\n                this.WriteLine$11(System.String.formatProvider(this.FormatProvider, format, arg0, arg1, arg2));\n            },\n            WriteLine$15: function (format, arg) {\n                if (arg === void 0) { arg = []; }\n                this.WriteLine$11(System.String.formatProvider.apply(System.String, [this.FormatProvider, format].concat(arg)));\n            }\n        }\n    });\n\n    Bridge.define(\"System.IO.BufferedStream\", {\n        inherits: [System.IO.Stream],\n        statics: {\n            fields: {\n                _DefaultBufferSize: 0,\n                MaxShadowBufferSize: 0\n            },\n            ctors: {\n                init: function () {\n                    this._DefaultBufferSize = 4096;\n                    this.MaxShadowBufferSize = 81920;\n                }\n            }\n        },\n        fields: {\n            _stream: null,\n            _buffer: null,\n            _bufferSize: 0,\n            _readPos: 0,\n            _readLen: 0,\n            _writePos: 0\n        },\n        props: {\n            UnderlyingStream: {\n                get: function () {\n                    return this._stream;\n                }\n            },\n            BufferSize: {\n                get: function () {\n                    return this._bufferSize;\n                }\n            },\n            CanRead: {\n                get: function () {\n                    return this._stream != null && this._stream.CanRead;\n                }\n            },\n            CanWrite: {\n                get: function () {\n                    return this._stream != null && this._stream.CanWrite;\n                }\n            },\n            CanSeek: {\n                get: function () {\n                    return this._stream != null && this._stream.CanSeek;\n                }\n            },\n            Length: {\n                get: function () {\n                    this.EnsureNotClosed();\n\n                    if (this._writePos > 0) {\n                        this.FlushWrite();\n                    }\n\n                    return this._stream.Length;\n                }\n            },\n            Position: {\n                get: function () {\n                    this.EnsureNotClosed();\n                    this.EnsureCanSeek();\n\n                    return this._stream.Position.add(System.Int64((((((this._readPos - this._readLen) | 0) + this._writePos) | 0))));\n                },\n                set: function (value) {\n                    if (value.lt(System.Int64(0))) {\n                        throw new System.ArgumentOutOfRangeException(\"value\");\n                    }\n\n                    this.EnsureNotClosed();\n                    this.EnsureCanSeek();\n\n                    if (this._writePos > 0) {\n                        this.FlushWrite();\n                    }\n\n                    this._readPos = 0;\n                    this._readLen = 0;\n                    this._stream.Seek(value, System.IO.SeekOrigin.Begin);\n                }\n            }\n        },\n        ctors: {\n            ctor: function () {\n                this.$initialize();\n                System.IO.Stream.ctor.call(this);\n            },\n            $ctor1: function (stream) {\n                System.IO.BufferedStream.$ctor2.call(this, stream, System.IO.BufferedStream._DefaultBufferSize);\n            },\n            $ctor2: function (stream, bufferSize) {\n                this.$initialize();\n                System.IO.Stream.ctor.call(this);\n\n                if (stream == null) {\n                    throw new System.ArgumentNullException(\"stream\");\n                }\n\n                if (bufferSize <= 0) {\n                    throw new System.ArgumentOutOfRangeException(\"bufferSize\");\n                }\n\n                this._stream = stream;\n                this._bufferSize = bufferSize;\n\n                // Allocate _buffer on its first use - it will not be used if all reads\n                // & writes are greater than or equal to buffer size.\n\n                if (!this._stream.CanRead && !this._stream.CanWrite) {\n                    System.IO.__Error.StreamIsClosed();\n                }\n            }\n        },\n        methods: {\n            EnsureNotClosed: function () {\n\n                if (this._stream == null) {\n                    System.IO.__Error.StreamIsClosed();\n                }\n            },\n            EnsureCanSeek: function () {\n\n\n                if (!this._stream.CanSeek) {\n                    System.IO.__Error.SeekNotSupported();\n                }\n            },\n            EnsureCanRead: function () {\n\n\n                if (!this._stream.CanRead) {\n                    System.IO.__Error.ReadNotSupported();\n                }\n            },\n            EnsureCanWrite: function () {\n\n\n                if (!this._stream.CanWrite) {\n                    System.IO.__Error.WriteNotSupported();\n                }\n            },\n            EnsureShadowBufferAllocated: function () {\n\n\n                // Already have shadow buffer?\n                if (this._buffer.length !== this._bufferSize || this._bufferSize >= System.IO.BufferedStream.MaxShadowBufferSize) {\n                    return;\n                }\n\n                var shadowBuffer = System.Array.init(Math.min(((this._bufferSize + this._bufferSize) | 0), System.IO.BufferedStream.MaxShadowBufferSize), 0, System.Byte);\n                System.Array.copy(this._buffer, 0, shadowBuffer, 0, this._writePos);\n                this._buffer = shadowBuffer;\n            },\n            EnsureBufferAllocated: function () {\n\n\n                // BufferedStream is not intended for multi-threaded use, so no worries about the get/set ---- on _buffer.\n                if (this._buffer == null) {\n                    this._buffer = System.Array.init(this._bufferSize, 0, System.Byte);\n                }\n            },\n            Dispose$1: function (disposing) {\n\n                try {\n                    if (disposing && this._stream != null) {\n                        try {\n                            this.Flush();\n                        }\n                        finally {\n                            this._stream.Close();\n                        }\n                    }\n                }\n                finally {\n                    this._stream = null;\n                    this._buffer = null;\n\n                    // Call base.Dispose(bool) to cleanup async IO resources\n                    System.IO.Stream.prototype.Dispose$1.call(this, disposing);\n                }\n            },\n            Flush: function () {\n\n                this.EnsureNotClosed();\n\n                // Has WRITE data in the buffer:\n                if (this._writePos > 0) {\n\n                    this.FlushWrite();\n                    return;\n                }\n\n                // Has READ data in the buffer:\n                if (this._readPos < this._readLen) {\n\n                    // If the underlying stream is not seekable AND we have something in the read buffer, then FlushRead would throw.\n                    // We can either throw away the buffer resulting in data loss (!) or ignore the Flush.\n                    // (We cannot throw becasue it would be a breaking change.) We opt into ignoring the Flush in that situation.\n                    if (!this._stream.CanSeek) {\n                        return;\n                    }\n\n                    this.FlushRead();\n\n                    // User streams may have opted to throw from Flush if CanWrite is false (although the abstract Stream does not do so).\n                    // However, if we do not forward the Flush to the underlying stream, we may have problems when chaining several streams.\n                    // Let us make a best effort attempt:\n                    if (this._stream.CanWrite || Bridge.is(this._stream, System.IO.BufferedStream)) {\n                        this._stream.Flush();\n                    }\n\n                    return;\n                }\n\n                // We had no data in the buffer, but we still need to tell the underlying stream to flush.\n                if (this._stream.CanWrite || Bridge.is(this._stream, System.IO.BufferedStream)) {\n                    this._stream.Flush();\n                }\n\n                this._writePos = (this._readPos = (this._readLen = 0));\n            },\n            FlushRead: function () {\n\n\n                if (((this._readPos - this._readLen) | 0) !== 0) {\n                    this._stream.Seek(System.Int64(this._readPos - this._readLen), System.IO.SeekOrigin.Current);\n                }\n\n                this._readPos = 0;\n                this._readLen = 0;\n            },\n            ClearReadBufferBeforeWrite: function () {\n\n                // This is called by write methods to clear the read buffer.\n\n\n                // No READ data in the buffer:\n                if (this._readPos === this._readLen) {\n\n                    this._readPos = (this._readLen = 0);\n                    return;\n                }\n\n                // Must have READ data.\n\n                // If the underlying stream cannot seek, FlushRead would end up throwing NotSupported.\n                // However, since the user did not call a method that is intuitively expected to seek, a better message is in order.\n                // Ideally, we would throw an InvalidOperation here, but for backward compat we have to stick with NotSupported.\n                if (!this._stream.CanSeek) {\n                    throw new System.NotSupportedException();\n                }\n\n                this.FlushRead();\n            },\n            FlushWrite: function () {\n\n\n                this._stream.Write(this._buffer, 0, this._writePos);\n                this._writePos = 0;\n                this._stream.Flush();\n            },\n            ReadFromBuffer: function (array, offset, count) {\n\n                var readBytes = (this._readLen - this._readPos) | 0;\n\n                if (readBytes === 0) {\n                    return 0;\n                }\n\n\n                if (readBytes > count) {\n                    readBytes = count;\n                }\n\n                System.Array.copy(this._buffer, this._readPos, array, offset, readBytes);\n                this._readPos = (this._readPos + readBytes) | 0;\n\n                return readBytes;\n            },\n            ReadFromBuffer$1: function (array, offset, count, error) {\n\n                try {\n\n                    error.v = null;\n                    return this.ReadFromBuffer(array, offset, count);\n\n                }\n                catch (ex) {\n                    ex = System.Exception.create(ex);\n                    error.v = ex;\n                    return 0;\n                }\n            },\n            Read: function (array, offset, count) {\n\n                if (array == null) {\n                    throw new System.ArgumentNullException(\"array\");\n                }\n                if (offset < 0) {\n                    throw new System.ArgumentOutOfRangeException(\"offset\");\n                }\n                if (count < 0) {\n                    throw new System.ArgumentOutOfRangeException(\"count\");\n                }\n                if (((array.length - offset) | 0) < count) {\n                    throw new System.ArgumentException();\n                }\n\n                this.EnsureNotClosed();\n                this.EnsureCanRead();\n\n                var bytesFromBuffer = this.ReadFromBuffer(array, offset, count);\n\n                // We may have read less than the number of bytes the user asked for, but that is part of the Stream contract.\n\n                // Reading again for more data may cause us to block if we're using a device with no clear end of file,\n                // such as a serial port or pipe. If we blocked here and this code was used with redirected pipes for a\n                // process's standard output, this can lead to deadlocks involving two processes.\n                // BUT - this is a breaking change.\n                // So: If we could not read all bytes the user asked for from the buffer, we will try once from the underlying\n                // stream thus ensuring the same blocking behaviour as if the underlying stream was not wrapped in this BufferedStream.\n                if (bytesFromBuffer === count) {\n                    return bytesFromBuffer;\n                }\n\n                var alreadySatisfied = bytesFromBuffer;\n                if (bytesFromBuffer > 0) {\n                    count = (count - bytesFromBuffer) | 0;\n                    offset = (offset + bytesFromBuffer) | 0;\n                }\n\n                // So the READ buffer is empty.\n                this._readPos = (this._readLen = 0);\n\n                // If there was anything in the WRITE buffer, clear it.\n                if (this._writePos > 0) {\n                    this.FlushWrite();\n                }\n\n                // If the requested read is larger than buffer size, avoid the buffer and still use a single read:\n                if (count >= this._bufferSize) {\n\n                    return ((this._stream.Read(array, offset, count) + alreadySatisfied) | 0);\n                }\n\n                // Ok. We can fill the buffer:\n                this.EnsureBufferAllocated();\n                this._readLen = this._stream.Read(this._buffer, 0, this._bufferSize);\n\n                bytesFromBuffer = this.ReadFromBuffer(array, offset, count);\n\n                // We may have read less than the number of bytes the user asked for, but that is part of the Stream contract.\n                // Reading again for more data may cause us to block if we're using a device with no clear end of stream,\n                // such as a serial port or pipe.  If we blocked here & this code was used with redirected pipes for a process's\n                // standard output, this can lead to deadlocks involving two processes. Additionally, translating one read on the\n                // BufferedStream to more than one read on the underlying Stream may defeat the whole purpose of buffering of the\n                // underlying reads are significantly more expensive.\n\n                return ((bytesFromBuffer + alreadySatisfied) | 0);\n            },\n            ReadByte: function () {\n\n                this.EnsureNotClosed();\n                this.EnsureCanRead();\n\n                if (this._readPos === this._readLen) {\n\n                    if (this._writePos > 0) {\n                        this.FlushWrite();\n                    }\n\n                    this.EnsureBufferAllocated();\n                    this._readLen = this._stream.Read(this._buffer, 0, this._bufferSize);\n                    this._readPos = 0;\n                }\n\n                if (this._readPos === this._readLen) {\n                    return -1;\n                }\n\n                var b = this._buffer[System.Array.index(Bridge.identity(this._readPos, (this._readPos = (this._readPos + 1) | 0)), this._buffer)];\n                return b;\n            },\n            WriteToBuffer: function (array, offset, count) {\n\n                var bytesToWrite = Math.min(((this._bufferSize - this._writePos) | 0), count.v);\n\n                if (bytesToWrite <= 0) {\n                    return;\n                }\n\n                this.EnsureBufferAllocated();\n                System.Array.copy(array, offset.v, this._buffer, this._writePos, bytesToWrite);\n\n                this._writePos = (this._writePos + bytesToWrite) | 0;\n                count.v = (count.v - bytesToWrite) | 0;\n                offset.v = (offset.v + bytesToWrite) | 0;\n            },\n            WriteToBuffer$1: function (array, offset, count, error) {\n\n                try {\n\n                    error.v = null;\n                    this.WriteToBuffer(array, offset, count);\n\n                }\n                catch (ex) {\n                    ex = System.Exception.create(ex);\n                    error.v = ex;\n                }\n            },\n            Write: function (array, offset, count) {\n                offset = {v:offset};\n                count = {v:count};\n\n                if (array == null) {\n                    throw new System.ArgumentNullException(\"array\");\n                }\n                if (offset.v < 0) {\n                    throw new System.ArgumentOutOfRangeException(\"offset\");\n                }\n                if (count.v < 0) {\n                    throw new System.ArgumentOutOfRangeException(\"count\");\n                }\n                if (((array.length - offset.v) | 0) < count.v) {\n                    throw new System.ArgumentException();\n                }\n\n                this.EnsureNotClosed();\n                this.EnsureCanWrite();\n\n                if (this._writePos === 0) {\n                    this.ClearReadBufferBeforeWrite();\n                }\n\n                // We need to use the buffer, while avoiding unnecessary buffer usage / memory copies.\n                // We ASSUME that memory copies are much cheaper than writes to the underlying stream, so if an extra copy is\n                // guaranteed to reduce the number of writes, we prefer it.\n                // We pick a simple strategy that makes degenerate cases rare if our assumptions are right.\n                //\n                // For ever write, we use a simple heuristic (below) to decide whether to use the buffer.\n                // The heuristic has the desirable property (*) that if the specified user data can fit into the currently available\n                // buffer space without filling it up completely, the heuristic will always tell us to use the buffer. It will also\n                // tell us to use the buffer in cases where the current write would fill the buffer, but the remaining data is small\n                // enough such that subsequent operations can use the buffer again.\n                //\n                // Algorithm:\n                // Determine whether or not to buffer according to the heuristic (below).\n                // If we decided to use the buffer:\n                //     Copy as much user data as we can into the buffer.\n                //     If we consumed all data: We are finished.\n                //     Otherwise, write the buffer out.\n                //     Copy the rest of user data into the now cleared buffer (no need to write out the buffer again as the heuristic\n                //     will prevent it from being filled twice).\n                // If we decided not to use the buffer:\n                //     Can the data already in the buffer and current user data be combines to a single write\n                //     by allocating a \"shadow\" buffer of up to twice the size of _bufferSize (up to a limit to avoid LOH)?\n                //     Yes, it can:\n                //         Allocate a larger \"shadow\" buffer and ensure the buffered  data is moved there.\n                //         Copy user data to the shadow buffer.\n                //         Write shadow buffer to the underlying stream in a single operation.\n                //     No, it cannot (amount of data is still too large):\n                //         Write out any data possibly in the buffer.\n                //         Write out user data directly.\n                //\n                // Heuristic:\n                // If the subsequent write operation that follows the current write operation will result in a write to the\n                // underlying stream in case that we use the buffer in the current write, while it would not have if we avoided\n                // using the buffer in the current write (by writing current user data to the underlying stream directly), then we\n                // prefer to avoid using the buffer since the corresponding memory copy is wasted (it will not reduce the number\n                // of writes to the underlying stream, which is what we are optimising for).\n                // ASSUME that the next write will be for the same amount of bytes as the current write (most common case) and\n                // determine if it will cause a write to the underlying stream. If the next write is actually larger, our heuristic\n                // still yields the right behaviour, if the next write is actually smaller, we may making an unnecessary write to\n                // the underlying stream. However, this can only occur if the current write is larger than half the buffer size and\n                // we will recover after one iteration.\n                // We have:\n                //     useBuffer = (_writePos + count + count < _bufferSize + _bufferSize)\n                //\n                // Example with _bufferSize = 20, _writePos = 6, count = 10:\n                //\n                //     +---------------------------------------+---------------------------------------+\n                //     |             current buffer            | next iteration's \"future\" buffer      |\n                //     +---------------------------------------+---------------------------------------+\n                //     |0| | | | | | | | | |1| | | | | | | | | |2| | | | | | | | | |3| | | | | | | | | |\n                //     |0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|\n                //     +-----------+-------------------+-------------------+---------------------------+\n                //     | _writePos |  current count    | assumed next count|avail buff after next write|\n                //     +-----------+-------------------+-------------------+---------------------------+\n                //\n                // A nice property (*) of this heuristic is that it will always succeed if the user data completely fits into the\n                // available buffer, i.e. if count < (_bufferSize - _writePos).\n\n\n                var totalUserBytes;\n                var useBuffer; // We do not expect buffer sizes big enough for an overflow, but if it happens, lets fail early:\n                totalUserBytes = Bridge.Int.check(this._writePos + count.v, System.Int32);\n                useBuffer = (Bridge.Int.check(totalUserBytes + count.v, System.Int32) < (Bridge.Int.check(this._bufferSize + this._bufferSize, System.Int32)));\n\n                if (useBuffer) {\n\n                    this.WriteToBuffer(array, offset, count);\n\n                    if (this._writePos < this._bufferSize) {\n\n                        return;\n                    }\n\n\n                    this._stream.Write(this._buffer, 0, this._writePos);\n                    this._writePos = 0;\n\n                    this.WriteToBuffer(array, offset, count);\n\n\n                } else { // if (!useBuffer)\n\n                    // Write out the buffer if necessary.\n                    if (this._writePos > 0) {\n\n\n                        // Try avoiding extra write to underlying stream by combining previously buffered data with current user data:\n                        if (totalUserBytes <= (((this._bufferSize + this._bufferSize) | 0)) && totalUserBytes <= System.IO.BufferedStream.MaxShadowBufferSize) {\n\n                            this.EnsureShadowBufferAllocated();\n                            System.Array.copy(array, offset.v, this._buffer, this._writePos, count.v);\n                            this._stream.Write(this._buffer, 0, totalUserBytes);\n                            this._writePos = 0;\n                            return;\n                        }\n\n                        this._stream.Write(this._buffer, 0, this._writePos);\n                        this._writePos = 0;\n                    }\n\n                    // Write out user data.\n                    this._stream.Write(array, offset.v, count.v);\n                }\n            },\n            WriteByte: function (value) {\n\n                this.EnsureNotClosed();\n\n                if (this._writePos === 0) {\n\n                    this.EnsureCanWrite();\n                    this.ClearReadBufferBeforeWrite();\n                    this.EnsureBufferAllocated();\n                }\n\n                // We should not be flushing here, but only writing to the underlying stream, but previous version flushed, so we keep this.\n                if (this._writePos >= ((this._bufferSize - 1) | 0)) {\n                    this.FlushWrite();\n                }\n\n                this._buffer[System.Array.index(Bridge.identity(this._writePos, (this._writePos = (this._writePos + 1) | 0)), this._buffer)] = value;\n\n            },\n            Seek: function (offset, origin) {\n\n                this.EnsureNotClosed();\n                this.EnsureCanSeek();\n\n                // If we have bytes in the WRITE buffer, flush them out, seek and be done.\n                if (this._writePos > 0) {\n\n                    // We should be only writing the buffer and not flushing,\n                    // but the previous version did flush and we stick to it for back-compat reasons.\n                    this.FlushWrite();\n                    return this._stream.Seek(offset, origin);\n                }\n\n                // The buffer is either empty or we have a buffered READ.\n\n                if (((this._readLen - this._readPos) | 0) > 0 && origin === System.IO.SeekOrigin.Current) {\n\n                    // If we have bytes in the READ buffer, adjust the seek offset to account for the resulting difference\n                    // between this stream's position and the underlying stream's position.\n                    offset = offset.sub(System.Int64((((this._readLen - this._readPos) | 0))));\n                }\n\n                var oldPos = this.Position;\n\n                var newPos = this._stream.Seek(offset, origin);\n\n                // If the seek destination is still within the data currently in the buffer, we want to keep the buffer data and continue using it.\n                // Otherwise we will throw away the buffer. This can only happen on READ, as we flushed WRITE data above.\n\n                // The offset of the new/updated seek pointer within _buffer:\n                this._readPos = System.Int64.clip32(newPos.sub((oldPos.sub(System.Int64(this._readPos)))));\n\n                // If the offset of the updated seek pointer in the buffer is still legal, then we can keep using the buffer:\n                if (0 <= this._readPos && this._readPos < this._readLen) {\n\n                    // Adjust the seek pointer of the underlying stream to reflect the amount of useful bytes in the read buffer:\n                    this._stream.Seek(System.Int64(this._readLen - this._readPos), System.IO.SeekOrigin.Current);\n\n                } else { // The offset of the updated seek pointer is not a legal offset. Loose the buffer.\n\n                    this._readPos = (this._readLen = 0);\n                }\n\n                return newPos;\n            },\n            SetLength: function (value) {\n\n                if (value.lt(System.Int64(0))) {\n                    throw new System.ArgumentOutOfRangeException(\"value\");\n                }\n\n                this.EnsureNotClosed();\n                this.EnsureCanSeek();\n                this.EnsureCanWrite();\n\n                this.Flush();\n                this._stream.SetLength(value);\n            }\n        }\n    });\n\n    Bridge.define(\"System.IO.EndOfStreamException\", {\n        inherits: [System.IO.IOException],\n        ctors: {\n            ctor: function () {\n                this.$initialize();\n                System.IO.IOException.$ctor1.call(this, \"Arg_EndOfStreamException\");\n            },\n            $ctor1: function (message) {\n                this.$initialize();\n                System.IO.IOException.$ctor1.call(this, message);\n            },\n            $ctor2: function (message, innerException) {\n                this.$initialize();\n                System.IO.IOException.$ctor2.call(this, message, innerException);\n            }\n        }\n    });\n\n    Bridge.define(\"System.IO.FileStream\", {\n        inherits: [System.IO.Stream],\n        statics: {\n            methods: {\n                FromFile: function (file) {\n                    var completer = new System.Threading.Tasks.TaskCompletionSource();\n                    var fileReader = new FileReader();\n                    fileReader.onload = function () {\n                        completer.setResult(new System.IO.FileStream.ctor(fileReader.result, file.name));\n                    };\n                    fileReader.onerror = function (e) {\n                        completer.setException(new Bridge.ErrorException(Bridge.unbox(e).target.error.As()));\n                    };\n                    fileReader.readAsArrayBuffer(file);\n\n                    return completer.task;\n                },\n                ReadBytes: function (path) {\n                    if (Bridge.isNode) {\n                        var fs = require(\"fs\");\n                        return Bridge.cast(fs.readFileSync(path), ArrayBuffer);\n                    } else {\n                        var req = new XMLHttpRequest();\n                        req.open(\"GET\", path, false);\n                        req.overrideMimeType(\"text/plain; charset=binary-data\");\n                        req.send(null);\n                        if (req.status !== 200) {\n                            throw new System.IO.IOException.$ctor1(System.String.format(\"Status of request to {0} returned status: {1}\", path, Bridge.box(req.status, System.UInt16)));\n                        }\n                        var text = req.responseText;\n                        var resultArray = new Uint8Array(text.length);\n                        System.String.toCharArray(text, 0, text.length).forEach(function (v, index, array) {\n                                var $t;\n                                return ($t = (v & 255) & 255, resultArray[index] = $t, $t);\n                            });\n                        return resultArray.buffer;\n                    }\n                }\n            }\n        },\n        fields: {\n            name: null,\n            _buffer: null\n        },\n        props: {\n            CanRead: {\n                get: function () {\n                    return true;\n                }\n            },\n            CanWrite: {\n                get: function () {\n                    return false;\n                }\n            },\n            CanSeek: {\n                get: function () {\n                    return false;\n                }\n            },\n            IsAsync: {\n                get: function () {\n                    return false;\n                }\n            },\n            Name: {\n                get: function () {\n                    return this.name;\n                }\n            },\n            Length: {\n                get: function () {\n                    return System.Int64(this._buffer.byteLength);\n                }\n            },\n            Position: System.Int64(0)\n        },\n        ctors: {\n            $ctor1: function (path, mode) {\n                this.$initialize();\n                System.IO.Stream.ctor.call(this);\n                this._buffer = System.IO.FileStream.ReadBytes(path);\n                this.name = path;\n            },\n            ctor: function (buffer, name) {\n                this.$initialize();\n                System.IO.Stream.ctor.call(this);\n                this._buffer = buffer;\n                this.name = name;\n            }\n        },\n        methods: {\n            Flush: function () { },\n            Seek: function (offset, origin) {\n                throw new System.NotImplementedException();\n            },\n            SetLength: function (value) {\n                throw new System.NotImplementedException();\n            },\n            Write: function (buffer, offset, count) {\n                throw new System.NotImplementedException();\n            },\n            Read: function (buffer, offset, count) {\n                if (buffer == null) {\n                    throw new System.ArgumentNullException(\"buffer\");\n                }\n\n                if (offset < 0) {\n                    throw new System.ArgumentOutOfRangeException(\"offset\");\n                }\n\n                if (count < 0) {\n                    throw new System.ArgumentOutOfRangeException(\"count\");\n                }\n\n                if ((this.Length.sub(System.Int64(offset))).lt(System.Int64(count))) {\n                    throw new System.ArgumentException();\n                }\n\n                var num = this.Length.sub(this.Position);\n                if (num.gt(System.Int64(count))) {\n                    num = System.Int64(count);\n                }\n\n                if (num.lte(System.Int64(0))) {\n                    return 0;\n                }\n\n                var byteBuffer = new Uint8Array(this._buffer);\n                if (num.gt(System.Int64(8))) {\n                    for (var n = 0; System.Int64(n).lt(num); n = (n + 1) | 0) {\n                        buffer[System.Array.index(((n + offset) | 0), buffer)] = byteBuffer[this.Position.add(System.Int64(n))];\n                    }\n                } else {\n                    var num1 = num;\n                    while (true) {\n                        var num2 = num1.sub(System.Int64(1));\n                        num1 = num2;\n                        if (num2.lt(System.Int64(0))) {\n                            break;\n                        }\n                        buffer[System.Array.index(System.Int64.toNumber(System.Int64(offset).add(num1)), buffer)] = byteBuffer[this.Position.add(num1)];\n                    }\n                }\n                this.Position = this.Position.add(num);\n                return System.Int64.clip32(num);\n            }\n        }\n    });\n\n    Bridge.define(\"System.IO.MemoryStream\", {\n        inherits: [System.IO.Stream],\n        statics: {\n            fields: {\n                MemStreamMaxLength: 0\n            },\n            ctors: {\n                init: function () {\n                    this.MemStreamMaxLength = 2147483647;\n                }\n            }\n        },\n        fields: {\n            _buffer: null,\n            _origin: 0,\n            _position: 0,\n            _length: 0,\n            _capacity: 0,\n            _expandable: false,\n            _writable: false,\n            _exposable: false,\n            _isOpen: false\n        },\n        props: {\n            CanRead: {\n                get: function () {\n                    return this._isOpen;\n                }\n            },\n            CanSeek: {\n                get: function () {\n                    return this._isOpen;\n                }\n            },\n            CanWrite: {\n                get: function () {\n                    return this._writable;\n                }\n            },\n            Capacity: {\n                get: function () {\n                    if (!this._isOpen) {\n                        System.IO.__Error.StreamIsClosed();\n                    }\n                    return ((this._capacity - this._origin) | 0);\n                },\n                set: function (value) {\n                    // Only update the capacity if the MS is expandable and the value is different than the current capacity.\n                    // Special behavior if the MS isn't expandable: we don't throw if value is the same as the current capacity\n                    if (System.Int64(value).lt(this.Length)) {\n                        throw new System.ArgumentOutOfRangeException(\"value\", \"ArgumentOutOfRange_SmallCapacity\");\n                    }\n\n                    if (!this._isOpen) {\n                        System.IO.__Error.StreamIsClosed();\n                    }\n                    if (!this._expandable && (value !== this.Capacity)) {\n                        System.IO.__Error.MemoryStreamNotExpandable();\n                    }\n\n                    // MemoryStream has this invariant: _origin > 0 => !expandable (see ctors)\n                    if (this._expandable && value !== this._capacity) {\n                        if (value > 0) {\n                            var newBuffer = System.Array.init(value, 0, System.Byte);\n                            if (this._length > 0) {\n                                System.Array.copy(this._buffer, 0, newBuffer, 0, this._length);\n                            }\n                            this._buffer = newBuffer;\n                        } else {\n                            this._buffer = null;\n                        }\n                        this._capacity = value;\n                    }\n                }\n            },\n            Length: {\n                get: function () {\n                    if (!this._isOpen) {\n                        System.IO.__Error.StreamIsClosed();\n                    }\n                    return System.Int64(this._length - this._origin);\n                }\n            },\n            Position: {\n                get: function () {\n                    if (!this._isOpen) {\n                        System.IO.__Error.StreamIsClosed();\n                    }\n                    return System.Int64(this._position - this._origin);\n                },\n                set: function (value) {\n                    if (value.lt(System.Int64(0))) {\n                        throw new System.ArgumentOutOfRangeException(\"value\", \"ArgumentOutOfRange_NeedNonNegNum\");\n                    }\n\n                    if (!this._isOpen) {\n                        System.IO.__Error.StreamIsClosed();\n                    }\n\n                    if (value.gt(System.Int64(System.IO.MemoryStream.MemStreamMaxLength))) {\n                        throw new System.ArgumentOutOfRangeException(\"value\", \"ArgumentOutOfRange_StreamLength\");\n                    }\n                    this._position = (this._origin + System.Int64.clip32(value)) | 0;\n                }\n            }\n        },\n        ctors: {\n            ctor: function () {\n                System.IO.MemoryStream.$ctor6.call(this, 0);\n            },\n            $ctor6: function (capacity) {\n                this.$initialize();\n                System.IO.Stream.ctor.call(this);\n                if (capacity < 0) {\n                    throw new System.ArgumentOutOfRangeException(\"capacity\", \"ArgumentOutOfRange_NegativeCapacity\");\n                }\n\n                this._buffer = System.Array.init(capacity, 0, System.Byte);\n                this._capacity = capacity;\n                this._expandable = true;\n                this._writable = true;\n                this._exposable = true;\n                this._origin = 0; // Must be 0 for byte[]'s created by MemoryStream\n                this._isOpen = true;\n            },\n            $ctor1: function (buffer) {\n                System.IO.MemoryStream.$ctor2.call(this, buffer, true);\n            },\n            $ctor2: function (buffer, writable) {\n                this.$initialize();\n                System.IO.Stream.ctor.call(this);\n                if (buffer == null) {\n                    throw new System.ArgumentNullException(\"buffer\", \"ArgumentNull_Buffer\");\n                }\n                this._buffer = buffer;\n                this._length = (this._capacity = buffer.length);\n                this._writable = writable;\n                this._exposable = false;\n                this._origin = 0;\n                this._isOpen = true;\n            },\n            $ctor3: function (buffer, index, count) {\n                System.IO.MemoryStream.$ctor5.call(this, buffer, index, count, true, false);\n            },\n            $ctor4: function (buffer, index, count, writable) {\n                System.IO.MemoryStream.$ctor5.call(this, buffer, index, count, writable, false);\n            },\n            $ctor5: function (buffer, index, count, writable, publiclyVisible) {\n                this.$initialize();\n                System.IO.Stream.ctor.call(this);\n                if (buffer == null) {\n                    throw new System.ArgumentNullException(\"buffer\", \"ArgumentNull_Buffer\");\n                }\n                if (index < 0) {\n                    throw new System.ArgumentOutOfRangeException(\"index\", \"ArgumentOutOfRange_NeedNonNegNum\");\n                }\n                if (count < 0) {\n                    throw new System.ArgumentOutOfRangeException(\"count\", \"ArgumentOutOfRange_NeedNonNegNum\");\n                }\n                if (((buffer.length - index) | 0) < count) {\n                    throw new System.ArgumentException(\"Argument_InvalidOffLen\");\n                }\n\n                this._buffer = buffer;\n                this._origin = (this._position = index);\n                this._length = (this._capacity = (index + count) | 0);\n                this._writable = writable;\n                this._exposable = publiclyVisible; // Can TryGetBuffer/GetBuffer return the array?\n                this._expandable = false;\n                this._isOpen = true;\n            }\n        },\n        methods: {\n            EnsureWriteable: function () {\n                if (!this.CanWrite) {\n                    System.IO.__Error.WriteNotSupported();\n                }\n            },\n            Dispose$1: function (disposing) {\n                try {\n                    if (disposing) {\n                        this._isOpen = false;\n                        this._writable = false;\n                        this._expandable = false;\n                    }\n                }\n                finally {\n                    // Call base.Close() to cleanup async IO resources\n                    System.IO.Stream.prototype.Dispose$1.call(this, disposing);\n                }\n            },\n            EnsureCapacity: function (value) {\n                // Check for overflow\n                if (value < 0) {\n                    throw new System.IO.IOException.$ctor1(\"IO.IO_StreamTooLong\");\n                }\n                if (value > this._capacity) {\n                    var newCapacity = value;\n                    if (newCapacity < 256) {\n                        newCapacity = 256;\n                    }\n                    // We are ok with this overflowing since the next statement will deal\n                    // with the cases where _capacity*2 overflows.\n                    if (newCapacity < Bridge.Int.mul(this._capacity, 2)) {\n                        newCapacity = Bridge.Int.mul(this._capacity, 2);\n                    }\n                    // We want to expand the array up to Array.MaxArrayLengthOneDimensional\n                    // And we want to give the user the value that they asked for\n                    if ((((Bridge.Int.mul(this._capacity, 2))) >>> 0) > 2147483591) {\n                        newCapacity = value > 2147483591 ? value : 2147483591;\n                    }\n\n                    this.Capacity = newCapacity;\n                    return true;\n                }\n                return false;\n            },\n            Flush: function () { },\n            GetBuffer: function () {\n                if (!this._exposable) {\n                    throw new System.Exception(\"UnauthorizedAccess_MemStreamBuffer\");\n                }\n                return this._buffer;\n            },\n            TryGetBuffer: function (buffer) {\n                if (!this._exposable) {\n                    buffer.v = Bridge.getDefaultValue(System.ArraySegment);\n                    return false;\n                }\n\n                buffer.v = new System.ArraySegment(this._buffer, this._origin, (((this._length - this._origin) | 0)));\n                return true;\n            },\n            InternalGetBuffer: function () {\n                return this._buffer;\n            },\n            InternalGetPosition: function () {\n                if (!this._isOpen) {\n                    System.IO.__Error.StreamIsClosed();\n                }\n                return this._position;\n            },\n            InternalReadInt32: function () {\n                if (!this._isOpen) {\n                    System.IO.__Error.StreamIsClosed();\n                }\n\n                var pos = ((this._position = (this._position + 4) | 0)); // use temp to avoid ----\n                if (pos > this._length) {\n                    this._position = this._length;\n                    System.IO.__Error.EndOfFile();\n                }\n                return this._buffer[System.Array.index(((pos - 4) | 0), this._buffer)] | this._buffer[System.Array.index(((pos - 3) | 0), this._buffer)] << 8 | this._buffer[System.Array.index(((pos - 2) | 0), this._buffer)] << 16 | this._buffer[System.Array.index(((pos - 1) | 0), this._buffer)] << 24;\n            },\n            InternalEmulateRead: function (count) {\n                if (!this._isOpen) {\n                    System.IO.__Error.StreamIsClosed();\n                }\n\n                var n = (this._length - this._position) | 0;\n                if (n > count) {\n                    n = count;\n                }\n                if (n < 0) {\n                    n = 0;\n                } // len is less than 2^31 -1.\n                this._position = (this._position + n) | 0;\n                return n;\n            },\n            Read: function (buffer, offset, count) {\n                if (buffer == null) {\n                    throw new System.ArgumentNullException(\"buffer\", \"ArgumentNull_Buffer\");\n                }\n                if (offset < 0) {\n                    throw new System.ArgumentOutOfRangeException(\"offset\", \"ArgumentOutOfRange_NeedNonNegNum\");\n                }\n                if (count < 0) {\n                    throw new System.ArgumentOutOfRangeException(\"count\", \"ArgumentOutOfRange_NeedNonNegNum\");\n                }\n                if (((buffer.length - offset) | 0) < count) {\n                    throw new System.ArgumentException(\"Argument_InvalidOffLen\");\n                }\n\n                if (!this._isOpen) {\n                    System.IO.__Error.StreamIsClosed();\n                }\n\n                var n = (this._length - this._position) | 0;\n                if (n > count) {\n                    n = count;\n                }\n                if (n <= 0) {\n                    return 0;\n                } // len is less than 2^31 -1.\n\n                if (n <= 8) {\n                    var byteCount = n;\n                    while (((byteCount = (byteCount - 1) | 0)) >= 0) {\n                        buffer[System.Array.index(((offset + byteCount) | 0), buffer)] = this._buffer[System.Array.index(((this._position + byteCount) | 0), this._buffer)];\n                    }\n                } else {\n                    System.Array.copy(this._buffer, this._position, buffer, offset, n);\n                }\n                this._position = (this._position + n) | 0;\n\n                return n;\n            },\n            ReadByte: function () {\n                if (!this._isOpen) {\n                    System.IO.__Error.StreamIsClosed();\n                }\n\n                if (this._position >= this._length) {\n                    return -1;\n                }\n\n                return this._buffer[System.Array.index(Bridge.identity(this._position, (this._position = (this._position + 1) | 0)), this._buffer)];\n            },\n            Seek: function (offset, loc) {\n                if (!this._isOpen) {\n                    System.IO.__Error.StreamIsClosed();\n                }\n\n                if (offset.gt(System.Int64(System.IO.MemoryStream.MemStreamMaxLength))) {\n                    throw new System.ArgumentOutOfRangeException(\"offset\", \"ArgumentOutOfRange_StreamLength\");\n                }\n                switch (loc) {\n                    case System.IO.SeekOrigin.Begin: \n                        {\n                            var tempPosition = ((this._origin + System.Int64.clip32(offset)) | 0);\n                            if (offset.lt(System.Int64(0)) || tempPosition < this._origin) {\n                                throw new System.IO.IOException.$ctor1(\"IO.IO_SeekBeforeBegin\");\n                            }\n                            this._position = tempPosition;\n                            break;\n                        }\n                    case System.IO.SeekOrigin.Current: \n                        {\n                            var tempPosition1 = ((this._position + System.Int64.clip32(offset)) | 0);\n                            if (System.Int64(this._position).add(offset).lt(System.Int64(this._origin)) || tempPosition1 < this._origin) {\n                                throw new System.IO.IOException.$ctor1(\"IO.IO_SeekBeforeBegin\");\n                            }\n                            this._position = tempPosition1;\n                            break;\n                        }\n                    case System.IO.SeekOrigin.End: \n                        {\n                            var tempPosition2 = ((this._length + System.Int64.clip32(offset)) | 0);\n                            if (System.Int64(this._length).add(offset).lt(System.Int64(this._origin)) || tempPosition2 < this._origin) {\n                                throw new System.IO.IOException.$ctor1(\"IO.IO_SeekBeforeBegin\");\n                            }\n                            this._position = tempPosition2;\n                            break;\n                        }\n                    default: \n                        throw new System.ArgumentException(\"Argument_InvalidSeekOrigin\");\n                }\n\n                return System.Int64(this._position);\n            },\n            SetLength: function (value) {\n                if (value.lt(System.Int64(0)) || value.gt(System.Int64(2147483647))) {\n                    throw new System.ArgumentOutOfRangeException(\"value\", \"ArgumentOutOfRange_StreamLength\");\n                }\n                this.EnsureWriteable();\n\n                // Origin wasn't publicly exposed above. // Check parameter validation logic in this method if this fails.\n                if (value.gt(System.Int64((((2147483647 - this._origin) | 0))))) {\n                    throw new System.ArgumentOutOfRangeException(\"value\", \"ArgumentOutOfRange_StreamLength\");\n                }\n\n                var newLength = (this._origin + System.Int64.clip32(value)) | 0;\n                var allocatedNewArray = this.EnsureCapacity(newLength);\n                if (!allocatedNewArray && newLength > this._length) {\n                    System.Array.fill(this._buffer, 0, this._length, ((newLength - this._length) | 0));\n                }\n                this._length = newLength;\n                if (this._position > newLength) {\n                    this._position = newLength;\n                }\n\n            },\n            ToArray: function () {\n                var copy = System.Array.init(((this._length - this._origin) | 0), 0, System.Byte);\n                System.Array.copy(this._buffer, this._origin, copy, 0, ((this._length - this._origin) | 0));\n                return copy;\n            },\n            Write: function (buffer, offset, count) {\n                if (buffer == null) {\n                    throw new System.ArgumentNullException(\"buffer\", \"ArgumentNull_Buffer\");\n                }\n                if (offset < 0) {\n                    throw new System.ArgumentOutOfRangeException(\"offset\", \"ArgumentOutOfRange_NeedNonNegNum\");\n                }\n                if (count < 0) {\n                    throw new System.ArgumentOutOfRangeException(\"count\", \"ArgumentOutOfRange_NeedNonNegNum\");\n                }\n                if (((buffer.length - offset) | 0) < count) {\n                    throw new System.ArgumentException(\"Argument_InvalidOffLen\");\n                }\n\n                if (!this._isOpen) {\n                    System.IO.__Error.StreamIsClosed();\n                }\n                this.EnsureWriteable();\n\n                var i = (this._position + count) | 0;\n                // Check for overflow\n                if (i < 0) {\n                    throw new System.IO.IOException.$ctor1(\"IO.IO_StreamTooLong\");\n                }\n\n                if (i > this._length) {\n                    var mustZero = this._position > this._length;\n                    if (i > this._capacity) {\n                        var allocatedNewArray = this.EnsureCapacity(i);\n                        if (allocatedNewArray) {\n                            mustZero = false;\n                        }\n                    }\n                    if (mustZero) {\n                        System.Array.fill(this._buffer, 0, this._length, ((i - this._length) | 0));\n                    }\n                    this._length = i;\n                }\n                if ((count <= 8) && (!Bridge.referenceEquals(buffer, this._buffer))) {\n                    var byteCount = count;\n                    while (((byteCount = (byteCount - 1) | 0)) >= 0) {\n                        this._buffer[System.Array.index(((this._position + byteCount) | 0), this._buffer)] = buffer[System.Array.index(((offset + byteCount) | 0), buffer)];\n                    }\n                } else {\n                    System.Array.copy(buffer, offset, this._buffer, this._position, count);\n                }\n                this._position = i;\n\n            },\n            WriteByte: function (value) {\n                if (!this._isOpen) {\n                    System.IO.__Error.StreamIsClosed();\n                }\n                this.EnsureWriteable();\n\n                if (this._position >= this._length) {\n                    var newLength = (this._position + 1) | 0;\n                    var mustZero = this._position > this._length;\n                    if (newLength >= this._capacity) {\n                        var allocatedNewArray = this.EnsureCapacity(newLength);\n                        if (allocatedNewArray) {\n                            mustZero = false;\n                        }\n                    }\n                    if (mustZero) {\n                        System.Array.fill(this._buffer, 0, this._length, ((this._position - this._length) | 0));\n                    }\n                    this._length = newLength;\n                }\n                this._buffer[System.Array.index(Bridge.identity(this._position, (this._position = (this._position + 1) | 0)), this._buffer)] = value;\n\n            },\n            WriteTo: function (stream) {\n                if (stream == null) {\n                    throw new System.ArgumentNullException(\"stream\", \"ArgumentNull_Stream\");\n                }\n\n                if (!this._isOpen) {\n                    System.IO.__Error.StreamIsClosed();\n                }\n                stream.Write(this._buffer, this._origin, ((this._length - this._origin) | 0));\n            }\n        }\n    });\n\n    Bridge.define(\"System.IO.ReadLinesIterator\", {\n        inherits: [System.IO.Iterator$1(System.String)],\n        statics: {\n            methods: {\n                CreateIterator: function (path, encoding) {\n                    return System.IO.ReadLinesIterator.CreateIterator$1(path, encoding, null);\n                },\n                CreateIterator$1: function (path, encoding, reader) {\n                    return new System.IO.ReadLinesIterator(path, encoding, reader || new System.IO.StreamReader.$ctor9(path, encoding));\n                }\n            }\n        },\n        fields: {\n            _path: null,\n            _encoding: null,\n            _reader: null\n        },\n        alias: [\"MoveNext\", \"System$Collections$IEnumerator$moveNext\"],\n        ctors: {\n            ctor: function (path, encoding, reader) {\n                this.$initialize();\n                System.IO.Iterator$1(System.String).ctor.call(this);\n\n                this._path = path;\n                this._encoding = encoding;\n                this._reader = reader;\n            }\n        },\n        methods: {\n            MoveNext: function () {\n                if (this._reader != null) {\n                    this.current = this._reader.ReadLine();\n                    if (this.current != null) {\n                        return true;\n                    }\n\n                    // To maintain 4.0 behavior we Dispose\n                    // after reading to the end of the reader.\n                    this.Dispose();\n                }\n\n                return false;\n            },\n            Clone: function () {\n                // NOTE: To maintain the same behavior with the previous yield-based\n                // iterator in 4.0, we have all the IEnumerator<T> instances share the same\n                // underlying reader. If we have already been disposed, _reader will be null,\n                // which will cause CreateIterator to simply new up a new instance to start up\n                // a new iteration. Dev10 Bugs 904764 has been filed to fix this in next side-\n                // by-side release.\n                return System.IO.ReadLinesIterator.CreateIterator$1(this._path, this._encoding, this._reader);\n            },\n            Dispose$1: function (disposing) {\n                try {\n                    if (disposing) {\n                        if (this._reader != null) {\n                            this._reader.Dispose();\n                        }\n                    }\n                }\n                finally {\n                    this._reader = null;\n                    System.IO.Iterator$1(System.String).prototype.Dispose$1.call(this, disposing);\n                }\n            }\n        }\n    });\n\n    Bridge.define(\"System.IO.Stream.NullStream\", {\n        inherits: [System.IO.Stream],\n        props: {\n            CanRead: {\n                get: function () {\n                    return true;\n                }\n            },\n            CanWrite: {\n                get: function () {\n                    return true;\n                }\n            },\n            CanSeek: {\n                get: function () {\n                    return true;\n                }\n            },\n            Length: {\n                get: function () {\n                    return System.Int64(0);\n                }\n            },\n            Position: {\n                get: function () {\n                    return System.Int64(0);\n                },\n                set: function (value) { }\n            }\n        },\n        ctors: {\n            ctor: function () {\n                this.$initialize();\n                System.IO.Stream.ctor.call(this);\n            }\n        },\n        methods: {\n            Dispose$1: function (disposing) {\n                // Do nothing - we don't want NullStream singleton (static) to be closable\n            },\n            Flush: function () { },\n            BeginRead: function (buffer, offset, count, callback, state) {\n                if (!this.CanRead) {\n                    System.IO.__Error.ReadNotSupported();\n                }\n\n                return this.BlockingBeginRead(buffer, offset, count, callback, state);\n            },\n            EndRead: function (asyncResult) {\n                if (asyncResult == null) {\n                    throw new System.ArgumentNullException(\"asyncResult\");\n                }\n\n                return System.IO.Stream.BlockingEndRead(asyncResult);\n            },\n            BeginWrite: function (buffer, offset, count, callback, state) {\n                if (!this.CanWrite) {\n                    System.IO.__Error.WriteNotSupported();\n                }\n\n                return this.BlockingBeginWrite(buffer, offset, count, callback, state);\n            },\n            EndWrite: function (asyncResult) {\n                if (asyncResult == null) {\n                    throw new System.ArgumentNullException(\"asyncResult\");\n                }\n\n                System.IO.Stream.BlockingEndWrite(asyncResult);\n            },\n            Read: function (buffer, offset, count) {\n                return 0;\n            },\n            ReadByte: function () {\n                return -1;\n            },\n            Write: function (buffer, offset, count) { },\n            WriteByte: function (value) { },\n            Seek: function (offset, origin) {\n                return System.Int64(0);\n            },\n            SetLength: function (length) { }\n        }\n    });\n\n    Bridge.define(\"System.IO.StreamReader\", {\n        inherits: [System.IO.TextReader],\n        statics: {\n            fields: {\n                Null: null,\n                DefaultFileStreamBufferSize: 0,\n                MinBufferSize: 0\n            },\n            props: {\n                DefaultBufferSize: {\n                    get: function () {\n                        return 1024;\n                    }\n                }\n            },\n            ctors: {\n                init: function () {\n                    this.Null = new System.IO.StreamReader.NullStreamReader();\n                    this.DefaultFileStreamBufferSize = 4096;\n                    this.MinBufferSize = 128;\n                }\n            }\n        },\n        fields: {\n            stream: null,\n            encoding: null,\n            byteBuffer: null,\n            charBuffer: null,\n            charPos: 0,\n            charLen: 0,\n            byteLen: 0,\n            bytePos: 0,\n            _maxCharsPerBuffer: 0,\n            _detectEncoding: false,\n            _isBlocked: false,\n            _closable: false\n        },\n        props: {\n            CurrentEncoding: {\n                get: function () {\n                    return this.encoding;\n                }\n            },\n            BaseStream: {\n                get: function () {\n                    return this.stream;\n                }\n            },\n            LeaveOpen: {\n                get: function () {\n                    return !this._closable;\n                }\n            },\n            EndOfStream: {\n                get: function () {\n                    if (this.stream == null) {\n                        System.IO.__Error.ReaderClosed();\n                    }\n\n\n                    if (this.charPos < this.charLen) {\n                        return false;\n                    }\n\n                    // This may block on pipes!\n                    var numRead = this.ReadBuffer();\n                    return numRead === 0;\n                }\n            }\n        },\n        ctors: {\n            ctor: function () {\n                this.$initialize();\n                System.IO.TextReader.ctor.call(this);\n            },\n            $ctor1: function (stream) {\n                System.IO.StreamReader.$ctor2.call(this, stream, true);\n            },\n            $ctor2: function (stream, detectEncodingFromByteOrderMarks) {\n                System.IO.StreamReader.$ctor6.call(this, stream, System.Text.Encoding.UTF8, detectEncodingFromByteOrderMarks, System.IO.StreamReader.DefaultBufferSize, false);\n            },\n            $ctor3: function (stream, encoding) {\n                System.IO.StreamReader.$ctor6.call(this, stream, encoding, true, System.IO.StreamReader.DefaultBufferSize, false);\n            },\n            $ctor4: function (stream, encoding, detectEncodingFromByteOrderMarks) {\n                System.IO.StreamReader.$ctor6.call(this, stream, encoding, detectEncodingFromByteOrderMarks, System.IO.StreamReader.DefaultBufferSize, false);\n            },\n            $ctor5: function (stream, encoding, detectEncodingFromByteOrderMarks, bufferSize) {\n                System.IO.StreamReader.$ctor6.call(this, stream, encoding, detectEncodingFromByteOrderMarks, bufferSize, false);\n            },\n            $ctor6: function (stream, encoding, detectEncodingFromByteOrderMarks, bufferSize, leaveOpen) {\n                this.$initialize();\n                System.IO.TextReader.ctor.call(this);\n                if (stream == null || encoding == null) {\n                    throw new System.ArgumentNullException((stream == null ? \"stream\" : \"encoding\"));\n                }\n                if (!stream.CanRead) {\n                    throw new System.ArgumentException();\n                }\n                if (bufferSize <= 0) {\n                    throw new System.ArgumentOutOfRangeException(\"bufferSize\");\n                }\n\n                this.Init$1(stream, encoding, detectEncodingFromByteOrderMarks, bufferSize, leaveOpen);\n            },\n            $ctor7: function (path) {\n                System.IO.StreamReader.$ctor8.call(this, path, true);\n            },\n            $ctor8: function (path, detectEncodingFromByteOrderMarks) {\n                System.IO.StreamReader.$ctor11.call(this, path, System.Text.Encoding.UTF8, detectEncodingFromByteOrderMarks, System.IO.StreamReader.DefaultBufferSize);\n            },\n            $ctor9: function (path, encoding) {\n                System.IO.StreamReader.$ctor11.call(this, path, encoding, true, System.IO.StreamReader.DefaultBufferSize);\n            },\n            $ctor10: function (path, encoding, detectEncodingFromByteOrderMarks) {\n                System.IO.StreamReader.$ctor11.call(this, path, encoding, detectEncodingFromByteOrderMarks, System.IO.StreamReader.DefaultBufferSize);\n            },\n            $ctor11: function (path, encoding, detectEncodingFromByteOrderMarks, bufferSize) {\n                System.IO.StreamReader.$ctor12.call(this, path, encoding, detectEncodingFromByteOrderMarks, bufferSize, true);\n            },\n            $ctor12: function (path, encoding, detectEncodingFromByteOrderMarks, bufferSize, checkHost) {\n                this.$initialize();\n                System.IO.TextReader.ctor.call(this);\n                // Don't open a Stream before checking for invalid arguments,\n                // or we'll create a FileStream on disk and we won't close it until\n                // the finalizer runs, causing problems for applications.\n                if (path == null || encoding == null) {\n                    throw new System.ArgumentNullException((path == null ? \"path\" : \"encoding\"));\n                }\n                if (path.length === 0) {\n                    throw new System.ArgumentException();\n                }\n                if (bufferSize <= 0) {\n                    throw new System.ArgumentOutOfRangeException(\"bufferSize\");\n                }\n\n                var stream = new System.IO.FileStream.$ctor1(path, System.IO.FileMode.Open);\n                this.Init$1(stream, encoding, detectEncodingFromByteOrderMarks, bufferSize, false);\n            }\n        },\n        methods: {\n            Init$1: function (stream, encoding, detectEncodingFromByteOrderMarks, bufferSize, leaveOpen) {\n                this.stream = stream;\n                this.encoding = encoding;\n                if (bufferSize < System.IO.StreamReader.MinBufferSize) {\n                    bufferSize = System.IO.StreamReader.MinBufferSize;\n                }\n                this.byteBuffer = System.Array.init(bufferSize, 0, System.Byte);\n                this._maxCharsPerBuffer = encoding.GetMaxCharCount(bufferSize);\n                this.charBuffer = System.Array.init(this._maxCharsPerBuffer, 0, System.Char);\n                this.byteLen = 0;\n                this.bytePos = 0;\n                this._detectEncoding = detectEncodingFromByteOrderMarks;\n                this._isBlocked = false;\n                this._closable = !leaveOpen;\n            },\n            Init: function (stream) {\n                this.stream = stream;\n                this._closable = true;\n            },\n            Close: function () {\n                this.Dispose$1(true);\n            },\n            Dispose$1: function (disposing) {\n                // Dispose of our resources if this StreamReader is closable.\n                // Note that Console.In should be left open.\n                try {\n                    // Note that Stream.Close() can potentially throw here. So we need to\n                    // ensure cleaning up internal resources, inside the finally block.\n                    if (!this.LeaveOpen && disposing && (this.stream != null)) {\n                        this.stream.Close();\n                    }\n                }\n                finally {\n                    if (!this.LeaveOpen && (this.stream != null)) {\n                        this.stream = null;\n                        this.encoding = null;\n                        this.byteBuffer = null;\n                        this.charBuffer = null;\n                        this.charPos = 0;\n                        this.charLen = 0;\n                        System.IO.TextReader.prototype.Dispose$1.call(this, disposing);\n                    }\n                }\n            },\n            DiscardBufferedData: function () {\n\n                this.byteLen = 0;\n                this.charLen = 0;\n                this.charPos = 0;\n                this._isBlocked = false;\n            },\n            Peek: function () {\n                if (this.stream == null) {\n                    System.IO.__Error.ReaderClosed();\n                }\n\n                if (this.charPos === this.charLen) {\n                    if (this._isBlocked || this.ReadBuffer() === 0) {\n                        return -1;\n                    }\n                }\n                return this.charBuffer[System.Array.index(this.charPos, this.charBuffer)];\n            },\n            Read: function () {\n                if (this.stream == null) {\n                    System.IO.__Error.ReaderClosed();\n                }\n\n\n                if (this.charPos === this.charLen) {\n                    if (this.ReadBuffer() === 0) {\n                        return -1;\n                    }\n                }\n                var result = this.charBuffer[System.Array.index(this.charPos, this.charBuffer)];\n                this.charPos = (this.charPos + 1) | 0;\n                return result;\n            },\n            Read$1: function (buffer, index, count) {\n                if (buffer == null) {\n                    throw new System.ArgumentNullException(\"buffer\");\n                }\n                if (index < 0 || count < 0) {\n                    throw new System.ArgumentOutOfRangeException((index < 0 ? \"index\" : \"count\"));\n                }\n                if (((buffer.length - index) | 0) < count) {\n                    throw new System.ArgumentException();\n                }\n\n                if (this.stream == null) {\n                    System.IO.__Error.ReaderClosed();\n                }\n\n\n                var charsRead = 0;\n                // As a perf optimization, if we had exactly one buffer's worth of\n                // data read in, let's try writing directly to the user's buffer.\n                var readToUserBuffer = { v : false };\n                while (count > 0) {\n                    var n = (this.charLen - this.charPos) | 0;\n                    if (n === 0) {\n                        n = this.ReadBuffer$1(buffer, ((index + charsRead) | 0), count, readToUserBuffer);\n                    }\n                    if (n === 0) {\n                        break;\n                    } // We're at EOF\n                    if (n > count) {\n                        n = count;\n                    }\n                    if (!readToUserBuffer.v) {\n                        System.Array.copy(this.charBuffer, this.charPos, buffer, (((index + charsRead) | 0)), n);\n                        this.charPos = (this.charPos + n) | 0;\n                    }\n                    charsRead = (charsRead + n) | 0;\n                    count = (count - n) | 0;\n                    // This function shouldn't block for an indefinite amount of time,\n                    // or reading from a network stream won't work right.  If we got\n                    // fewer bytes than we requested, then we want to break right here.\n                    if (this._isBlocked) {\n                        break;\n                    }\n                }\n\n                return charsRead;\n            },\n            ReadToEnd: function () {\n                if (this.stream == null) {\n                    System.IO.__Error.ReaderClosed();\n                }\n\n                // Call ReadBuffer, then pull data out of charBuffer.\n                var sb = new System.Text.StringBuilder(\"\", ((this.charLen - this.charPos) | 0));\n                do {\n                    sb.append(System.String.fromCharArray(this.charBuffer, this.charPos, ((this.charLen - this.charPos) | 0)));\n                    this.charPos = this.charLen; // Note we consumed these characters\n                    this.ReadBuffer();\n                } while (this.charLen > 0);\n                return sb.toString();\n            },\n            ReadBlock: function (buffer, index, count) {\n                if (buffer == null) {\n                    throw new System.ArgumentNullException(\"buffer\");\n                }\n                if (index < 0 || count < 0) {\n                    throw new System.ArgumentOutOfRangeException((index < 0 ? \"index\" : \"count\"));\n                }\n                if (((buffer.length - index) | 0) < count) {\n                    throw new System.ArgumentException();\n                }\n\n                if (this.stream == null) {\n                    System.IO.__Error.ReaderClosed();\n                }\n\n                return System.IO.TextReader.prototype.ReadBlock.call(this, buffer, index, count);\n            },\n            CompressBuffer: function (n) {\n                System.Array.copy(this.byteBuffer, n, this.byteBuffer, 0, ((this.byteLen - n) | 0));\n                this.byteLen = (this.byteLen - n) | 0;\n            },\n            DetectEncoding: function () {\n                if (this.byteLen < 2) {\n                    return;\n                }\n                this._detectEncoding = false;\n                var changedEncoding = false;\n                if (this.byteBuffer[System.Array.index(0, this.byteBuffer)] === 254 && this.byteBuffer[System.Array.index(1, this.byteBuffer)] === 255) {\n                    // Big Endian Unicode\n\n                    this.encoding = new System.Text.UnicodeEncoding.$ctor1(true, true);\n                    this.CompressBuffer(2);\n                    changedEncoding = true;\n                } else if (this.byteBuffer[System.Array.index(0, this.byteBuffer)] === 255 && this.byteBuffer[System.Array.index(1, this.byteBuffer)] === 254) {\n                    // Little Endian Unicode, or possibly little endian UTF32\n                    if (this.byteLen < 4 || this.byteBuffer[System.Array.index(2, this.byteBuffer)] !== 0 || this.byteBuffer[System.Array.index(3, this.byteBuffer)] !== 0) {\n                        this.encoding = new System.Text.UnicodeEncoding.$ctor1(false, true);\n                        this.CompressBuffer(2);\n                        changedEncoding = true;\n                    } else {\n                        this.encoding = new System.Text.UTF32Encoding.$ctor1(false, true);\n                        this.CompressBuffer(4);\n                        changedEncoding = true;\n                    }\n                } else if (this.byteLen >= 3 && this.byteBuffer[System.Array.index(0, this.byteBuffer)] === 239 && this.byteBuffer[System.Array.index(1, this.byteBuffer)] === 187 && this.byteBuffer[System.Array.index(2, this.byteBuffer)] === 191) {\n                    // UTF-8\n                    this.encoding = System.Text.Encoding.UTF8;\n                    this.CompressBuffer(3);\n                    changedEncoding = true;\n                } else if (this.byteLen >= 4 && this.byteBuffer[System.Array.index(0, this.byteBuffer)] === 0 && this.byteBuffer[System.Array.index(1, this.byteBuffer)] === 0 && this.byteBuffer[System.Array.index(2, this.byteBuffer)] === 254 && this.byteBuffer[System.Array.index(3, this.byteBuffer)] === 255) {\n                    // Big Endian UTF32\n                    this.encoding = new System.Text.UTF32Encoding.$ctor1(true, true);\n                    this.CompressBuffer(4);\n                    changedEncoding = true;\n                } else if (this.byteLen === 2) {\n                    this._detectEncoding = true;\n                }\n                // Note: in the future, if we change this algorithm significantly,\n                // we can support checking for the preamble of the given encoding.\n\n                if (changedEncoding) {\n                    this._maxCharsPerBuffer = this.encoding.GetMaxCharCount(this.byteBuffer.length);\n                    this.charBuffer = System.Array.init(this._maxCharsPerBuffer, 0, System.Char);\n                }\n            },\n            IsPreamble: function () {\n                return false;\n            },\n            ReadBuffer: function () {\n                this.charLen = 0;\n                this.charPos = 0;\n\n                this.byteLen = 0;\n                do {\n                    this.byteLen = this.stream.Read(this.byteBuffer, 0, this.byteBuffer.length);\n\n                    if (this.byteLen === 0) {\n                        return this.charLen;\n                    }\n\n                    // _isBlocked == whether we read fewer bytes than we asked for.\n                    // Note we must check it here because CompressBuffer or\n                    // DetectEncoding will change byteLen.\n                    this._isBlocked = (this.byteLen < this.byteBuffer.length);\n\n                    // Check for preamble before detect encoding. This is not to override the\n                    // user suppplied Encoding for the one we implicitly detect. The user could\n                    // customize the encoding which we will loose, such as ThrowOnError on UTF8\n                    if (this.IsPreamble()) {\n                        continue;\n                    }\n\n                    // If we're supposed to detect the encoding and haven't done so yet,\n                    // do it.  Note this may need to be called more than once.\n                    if (this._detectEncoding && this.byteLen >= 2) {\n                        this.DetectEncoding();\n                    }\n\n                    this.charLen = (this.charLen + (this.encoding.GetChars$2(this.byteBuffer, 0, this.byteLen, this.charBuffer, this.charLen))) | 0;\n                } while (this.charLen === 0);\n                //Console.WriteLine(\"ReadBuffer called.  chars: \"+charLen);\n                return this.charLen;\n            },\n            ReadBuffer$1: function (userBuffer, userOffset, desiredChars, readToUserBuffer) {\n                this.charLen = 0;\n                this.charPos = 0;\n\n                this.byteLen = 0;\n\n                var charsRead = 0;\n\n                // As a perf optimization, we can decode characters DIRECTLY into a\n                // user's char[].  We absolutely must not write more characters\n                // into the user's buffer than they asked for.  Calculating\n                // encoding.GetMaxCharCount(byteLen) each time is potentially very\n                // expensive - instead, cache the number of chars a full buffer's\n                // worth of data may produce.  Yes, this makes the perf optimization\n                // less aggressive, in that all reads that asked for fewer than AND\n                // returned fewer than _maxCharsPerBuffer chars won't get the user\n                // buffer optimization.  This affects reads where the end of the\n                // Stream comes in the middle somewhere, and when you ask for\n                // fewer chars than your buffer could produce.\n                readToUserBuffer.v = desiredChars >= this._maxCharsPerBuffer;\n\n                do {\n\n\n                    this.byteLen = this.stream.Read(this.byteBuffer, 0, this.byteBuffer.length);\n\n\n                    if (this.byteLen === 0) {\n                        break;\n                    }\n\n                    // _isBlocked == whether we read fewer bytes than we asked for.\n                    // Note we must check it here because CompressBuffer or\n                    // DetectEncoding will change byteLen.\n                    this._isBlocked = (this.byteLen < this.byteBuffer.length);\n\n                    // Check for preamble before detect encoding. This is not to override the\n                    // user suppplied Encoding for the one we implicitly detect. The user could\n                    // customize the encoding which we will loose, such as ThrowOnError on UTF8\n                    // Note: we don't need to recompute readToUserBuffer optimization as IsPreamble\n                    // doesn't change the encoding or affect _maxCharsPerBuffer\n                    if (this.IsPreamble()) {\n                        continue;\n                    }\n\n                    // On the first call to ReadBuffer, if we're supposed to detect the encoding, do it.\n                    if (this._detectEncoding && this.byteLen >= 2) {\n                        this.DetectEncoding();\n                        // DetectEncoding changes some buffer state.  Recompute this.\n                        readToUserBuffer.v = desiredChars >= this._maxCharsPerBuffer;\n                    }\n\n                    this.charPos = 0;\n                    if (readToUserBuffer.v) {\n                        charsRead = (charsRead + (this.encoding.GetChars$2(this.byteBuffer, 0, this.byteLen, userBuffer, ((userOffset + charsRead) | 0)))) | 0;\n                        this.charLen = 0; // StreamReader's buffer is empty.\n                    } else {\n                        charsRead = this.encoding.GetChars$2(this.byteBuffer, 0, this.byteLen, this.charBuffer, charsRead);\n                        this.charLen = (this.charLen + charsRead) | 0; // Number of chars in StreamReader's buffer.\n                    }\n                } while (charsRead === 0);\n\n                this._isBlocked = !!(this._isBlocked & charsRead < desiredChars);\n\n                //Console.WriteLine(\"ReadBuffer: charsRead: \"+charsRead+\"  readToUserBuffer: \"+readToUserBuffer);\n                return charsRead;\n            },\n            ReadLine: function () {\n                if (this.stream == null) {\n                    System.IO.__Error.ReaderClosed();\n                }\n\n                if (this.charPos === this.charLen) {\n                    if (this.ReadBuffer() === 0) {\n                        return null;\n                    }\n                }\n\n                var sb = null;\n                do {\n                    var i = this.charPos;\n                    do {\n                        var ch = this.charBuffer[System.Array.index(i, this.charBuffer)];\n                        // Note the following common line feed chars:\n                        // \\n - UNIX   \\r\\n - DOS   \\r - Mac\n                        if (ch === 13 || ch === 10) {\n                            var s;\n                            if (sb != null) {\n                                sb.append(System.String.fromCharArray(this.charBuffer, this.charPos, ((i - this.charPos) | 0)));\n                                s = sb.toString();\n                            } else {\n                                s = System.String.fromCharArray(this.charBuffer, this.charPos, ((i - this.charPos) | 0));\n                            }\n                            this.charPos = (i + 1) | 0;\n                            if (ch === 13 && (this.charPos < this.charLen || this.ReadBuffer() > 0)) {\n                                if (this.charBuffer[System.Array.index(this.charPos, this.charBuffer)] === 10) {\n                                    this.charPos = (this.charPos + 1) | 0;\n                                }\n                            }\n                            return s;\n                        }\n                        i = (i + 1) | 0;\n                    } while (i < this.charLen);\n                    i = (this.charLen - this.charPos) | 0;\n                    if (sb == null) {\n                        sb = new System.Text.StringBuilder(\"\", ((i + 80) | 0));\n                    }\n                    sb.append(System.String.fromCharArray(this.charBuffer, this.charPos, i));\n                } while (this.ReadBuffer() > 0);\n                return sb.toString();\n            }\n        }\n    });\n\n    Bridge.define(\"System.IO.StreamWriter\", {\n        inherits: [System.IO.TextWriter],\n        statics: {\n            fields: {\n                DefaultBufferSize: 0,\n                DefaultFileStreamBufferSize: 0,\n                MinBufferSize: 0,\n                Null: null,\n                _UTF8NoBOM: null\n            },\n            props: {\n                UTF8NoBOM: {\n                    get: function () {\n                        if (System.IO.StreamWriter._UTF8NoBOM == null) {\n                            // No need for double lock - we just want to avoid extra\n                            // allocations in the common case.\n                            var noBOM = new System.Text.UTF8Encoding.$ctor2(false, true);\n                            System.IO.StreamWriter._UTF8NoBOM = noBOM;\n                        }\n                        return System.IO.StreamWriter._UTF8NoBOM;\n                    }\n                }\n            },\n            ctors: {\n                init: function () {\n                    this.DefaultBufferSize = 1024;\n                    this.DefaultFileStreamBufferSize = 4096;\n                    this.MinBufferSize = 128;\n                    this.Null = new System.IO.StreamWriter.$ctor4(System.IO.Stream.Null, new System.Text.UTF8Encoding.$ctor2(false, true), System.IO.StreamWriter.MinBufferSize, true);\n                }\n            }\n        },\n        fields: {\n            stream: null,\n            encoding: null,\n            byteBuffer: null,\n            charBuffer: null,\n            charPos: 0,\n            charLen: 0,\n            autoFlush: false,\n            haveWrittenPreamble: false,\n            closable: false\n        },\n        props: {\n            AutoFlush: {\n                get: function () {\n                    return this.autoFlush;\n                },\n                set: function (value) {\n                    this.autoFlush = value;\n                    if (value) {\n                        this.Flush$1(true, false);\n                    }\n                }\n            },\n            BaseStream: {\n                get: function () {\n                    return this.stream;\n                }\n            },\n            LeaveOpen: {\n                get: function () {\n                    return !this.closable;\n                }\n            },\n            HaveWrittenPreamble: {\n                set: function (value) {\n                    this.haveWrittenPreamble = value;\n                }\n            },\n            Encoding: {\n                get: function () {\n                    return this.encoding;\n                }\n            }\n        },\n        ctors: {\n            ctor: function () {\n                this.$initialize();\n                System.IO.TextWriter.$ctor1.call(this, null); // Ask for CurrentCulture all the time\n            },\n            $ctor1: function (stream) {\n                System.IO.StreamWriter.$ctor4.call(this, stream, System.IO.StreamWriter.UTF8NoBOM, System.IO.StreamWriter.DefaultBufferSize, false);\n            },\n            $ctor2: function (stream, encoding) {\n                System.IO.StreamWriter.$ctor4.call(this, stream, encoding, System.IO.StreamWriter.DefaultBufferSize, false);\n            },\n            $ctor3: function (stream, encoding, bufferSize) {\n                System.IO.StreamWriter.$ctor4.call(this, stream, encoding, bufferSize, false);\n            },\n            $ctor4: function (stream, encoding, bufferSize, leaveOpen) {\n                this.$initialize();\n                System.IO.TextWriter.$ctor1.call(this, null);\n                if (stream == null || encoding == null) {\n                    throw new System.ArgumentNullException((stream == null ? \"stream\" : \"encoding\"));\n                }\n                if (!stream.CanWrite) {\n                    throw new System.ArgumentException(\"Argument_StreamNotWritable\");\n                }\n                if (bufferSize <= 0) {\n                    throw new System.ArgumentOutOfRangeException(\"bufferSize\", \"ArgumentOutOfRange_NeedPosNum\");\n                }\n\n                this.Init(stream, encoding, bufferSize, leaveOpen);\n            },\n            $ctor5: function (path) {\n                System.IO.StreamWriter.$ctor8.call(this, path, false, System.IO.StreamWriter.UTF8NoBOM, System.IO.StreamWriter.DefaultBufferSize);\n            },\n            $ctor6: function (path, append) {\n                System.IO.StreamWriter.$ctor8.call(this, path, append, System.IO.StreamWriter.UTF8NoBOM, System.IO.StreamWriter.DefaultBufferSize);\n            },\n            $ctor7: function (path, append, encoding) {\n                System.IO.StreamWriter.$ctor8.call(this, path, append, encoding, System.IO.StreamWriter.DefaultBufferSize);\n            },\n            $ctor8: function (path, append, encoding, bufferSize) {\n                System.IO.StreamWriter.$ctor9.call(this, path, append, encoding, bufferSize, true);\n            },\n            $ctor9: function (path, append, encoding, bufferSize, checkHost) {\n                this.$initialize();\n                System.IO.TextWriter.$ctor1.call(this, null);\n                throw new System.NotSupportedException();\n            }\n        },\n        methods: {\n            Init: function (streamArg, encodingArg, bufferSize, shouldLeaveOpen) {\n                this.stream = streamArg;\n                this.encoding = encodingArg;\n                if (bufferSize < System.IO.StreamWriter.MinBufferSize) {\n                    bufferSize = System.IO.StreamWriter.MinBufferSize;\n                }\n                this.charBuffer = System.Array.init(bufferSize, 0, System.Char);\n                this.byteBuffer = System.Array.init(this.encoding.GetMaxByteCount(bufferSize), 0, System.Byte);\n                this.charLen = bufferSize;\n                // If we're appending to a Stream that already has data, don't write\n                // the preamble.\n                if (this.stream.CanSeek && this.stream.Position.gt(System.Int64(0))) {\n                    this.haveWrittenPreamble = true;\n                }\n                this.closable = !shouldLeaveOpen;\n            },\n            Close: function () {\n                this.Dispose$1(true);\n            },\n            Dispose$1: function (disposing) {\n                try {\n                    // We need to flush any buffered data if we are being closed/disposed.\n                    // Also, we never close the handles for stdout & friends.  So we can safely\n                    // write any buffered data to those streams even during finalization, which\n                    // is generally the right thing to do.\n                    if (this.stream != null) {\n                        // Note: flush on the underlying stream can throw (ex., low disk space)\n                        if (disposing) {\n                            this.Flush$1(true, true);\n                        }\n                    }\n                }\n                finally {\n                    // Dispose of our resources if this StreamWriter is closable.\n                    // Note: Console.Out and other such non closable streamwriters should be left alone\n                    if (!this.LeaveOpen && this.stream != null) {\n                        try {\n                            // Attempt to close the stream even if there was an IO error from Flushing.\n                            // Note that Stream.Close() can potentially throw here (may or may not be\n                            // due to the same Flush error). In this case, we still need to ensure\n                            // cleaning up internal resources, hence the finally block.\n                            if (disposing) {\n                                this.stream.Close();\n                            }\n                        }\n                        finally {\n                            this.stream = null;\n                            this.byteBuffer = null;\n                            this.charBuffer = null;\n                            this.encoding = null;\n                            this.charLen = 0;\n                            System.IO.TextWriter.prototype.Dispose$1.call(this, disposing);\n                        }\n                    }\n                }\n            },\n            Flush: function () {\n                this.Flush$1(true, true);\n            },\n            Flush$1: function (flushStream, flushEncoder) {\n                // flushEncoder should be true at the end of the file and if\n                // the user explicitly calls Flush (though not if AutoFlush is true).\n                // This is required to flush any dangling characters from our UTF-7\n                // and UTF-8 encoders.\n                if (this.stream == null) {\n                    System.IO.__Error.WriterClosed();\n                }\n\n                // Perf boost for Flush on non-dirty writers.\n                if (this.charPos === 0 && (!flushStream && !flushEncoder)) {\n                    return;\n                }\n\n                /* if (!haveWrittenPreamble) {\n                   haveWrittenPreamble = true;\n                   byte[] preamble = encoding.GetPreamble();\n                   if (preamble.Length > 0)\n                       stream.Write(preamble, 0, preamble.Length);\n                }*/\n\n                var count = this.encoding.GetBytes$3(this.charBuffer, 0, this.charPos, this.byteBuffer, 0);\n                this.charPos = 0;\n                if (count > 0) {\n                    this.stream.Write(this.byteBuffer, 0, count);\n                }\n                // By definition, calling Flush should flush the stream, but this is\n                // only necessary if we passed in true for flushStream.  The Web\n                // Services guys have some perf tests where flushing needlessly hurts.\n                if (flushStream) {\n                    this.stream.Flush();\n                }\n            },\n            Write$1: function (value) {\n                if (this.charPos === this.charLen) {\n                    this.Flush$1(false, false);\n                }\n                this.charBuffer[System.Array.index(this.charPos, this.charBuffer)] = value;\n                this.charPos = (this.charPos + 1) | 0;\n                if (this.autoFlush) {\n                    this.Flush$1(true, false);\n                }\n            },\n            Write$2: function (buffer) {\n                // This may be faster than the one with the index & count since it\n                // has to do less argument checking.\n                if (buffer == null) {\n                    return;\n                }\n\n                var index = 0;\n                var count = buffer.length;\n                while (count > 0) {\n                    if (this.charPos === this.charLen) {\n                        this.Flush$1(false, false);\n                    }\n                    var n = (this.charLen - this.charPos) | 0;\n                    if (n > count) {\n                        n = count;\n                    }\n                    System.Array.copy(buffer, index, this.charBuffer, this.charPos, n);\n                    this.charPos = (this.charPos + n) | 0;\n                    index = (index + n) | 0;\n                    count = (count - n) | 0;\n                }\n                if (this.autoFlush) {\n                    this.Flush$1(true, false);\n                }\n            },\n            Write$3: function (buffer, index, count) {\n                if (buffer == null) {\n                    throw new System.ArgumentNullException(\"buffer\", \"ArgumentNull_Buffer\");\n                }\n                if (index < 0) {\n                    throw new System.ArgumentOutOfRangeException(\"index\", \"ArgumentOutOfRange_NeedNonNegNum\");\n                }\n                if (count < 0) {\n                    throw new System.ArgumentOutOfRangeException(\"count\", \"ArgumentOutOfRange_NeedNonNegNum\");\n                }\n                if (((buffer.length - index) | 0) < count) {\n                    throw new System.ArgumentException(\"Argument_InvalidOffLen\");\n                }\n\n                while (count > 0) {\n                    if (this.charPos === this.charLen) {\n                        this.Flush$1(false, false);\n                    }\n                    var n = (this.charLen - this.charPos) | 0;\n                    if (n > count) {\n                        n = count;\n                    }\n                    System.Array.copy(buffer, index, this.charBuffer, this.charPos, n);\n                    this.charPos = (this.charPos + n) | 0;\n                    index = (index + n) | 0;\n                    count = (count - n) | 0;\n                }\n                if (this.autoFlush) {\n                    this.Flush$1(true, false);\n                }\n            },\n            Write$10: function (value) {\n                if (value != null) {\n                    var count = value.length;\n                    var index = 0;\n                    while (count > 0) {\n                        if (this.charPos === this.charLen) {\n                            this.Flush$1(false, false);\n                        }\n                        var n = (this.charLen - this.charPos) | 0;\n                        if (n > count) {\n                            n = count;\n                        }\n                        System.String.copyTo(value, index, this.charBuffer, this.charPos, n);\n                        this.charPos = (this.charPos + n) | 0;\n                        index = (index + n) | 0;\n                        count = (count - n) | 0;\n                    }\n                    if (this.autoFlush) {\n                        this.Flush$1(true, false);\n                    }\n                }\n            }\n        }\n    });\n\n    Bridge.define(\"System.IO.StringReader\", {\n        inherits: [System.IO.TextReader],\n        fields: {\n            _s: null,\n            _pos: 0,\n            _length: 0\n        },\n        ctors: {\n            ctor: function (s) {\n                this.$initialize();\n                System.IO.TextReader.ctor.call(this);\n                if (s == null) {\n                    throw new System.ArgumentNullException(\"s\");\n                }\n                this._s = s;\n                this._length = s == null ? 0 : s.length;\n            }\n        },\n        methods: {\n            Close: function () {\n                this.Dispose$1(true);\n            },\n            Dispose$1: function (disposing) {\n                this._s = null;\n                this._pos = 0;\n                this._length = 0;\n                System.IO.TextReader.prototype.Dispose$1.call(this, disposing);\n            },\n            Peek: function () {\n                if (this._s == null) {\n                    System.IO.__Error.ReaderClosed();\n                }\n                if (this._pos === this._length) {\n                    return -1;\n                }\n                return this._s.charCodeAt(this._pos);\n            },\n            Read: function () {\n                if (this._s == null) {\n                    System.IO.__Error.ReaderClosed();\n                }\n                if (this._pos === this._length) {\n                    return -1;\n                }\n                return this._s.charCodeAt(Bridge.identity(this._pos, (this._pos = (this._pos + 1) | 0)));\n            },\n            Read$1: function (buffer, index, count) {\n                if (buffer == null) {\n                    throw new System.ArgumentNullException(\"buffer\");\n                }\n                if (index < 0) {\n                    throw new System.ArgumentOutOfRangeException(\"index\");\n                }\n                if (count < 0) {\n                    throw new System.ArgumentOutOfRangeException(\"count\");\n                }\n                if (((buffer.length - index) | 0) < count) {\n                    throw new System.ArgumentException();\n                }\n                if (this._s == null) {\n                    System.IO.__Error.ReaderClosed();\n                }\n\n                var n = (this._length - this._pos) | 0;\n                if (n > 0) {\n                    if (n > count) {\n                        n = count;\n                    }\n                    System.String.copyTo(this._s, this._pos, buffer, index, n);\n                    this._pos = (this._pos + n) | 0;\n                }\n                return n;\n            },\n            ReadToEnd: function () {\n                if (this._s == null) {\n                    System.IO.__Error.ReaderClosed();\n                }\n                var s;\n                if (this._pos === 0) {\n                    s = this._s;\n                } else {\n                    s = this._s.substr(this._pos, ((this._length - this._pos) | 0));\n                }\n                this._pos = this._length;\n                return s;\n            },\n            ReadLine: function () {\n                if (this._s == null) {\n                    System.IO.__Error.ReaderClosed();\n                }\n                var i = this._pos;\n                while (i < this._length) {\n                    var ch = this._s.charCodeAt(i);\n                    if (ch === 13 || ch === 10) {\n                        var result = this._s.substr(this._pos, ((i - this._pos) | 0));\n                        this._pos = (i + 1) | 0;\n                        if (ch === 13 && this._pos < this._length && this._s.charCodeAt(this._pos) === 10) {\n                            this._pos = (this._pos + 1) | 0;\n                        }\n                        return result;\n                    }\n                    i = (i + 1) | 0;\n                }\n                if (i > this._pos) {\n                    var result1 = this._s.substr(this._pos, ((i - this._pos) | 0));\n                    this._pos = i;\n                    return result1;\n                }\n                return null;\n            }\n        }\n    });\n\n    Bridge.define(\"System.IO.StringWriter\", {\n        inherits: [System.IO.TextWriter],\n        statics: {\n            fields: {\n                m_encoding: null\n            }\n        },\n        fields: {\n            _sb: null,\n            _isOpen: false\n        },\n        props: {\n            Encoding: {\n                get: function () {\n                    if (System.IO.StringWriter.m_encoding == null) {\n                        System.IO.StringWriter.m_encoding = new System.Text.UnicodeEncoding.$ctor1(false, false);\n                    }\n                    return System.IO.StringWriter.m_encoding;\n                }\n            }\n        },\n        ctors: {\n            ctor: function () {\n                System.IO.StringWriter.$ctor3.call(this, new System.Text.StringBuilder(), System.Globalization.CultureInfo.getCurrentCulture());\n            },\n            $ctor1: function (formatProvider) {\n                System.IO.StringWriter.$ctor3.call(this, new System.Text.StringBuilder(), formatProvider);\n            },\n            $ctor2: function (sb) {\n                System.IO.StringWriter.$ctor3.call(this, sb, System.Globalization.CultureInfo.getCurrentCulture());\n            },\n            $ctor3: function (sb, formatProvider) {\n                this.$initialize();\n                System.IO.TextWriter.$ctor1.call(this, formatProvider);\n                if (sb == null) {\n                    throw new System.ArgumentNullException(\"sb\");\n                }\n                this._sb = sb;\n                this._isOpen = true;\n            }\n        },\n        methods: {\n            Close: function () {\n                this.Dispose$1(true);\n            },\n            Dispose$1: function (disposing) {\n                // Do not destroy _sb, so that we can extract this after we are\n                // done writing (similar to MemoryStream's GetBuffer & ToArray methods)\n                this._isOpen = false;\n                System.IO.TextWriter.prototype.Dispose$1.call(this, disposing);\n            },\n            GetStringBuilder: function () {\n                return this._sb;\n            },\n            Write$1: function (value) {\n                if (!this._isOpen) {\n                    System.IO.__Error.WriterClosed();\n                }\n                this._sb.append(String.fromCharCode(value));\n            },\n            Write$3: function (buffer, index, count) {\n                if (buffer == null) {\n                    throw new System.ArgumentNullException(\"buffer\");\n                }\n                if (index < 0) {\n                    throw new System.ArgumentOutOfRangeException(\"index\");\n                }\n                if (count < 0) {\n                    throw new System.ArgumentOutOfRangeException(\"count\");\n                }\n                if (((buffer.length - index) | 0) < count) {\n                    throw new System.ArgumentException();\n                }\n\n                if (!this._isOpen) {\n                    System.IO.__Error.WriterClosed();\n                }\n\n                this._sb.append(System.String.fromCharArray(buffer, index, count));\n            },\n            Write$10: function (value) {\n                if (!this._isOpen) {\n                    System.IO.__Error.WriterClosed();\n                }\n                if (value != null) {\n                    this._sb.append(value);\n                }\n            },\n            toString: function () {\n                return this._sb.toString();\n            }\n        }\n    });\n\n    Bridge.define(\"System.IO.TextReader.NullTextReader\", {\n        inherits: [System.IO.TextReader],\n        ctors: {\n            ctor: function () {\n                this.$initialize();\n                System.IO.TextReader.ctor.call(this);\n            }\n        },\n        methods: {\n            Read$1: function (buffer, index, count) {\n                return 0;\n            },\n            ReadLine: function () {\n                return null;\n            }\n        }\n    });\n\n    Bridge.define(\"System.IO.TextWriter.NullTextWriter\", {\n        inherits: [System.IO.TextWriter],\n        props: {\n            Encoding: {\n                get: function () {\n                    return System.Text.Encoding.Default;\n                }\n            }\n        },\n        ctors: {\n            ctor: function () {\n                this.$initialize();\n                System.IO.TextWriter.$ctor1.call(this, System.Globalization.CultureInfo.invariantCulture);\n            }\n        },\n        methods: {\n            Write$3: function (buffer, index, count) { },\n            Write$10: function (value) { },\n            WriteLine: function () { },\n            WriteLine$11: function (value) { },\n            WriteLine$9: function (value) { }\n        }\n    });\n\n    Bridge.define(\"System.IO.StreamReader.NullStreamReader\", {\n        inherits: [System.IO.StreamReader],\n        props: {\n            BaseStream: {\n                get: function () {\n                    return System.IO.Stream.Null;\n                }\n            },\n            CurrentEncoding: {\n                get: function () {\n                    return System.Text.Encoding.Unicode;\n                }\n            }\n        },\n        ctors: {\n            ctor: function () {\n                this.$initialize();\n                System.IO.StreamReader.ctor.call(this);\n                this.Init(System.IO.Stream.Null);\n            }\n        },\n        methods: {\n            Dispose$1: function (disposing) {\n                // Do nothing - this is essentially unclosable.\n            },\n            Peek: function () {\n                return -1;\n            },\n            Read: function () {\n                return -1;\n            },\n            Read$1: function (buffer, index, count) {\n                return 0;\n            },\n            ReadLine: function () {\n                return null;\n            },\n            ReadToEnd: function () {\n                return \"\";\n            },\n            ReadBuffer: function () {\n                return 0;\n            }\n        }\n    });\n\n    // @source random.js\n\n    Bridge.define(\"System.Random\", {\n        statics: {\n            fields: {\n                MBIG: 0,\n                MSEED: 0,\n                MZ: 0\n            },\n            ctors: {\n                init: function () {\n                    this.MBIG = 2147483647;\n                    this.MSEED = 161803398;\n                    this.MZ = 0;\n                }\n            }\n        },\n        fields: {\n            inext: 0,\n            inextp: 0,\n            seedArray: null\n        },\n        ctors: {\n            init: function () {\n                this.seedArray = System.Array.init(56, 0, System.Int32);\n            },\n            ctor: function () {\n                System.Random.$ctor1.call(this, System.Int64.clip32(System.DateTime.getTicks(System.DateTime.getNow())));\n            },\n            $ctor1: function (seed) {\n                this.$initialize();\n                var ii;\n                var mj, mk;\n\n                //Initialize our Seed array.\n                //This algorithm comes from Numerical Recipes in C (2nd Ed.)\n                var subtraction = (seed === -2147483648) ? 2147483647 : Math.abs(seed);\n                mj = (System.Random.MSEED - subtraction) | 0;\n                this.seedArray[System.Array.index(55, this.seedArray)] = mj;\n                mk = 1;\n                for (var i = 1; i < 55; i = (i + 1) | 0) { //Apparently the range [1..55] is special (Knuth) and so we're wasting the 0'th position.\n                    ii = (Bridge.Int.mul(21, i)) % 55;\n                    this.seedArray[System.Array.index(ii, this.seedArray)] = mk;\n                    mk = (mj - mk) | 0;\n                    if (mk < 0) {\n                        mk = (mk + System.Random.MBIG) | 0;\n                    }\n                    mj = this.seedArray[System.Array.index(ii, this.seedArray)];\n                }\n                for (var k = 1; k < 5; k = (k + 1) | 0) {\n                    for (var i1 = 1; i1 < 56; i1 = (i1 + 1) | 0) {\n                        this.seedArray[System.Array.index(i1, this.seedArray)] = (this.seedArray[System.Array.index(i1, this.seedArray)] - this.seedArray[System.Array.index(((1 + (((i1 + 30) | 0)) % 55) | 0), this.seedArray)]) | 0;\n                        if (this.seedArray[System.Array.index(i1, this.seedArray)] < 0) {\n                            this.seedArray[System.Array.index(i1, this.seedArray)] = (this.seedArray[System.Array.index(i1, this.seedArray)] + System.Random.MBIG) | 0;\n                        }\n                    }\n                }\n                this.inext = 0;\n                this.inextp = 21;\n                seed = 1;\n            }\n        },\n        methods: {\n            sample: function () {\n                //Including this division at the end gives us significantly improved\n                //random number distribution.\n                return (this.internalSample() * (4.6566128752457969E-10));\n            },\n            internalSample: function () {\n                var retVal;\n                var locINext = this.inext;\n                var locINextp = this.inextp;\n\n                if (((locINext = (locINext + 1) | 0)) >= 56) {\n                    locINext = 1;\n                }\n\n                if (((locINextp = (locINextp + 1) | 0)) >= 56) {\n                    locINextp = 1;\n                }\n\n                retVal = (this.seedArray[System.Array.index(locINext, this.seedArray)] - this.seedArray[System.Array.index(locINextp, this.seedArray)]) | 0;\n\n                if (retVal === System.Random.MBIG) {\n                    retVal = (retVal - 1) | 0;\n                }\n\n                if (retVal < 0) {\n                    retVal = (retVal + System.Random.MBIG) | 0;\n                }\n\n                this.seedArray[System.Array.index(locINext, this.seedArray)] = retVal;\n\n                this.inext = locINext;\n                this.inextp = locINextp;\n\n                return retVal;\n            },\n            next: function () {\n                return this.internalSample();\n            },\n            next$2: function (minValue, maxValue) {\n                if (minValue > maxValue) {\n                    throw new System.ArgumentOutOfRangeException(\"minValue\", \"'minValue' cannot be greater than maxValue.\");\n                }\n\n                var range = System.Int64(maxValue).sub(System.Int64(minValue));\n                if (range.lte(System.Int64(2147483647))) {\n                    return (((Bridge.Int.clip32((this.sample() * System.Int64.toNumber(range))) + minValue) | 0));\n                } else {\n                    return System.Int64.clip32(Bridge.Int.clip64((this.getSampleForLargeRange() * System.Int64.toNumber(range))).add(System.Int64(minValue)));\n                }\n            },\n            next$1: function (maxValue) {\n                if (maxValue < 0) {\n                    throw new System.ArgumentOutOfRangeException(\"maxValue\", \"'maxValue' must be greater than zero.\");\n                }\n                return Bridge.Int.clip32(this.sample() * maxValue);\n            },\n            getSampleForLargeRange: function () {\n                // The distribution of double value returned by Sample\n                // is not distributed well enough for a large range.\n                // If we use Sample for a range [Int32.MinValue..Int32.MaxValue)\n                // We will end up getting even numbers only.\n\n                var result = this.internalSample();\n                // Note we can't use addition here. The distribution will be bad if we do that.\n                var negative = (this.internalSample() % 2 === 0) ? true : false; // decide the sign based on second sample\n                if (negative) {\n                    result = (-result) | 0;\n                }\n                var d = result;\n                d += (2147483646); // get a number in range [0 .. 2 * Int32MaxValue - 1)\n                d /= 4294967293;\n                return d;\n            },\n            nextDouble: function () {\n                return this.sample();\n            },\n            nextBytes: function (buffer) {\n                if (buffer == null) {\n                    throw new System.ArgumentNullException(\"buffer\");\n                }\n                for (var i = 0; i < buffer.length; i = (i + 1) | 0) {\n                    buffer[System.Array.index(i, buffer)] = (this.internalSample() % (256)) & 255;\n                }\n            }\n        }\n    });\n\n    // @source bitConverter.js\n\n    Bridge.define(\"System.BitConverter\", {\n        statics: {\n            fields: {\n                isLittleEndian: false,\n                arg_ArrayPlusOffTooSmall: null\n            },\n            ctors: {\n                init: function () {\n                    this.isLittleEndian = System.BitConverter.getIsLittleEndian();\n                    this.arg_ArrayPlusOffTooSmall = \"Destination array is not long enough to copy all the items in the collection. Check array index and length.\";\n                }\n            },\n            methods: {\n                getBytes: function (value) {\n                    return value ? System.Array.init([1], System.Byte) : System.Array.init([0], System.Byte);\n                },\n                getBytes$1: function (value) {\n                    return System.BitConverter.getBytes$3(Bridge.Int.sxs(value & 65535));\n                },\n                getBytes$3: function (value) {\n                    var view = System.BitConverter.view(2);\n                    view.setInt16(0, value);\n\n                    return System.BitConverter.getViewBytes(view);\n                },\n                getBytes$4: function (value) {\n                    var view = System.BitConverter.view(4);\n                    view.setInt32(0, value);\n\n                    return System.BitConverter.getViewBytes(view);\n                },\n                getBytes$5: function (value) {\n                    var view = System.BitConverter.getView(value);\n\n                    return System.BitConverter.getViewBytes(view);\n                },\n                getBytes$7: function (value) {\n                    var view = System.BitConverter.view(2);\n                    view.setUint16(0, value);\n\n                    return System.BitConverter.getViewBytes(view);\n                },\n                getBytes$8: function (value) {\n                    var view = System.BitConverter.view(4);\n                    view.setUint32(0, value);\n\n                    return System.BitConverter.getViewBytes(view);\n                },\n                getBytes$9: function (value) {\n                    var view = System.BitConverter.getView(System.Int64.clip64(value));\n\n                    return System.BitConverter.getViewBytes(view);\n                },\n                getBytes$6: function (value) {\n                    var view = System.BitConverter.view(4);\n                    view.setFloat32(0, value);\n\n                    return System.BitConverter.getViewBytes(view);\n                },\n                getBytes$2: function (value) {\n                    if (isNaN(value)) {\n                        if (System.BitConverter.isLittleEndian) {\n                            return System.Array.init([0, 0, 0, 0, 0, 0, 248, 255], System.Byte);\n                        } else {\n                            return System.Array.init([255, 248, 0, 0, 0, 0, 0, 0], System.Byte);\n                        }\n                    }\n\n                    var view = System.BitConverter.view(8);\n                    view.setFloat64(0, value);\n\n                    return System.BitConverter.getViewBytes(view);\n                },\n                toChar: function (value, startIndex) {\n                    return ((System.BitConverter.toInt16(value, startIndex)) & 65535);\n                },\n                toInt16: function (value, startIndex) {\n                    System.BitConverter.checkArguments(value, startIndex, 2);\n\n                    var view = System.BitConverter.view(2);\n\n                    System.BitConverter.setViewBytes(view, value, -1, startIndex);\n\n                    return view.getInt16(0);\n                },\n                toInt32: function (value, startIndex) {\n                    System.BitConverter.checkArguments(value, startIndex, 4);\n\n                    var view = System.BitConverter.view(4);\n\n                    System.BitConverter.setViewBytes(view, value, -1, startIndex);\n\n                    return view.getInt32(0);\n                },\n                toInt64: function (value, startIndex) {\n                    System.BitConverter.checkArguments(value, startIndex, 8);\n\n                    var low = System.BitConverter.toInt32(value, startIndex);\n                    var high = System.BitConverter.toInt32(value, ((startIndex + 4) | 0));\n\n                    if (System.BitConverter.isLittleEndian) {\n                        return System.Int64([low, high]);\n                    }\n\n                    return System.Int64([high, low]);\n                },\n                toUInt16: function (value, startIndex) {\n                    return ((System.BitConverter.toInt16(value, startIndex)) & 65535);\n                },\n                toUInt32: function (value, startIndex) {\n                    return ((System.BitConverter.toInt32(value, startIndex)) >>> 0);\n                },\n                toUInt64: function (value, startIndex) {\n                    var l = System.BitConverter.toInt64(value, startIndex);\n\n                    return System.UInt64([l.value.low, l.value.high]);\n                },\n                toSingle: function (value, startIndex) {\n                    System.BitConverter.checkArguments(value, startIndex, 4);\n\n                    var view = System.BitConverter.view(4);\n\n                    System.BitConverter.setViewBytes(view, value, -1, startIndex);\n\n                    return view.getFloat32(0);\n                },\n                toDouble: function (value, startIndex) {\n                    System.BitConverter.checkArguments(value, startIndex, 8);\n\n                    var view = System.BitConverter.view(8);\n\n                    System.BitConverter.setViewBytes(view, value, -1, startIndex);\n\n                    return view.getFloat64(0);\n                },\n                toString$2: function (value, startIndex, length) {\n                    if (value == null) {\n                        throw new System.ArgumentNullException(\"value\");\n                    }\n\n                    if (startIndex < 0 || startIndex >= value.length && startIndex > 0) { // Don't throw for a 0 length array.\n                        throw new System.ArgumentOutOfRangeException(\"startIndex\");\n                    }\n\n                    if (length < 0) {\n                        throw new System.ArgumentOutOfRangeException(\"length\");\n                    }\n\n                    if (startIndex > ((value.length - length) | 0)) {\n                        throw new System.ArgumentException(System.BitConverter.arg_ArrayPlusOffTooSmall);\n                    }\n\n                    if (length === 0) {\n                        return \"\";\n                    }\n\n                    if (length > (715827882)) {\n                        // (Int32.MaxValue / 3) == 715,827,882 Bytes == 699 MB\n                        throw new System.ArgumentOutOfRangeException(\"length\", (715827882).toString());\n                    }\n\n                    var chArrayLength = Bridge.Int.mul(length, 3);\n\n                    var chArray = System.Array.init(chArrayLength, 0, System.Char);\n                    var i = 0;\n                    var index = startIndex;\n                    for (i = 0; i < chArrayLength; i = (i + 3) | 0) {\n                        var b = value[System.Array.index(Bridge.identity(index, (index = (index + 1) | 0)), value)];\n                        chArray[System.Array.index(i, chArray)] = System.BitConverter.getHexValue(((Bridge.Int.div(b, 16)) | 0));\n                        chArray[System.Array.index(((i + 1) | 0), chArray)] = System.BitConverter.getHexValue(b % 16);\n                        chArray[System.Array.index(((i + 2) | 0), chArray)] = 45;\n                    }\n\n                    // We don't need the last '-' character\n                    return System.String.fromCharArray(chArray, 0, ((chArray.length - 1) | 0));\n                },\n                toString: function (value) {\n                    if (value == null) {\n                        throw new System.ArgumentNullException(\"value\");\n                    }\n\n                    return System.BitConverter.toString$2(value, 0, value.length);\n                },\n                toString$1: function (value, startIndex) {\n                    if (value == null) {\n                        throw new System.ArgumentNullException(\"value\");\n                    }\n\n                    return System.BitConverter.toString$2(value, startIndex, ((value.length - startIndex) | 0));\n                },\n                toBoolean: function (value, startIndex) {\n                    System.BitConverter.checkArguments(value, startIndex, 1);\n\n                    return (value[System.Array.index(startIndex, value)] === 0) ? false : true;\n                },\n                doubleToInt64Bits: function (value) {\n                    var view = System.BitConverter.view(8);\n                    view.setFloat64(0, value);\n\n                    return System.Int64([view.getInt32(4), view.getInt32(0)]);\n                },\n                int64BitsToDouble: function (value) {\n                    var view = System.BitConverter.getView(value);\n\n                    return view.getFloat64(0);\n                },\n                getHexValue: function (i) {\n                    if (i < 10) {\n                        return ((((i + 48) | 0)) & 65535);\n                    }\n\n                    return ((((((i - 10) | 0) + 65) | 0)) & 65535);\n                },\n                getViewBytes: function (view, count, startIndex) {\n                    if (count === void 0) { count = -1; }\n                    if (startIndex === void 0) { startIndex = 0; }\n                    if (count === -1) {\n                        count = view.byteLength;\n                    }\n\n                    var r = System.Array.init(count, 0, System.Byte);\n\n                    if (System.BitConverter.isLittleEndian) {\n                        for (var i = (count - 1) | 0; i >= 0; i = (i - 1) | 0) {\n                            r[System.Array.index(i, r)] = view.getUint8(Bridge.identity(startIndex, (startIndex = (startIndex + 1) | 0)));\n                        }\n                    } else {\n                        for (var i1 = 0; i1 < count; i1 = (i1 + 1) | 0) {\n                            r[System.Array.index(i1, r)] = view.getUint8(Bridge.identity(startIndex, (startIndex = (startIndex + 1) | 0)));\n                        }\n                    }\n\n                    return r;\n                },\n                setViewBytes: function (view, value, count, startIndex) {\n                    if (count === void 0) { count = -1; }\n                    if (startIndex === void 0) { startIndex = 0; }\n                    if (count === -1) {\n                        count = view.byteLength;\n                    }\n\n                    if (System.BitConverter.isLittleEndian) {\n                        for (var i = (count - 1) | 0; i >= 0; i = (i - 1) | 0) {\n                            view.setUint8(i, value[System.Array.index(Bridge.identity(startIndex, (startIndex = (startIndex + 1) | 0)), value)]);\n                        }\n                    } else {\n                        for (var i1 = 0; i1 < count; i1 = (i1 + 1) | 0) {\n                            view.setUint8(i1, value[System.Array.index(Bridge.identity(startIndex, (startIndex = (startIndex + 1) | 0)), value)]);\n                        }\n                    }\n                },\n                view: function (length) {\n                    var buffer = new ArrayBuffer(length);\n                    var view = new DataView(buffer);\n\n                    return view;\n                },\n                getView: function (value) {\n                    var view = System.BitConverter.view(8);\n\n                    view.setInt32(4, value.value.low);\n                    view.setInt32(0, value.value.high);\n\n                    return view;\n                },\n                getIsLittleEndian: function () {\n                    var view = System.BitConverter.view(2);\n\n                    view.setUint8(0, 170);\n                    view.setUint8(1, 187);\n\n                    if (view.getUint16(0) === 43707) {\n                        return true;\n                    }\n\n                    return false;\n                },\n                checkArguments: function (value, startIndex, size) {\n                    if (value == null) {\n                        throw new System.ArgumentNullException(\"null\");\n                    }\n\n                    if (System.Int64((startIndex >>> 0)).gte(System.Int64(value.length))) {\n                        throw new System.ArgumentOutOfRangeException(\"startIndex\");\n                    }\n\n                    if (startIndex > ((value.length - size) | 0)) {\n                        throw new System.ArgumentException(System.BitConverter.arg_ArrayPlusOffTooSmall);\n                    }\n                }\n            }\n        }\n    });\n\n    // @source timer.js\n\n    Bridge.define(\"System.Threading.Timer\", {\n        inherits: [System.IDisposable],\n        statics: {\n            fields: {\n                MAX_SUPPORTED_TIMEOUT: 0,\n                EXC_LESS: null,\n                EXC_MORE: null,\n                EXC_DISPOSED: null\n            },\n            ctors: {\n                init: function () {\n                    this.MAX_SUPPORTED_TIMEOUT = 4294967294;\n                    this.EXC_LESS = \"Number must be either non-negative and less than or equal to Int32.MaxValue or -1.\";\n                    this.EXC_MORE = \"Time-out interval must be less than 2^32-2.\";\n                    this.EXC_DISPOSED = \"The timer has been already disposed.\";\n                }\n            }\n        },\n        fields: {\n            dueTime: System.Int64(0),\n            period: System.Int64(0),\n            timerCallback: null,\n            state: null,\n            id: null,\n            disposed: false\n        },\n        alias: [\"dispose\", \"System$IDisposable$dispose\"],\n        ctors: {\n            $ctor1: function (callback, state, dueTime, period) {\n                this.$initialize();\n                this.timerSetup(callback, state, System.Int64(dueTime), System.Int64(period));\n            },\n            $ctor3: function (callback, state, dueTime, period) {\n                this.$initialize();\n                var dueTm = Bridge.Int.clip64(dueTime.getTotalMilliseconds());\n                var periodTm = Bridge.Int.clip64(period.getTotalMilliseconds());\n\n                this.timerSetup(callback, state, dueTm, periodTm);\n            },\n            $ctor4: function (callback, state, dueTime, period) {\n                this.$initialize();\n                this.timerSetup(callback, state, System.Int64(dueTime), System.Int64(period));\n            },\n            $ctor2: function (callback, state, dueTime, period) {\n                this.$initialize();\n                this.timerSetup(callback, state, dueTime, period);\n            },\n            ctor: function (callback) {\n                this.$initialize();\n                var dueTime = -1; // we want timer to be registered, but not activated.  Requires caller to call\n                var period = -1; // Change after a timer instance is created.  This is to avoid the potential\n                // for a timer to be fired before the returned value is assigned to the variable,\n                // potentially causing the callback to reference a bogus value (if passing the timer to the callback).\n\n                this.timerSetup(callback, this, System.Int64(dueTime), System.Int64(period));\n            }\n        },\n        methods: {\n            timerSetup: function (callback, state, dueTime, period) {\n                if (this.disposed) {\n                    throw new System.InvalidOperationException(System.Threading.Timer.EXC_DISPOSED);\n                }\n\n                if (Bridge.staticEquals(callback, null)) {\n                    throw new System.ArgumentNullException(\"TimerCallback\");\n                }\n\n                if (dueTime.lt(System.Int64(-1))) {\n                    throw new System.ArgumentOutOfRangeException(\"dueTime\", System.Threading.Timer.EXC_LESS);\n                }\n                if (period.lt(System.Int64(-1))) {\n                    throw new System.ArgumentOutOfRangeException(\"period\", System.Threading.Timer.EXC_LESS);\n                }\n                if (dueTime.gt(System.Int64(System.Threading.Timer.MAX_SUPPORTED_TIMEOUT))) {\n                    throw new System.ArgumentOutOfRangeException(\"dueTime\", System.Threading.Timer.EXC_MORE);\n                }\n                if (period.gt(System.Int64(System.Threading.Timer.MAX_SUPPORTED_TIMEOUT))) {\n                    throw new System.ArgumentOutOfRangeException(\"period\", System.Threading.Timer.EXC_MORE);\n                }\n\n                this.dueTime = dueTime;\n                this.period = period;\n\n                this.state = state;\n                this.timerCallback = callback;\n\n                return this.runTimer(this.dueTime);\n            },\n            handleCallback: function () {\n                if (this.disposed) {\n                    return;\n                }\n\n                if (!Bridge.staticEquals(this.timerCallback, null)) {\n                    var myId = this.id;\n                    this.timerCallback(this.state);\n\n                    // timerCallback may call Change(). To prevent double call we can check if timer changed\n                    if (System.Nullable.eq(this.id, myId)) {\n                        this.runTimer(this.period, false);\n                    }\n                }\n            },\n            runTimer: function (period, checkDispose) {\n                if (checkDispose === void 0) { checkDispose = true; }\n                if (checkDispose && this.disposed) {\n                    throw new System.InvalidOperationException(System.Threading.Timer.EXC_DISPOSED);\n                }\n\n                if (period.ne(System.Int64(-1)) && !this.disposed) {\n                    var p = period.toNumber();\n                    this.id = Bridge.global.setTimeout(Bridge.fn.cacheBind(this, this.handleCallback), p);\n                    return true;\n                }\n\n                return false;\n            },\n            change: function (dueTime, period) {\n                return this.changeTimer(System.Int64(dueTime), System.Int64(period));\n            },\n            change$2: function (dueTime, period) {\n                return this.changeTimer(Bridge.Int.clip64(dueTime.getTotalMilliseconds()), Bridge.Int.clip64(period.getTotalMilliseconds()));\n            },\n            change$3: function (dueTime, period) {\n                return this.changeTimer(System.Int64(dueTime), System.Int64(period));\n            },\n            change$1: function (dueTime, period) {\n                return this.changeTimer(dueTime, period);\n            },\n            changeTimer: function (dueTime, period) {\n                this.clearTimeout();\n                return this.timerSetup(this.timerCallback, this.state, dueTime, period);\n            },\n            clearTimeout: function () {\n                if (System.Nullable.hasValue(this.id)) {\n                    Bridge.global.clearTimeout(System.Nullable.getValue(this.id));\n                    this.id = null;\n                }\n            },\n            dispose: function () {\n                this.clearTimeout();\n                this.disposed = true;\n            }\n        }\n    });\n\n    // @source console.js\n\n    Bridge.define(\"System.Console\", {\n        statics: {\n            methods: {\n                Write: function (value) {\n                    var con = Bridge.global.console;\n\n                    if (con && con.log) {\n                        con.log(!Bridge.isDefined(Bridge.unbox(value)) ? \"\" : Bridge.unbox(value));\n                    }\n                },\n                WriteLine: function (value) {\n                    var con = Bridge.global.console;\n\n                    if (con && con.log) {\n                        con.log(!Bridge.isDefined(Bridge.unbox(value)) ? \"\" : Bridge.unbox(value));\n                    }\n                },\n                TransformChars: function (buffer, all, index, count) {\n                    if (all !== 1) {\n                        if (buffer == null) {\n                            throw new System.ArgumentNullException(\"buffer\");\n                        }\n\n                        if (index < 0) {\n                            throw new System.ArgumentOutOfRangeException(\"index\", \"less than zero\");\n                        }\n\n                        if (count < 0) {\n                            throw new System.ArgumentOutOfRangeException(\"count\", \"less than zero\");\n                        }\n\n                        if (((index + count) | 0) > buffer.length) {\n                            throw new System.ArgumentException(\"index plus count specify a position that is not within buffer.\");\n                        }\n                    }\n\n                    var s = \"\";\n                    if (buffer != null) {\n                        if (all === 1) {\n                            index = 0;\n                            count = buffer.length;\n                        }\n\n                        for (var i = index; i < ((index + count) | 0); i = (i + 1) | 0) {\n                            s = (s || \"\") + String.fromCharCode(buffer[System.Array.index(i, buffer)]);\n                        }\n                    }\n\n                    return s;\n                },\n                Clear: function () {\n                    var con = Bridge.global.console;\n\n                    if (con && con.clear) {\n                        con.clear();\n                    }\n                }\n            }\n        }\n    });\n\n    // @source bitArray.js\n\n    Bridge.define(\"System.Collections.BitArray\", {\n        inherits: [System.Collections.ICollection,System.ICloneable],\n        statics: {\n            fields: {\n                BitsPerInt32: 0,\n                BytesPerInt32: 0,\n                BitsPerByte: 0,\n                _ShrinkThreshold: 0\n            },\n            ctors: {\n                init: function () {\n                    this.BitsPerInt32 = 32;\n                    this.BytesPerInt32 = 4;\n                    this.BitsPerByte = 8;\n                    this._ShrinkThreshold = 256;\n                }\n            },\n            methods: {\n                getArrayLength: function (n, div) {\n                    return n > 0 ? ((((((Bridge.Int.div((((n - 1) | 0)), div)) | 0)) + 1) | 0)) : 0;\n                }\n            }\n        },\n        fields: {\n            m_array: null,\n            m_length: 0,\n            _version: 0\n        },\n        props: {\n            Length: {\n                get: function () {\n                    return this.m_length;\n                },\n                set: function (value) {\n                    if (value < 0) {\n                        throw new System.ArgumentOutOfRangeException(\"value\", \"Non-negative number required.\");\n                    }\n\n                    var newints = System.Collections.BitArray.getArrayLength(value, System.Collections.BitArray.BitsPerInt32);\n                    if (newints > this.m_array.length || ((newints + System.Collections.BitArray._ShrinkThreshold) | 0) < this.m_array.length) {\n                        // grow or shrink (if wasting more than _ShrinkThreshold ints)\n                        var newarray = System.Array.init(newints, 0, System.Int32);\n                        System.Array.copy(this.m_array, 0, newarray, 0, newints > this.m_array.length ? this.m_array.length : newints);\n                        this.m_array = newarray;\n                    }\n\n                    if (value > this.m_length) {\n                        // clear high bit values in the last int\n                        var last = (System.Collections.BitArray.getArrayLength(this.m_length, System.Collections.BitArray.BitsPerInt32) - 1) | 0;\n                        var bits = this.m_length % 32;\n                        if (bits > 0) {\n                            this.m_array[System.Array.index(last, this.m_array)] = this.m_array[System.Array.index(last, this.m_array)] & ((((1 << bits) - 1) | 0));\n                        }\n\n                        // clear remaining int values\n                        System.Array.fill(this.m_array, 0, ((last + 1) | 0), ((((newints - last) | 0) - 1) | 0));\n                    }\n\n                    this.m_length = value;\n                    this._version = (this._version + 1) | 0;\n                }\n            },\n            Count: {\n                get: function () {\n                    return this.m_length;\n                }\n            },\n            IsReadOnly: {\n                get: function () {\n                    return false;\n                }\n            },\n            IsSynchronized: {\n                get: function () {\n                    return false;\n                }\n            }\n        },\n        alias: [\n            \"copyTo\", \"System$Collections$ICollection$copyTo\",\n            \"Count\", \"System$Collections$ICollection$Count\",\n            \"clone\", \"System$ICloneable$clone\",\n            \"getEnumerator\", \"System$Collections$IEnumerable$getEnumerator\"\n        ],\n        ctors: {\n            $ctor3: function (length) {\n                System.Collections.BitArray.$ctor4.call(this, length, false);\n            },\n            $ctor4: function (length, defaultValue) {\n                this.$initialize();\n                if (length < 0) {\n                    throw new System.ArgumentOutOfRangeException(\"length\", \"Index is less than zero.\");\n                }\n\n                this.m_array = System.Array.init(System.Collections.BitArray.getArrayLength(length, System.Collections.BitArray.BitsPerInt32), 0, System.Int32);\n                this.m_length = length;\n\n                var fillValue = defaultValue ? (-1) : 0;\n                for (var i = 0; i < this.m_array.length; i = (i + 1) | 0) {\n                    this.m_array[System.Array.index(i, this.m_array)] = fillValue;\n                }\n\n                this._version = 0;\n            },\n            $ctor1: function (bytes) {\n                this.$initialize();\n                if (bytes == null) {\n                    throw new System.ArgumentNullException(\"bytes\");\n                }\n                // this value is chosen to prevent overflow when computing m_length.\n                // m_length is of type int32 and is exposed as a property, so\n                // type of m_length can't be changed to accommodate.\n                if (bytes.length > 268435455) {\n                    throw new System.ArgumentException(System.String.format(\"The input array length must not exceed Int32.MaxValue / {0}. Otherwise BitArray.Length would exceed Int32.MaxValue.\", Bridge.box(System.Collections.BitArray.BitsPerByte, System.Int32)), \"bytes\");\n                }\n\n                this.m_array = System.Array.init(System.Collections.BitArray.getArrayLength(bytes.length, System.Collections.BitArray.BytesPerInt32), 0, System.Int32);\n                this.m_length = Bridge.Int.mul(bytes.length, System.Collections.BitArray.BitsPerByte);\n\n                var i = 0;\n                var j = 0;\n                while (((bytes.length - j) | 0) >= 4) {\n                    this.m_array[System.Array.index(Bridge.identity(i, (i = (i + 1) | 0)), this.m_array)] = (bytes[System.Array.index(j, bytes)] & 255) | ((bytes[System.Array.index(((j + 1) | 0), bytes)] & 255) << 8) | ((bytes[System.Array.index(((j + 2) | 0), bytes)] & 255) << 16) | ((bytes[System.Array.index(((j + 3) | 0), bytes)] & 255) << 24);\n                    j = (j + 4) | 0;\n                }\n\n                var r = (bytes.length - j) | 0;\n                if (r === 3) {\n                    this.m_array[System.Array.index(i, this.m_array)] = ((bytes[System.Array.index(((j + 2) | 0), bytes)] & 255) << 16);\n                    r = 2;\n                }\n\n                if (r === 2) {\n                    this.m_array[System.Array.index(i, this.m_array)] = this.m_array[System.Array.index(i, this.m_array)] | ((bytes[System.Array.index(((j + 1) | 0), bytes)] & 255) << 8);\n                    r = 1;\n                }\n\n                if (r === 1) {\n                    this.m_array[System.Array.index(i, this.m_array)] = this.m_array[System.Array.index(i, this.m_array)] | (bytes[System.Array.index(j, bytes)] & 255);\n                }\n\n                this._version = 0;\n            },\n            ctor: function (values) {\n                var $t;\n                this.$initialize();\n                if (values == null) {\n                    throw new System.ArgumentNullException(\"values\");\n                }\n\n                this.m_array = System.Array.init(System.Collections.BitArray.getArrayLength(values.length, System.Collections.BitArray.BitsPerInt32), 0, System.Int32);\n                this.m_length = values.length;\n\n                for (var i = 0; i < values.length; i = (i + 1) | 0) {\n                    if (values[System.Array.index(i, values)]) {\n                        this.m_array[System.Array.index(($t = ((Bridge.Int.div(i, 32)) | 0)), this.m_array)] = this.m_array[System.Array.index($t, this.m_array)] | (1 << (i % 32));\n                    }\n                }\n\n                this._version = 0;\n            },\n            $ctor5: function (values) {\n                this.$initialize();\n                if (values == null) {\n                    throw new System.ArgumentNullException(\"values\");\n                }\n                // this value is chosen to prevent overflow when computing m_length\n                if (values.length > 67108863) {\n                    throw new System.ArgumentException(System.String.format(\"The input array length must not exceed Int32.MaxValue / {0}. Otherwise BitArray.Length would exceed Int32.MaxValue.\", Bridge.box(System.Collections.BitArray.BitsPerInt32, System.Int32)), \"values\");\n                }\n\n                this.m_array = System.Array.init(values.length, 0, System.Int32);\n                this.m_length = Bridge.Int.mul(values.length, System.Collections.BitArray.BitsPerInt32);\n\n                System.Array.copy(values, 0, this.m_array, 0, values.length);\n\n                this._version = 0;\n            },\n            $ctor2: function (bits) {\n                this.$initialize();\n                if (bits == null) {\n                    throw new System.ArgumentNullException(\"bits\");\n                }\n\n                var arrayLength = System.Collections.BitArray.getArrayLength(bits.m_length, System.Collections.BitArray.BitsPerInt32);\n                this.m_array = System.Array.init(arrayLength, 0, System.Int32);\n                this.m_length = bits.m_length;\n\n                System.Array.copy(bits.m_array, 0, this.m_array, 0, arrayLength);\n\n                this._version = bits._version;\n            }\n        },\n        methods: {\n            getItem: function (index) {\n                return this.get(index);\n            },\n            setItem: function (index, value) {\n                this.set(index, value);\n            },\n            copyTo: function (array, index) {\n                if (array == null) {\n                    throw new System.ArgumentNullException(\"array\");\n                }\n\n                if (index < 0) {\n                    throw new System.ArgumentOutOfRangeException(\"index\");\n                }\n\n                if (System.Array.getRank(array) !== 1) {\n                    throw new System.ArgumentException(\"Only single dimensional arrays are supported for the requested action.\");\n                }\n\n                if (Bridge.is(array, System.Array.type(System.Int32))) {\n                    System.Array.copy(this.m_array, 0, array, index, System.Collections.BitArray.getArrayLength(this.m_length, System.Collections.BitArray.BitsPerInt32));\n                } else if (Bridge.is(array, System.Array.type(System.Byte))) {\n                    var arrayLength = System.Collections.BitArray.getArrayLength(this.m_length, System.Collections.BitArray.BitsPerByte);\n                    if ((((array.length - index) | 0)) < arrayLength) {\n                        throw new System.ArgumentException(\"Offset and length were out of bounds for the array or count is greater than the number of elements from index to the end of the source collection.\");\n                    }\n\n                    var b = Bridge.cast(array, System.Array.type(System.Byte));\n                    for (var i = 0; i < arrayLength; i = (i + 1) | 0) {\n                        b[System.Array.index(((index + i) | 0), b)] = ((this.m_array[System.Array.index(((Bridge.Int.div(i, 4)) | 0), this.m_array)] >> (Bridge.Int.mul((i % 4), 8))) & 255) & 255; // Shift to bring the required byte to LSB, then mask\n                    }\n                } else if (Bridge.is(array, System.Array.type(System.Boolean))) {\n                    if (((array.length - index) | 0) < this.m_length) {\n                        throw new System.ArgumentException(\"Offset and length were out of bounds for the array or count is greater than the number of elements from index to the end of the source collection.\");\n                    }\n\n                    var b1 = Bridge.cast(array, System.Array.type(System.Boolean));\n                    for (var i1 = 0; i1 < this.m_length; i1 = (i1 + 1) | 0) {\n                        b1[System.Array.index(((index + i1) | 0), b1)] = ((this.m_array[System.Array.index(((Bridge.Int.div(i1, 32)) | 0), this.m_array)] >> (i1 % 32)) & 1) !== 0;\n                    }\n                } else {\n                    throw new System.ArgumentException(\"Only supported array types for CopyTo on BitArrays are Boolean[], Int32[] and Byte[].\");\n                }\n            },\n            get: function (index) {\n                if (index < 0 || index >= this.Length) {\n                    throw new System.ArgumentOutOfRangeException(\"index\", \"Index was out of range. Must be non-negative and less than the size of the collection.\");\n                }\n\n                return (this.m_array[System.Array.index(((Bridge.Int.div(index, 32)) | 0), this.m_array)] & (1 << (index % 32))) !== 0;\n            },\n            set: function (index, value) {\n                var $t, $t1;\n                if (index < 0 || index >= this.Length) {\n                    throw new System.ArgumentOutOfRangeException(\"index\", \"Index was out of range. Must be non-negative and less than the size of the collection.\");\n                }\n\n                if (value) {\n                    this.m_array[System.Array.index(($t = ((Bridge.Int.div(index, 32)) | 0)), this.m_array)] = this.m_array[System.Array.index($t, this.m_array)] | (1 << (index % 32));\n                } else {\n                    this.m_array[System.Array.index(($t1 = ((Bridge.Int.div(index, 32)) | 0)), this.m_array)] = this.m_array[System.Array.index($t1, this.m_array)] & (~(1 << (index % 32)));\n                }\n\n                this._version = (this._version + 1) | 0;\n            },\n            setAll: function (value) {\n                var fillValue = value ? (-1) : 0;\n                var ints = System.Collections.BitArray.getArrayLength(this.m_length, System.Collections.BitArray.BitsPerInt32);\n                for (var i = 0; i < ints; i = (i + 1) | 0) {\n                    this.m_array[System.Array.index(i, this.m_array)] = fillValue;\n                }\n\n                this._version = (this._version + 1) | 0;\n            },\n            and: function (value) {\n                if (value == null) {\n                    throw new System.ArgumentNullException(\"value\");\n                }\n                if (this.Length !== value.Length) {\n                    throw new System.ArgumentException(\"Array lengths must be the same.\");\n                }\n\n                var ints = System.Collections.BitArray.getArrayLength(this.m_length, System.Collections.BitArray.BitsPerInt32);\n                for (var i = 0; i < ints; i = (i + 1) | 0) {\n                    this.m_array[System.Array.index(i, this.m_array)] = this.m_array[System.Array.index(i, this.m_array)] & value.m_array[System.Array.index(i, value.m_array)];\n                }\n\n                this._version = (this._version + 1) | 0;\n                return this;\n            },\n            or: function (value) {\n                if (value == null) {\n                    throw new System.ArgumentNullException(\"value\");\n                }\n                if (this.Length !== value.Length) {\n                    throw new System.ArgumentException(\"Array lengths must be the same.\");\n                }\n\n                var ints = System.Collections.BitArray.getArrayLength(this.m_length, System.Collections.BitArray.BitsPerInt32);\n                for (var i = 0; i < ints; i = (i + 1) | 0) {\n                    this.m_array[System.Array.index(i, this.m_array)] = this.m_array[System.Array.index(i, this.m_array)] | value.m_array[System.Array.index(i, value.m_array)];\n                }\n\n                this._version = (this._version + 1) | 0;\n                return this;\n            },\n            xor: function (value) {\n                if (value == null) {\n                    throw new System.ArgumentNullException(\"value\");\n                }\n                if (this.Length !== value.Length) {\n                    throw new System.ArgumentException(\"Array lengths must be the same.\");\n                }\n\n                var ints = System.Collections.BitArray.getArrayLength(this.m_length, System.Collections.BitArray.BitsPerInt32);\n                for (var i = 0; i < ints; i = (i + 1) | 0) {\n                    this.m_array[System.Array.index(i, this.m_array)] = this.m_array[System.Array.index(i, this.m_array)] ^ value.m_array[System.Array.index(i, value.m_array)];\n                }\n\n                this._version = (this._version + 1) | 0;\n                return this;\n            },\n            not: function () {\n                var ints = System.Collections.BitArray.getArrayLength(this.m_length, System.Collections.BitArray.BitsPerInt32);\n                for (var i = 0; i < ints; i = (i + 1) | 0) {\n                    this.m_array[System.Array.index(i, this.m_array)] = ~this.m_array[System.Array.index(i, this.m_array)];\n                }\n\n                this._version = (this._version + 1) | 0;\n                return this;\n            },\n            clone: function () {\n                var bitArray = new System.Collections.BitArray.$ctor5(this.m_array);\n                bitArray._version = this._version;\n                bitArray.m_length = this.m_length;\n                return bitArray;\n            },\n            getEnumerator: function () {\n                return new System.Collections.BitArray.BitArrayEnumeratorSimple(this);\n            }\n        }\n    });\n\n    // @source bitArrayEnumeratorSimple.js\n\n    Bridge.define(\"System.Collections.BitArray.BitArrayEnumeratorSimple\", {\n        inherits: [System.Collections.IEnumerator],\n        fields: {\n            bitarray: null,\n            index: 0,\n            version: 0,\n            currentElement: false\n        },\n        props: {\n            Current: {\n                get: function () {\n                    if (this.index === -1) {\n                        throw new System.InvalidOperationException(\"Enumeration has not started. Call MoveNext.\");\n                    }\n                    if (this.index >= this.bitarray.Count) {\n                        throw new System.InvalidOperationException(\"Enumeration already finished.\");\n                    }\n                    return Bridge.box(this.currentElement, System.Boolean, System.Boolean.toString);\n                }\n            }\n        },\n        alias: [\n            \"moveNext\", \"System$Collections$IEnumerator$moveNext\",\n            \"Current\", \"System$Collections$IEnumerator$Current\",\n            \"reset\", \"System$Collections$IEnumerator$reset\"\n        ],\n        ctors: {\n            ctor: function (bitarray) {\n                this.$initialize();\n                this.bitarray = bitarray;\n                this.index = -1;\n                this.version = bitarray._version;\n            }\n        },\n        methods: {\n            moveNext: function () {\n                if (this.version !== this.bitarray._version) {\n                    throw new System.InvalidOperationException(\"Collection was modified; enumeration operation may not execute.\");\n                }\n                if (this.index < (((this.bitarray.Count - 1) | 0))) {\n                    this.index = (this.index + 1) | 0;\n                    this.currentElement = this.bitarray.get(this.index);\n                    return true;\n                } else {\n                    this.index = this.bitarray.Count;\n                }\n\n                return false;\n            },\n            reset: function () {\n                if (this.version !== this.bitarray._version) {\n                    throw new System.InvalidOperationException(\"Collection was modified; enumeration operation may not execute.\");\n                }\n                this.index = -1;\n            }\n        }\n    });\n\n    // @source bitHelper.js\n\n    Bridge.define(\"System.Collections.Generic.BitHelper\", {\n        statics: {\n            fields: {\n                MarkedBitFlag: 0,\n                IntSize: 0\n            },\n            ctors: {\n                init: function () {\n                    this.MarkedBitFlag = 1;\n                    this.IntSize = 32;\n                }\n            },\n            methods: {\n                toIntArrayLength: function (n) {\n                    return n > 0 ? (((((Bridge.Int.div((((n - 1) | 0)), System.Collections.Generic.BitHelper.IntSize)) | 0) + 1) | 0)) : 0;\n                }\n            }\n        },\n        fields: {\n            _length: 0,\n            _array: null\n        },\n        ctors: {\n            ctor: function (bitArray, length) {\n                this.$initialize();\n                this._array = bitArray;\n                this._length = length;\n            }\n        },\n        methods: {\n            markBit: function (bitPosition) {\n                var bitArrayIndex = (Bridge.Int.div(bitPosition, System.Collections.Generic.BitHelper.IntSize)) | 0;\n                if (bitArrayIndex < this._length && bitArrayIndex >= 0) {\n                    var flag = (System.Collections.Generic.BitHelper.MarkedBitFlag << (bitPosition % System.Collections.Generic.BitHelper.IntSize));\n                    this._array[System.Array.index(bitArrayIndex, this._array)] = this._array[System.Array.index(bitArrayIndex, this._array)] | flag;\n                }\n            },\n            isMarked: function (bitPosition) {\n                var bitArrayIndex = (Bridge.Int.div(bitPosition, System.Collections.Generic.BitHelper.IntSize)) | 0;\n                if (bitArrayIndex < this._length && bitArrayIndex >= 0) {\n                    var flag = (System.Collections.Generic.BitHelper.MarkedBitFlag << (bitPosition % System.Collections.Generic.BitHelper.IntSize));\n                    return ((this._array[System.Array.index(bitArrayIndex, this._array)] & flag) !== 0);\n                }\n                return false;\n            }\n        }\n    });\n\n    // @source enumerableHelpers.js\n\n    Bridge.define(\"Bridge.Collections.EnumerableHelpers\", {\n        statics: {\n            methods: {\n                toArray: function (T, source) {\n                    var count = { };\n                    var results = { v : Bridge.Collections.EnumerableHelpers.toArray$1(T, source, count) };\n                    System.Array.resize(results, count.v, Bridge.getDefaultValue(T));\n                    return results.v;\n                },\n                toArray$1: function (T, source, length) {\n                    var en = Bridge.getEnumerator(source, T);\n                    try {\n                        if (en.System$Collections$IEnumerator$moveNext()) {\n                            var DefaultCapacity = 4;\n                            var arr = { v : System.Array.init(DefaultCapacity, function (){\n                                return Bridge.getDefaultValue(T);\n                            }, T) };\n                            arr.v[System.Array.index(0, arr.v)] = en[Bridge.geti(en, \"System$Collections$Generic$IEnumerator$1$\" + Bridge.getTypeAlias(T) + \"$Current$1\", \"System$Collections$Generic$IEnumerator$1$Current$1\")];\n                            var count = 1;\n\n                            while (en.System$Collections$IEnumerator$moveNext()) {\n                                if (count === arr.v.length) {\n                                    // MaxArrayLength is defined in Array.MaxArrayLength and in gchelpers in CoreCLR.\n                                    // It represents the maximum number of elements that can be in an array where\n                                    // the size of the element is greater than one byte; a separate, slightly larger constant,\n                                    // is used when the size of the element is one.\n                                    var MaxArrayLength = 2146435071;\n\n                                    // This is the same growth logic as in List<T>:\n                                    // If the array is currently empty, we make it a default size.  Otherwise, we attempt to\n                                    // double the size of the array.  Doubling will overflow once the size of the array reaches\n                                    // 2^30, since doubling to 2^31 is 1 larger than Int32.MaxValue.  In that case, we instead\n                                    // constrain the length to be MaxArrayLength (this overflow check works because of of the\n                                    // cast to uint).  Because a slightly larger constant is used when T is one byte in size, we\n                                    // could then end up in a situation where arr.Length is MaxArrayLength or slightly larger, such\n                                    // that we constrain newLength to be MaxArrayLength but the needed number of elements is actually\n                                    // larger than that.  For that case, we then ensure that the newLength is large enough to hold\n                                    // the desired capacity.  This does mean that in the very rare case where we've grown to such a\n                                    // large size, each new element added after MaxArrayLength will end up doing a resize.\n                                    var newLength = count << 1;\n                                    if ((newLength >>> 0) > MaxArrayLength) {\n                                        newLength = MaxArrayLength <= count ? ((count + 1) | 0) : MaxArrayLength;\n                                    }\n\n                                    System.Array.resize(arr, newLength, Bridge.getDefaultValue(T));\n                                }\n\n                                arr.v[System.Array.index(Bridge.identity(count, (count = (count + 1) | 0)), arr.v)] = en[Bridge.geti(en, \"System$Collections$Generic$IEnumerator$1$\" + Bridge.getTypeAlias(T) + \"$Current$1\", \"System$Collections$Generic$IEnumerator$1$Current$1\")];\n                            }\n\n                            length.v = count;\n                            return arr.v;\n                        }\n                    }\n                    finally {\n                        if (Bridge.hasValue(en)) {\n                            en.System$IDisposable$dispose();\n                        }\n                    }\n\n                    length.v = 0;\n                    return System.Array.init(0, function (){\n                        return Bridge.getDefaultValue(T);\n                    }, T);\n                }\n            }\n        }\n    });\n\n    // @source hashSet.js\n\n    Bridge.define(\"System.Collections.Generic.HashSet$1\", function (T) { return {\n        inherits: [System.Collections.Generic.ICollection$1(T),System.Collections.Generic.ISet$1(T)],\n        statics: {\n            fields: {\n                Lower31BitMask: 0,\n                ShrinkThreshold: 0\n            },\n            ctors: {\n                init: function () {\n                    this.Lower31BitMask = 2147483647;\n                    this.ShrinkThreshold = 3;\n                }\n            },\n            methods: {\n                hashSetEquals: function (set1, set2, comparer) {\n                    var $t, $t1, $t2;\n                    if (set1 == null) {\n                        return (set2 == null);\n                    } else if (set2 == null) {\n                        return false;\n                    }\n                    if (System.Collections.Generic.HashSet$1(T).areEqualityComparersEqual(set1, set2)) {\n                        if (set1.Count !== set2.Count) {\n                            return false;\n                        }\n                        $t = Bridge.getEnumerator(set2);\n                        try {\n                            while ($t.moveNext()) {\n                                var item = $t.Current;\n                                if (!set1.contains(item)) {\n                                    return false;\n                                }\n                            }\n                        } finally {\n                            if (Bridge.is($t, System.IDisposable)) {\n                                $t.System$IDisposable$dispose();\n                            }\n                        }return true;\n                    } else {\n                        $t1 = Bridge.getEnumerator(set2);\n                        try {\n                            while ($t1.moveNext()) {\n                                var set2Item = $t1.Current;\n                                var found = false;\n                                $t2 = Bridge.getEnumerator(set1);\n                                try {\n                                    while ($t2.moveNext()) {\n                                        var set1Item = $t2.Current;\n                                        if (comparer[Bridge.geti(comparer, \"System$Collections$Generic$IEqualityComparer$1$\" + Bridge.getTypeAlias(T) + \"$equals2\", \"System$Collections$Generic$IEqualityComparer$1$equals2\")](set2Item, set1Item)) {\n                                            found = true;\n                                            break;\n                                        }\n                                    }\n                                } finally {\n                                    if (Bridge.is($t2, System.IDisposable)) {\n                                        $t2.System$IDisposable$dispose();\n                                    }\n                                }if (!found) {\n                                    return false;\n                                }\n                            }\n                        } finally {\n                            if (Bridge.is($t1, System.IDisposable)) {\n                                $t1.System$IDisposable$dispose();\n                            }\n                        }return true;\n                    }\n                },\n                areEqualityComparersEqual: function (set1, set2) {\n                    return Bridge.equals(set1.Comparer, set2.Comparer);\n                }\n            }\n        },\n        fields: {\n            _buckets: null,\n            _slots: null,\n            _count: 0,\n            _lastIndex: 0,\n            _freeList: 0,\n            _comparer: null,\n            _version: 0\n        },\n        props: {\n            Count: {\n                get: function () {\n                    return this._count;\n                }\n            },\n            IsReadOnly: {\n                get: function () {\n                    return false;\n                }\n            },\n            Comparer: {\n                get: function () {\n                    return this._comparer;\n                }\n            }\n        },\n        alias: [\n            \"System$Collections$Generic$ICollection$1$add\", \"System$Collections$Generic$ICollection$1$\" + Bridge.getTypeAlias(T) + \"$add\",\n            \"clear\", \"System$Collections$Generic$ICollection$1$\" + Bridge.getTypeAlias(T) + \"$clear\",\n            \"contains\", \"System$Collections$Generic$ICollection$1$\" + Bridge.getTypeAlias(T) + \"$contains\",\n            \"copyTo\", \"System$Collections$Generic$ICollection$1$\" + Bridge.getTypeAlias(T) + \"$copyTo\",\n            \"remove\", \"System$Collections$Generic$ICollection$1$\" + Bridge.getTypeAlias(T) + \"$remove\",\n            \"Count\", \"System$Collections$Generic$ICollection$1$\" + Bridge.getTypeAlias(T) + \"$Count\",\n            \"IsReadOnly\", \"System$Collections$Generic$ICollection$1$\" + Bridge.getTypeAlias(T) + \"$IsReadOnly\",\n            \"System$Collections$Generic$IEnumerable$1$getEnumerator\", \"System$Collections$Generic$IEnumerable$1$\" + Bridge.getTypeAlias(T) + \"$getEnumerator\",\n            \"add\", \"System$Collections$Generic$ISet$1$\" + Bridge.getTypeAlias(T) + \"$add\",\n            \"unionWith\", \"System$Collections$Generic$ISet$1$\" + Bridge.getTypeAlias(T) + \"$unionWith\",\n            \"intersectWith\", \"System$Collections$Generic$ISet$1$\" + Bridge.getTypeAlias(T) + \"$intersectWith\",\n            \"exceptWith\", \"System$Collections$Generic$ISet$1$\" + Bridge.getTypeAlias(T) + \"$exceptWith\",\n            \"symmetricExceptWith\", \"System$Collections$Generic$ISet$1$\" + Bridge.getTypeAlias(T) + \"$symmetricExceptWith\",\n            \"isSubsetOf\", \"System$Collections$Generic$ISet$1$\" + Bridge.getTypeAlias(T) + \"$isSubsetOf\",\n            \"isProperSubsetOf\", \"System$Collections$Generic$ISet$1$\" + Bridge.getTypeAlias(T) + \"$isProperSubsetOf\",\n            \"isSupersetOf\", \"System$Collections$Generic$ISet$1$\" + Bridge.getTypeAlias(T) + \"$isSupersetOf\",\n            \"isProperSupersetOf\", \"System$Collections$Generic$ISet$1$\" + Bridge.getTypeAlias(T) + \"$isProperSupersetOf\",\n            \"overlaps\", \"System$Collections$Generic$ISet$1$\" + Bridge.getTypeAlias(T) + \"$overlaps\",\n            \"setEquals\", \"System$Collections$Generic$ISet$1$\" + Bridge.getTypeAlias(T) + \"$setEquals\"\n        ],\n        ctors: {\n            ctor: function () {\n                System.Collections.Generic.HashSet$1(T).$ctor3.call(this, System.Collections.Generic.EqualityComparer$1(T).def);\n            },\n            $ctor3: function (comparer) {\n                this.$initialize();\n                if (comparer == null) {\n                    comparer = System.Collections.Generic.EqualityComparer$1(T).def;\n                }\n                this._comparer = comparer;\n                this._lastIndex = 0;\n                this._count = 0;\n                this._freeList = -1;\n                this._version = 0;\n            },\n            $ctor1: function (collection) {\n                System.Collections.Generic.HashSet$1(T).$ctor2.call(this, collection, System.Collections.Generic.EqualityComparer$1(T).def);\n            },\n            $ctor2: function (collection, comparer) {\n                System.Collections.Generic.HashSet$1(T).$ctor3.call(this, comparer);\n                if (collection == null) {\n                    throw new System.ArgumentNullException(\"collection\");\n                }\n                var suggestedCapacity = 0;\n                var coll = Bridge.as(collection, System.Collections.Generic.ICollection$1(T));\n                if (coll != null) {\n                    suggestedCapacity = System.Array.getCount(coll, T);\n                }\n                this.initialize(suggestedCapacity);\n                this.unionWith(collection);\n                if ((this._count === 0 && this._slots.length > System.Collections.HashHelpers.getMinPrime()) || (this._count > 0 && ((Bridge.Int.div(this._slots.length, this._count)) | 0) > System.Collections.Generic.HashSet$1(T).ShrinkThreshold)) {\n                    this.trimExcess();\n                }\n            }\n        },\n        methods: {\n            System$Collections$Generic$ICollection$1$add: function (item) {\n                this.addIfNotPresent(item);\n            },\n            add: function (item) {\n                return this.addIfNotPresent(item);\n            },\n            clear: function () {\n                if (this._lastIndex > 0) {\n                    for (var i = 0; i < this._lastIndex; i = (i + 1) | 0) {\n                        this._slots[System.Array.index(i, this._slots)] = new (System.Collections.Generic.HashSet$1.Slot(T))();\n                    }\n\n                    for (var i1 = 0; i1 < this._buckets.length; i1 = (i1 + 1) | 0) {\n                        this._buckets[System.Array.index(i1, this._buckets)] = 0;\n                    }\n\n                    this._lastIndex = 0;\n                    this._count = 0;\n                    this._freeList = -1;\n                }\n                this._version = (this._version + 1) | 0;\n            },\n            arrayClear: function (array, index, length) { },\n            contains: function (item) {\n                if (this._buckets != null) {\n                    var hashCode = this.internalGetHashCode(item);\n                    for (var i = (this._buckets[System.Array.index(hashCode % this._buckets.length, this._buckets)] - 1) | 0; i >= 0; i = this._slots[System.Array.index(i, this._slots)].next) {\n                        if (this._slots[System.Array.index(i, this._slots)].hashCode === hashCode && this._comparer[Bridge.geti(this._comparer, \"System$Collections$Generic$IEqualityComparer$1$\" + Bridge.getTypeAlias(T) + \"$equals2\", \"System$Collections$Generic$IEqualityComparer$1$equals2\")](this._slots[System.Array.index(i, this._slots)].value, item)) {\n                            return true;\n                        }\n                    }\n                }\n                return false;\n            },\n            copyTo: function (array, arrayIndex) {\n                this.copyTo$2(array, arrayIndex, this._count);\n            },\n            copyTo$1: function (array) {\n                this.copyTo$2(array, 0, this._count);\n            },\n            copyTo$2: function (array, arrayIndex, count) {\n                if (array == null) {\n                    throw new System.ArgumentNullException(\"array\");\n                }\n                if (arrayIndex < 0) {\n                    throw new System.ArgumentOutOfRangeException(\"arrayIndex\");\n                }\n                if (count < 0) {\n                    throw new System.ArgumentOutOfRangeException(\"count\");\n                }\n                if (arrayIndex > array.length || count > ((array.length - arrayIndex) | 0)) {\n                    throw new System.ArgumentException(\"Destination array is not long enough to copy all the items in the collection. Check array index and length.\");\n                }\n                var numCopied = 0;\n                for (var i = 0; i < this._lastIndex && numCopied < count; i = (i + 1) | 0) {\n                    if (this._slots[System.Array.index(i, this._slots)].hashCode >= 0) {\n                        array[System.Array.index(((arrayIndex + numCopied) | 0), array)] = this._slots[System.Array.index(i, this._slots)].value;\n                        numCopied = (numCopied + 1) | 0;\n                    }\n                }\n            },\n            remove: function (item) {\n                if (this._buckets != null) {\n                    var hashCode = this.internalGetHashCode(item);\n                    var bucket = hashCode % this._buckets.length;\n                    var last = -1;\n                    for (var i = (this._buckets[System.Array.index(bucket, this._buckets)] - 1) | 0; i >= 0; last = i, i = this._slots[System.Array.index(i, this._slots)].next) {\n                        if (this._slots[System.Array.index(i, this._slots)].hashCode === hashCode && this._comparer[Bridge.geti(this._comparer, \"System$Collections$Generic$IEqualityComparer$1$\" + Bridge.getTypeAlias(T) + \"$equals2\", \"System$Collections$Generic$IEqualityComparer$1$equals2\")](this._slots[System.Array.index(i, this._slots)].value, item)) {\n                            if (last < 0) {\n                                this._buckets[System.Array.index(bucket, this._buckets)] = (this._slots[System.Array.index(i, this._slots)].next + 1) | 0;\n                            } else {\n                                this._slots[System.Array.index(last, this._slots)].next = this._slots[System.Array.index(i, this._slots)].next;\n                            }\n                            this._slots[System.Array.index(i, this._slots)].hashCode = -1;\n                            this._slots[System.Array.index(i, this._slots)].value = Bridge.getDefaultValue(T);\n                            this._slots[System.Array.index(i, this._slots)].next = this._freeList;\n                            this._count = (this._count - 1) | 0;\n                            this._version = (this._version + 1) | 0;\n                            if (this._count === 0) {\n                                this._lastIndex = 0;\n                                this._freeList = -1;\n                            } else {\n                                this._freeList = i;\n                            }\n                            return true;\n                        }\n                    }\n                }\n                return false;\n            },\n            getEnumerator: function () {\n                return new (System.Collections.Generic.HashSet$1.Enumerator(T)).$ctor1(this);\n            },\n            System$Collections$Generic$IEnumerable$1$getEnumerator: function () {\n                return new (System.Collections.Generic.HashSet$1.Enumerator(T)).$ctor1(this).$clone();\n            },\n            System$Collections$IEnumerable$getEnumerator: function () {\n                return new (System.Collections.Generic.HashSet$1.Enumerator(T)).$ctor1(this).$clone();\n            },\n            unionWith: function (other) {\n                var $t;\n                if (other == null) {\n                    throw new System.ArgumentNullException(\"other\");\n                }\n                $t = Bridge.getEnumerator(other, T);\n                try {\n                    while ($t.moveNext()) {\n                        var item = $t.Current;\n                        this.addIfNotPresent(item);\n                    }\n                } finally {\n                    if (Bridge.is($t, System.IDisposable)) {\n                        $t.System$IDisposable$dispose();\n                    }\n                }},\n            intersectWith: function (other) {\n                if (other == null) {\n                    throw new System.ArgumentNullException(\"other\");\n                }\n                if (this._count === 0) {\n                    return;\n                }\n                var otherAsCollection = Bridge.as(other, System.Collections.Generic.ICollection$1(T));\n                if (otherAsCollection != null) {\n                    if (System.Array.getCount(otherAsCollection, T) === 0) {\n                        this.clear();\n                        return;\n                    }\n                    var otherAsSet = Bridge.as(other, System.Collections.Generic.HashSet$1(T));\n                    if (otherAsSet != null && System.Collections.Generic.HashSet$1(T).areEqualityComparersEqual(this, otherAsSet)) {\n                        this.intersectWithHashSetWithSameEC(otherAsSet);\n                        return;\n                    }\n                }\n                this.intersectWithEnumerable(other);\n            },\n            exceptWith: function (other) {\n                var $t;\n                if (other == null) {\n                    throw new System.ArgumentNullException(\"other\");\n                }\n                if (this._count === 0) {\n                    return;\n                }\n                if (Bridge.referenceEquals(other, this)) {\n                    this.clear();\n                    return;\n                }\n                $t = Bridge.getEnumerator(other, T);\n                try {\n                    while ($t.moveNext()) {\n                        var element = $t.Current;\n                        this.remove(element);\n                    }\n                } finally {\n                    if (Bridge.is($t, System.IDisposable)) {\n                        $t.System$IDisposable$dispose();\n                    }\n                }},\n            symmetricExceptWith: function (other) {\n                if (other == null) {\n                    throw new System.ArgumentNullException(\"other\");\n                }\n                if (this._count === 0) {\n                    this.unionWith(other);\n                    return;\n                }\n                if (Bridge.referenceEquals(other, this)) {\n                    this.clear();\n                    return;\n                }\n                var otherAsSet = Bridge.as(other, System.Collections.Generic.HashSet$1(T));\n                if (otherAsSet != null && System.Collections.Generic.HashSet$1(T).areEqualityComparersEqual(this, otherAsSet)) {\n                    this.symmetricExceptWithUniqueHashSet(otherAsSet);\n                } else {\n                    this.symmetricExceptWithEnumerable(other);\n                }\n            },\n            isSubsetOf: function (other) {\n                if (other == null) {\n                    throw new System.ArgumentNullException(\"other\");\n                }\n                if (this._count === 0) {\n                    return true;\n                }\n                var otherAsSet = Bridge.as(other, System.Collections.Generic.HashSet$1(T));\n                if (otherAsSet != null && System.Collections.Generic.HashSet$1(T).areEqualityComparersEqual(this, otherAsSet)) {\n                    if (this._count > otherAsSet.Count) {\n                        return false;\n                    }\n                    return this.isSubsetOfHashSetWithSameEC(otherAsSet);\n                } else {\n                    var result = this.checkUniqueAndUnfoundElements(other, false);\n                    return (result.uniqueCount === this._count && result.unfoundCount >= 0);\n                }\n            },\n            isProperSubsetOf: function (other) {\n                if (other == null) {\n                    throw new System.ArgumentNullException(\"other\");\n                }\n                var otherAsCollection = Bridge.as(other, System.Collections.Generic.ICollection$1(T));\n                if (otherAsCollection != null) {\n                    if (this._count === 0) {\n                        return System.Array.getCount(otherAsCollection, T) > 0;\n                    }\n                    var otherAsSet = Bridge.as(other, System.Collections.Generic.HashSet$1(T));\n                    if (otherAsSet != null && System.Collections.Generic.HashSet$1(T).areEqualityComparersEqual(this, otherAsSet)) {\n                        if (this._count >= otherAsSet.Count) {\n                            return false;\n                        }\n                        return this.isSubsetOfHashSetWithSameEC(otherAsSet);\n                    }\n                }\n                var result = this.checkUniqueAndUnfoundElements(other, false);\n                return (result.uniqueCount === this._count && result.unfoundCount > 0);\n            },\n            isSupersetOf: function (other) {\n                if (other == null) {\n                    throw new System.ArgumentNullException(\"other\");\n                }\n                var otherAsCollection = Bridge.as(other, System.Collections.Generic.ICollection$1(T));\n                if (otherAsCollection != null) {\n                    if (System.Array.getCount(otherAsCollection, T) === 0) {\n                        return true;\n                    }\n                    var otherAsSet = Bridge.as(other, System.Collections.Generic.HashSet$1(T));\n                    if (otherAsSet != null && System.Collections.Generic.HashSet$1(T).areEqualityComparersEqual(this, otherAsSet)) {\n                        if (otherAsSet.Count > this._count) {\n                            return false;\n                        }\n                    }\n                }\n                return this.containsAllElements(other);\n            },\n            isProperSupersetOf: function (other) {\n                if (other == null) {\n                    throw new System.ArgumentNullException(\"other\");\n                }\n                if (this._count === 0) {\n                    return false;\n                }\n                var otherAsCollection = Bridge.as(other, System.Collections.Generic.ICollection$1(T));\n                if (otherAsCollection != null) {\n                    if (System.Array.getCount(otherAsCollection, T) === 0) {\n                        return true;\n                    }\n                    var otherAsSet = Bridge.as(other, System.Collections.Generic.HashSet$1(T));\n                    if (otherAsSet != null && System.Collections.Generic.HashSet$1(T).areEqualityComparersEqual(this, otherAsSet)) {\n                        if (otherAsSet.Count >= this._count) {\n                            return false;\n                        }\n                        return this.containsAllElements(otherAsSet);\n                    }\n                }\n                var result = this.checkUniqueAndUnfoundElements(other, true);\n                return (result.uniqueCount < this._count && result.unfoundCount === 0);\n            },\n            overlaps: function (other) {\n                var $t;\n                if (other == null) {\n                    throw new System.ArgumentNullException(\"other\");\n                }\n                if (this._count === 0) {\n                    return false;\n                }\n                $t = Bridge.getEnumerator(other, T);\n                try {\n                    while ($t.moveNext()) {\n                        var element = $t.Current;\n                        if (this.contains(element)) {\n                            return true;\n                        }\n                    }\n                } finally {\n                    if (Bridge.is($t, System.IDisposable)) {\n                        $t.System$IDisposable$dispose();\n                    }\n                }return false;\n            },\n            setEquals: function (other) {\n                if (other == null) {\n                    throw new System.ArgumentNullException(\"other\");\n                }\n                var otherAsSet = Bridge.as(other, System.Collections.Generic.HashSet$1(T));\n                if (otherAsSet != null && System.Collections.Generic.HashSet$1(T).areEqualityComparersEqual(this, otherAsSet)) {\n                    if (this._count !== otherAsSet.Count) {\n                        return false;\n                    }\n                    return this.containsAllElements(otherAsSet);\n                } else {\n                    var otherAsCollection = Bridge.as(other, System.Collections.Generic.ICollection$1(T));\n                    if (otherAsCollection != null) {\n                        if (this._count === 0 && System.Array.getCount(otherAsCollection, T) > 0) {\n                            return false;\n                        }\n                    }\n                    var result = this.checkUniqueAndUnfoundElements(other, true);\n                    return (result.uniqueCount === this._count && result.unfoundCount === 0);\n                }\n            },\n            removeWhere: function (match) {\n                if (Bridge.staticEquals(match, null)) {\n                    throw new System.ArgumentNullException(\"match\");\n                }\n                var numRemoved = 0;\n                for (var i = 0; i < this._lastIndex; i = (i + 1) | 0) {\n                    if (this._slots[System.Array.index(i, this._slots)].hashCode >= 0) {\n                        var value = this._slots[System.Array.index(i, this._slots)].value;\n                        if (match(value)) {\n                            if (this.remove(value)) {\n                                numRemoved = (numRemoved + 1) | 0;\n                            }\n                        }\n                    }\n                }\n                return numRemoved;\n            },\n            trimExcess: function () {\n                if (this._count === 0) {\n                    this._buckets = null;\n                    this._slots = null;\n                    this._version = (this._version + 1) | 0;\n                } else {\n                    var newSize = System.Collections.HashHelpers.getPrime(this._count);\n                    var newSlots = System.Array.init(newSize, function (){\n                        return new (System.Collections.Generic.HashSet$1.Slot(T))();\n                    }, System.Collections.Generic.HashSet$1.Slot(T));\n                    var newBuckets = System.Array.init(newSize, 0, System.Int32);\n                    var newIndex = 0;\n                    for (var i = 0; i < this._lastIndex; i = (i + 1) | 0) {\n                        if (this._slots[System.Array.index(i, this._slots)].hashCode >= 0) {\n                            newSlots[System.Array.index(newIndex, newSlots)] = this._slots[System.Array.index(i, this._slots)].$clone();\n                            var bucket = newSlots[System.Array.index(newIndex, newSlots)].hashCode % newSize;\n                            newSlots[System.Array.index(newIndex, newSlots)].next = (newBuckets[System.Array.index(bucket, newBuckets)] - 1) | 0;\n                            newBuckets[System.Array.index(bucket, newBuckets)] = (newIndex + 1) | 0;\n                            newIndex = (newIndex + 1) | 0;\n                        }\n                    }\n                    this._lastIndex = newIndex;\n                    this._slots = newSlots;\n                    this._buckets = newBuckets;\n                    this._freeList = -1;\n                }\n            },\n            initialize: function (capacity) {\n                var size = System.Collections.HashHelpers.getPrime(capacity);\n                this._buckets = System.Array.init(size, 0, System.Int32);\n                this._slots = System.Array.init(size, function (){\n                    return new (System.Collections.Generic.HashSet$1.Slot(T))();\n                }, System.Collections.Generic.HashSet$1.Slot(T));\n            },\n            increaseCapacity: function () {\n                var newSize = System.Collections.HashHelpers.expandPrime(this._count);\n                if (newSize <= this._count) {\n                    throw new System.ArgumentException(\"HashSet capacity is too big.\");\n                }\n                this.setCapacity(newSize, false);\n            },\n            setCapacity: function (newSize, forceNewHashCodes) {\n                var newSlots = System.Array.init(newSize, function (){\n                    return new (System.Collections.Generic.HashSet$1.Slot(T))();\n                }, System.Collections.Generic.HashSet$1.Slot(T));\n                if (this._slots != null) {\n                    for (var i = 0; i < this._lastIndex; i = (i + 1) | 0) {\n                        newSlots[System.Array.index(i, newSlots)] = this._slots[System.Array.index(i, this._slots)].$clone();\n                    }\n                }\n                if (forceNewHashCodes) {\n                    for (var i1 = 0; i1 < this._lastIndex; i1 = (i1 + 1) | 0) {\n                        if (newSlots[System.Array.index(i1, newSlots)].hashCode !== -1) {\n                            newSlots[System.Array.index(i1, newSlots)].hashCode = this.internalGetHashCode(newSlots[System.Array.index(i1, newSlots)].value);\n                        }\n                    }\n                }\n                var newBuckets = System.Array.init(newSize, 0, System.Int32);\n                for (var i2 = 0; i2 < this._lastIndex; i2 = (i2 + 1) | 0) {\n                    var bucket = newSlots[System.Array.index(i2, newSlots)].hashCode % newSize;\n                    newSlots[System.Array.index(i2, newSlots)].next = (newBuckets[System.Array.index(bucket, newBuckets)] - 1) | 0;\n                    newBuckets[System.Array.index(bucket, newBuckets)] = (i2 + 1) | 0;\n                }\n                this._slots = newSlots;\n                this._buckets = newBuckets;\n            },\n            addIfNotPresent: function (value) {\n                if (this._buckets == null) {\n                    this.initialize(0);\n                }\n                var hashCode = this.internalGetHashCode(value);\n                var bucket = hashCode % this._buckets.length;\n                for (var i = (this._buckets[System.Array.index(bucket, this._buckets)] - 1) | 0; i >= 0; i = this._slots[System.Array.index(i, this._slots)].next) {\n                    if (this._slots[System.Array.index(i, this._slots)].hashCode === hashCode && this._comparer[Bridge.geti(this._comparer, \"System$Collections$Generic$IEqualityComparer$1$\" + Bridge.getTypeAlias(T) + \"$equals2\", \"System$Collections$Generic$IEqualityComparer$1$equals2\")](this._slots[System.Array.index(i, this._slots)].value, value)) {\n                        return false;\n                    }\n                }\n                var index;\n                if (this._freeList >= 0) {\n                    index = this._freeList;\n                    this._freeList = this._slots[System.Array.index(index, this._slots)].next;\n                } else {\n                    if (this._lastIndex === this._slots.length) {\n                        this.increaseCapacity();\n                        bucket = hashCode % this._buckets.length;\n                    }\n                    index = this._lastIndex;\n                    this._lastIndex = (this._lastIndex + 1) | 0;\n                }\n                this._slots[System.Array.index(index, this._slots)].hashCode = hashCode;\n                this._slots[System.Array.index(index, this._slots)].value = value;\n                this._slots[System.Array.index(index, this._slots)].next = (this._buckets[System.Array.index(bucket, this._buckets)] - 1) | 0;\n                this._buckets[System.Array.index(bucket, this._buckets)] = (index + 1) | 0;\n                this._count = (this._count + 1) | 0;\n                this._version = (this._version + 1) | 0;\n                return true;\n            },\n            containsAllElements: function (other) {\n                var $t;\n                $t = Bridge.getEnumerator(other, T);\n                try {\n                    while ($t.moveNext()) {\n                        var element = $t.Current;\n                        if (!this.contains(element)) {\n                            return false;\n                        }\n                    }\n                } finally {\n                    if (Bridge.is($t, System.IDisposable)) {\n                        $t.System$IDisposable$dispose();\n                    }\n                }return true;\n            },\n            isSubsetOfHashSetWithSameEC: function (other) {\n                var $t;\n                $t = Bridge.getEnumerator(this);\n                try {\n                    while ($t.moveNext()) {\n                        var item = $t.Current;\n                        if (!other.contains(item)) {\n                            return false;\n                        }\n                    }\n                } finally {\n                    if (Bridge.is($t, System.IDisposable)) {\n                        $t.System$IDisposable$dispose();\n                    }\n                }return true;\n            },\n            intersectWithHashSetWithSameEC: function (other) {\n                for (var i = 0; i < this._lastIndex; i = (i + 1) | 0) {\n                    if (this._slots[System.Array.index(i, this._slots)].hashCode >= 0) {\n                        var item = this._slots[System.Array.index(i, this._slots)].value;\n                        if (!other.contains(item)) {\n                            this.remove(item);\n                        }\n                    }\n                }\n            },\n            intersectWithEnumerable: function (other) {\n                var $t;\n                var originalLastIndex = this._lastIndex;\n                var intArrayLength = System.Collections.Generic.BitHelper.toIntArrayLength(originalLastIndex);\n                var bitHelper;\n                var bitArray = System.Array.init(intArrayLength, 0, System.Int32);\n                bitHelper = new System.Collections.Generic.BitHelper(bitArray, intArrayLength);\n                $t = Bridge.getEnumerator(other, T);\n                try {\n                    while ($t.moveNext()) {\n                        var item = $t.Current;\n                        var index = this.internalIndexOf(item);\n                        if (index >= 0) {\n                            bitHelper.markBit(index);\n                        }\n                    }\n                } finally {\n                    if (Bridge.is($t, System.IDisposable)) {\n                        $t.System$IDisposable$dispose();\n                    }\n                }for (var i = 0; i < originalLastIndex; i = (i + 1) | 0) {\n                    if (this._slots[System.Array.index(i, this._slots)].hashCode >= 0 && !bitHelper.isMarked(i)) {\n                        this.remove(this._slots[System.Array.index(i, this._slots)].value);\n                    }\n                }\n            },\n            internalIndexOf: function (item) {\n                var hashCode = this.internalGetHashCode(item);\n                for (var i = (this._buckets[System.Array.index(hashCode % this._buckets.length, this._buckets)] - 1) | 0; i >= 0; i = this._slots[System.Array.index(i, this._slots)].next) {\n                    if ((this._slots[System.Array.index(i, this._slots)].hashCode) === hashCode && this._comparer[Bridge.geti(this._comparer, \"System$Collections$Generic$IEqualityComparer$1$\" + Bridge.getTypeAlias(T) + \"$equals2\", \"System$Collections$Generic$IEqualityComparer$1$equals2\")](this._slots[System.Array.index(i, this._slots)].value, item)) {\n                        return i;\n                    }\n                }\n                return -1;\n            },\n            symmetricExceptWithUniqueHashSet: function (other) {\n                var $t;\n                $t = Bridge.getEnumerator(other);\n                try {\n                    while ($t.moveNext()) {\n                        var item = $t.Current;\n                        if (!this.remove(item)) {\n                            this.addIfNotPresent(item);\n                        }\n                    }\n                } finally {\n                    if (Bridge.is($t, System.IDisposable)) {\n                        $t.System$IDisposable$dispose();\n                    }\n                }},\n            symmetricExceptWithEnumerable: function (other) {\n                var $t;\n                var originalLastIndex = this._lastIndex;\n                var intArrayLength = System.Collections.Generic.BitHelper.toIntArrayLength(originalLastIndex);\n                var itemsToRemove;\n                var itemsAddedFromOther;\n                var itemsToRemoveArray = System.Array.init(intArrayLength, 0, System.Int32);\n                itemsToRemove = new System.Collections.Generic.BitHelper(itemsToRemoveArray, intArrayLength);\n                var itemsAddedFromOtherArray = System.Array.init(intArrayLength, 0, System.Int32);\n                itemsAddedFromOther = new System.Collections.Generic.BitHelper(itemsAddedFromOtherArray, intArrayLength);\n                $t = Bridge.getEnumerator(other, T);\n                try {\n                    while ($t.moveNext()) {\n                        var item = $t.Current;\n                        var location = { v : 0 };\n                        var added = this.addOrGetLocation(item, location);\n                        if (added) {\n                            itemsAddedFromOther.markBit(location.v);\n                        } else {\n                            if (location.v < originalLastIndex && !itemsAddedFromOther.isMarked(location.v)) {\n                                itemsToRemove.markBit(location.v);\n                            }\n                        }\n                    }\n                } finally {\n                    if (Bridge.is($t, System.IDisposable)) {\n                        $t.System$IDisposable$dispose();\n                    }\n                }for (var i = 0; i < originalLastIndex; i = (i + 1) | 0) {\n                    if (itemsToRemove.isMarked(i)) {\n                        this.remove(this._slots[System.Array.index(i, this._slots)].value);\n                    }\n                }\n            },\n            addOrGetLocation: function (value, location) {\n                var hashCode = this.internalGetHashCode(value);\n                var bucket = hashCode % this._buckets.length;\n                for (var i = (this._buckets[System.Array.index(bucket, this._buckets)] - 1) | 0; i >= 0; i = this._slots[System.Array.index(i, this._slots)].next) {\n                    if (this._slots[System.Array.index(i, this._slots)].hashCode === hashCode && this._comparer[Bridge.geti(this._comparer, \"System$Collections$Generic$IEqualityComparer$1$\" + Bridge.getTypeAlias(T) + \"$equals2\", \"System$Collections$Generic$IEqualityComparer$1$equals2\")](this._slots[System.Array.index(i, this._slots)].value, value)) {\n                        location.v = i;\n                        return false;\n                    }\n                }\n                var index;\n                if (this._freeList >= 0) {\n                    index = this._freeList;\n                    this._freeList = this._slots[System.Array.index(index, this._slots)].next;\n                } else {\n                    if (this._lastIndex === this._slots.length) {\n                        this.increaseCapacity();\n                        bucket = hashCode % this._buckets.length;\n                    }\n                    index = this._lastIndex;\n                    this._lastIndex = (this._lastIndex + 1) | 0;\n                }\n                this._slots[System.Array.index(index, this._slots)].hashCode = hashCode;\n                this._slots[System.Array.index(index, this._slots)].value = value;\n                this._slots[System.Array.index(index, this._slots)].next = (this._buckets[System.Array.index(bucket, this._buckets)] - 1) | 0;\n                this._buckets[System.Array.index(bucket, this._buckets)] = (index + 1) | 0;\n                this._count = (this._count + 1) | 0;\n                this._version = (this._version + 1) | 0;\n                location.v = index;\n                return true;\n            },\n            checkUniqueAndUnfoundElements: function (other, returnIfUnfound) {\n                var $t, $t1;\n                var result = new (System.Collections.Generic.HashSet$1.ElementCount(T))();\n                if (this._count === 0) {\n                    var numElementsInOther = 0;\n                    $t = Bridge.getEnumerator(other, T);\n                    try {\n                        while ($t.moveNext()) {\n                            var item = $t.Current;\n                            numElementsInOther = (numElementsInOther + 1) | 0;\n                            break;\n                        }\n                    } finally {\n                        if (Bridge.is($t, System.IDisposable)) {\n                            $t.System$IDisposable$dispose();\n                        }\n                    }result.uniqueCount = 0;\n                    result.unfoundCount = numElementsInOther;\n                    return result.$clone();\n                }\n                var originalLastIndex = this._lastIndex;\n                var intArrayLength = System.Collections.Generic.BitHelper.toIntArrayLength(originalLastIndex);\n                var bitHelper;\n                var bitArray = System.Array.init(intArrayLength, 0, System.Int32);\n                bitHelper = new System.Collections.Generic.BitHelper(bitArray, intArrayLength);\n                var unfoundCount = 0;\n                var uniqueFoundCount = 0;\n                $t1 = Bridge.getEnumerator(other, T);\n                try {\n                    while ($t1.moveNext()) {\n                        var item1 = $t1.Current;\n                        var index = this.internalIndexOf(item1);\n                        if (index >= 0) {\n                            if (!bitHelper.isMarked(index)) {\n                                bitHelper.markBit(index);\n                                uniqueFoundCount = (uniqueFoundCount + 1) | 0;\n                            }\n                        } else {\n                            unfoundCount = (unfoundCount + 1) | 0;\n                            if (returnIfUnfound) {\n                                break;\n                            }\n                        }\n                    }\n                } finally {\n                    if (Bridge.is($t1, System.IDisposable)) {\n                        $t1.System$IDisposable$dispose();\n                    }\n                }result.uniqueCount = uniqueFoundCount;\n                result.unfoundCount = unfoundCount;\n                return result.$clone();\n            },\n            toArray: function () {\n                var newArray = System.Array.init(this.Count, function (){\n                    return Bridge.getDefaultValue(T);\n                }, T);\n                this.copyTo$1(newArray);\n                return newArray;\n            },\n            internalGetHashCode: function (item) {\n                if (item == null) {\n                    return 0;\n                }\n                return this._comparer[Bridge.geti(this._comparer, \"System$Collections$Generic$IEqualityComparer$1$\" + Bridge.getTypeAlias(T) + \"$getHashCode2\", \"System$Collections$Generic$IEqualityComparer$1$getHashCode2\")](item) & System.Collections.Generic.HashSet$1(T).Lower31BitMask;\n            }\n        }\n    }; });\n\n    // @source elementCount.js\n\n    Bridge.define(\"System.Collections.Generic.HashSet$1.ElementCount\", function (T) { return {\n        $kind: \"struct\",\n        statics: {\n            methods: {\n                getDefaultValue: function () { return new (System.Collections.Generic.HashSet$1.ElementCount(T))(); }\n            }\n        },\n        fields: {\n            uniqueCount: 0,\n            unfoundCount: 0\n        },\n        ctors: {\n            ctor: function () {\n                this.$initialize();\n            }\n        },\n        methods: {\n            getHashCode: function () {\n                var h = Bridge.addHash([4920463385, this.uniqueCount, this.unfoundCount]);\n                return h;\n            },\n            equals: function (o) {\n                if (!Bridge.is(o, System.Collections.Generic.HashSet$1.ElementCount(T))) {\n                    return false;\n                }\n                return Bridge.equals(this.uniqueCount, o.uniqueCount) && Bridge.equals(this.unfoundCount, o.unfoundCount);\n            },\n            $clone: function (to) {\n                var s = to || new (System.Collections.Generic.HashSet$1.ElementCount(T))();\n                s.uniqueCount = this.uniqueCount;\n                s.unfoundCount = this.unfoundCount;\n                return s;\n            }\n        }\n    }; });\n\n    // @source enumerator.js\n\n    Bridge.define(\"System.Collections.Generic.HashSet$1.Enumerator\", function (T) { return {\n        inherits: [System.Collections.Generic.IEnumerator$1(T)],\n        $kind: \"struct\",\n        statics: {\n            methods: {\n                getDefaultValue: function () { return new (System.Collections.Generic.HashSet$1.Enumerator(T))(); }\n            }\n        },\n        fields: {\n            _set: null,\n            _index: 0,\n            _version: 0,\n            _current: Bridge.getDefaultValue(T)\n        },\n        props: {\n            Current: {\n                get: function () {\n                    return this._current;\n                }\n            },\n            System$Collections$IEnumerator$Current: {\n                get: function () {\n                    if (this._index === 0 || this._index === ((this._set._lastIndex + 1) | 0)) {\n                        throw new System.InvalidOperationException(\"Enumeration has either not started or has already finished.\");\n                    }\n                    return this.Current;\n                }\n            }\n        },\n        alias: [\n            \"dispose\", \"System$IDisposable$dispose\",\n            \"moveNext\", \"System$Collections$IEnumerator$moveNext\",\n            \"Current\", [\"System$Collections$Generic$IEnumerator$1$\" + Bridge.getTypeAlias(T) + \"$Current$1\", \"System$Collections$Generic$IEnumerator$1$Current$1\"]\n        ],\n        ctors: {\n            $ctor1: function (set) {\n                this.$initialize();\n                this._set = set;\n                this._index = 0;\n                this._version = set._version;\n                this._current = Bridge.getDefaultValue(T);\n            },\n            ctor: function () {\n                this.$initialize();\n            }\n        },\n        methods: {\n            dispose: function () { },\n            moveNext: function () {\n                var $t, $t1;\n                if (this._version !== this._set._version) {\n                    throw new System.InvalidOperationException(\"Collection was modified; enumeration operation may not execute.\");\n                }\n                while (this._index < this._set._lastIndex) {\n                    if (($t = this._set._slots)[System.Array.index(this._index, $t)].hashCode >= 0) {\n                        this._current = ($t1 = this._set._slots)[System.Array.index(this._index, $t1)].value;\n                        this._index = (this._index + 1) | 0;\n                        return true;\n                    }\n                    this._index = (this._index + 1) | 0;\n                }\n                this._index = (this._set._lastIndex + 1) | 0;\n                this._current = Bridge.getDefaultValue(T);\n                return false;\n            },\n            System$Collections$IEnumerator$reset: function () {\n                if (this._version !== this._set._version) {\n                    throw new System.InvalidOperationException(\"Collection was modified; enumeration operation may not execute.\");\n                }\n                this._index = 0;\n                this._current = Bridge.getDefaultValue(T);\n            },\n            getHashCode: function () {\n                var h = Bridge.addHash([3788985113, this._set, this._index, this._version, this._current]);\n                return h;\n            },\n            equals: function (o) {\n                if (!Bridge.is(o, System.Collections.Generic.HashSet$1.Enumerator(T))) {\n                    return false;\n                }\n                return Bridge.equals(this._set, o._set) && Bridge.equals(this._index, o._index) && Bridge.equals(this._version, o._version) && Bridge.equals(this._current, o._current);\n            },\n            $clone: function (to) {\n                var s = to || new (System.Collections.Generic.HashSet$1.Enumerator(T))();\n                s._set = this._set;\n                s._index = this._index;\n                s._version = this._version;\n                s._current = this._current;\n                return s;\n            }\n        }\n    }; });\n\n    // @source slot.js\n\n    Bridge.define(\"System.Collections.Generic.HashSet$1.Slot\", function (T) { return {\n        $kind: \"struct\",\n        statics: {\n            methods: {\n                getDefaultValue: function () { return new (System.Collections.Generic.HashSet$1.Slot(T))(); }\n            }\n        },\n        fields: {\n            hashCode: 0,\n            value: Bridge.getDefaultValue(T),\n            next: 0\n        },\n        ctors: {\n            ctor: function () {\n                this.$initialize();\n            }\n        },\n        methods: {\n            getHashCode: function () {\n                var h = Bridge.addHash([1953459283, this.hashCode, this.value, this.next]);\n                return h;\n            },\n            equals: function (o) {\n                if (!Bridge.is(o, System.Collections.Generic.HashSet$1.Slot(T))) {\n                    return false;\n                }\n                return Bridge.equals(this.hashCode, o.hashCode) && Bridge.equals(this.value, o.value) && Bridge.equals(this.next, o.next);\n            },\n            $clone: function (to) {\n                var s = to || new (System.Collections.Generic.HashSet$1.Slot(T))();\n                s.hashCode = this.hashCode;\n                s.value = this.value;\n                s.next = this.next;\n                return s;\n            }\n        }\n    }; });\n\n    // @source queue.js\n\n    Bridge.define(\"System.Collections.Generic.Queue$1\", function (T) { return {\n        inherits: [System.Collections.Generic.IEnumerable$1(T),System.Collections.ICollection],\n        statics: {\n            fields: {\n                MinimumGrow: 0,\n                GrowFactor: 0,\n                DefaultCapacity: 0\n            },\n            ctors: {\n                init: function () {\n                    this.MinimumGrow = 4;\n                    this.GrowFactor = 200;\n                    this.DefaultCapacity = 4;\n                }\n            }\n        },\n        fields: {\n            _array: null,\n            _head: 0,\n            _tail: 0,\n            _size: 0,\n            _version: 0\n        },\n        props: {\n            Count: {\n                get: function () {\n                    return this._size;\n                }\n            },\n            IsReadOnly: {\n                get: function () {\n                    return false;\n                }\n            }\n        },\n        alias: [\n            \"Count\", \"System$Collections$ICollection$Count\",\n            \"copyTo\", \"System$Collections$ICollection$copyTo\",\n            \"System$Collections$Generic$IEnumerable$1$getEnumerator\", \"System$Collections$Generic$IEnumerable$1$\" + Bridge.getTypeAlias(T) + \"$getEnumerator\"\n        ],\n        ctors: {\n            ctor: function () {\n                this.$initialize();\n                this._array = System.Array.init(0, function (){\n                    return Bridge.getDefaultValue(T);\n                }, T);\n            },\n            $ctor2: function (capacity) {\n                this.$initialize();\n                if (capacity < 0) {\n                    throw new System.ArgumentOutOfRangeException(\"capacity\", \"Non-negative number required.\");\n                }\n                this._array = System.Array.init(capacity, function (){\n                    return Bridge.getDefaultValue(T);\n                }, T);\n            },\n            $ctor1: function (collection) {\n                this.$initialize();\n                if (collection == null) {\n                    throw new System.ArgumentNullException(\"collection\");\n                }\n\n                this._array = System.Array.init(System.Collections.Generic.Queue$1(T).DefaultCapacity, function (){\n                    return Bridge.getDefaultValue(T);\n                }, T);\n\n                var en = Bridge.getEnumerator(collection, T);\n                try {\n                    while (en.System$Collections$IEnumerator$moveNext()) {\n                        this.enqueue(en[Bridge.geti(en, \"System$Collections$Generic$IEnumerator$1$\" + Bridge.getTypeAlias(T) + \"$Current$1\", \"System$Collections$Generic$IEnumerator$1$Current$1\")]);\n                    }\n                }\n                finally {\n                    if (Bridge.hasValue(en)) {\n                        en.System$IDisposable$dispose();\n                    }\n                }\n            }\n        },\n        methods: {\n            copyTo: function (array, index) {\n                if (array == null) {\n                    throw new System.ArgumentNullException(\"array\");\n                }\n\n                if (System.Array.getRank(array) !== 1) {\n                    throw new System.ArgumentException(\"Only single dimensional arrays are supported for the requested action.\");\n                }\n\n                if (index < 0) {\n                    throw new System.ArgumentOutOfRangeException(\"index\");\n                }\n\n                var arrayLen = array.length;\n                if (((arrayLen - index) | 0) < this._size) {\n                    throw new System.ArgumentException(\"Offset and length were out of bounds for the array or count is greater than the number of elements from index to the end of the source collection.\");\n                }\n\n                var numToCopy = this._size;\n                if (numToCopy === 0) {\n                    return;\n                }\n\n                var firstPart = (((this._array.length - this._head) | 0) < numToCopy) ? ((this._array.length - this._head) | 0) : numToCopy;\n                System.Array.copy(this._array, this._head, array, index, firstPart);\n\n                numToCopy = (numToCopy - firstPart) | 0;\n                if (numToCopy > 0) {\n                    System.Array.copy(this._array, 0, array, ((((index + this._array.length) | 0) - this._head) | 0), numToCopy);\n                }\n            },\n            copyTo$1: function (array, arrayIndex) {\n                if (array == null) {\n                    throw new System.ArgumentNullException(\"array\");\n                }\n\n                if (arrayIndex < 0 || arrayIndex > array.length) {\n                    throw new System.ArgumentOutOfRangeException(\"arrayIndex\", \"Index was out of range. Must be non-negative and less than the size of the collection.\");\n                }\n\n                var arrayLen = array.length;\n                if (((arrayLen - arrayIndex) | 0) < this._size) {\n                    throw new System.ArgumentException(\"Offset and length were out of bounds for the array or count is greater than the number of elements from index to the end of the source collection.\");\n                }\n\n                var numToCopy = (((arrayLen - arrayIndex) | 0) < this._size) ? (((arrayLen - arrayIndex) | 0)) : this._size;\n                if (numToCopy === 0) {\n                    return;\n                }\n\n                var firstPart = (((this._array.length - this._head) | 0) < numToCopy) ? ((this._array.length - this._head) | 0) : numToCopy;\n                System.Array.copy(this._array, this._head, array, arrayIndex, firstPart);\n                numToCopy = (numToCopy - firstPart) | 0;\n                if (numToCopy > 0) {\n                    System.Array.copy(this._array, 0, array, ((((arrayIndex + this._array.length) | 0) - this._head) | 0), numToCopy);\n                }\n            },\n            clear: function () {\n                if (this._head < this._tail) {\n                    System.Array.fill(this._array, Bridge.getDefaultValue(T), this._head, this._size);\n                } else {\n                    System.Array.fill(this._array, Bridge.getDefaultValue(T), this._head, ((this._array.length - this._head) | 0));\n                    System.Array.fill(this._array, Bridge.getDefaultValue(T), 0, this._tail);\n                }\n\n                this._head = 0;\n                this._tail = 0;\n                this._size = 0;\n                this._version = (this._version + 1) | 0;\n            },\n            enqueue: function (item) {\n                if (this._size === this._array.length) {\n                    var newcapacity = (Bridge.Int.div(Bridge.Int.mul(this._array.length, System.Collections.Generic.Queue$1(T).GrowFactor), 100)) | 0;\n                    if (newcapacity < ((this._array.length + System.Collections.Generic.Queue$1(T).MinimumGrow) | 0)) {\n                        newcapacity = (this._array.length + System.Collections.Generic.Queue$1(T).MinimumGrow) | 0;\n                    }\n                    this.setCapacity(newcapacity);\n                }\n\n                this._array[System.Array.index(this._tail, this._array)] = item;\n                this._tail = this.moveNext(this._tail);\n                this._size = (this._size + 1) | 0;\n                this._version = (this._version + 1) | 0;\n            },\n            getEnumerator: function () {\n                return new (System.Collections.Generic.Queue$1.Enumerator(T)).$ctor1(this);\n            },\n            System$Collections$Generic$IEnumerable$1$getEnumerator: function () {\n                return new (System.Collections.Generic.Queue$1.Enumerator(T)).$ctor1(this).$clone();\n            },\n            System$Collections$IEnumerable$getEnumerator: function () {\n                return new (System.Collections.Generic.Queue$1.Enumerator(T)).$ctor1(this).$clone();\n            },\n            dequeue: function () {\n                if (this._size === 0) {\n                    throw new System.InvalidOperationException(\"Queue empty.\");\n                }\n\n                var removed = this._array[System.Array.index(this._head, this._array)];\n                this._array[System.Array.index(this._head, this._array)] = Bridge.getDefaultValue(T);\n                this._head = this.moveNext(this._head);\n                this._size = (this._size - 1) | 0;\n                this._version = (this._version + 1) | 0;\n                return removed;\n            },\n            peek: function () {\n                if (this._size === 0) {\n                    throw new System.InvalidOperationException(\"Queue empty.\");\n                }\n\n                return this._array[System.Array.index(this._head, this._array)];\n            },\n            contains: function (item) {\n                var index = this._head;\n                var count = this._size;\n\n                var c = System.Collections.Generic.EqualityComparer$1(T).def;\n                while (Bridge.identity(count, (count = (count - 1) | 0)) > 0) {\n                    if (item == null) {\n                        if (this._array[System.Array.index(index, this._array)] == null) {\n                            return true;\n                        }\n                    } else if (this._array[System.Array.index(index, this._array)] != null && c.equals2(this._array[System.Array.index(index, this._array)], item)) {\n                        return true;\n                    }\n                    index = this.moveNext(index);\n                }\n\n                return false;\n            },\n            getElement: function (i) {\n                return this._array[System.Array.index((((this._head + i) | 0)) % this._array.length, this._array)];\n            },\n            toArray: function () {\n                var arr = System.Array.init(this._size, function (){\n                    return Bridge.getDefaultValue(T);\n                }, T);\n                if (this._size === 0) {\n                    return arr;\n                } // consider replacing with Array.Empty<T>() to be consistent with non-generic Queue\n\n                if (this._head < this._tail) {\n                    System.Array.copy(this._array, this._head, arr, 0, this._size);\n                } else {\n                    System.Array.copy(this._array, this._head, arr, 0, ((this._array.length - this._head) | 0));\n                    System.Array.copy(this._array, 0, arr, ((this._array.length - this._head) | 0), this._tail);\n                }\n\n                return arr;\n            },\n            setCapacity: function (capacity) {\n                var newarray = System.Array.init(capacity, function (){\n                    return Bridge.getDefaultValue(T);\n                }, T);\n                if (this._size > 0) {\n                    if (this._head < this._tail) {\n                        System.Array.copy(this._array, this._head, newarray, 0, this._size);\n                    } else {\n                        System.Array.copy(this._array, this._head, newarray, 0, ((this._array.length - this._head) | 0));\n                        System.Array.copy(this._array, 0, newarray, ((this._array.length - this._head) | 0), this._tail);\n                    }\n                }\n\n                this._array = newarray;\n                this._head = 0;\n                this._tail = (this._size === capacity) ? 0 : this._size;\n                this._version = (this._version + 1) | 0;\n            },\n            moveNext: function (index) {\n                // It is tempting to use the remainder operator here but it is actually much slower\n                // than a simple comparison and a rarely taken branch.\n                var tmp = (index + 1) | 0;\n                return (tmp === this._array.length) ? 0 : tmp;\n            },\n            trimExcess: function () {\n                var threshold = Bridge.Int.clip32(this._array.length * 0.9);\n                if (this._size < threshold) {\n                    this.setCapacity(this._size);\n                }\n            }\n        }\n    }; });\n\n    // @source enumerator.js\n\n    Bridge.define(\"System.Collections.Generic.Queue$1.Enumerator\", function (T) { return {\n        inherits: [System.Collections.Generic.IEnumerator$1(T),System.Collections.IEnumerator],\n        $kind: \"struct\",\n        statics: {\n            methods: {\n                getDefaultValue: function () { return new (System.Collections.Generic.Queue$1.Enumerator(T))(); }\n            }\n        },\n        fields: {\n            _q: null,\n            _index: 0,\n            _version: 0,\n            _currentElement: Bridge.getDefaultValue(T)\n        },\n        props: {\n            Current: {\n                get: function () {\n                    if (this._index < 0) {\n                        if (this._index === -1) {\n                            throw new System.InvalidOperationException(\"Enumeration has not started. Call MoveNext.\");\n                        } else {\n                            throw new System.InvalidOperationException(\"Enumeration already finished.\");\n                        }\n                    }\n                    return this._currentElement;\n                }\n            },\n            System$Collections$IEnumerator$Current: {\n                get: function () {\n                    return this.Current;\n                }\n            }\n        },\n        alias: [\n            \"dispose\", \"System$IDisposable$dispose\",\n            \"moveNext\", \"System$Collections$IEnumerator$moveNext\",\n            \"Current\", [\"System$Collections$Generic$IEnumerator$1$\" + Bridge.getTypeAlias(T) + \"$Current$1\", \"System$Collections$Generic$IEnumerator$1$Current$1\"]\n        ],\n        ctors: {\n            $ctor1: function (q) {\n                this.$initialize();\n                this._q = q;\n                this._version = this._q._version;\n                this._index = -1;\n                this._currentElement = Bridge.getDefaultValue(T);\n            },\n            ctor: function () {\n                this.$initialize();\n            }\n        },\n        methods: {\n            dispose: function () {\n                this._index = -2;\n                this._currentElement = Bridge.getDefaultValue(T);\n            },\n            moveNext: function () {\n                if (this._version !== this._q._version) {\n                    throw new System.InvalidOperationException(\"Collection was modified; enumeration operation may not execute.\");\n                }\n\n                if (this._index === -2) {\n                    return false;\n                }\n\n                this._index = (this._index + 1) | 0;\n\n                if (this._index === this._q._size) {\n                    this._index = -2;\n                    this._currentElement = Bridge.getDefaultValue(T);\n                    return false;\n                }\n\n                this._currentElement = this._q.getElement(this._index);\n                return true;\n            },\n            System$Collections$IEnumerator$reset: function () {\n                if (this._version !== this._q._version) {\n                    throw new System.InvalidOperationException(\"Collection was modified; enumeration operation may not execute.\");\n                }\n                this._index = -1;\n                this._currentElement = Bridge.getDefaultValue(T);\n            },\n            getHashCode: function () {\n                var h = Bridge.addHash([3788985113, this._q, this._index, this._version, this._currentElement]);\n                return h;\n            },\n            equals: function (o) {\n                if (!Bridge.is(o, System.Collections.Generic.Queue$1.Enumerator(T))) {\n                    return false;\n                }\n                return Bridge.equals(this._q, o._q) && Bridge.equals(this._index, o._index) && Bridge.equals(this._version, o._version) && Bridge.equals(this._currentElement, o._currentElement);\n            },\n            $clone: function (to) {\n                var s = to || new (System.Collections.Generic.Queue$1.Enumerator(T))();\n                s._q = this._q;\n                s._index = this._index;\n                s._version = this._version;\n                s._currentElement = this._currentElement;\n                return s;\n            }\n        }\n    }; });\n\n    // @source stack.js\n\n    Bridge.define(\"System.Collections.Generic.Stack$1\", function (T) { return {\n        inherits: [System.Collections.Generic.IEnumerable$1(T),System.Collections.ICollection],\n        statics: {\n            fields: {\n                DefaultCapacity: 0\n            },\n            ctors: {\n                init: function () {\n                    this.DefaultCapacity = 4;\n                }\n            }\n        },\n        fields: {\n            _array: null,\n            _size: 0,\n            _version: 0\n        },\n        props: {\n            Count: {\n                get: function () {\n                    return this._size;\n                }\n            },\n            IsReadOnly: {\n                get: function () {\n                    return false;\n                }\n            }\n        },\n        alias: [\n            \"Count\", \"System$Collections$ICollection$Count\",\n            \"copyTo\", \"System$Collections$ICollection$copyTo\",\n            \"System$Collections$Generic$IEnumerable$1$getEnumerator\", \"System$Collections$Generic$IEnumerable$1$\" + Bridge.getTypeAlias(T) + \"$getEnumerator\"\n        ],\n        ctors: {\n            ctor: function () {\n                this.$initialize();\n                this._array = System.Array.init(0, function (){\n                    return Bridge.getDefaultValue(T);\n                }, T);\n            },\n            $ctor2: function (capacity) {\n                this.$initialize();\n                if (capacity < 0) {\n                    throw new System.ArgumentOutOfRangeException(\"capacity\", \"Non-negative number required.\");\n                }\n                this._array = System.Array.init(capacity, function (){\n                    return Bridge.getDefaultValue(T);\n                }, T);\n            },\n            $ctor1: function (collection) {\n                this.$initialize();\n                if (collection == null) {\n                    throw new System.ArgumentNullException(\"collection\");\n                }\n                var length = { };\n                this._array = Bridge.Collections.EnumerableHelpers.toArray$1(T, collection, length);\n                this._size = length.v;\n            }\n        },\n        methods: {\n            clear: function () {\n                System.Array.fill(this._array, Bridge.getDefaultValue(T), 0, this._size); // Don't need to doc this but we clear the elements so that the gc can reclaim the references.\n                this._size = 0;\n                this._version = (this._version + 1) | 0;\n            },\n            contains: function (item) {\n                var count = this._size;\n\n                var c = System.Collections.Generic.EqualityComparer$1(T).def;\n                while (Bridge.identity(count, (count = (count - 1) | 0)) > 0) {\n                    if (item == null) {\n                        if (this._array[System.Array.index(count, this._array)] == null) {\n                            return true;\n                        }\n                    } else if (this._array[System.Array.index(count, this._array)] != null && c.equals2(this._array[System.Array.index(count, this._array)], item)) {\n                        return true;\n                    }\n                }\n                return false;\n            },\n            copyTo$1: function (array, arrayIndex) {\n                if (array == null) {\n                    throw new System.ArgumentNullException(\"array\");\n                }\n\n                if (arrayIndex < 0 || arrayIndex > array.length) {\n                    throw new System.ArgumentOutOfRangeException(\"arrayIndex\", \"Non-negative number required.\");\n                }\n\n                if (((array.length - arrayIndex) | 0) < this._size) {\n                    throw new System.ArgumentException(\"Offset and length were out of bounds for the array or count is greater than the number of elements from index to the end of the source collection.\");\n                }\n\n                if (!Bridge.referenceEquals(array, this._array)) {\n                    var srcIndex = 0;\n                    var dstIndex = (arrayIndex + this._size) | 0;\n                    for (var i = 0; i < this._size; i = (i + 1) | 0) {\n                        array[System.Array.index(((dstIndex = (dstIndex - 1) | 0)), array)] = this._array[System.Array.index(Bridge.identity(srcIndex, (srcIndex = (srcIndex + 1) | 0)), this._array)];\n                    }\n                } else {\n                    // Legacy fallback in case we ever end up copying within the same array.\n                    System.Array.copy(this._array, 0, array, arrayIndex, this._size);\n                    System.Array.reverse(array, arrayIndex, this._size);\n                }\n            },\n            copyTo: function (array, arrayIndex) {\n                if (array == null) {\n                    throw new System.ArgumentNullException(\"array\");\n                }\n\n                if (System.Array.getRank(array) !== 1) {\n                    throw new System.ArgumentException(\"Only single dimensional arrays are supported for the requested action.\");\n                }\n\n                if (System.Array.getLower(array, 0) !== 0) {\n                    throw new System.ArgumentException(\"The lower bound of target array must be zero.\");\n                }\n\n                if (arrayIndex < 0 || arrayIndex > array.length) {\n                    throw new System.ArgumentOutOfRangeException(\"arrayIndex\", \"Non-negative number required.\");\n                }\n\n                if (((array.length - arrayIndex) | 0) < this._size) {\n                    throw new System.ArgumentException(\"Offset and length were out of bounds for the array or count is greater than the number of elements from index to the end of the source collection.\");\n                }\n\n                try {\n                    System.Array.copy(this._array, 0, array, arrayIndex, this._size);\n                    System.Array.reverse(array, arrayIndex, this._size);\n                }\n                catch ($e1) {\n                    $e1 = System.Exception.create($e1);\n                    throw new System.ArgumentException(\"Target array type is not compatible with the type of items in the collection.\");\n                }\n            },\n            getEnumerator: function () {\n                return new (System.Collections.Generic.Stack$1.Enumerator(T)).$ctor1(this);\n            },\n            System$Collections$Generic$IEnumerable$1$getEnumerator: function () {\n                return new (System.Collections.Generic.Stack$1.Enumerator(T)).$ctor1(this).$clone();\n            },\n            System$Collections$IEnumerable$getEnumerator: function () {\n                return new (System.Collections.Generic.Stack$1.Enumerator(T)).$ctor1(this).$clone();\n            },\n            trimExcess: function () {\n                var threshold = Bridge.Int.clip32(this._array.length * 0.9);\n                if (this._size < threshold) {\n                    var localArray = { v : this._array };\n                    System.Array.resize(localArray, this._size, Bridge.getDefaultValue(T));\n                    this._array = localArray.v;\n                    this._version = (this._version + 1) | 0;\n                }\n            },\n            peek: function () {\n                if (this._size === 0) {\n                    throw new System.InvalidOperationException(\"Stack empty.\");\n                }\n                return this._array[System.Array.index(((this._size - 1) | 0), this._array)];\n            },\n            pop: function () {\n                if (this._size === 0) {\n                    throw new System.InvalidOperationException(\"Stack empty.\");\n                }\n                this._version = (this._version + 1) | 0;\n                var item = this._array[System.Array.index(((this._size = (this._size - 1) | 0)), this._array)];\n                this._array[System.Array.index(this._size, this._array)] = Bridge.getDefaultValue(T); // Free memory quicker.\n                return item;\n            },\n            push: function (item) {\n                if (this._size === this._array.length) {\n                    var localArray = { v : this._array };\n                    System.Array.resize(localArray, (this._array.length === 0) ? System.Collections.Generic.Stack$1(T).DefaultCapacity : Bridge.Int.mul(2, this._array.length), Bridge.getDefaultValue(T));\n                    this._array = localArray.v;\n                }\n                this._array[System.Array.index(Bridge.identity(this._size, (this._size = (this._size + 1) | 0)), this._array)] = item;\n                this._version = (this._version + 1) | 0;\n            },\n            toArray: function () {\n                var objArray = System.Array.init(this._size, function (){\n                    return Bridge.getDefaultValue(T);\n                }, T);\n                var i = 0;\n                while (i < this._size) {\n                    objArray[System.Array.index(i, objArray)] = this._array[System.Array.index(((((this._size - i) | 0) - 1) | 0), this._array)];\n                    i = (i + 1) | 0;\n                }\n                return objArray;\n            }\n        }\n    }; });\n\n    // @source enumerator.js\n\n    Bridge.define(\"System.Collections.Generic.Stack$1.Enumerator\", function (T) { return {\n        inherits: [System.Collections.Generic.IEnumerator$1(T),System.Collections.IEnumerator],\n        $kind: \"struct\",\n        statics: {\n            methods: {\n                getDefaultValue: function () { return new (System.Collections.Generic.Stack$1.Enumerator(T))(); }\n            }\n        },\n        fields: {\n            _stack: null,\n            _index: 0,\n            _version: 0,\n            _currentElement: Bridge.getDefaultValue(T)\n        },\n        props: {\n            Current: {\n                get: function () {\n                    if (this._index === -2) {\n                        throw new System.InvalidOperationException(\"Enumeration has not started. Call MoveNext.\");\n                    }\n                    if (this._index === -1) {\n                        throw new System.InvalidOperationException(\"Enumeration already finished.\");\n                    }\n                    return this._currentElement;\n                }\n            },\n            System$Collections$IEnumerator$Current: {\n                get: function () {\n                    if (this._index === -2) {\n                        throw new System.InvalidOperationException(\"Enumeration has not started. Call MoveNext.\");\n                    }\n                    if (this._index === -1) {\n                        throw new System.InvalidOperationException(\"Enumeration already finished.\");\n                    }\n                    return this._currentElement;\n                }\n            }\n        },\n        alias: [\n            \"dispose\", \"System$IDisposable$dispose\",\n            \"moveNext\", \"System$Collections$IEnumerator$moveNext\",\n            \"Current\", [\"System$Collections$Generic$IEnumerator$1$\" + Bridge.getTypeAlias(T) + \"$Current$1\", \"System$Collections$Generic$IEnumerator$1$Current$1\"]\n        ],\n        ctors: {\n            $ctor1: function (stack) {\n                this.$initialize();\n                this._stack = stack;\n                this._version = this._stack._version;\n                this._index = -2;\n                this._currentElement = Bridge.getDefaultValue(T);\n            },\n            ctor: function () {\n                this.$initialize();\n            }\n        },\n        methods: {\n            dispose: function () {\n                this._index = -1;\n            },\n            moveNext: function () {\n                var $t, $t1;\n                var retval;\n                if (this._version !== this._stack._version) {\n                    throw new System.InvalidOperationException(\"Collection was modified; enumeration operation may not execute.\");\n                }\n                if (this._index === -2) { // First call to enumerator.\n                    this._index = (this._stack._size - 1) | 0;\n                    retval = (this._index >= 0);\n                    if (retval) {\n                        this._currentElement = ($t = this._stack._array)[System.Array.index(this._index, $t)];\n                    }\n                    return retval;\n                }\n                if (this._index === -1) { // End of enumeration.\n                    return false;\n                }\n\n                retval = (((this._index = (this._index - 1) | 0)) >= 0);\n                if (retval) {\n                    this._currentElement = ($t1 = this._stack._array)[System.Array.index(this._index, $t1)];\n                } else {\n                    this._currentElement = Bridge.getDefaultValue(T);\n                }\n                return retval;\n            },\n            System$Collections$IEnumerator$reset: function () {\n                if (this._version !== this._stack._version) {\n                    throw new System.InvalidOperationException(\"Collection was modified; enumeration operation may not execute.\");\n                }\n                this._index = -2;\n                this._currentElement = Bridge.getDefaultValue(T);\n            },\n            getHashCode: function () {\n                var h = Bridge.addHash([3788985113, this._stack, this._index, this._version, this._currentElement]);\n                return h;\n            },\n            equals: function (o) {\n                if (!Bridge.is(o, System.Collections.Generic.Stack$1.Enumerator(T))) {\n                    return false;\n                }\n                return Bridge.equals(this._stack, o._stack) && Bridge.equals(this._index, o._index) && Bridge.equals(this._version, o._version) && Bridge.equals(this._currentElement, o._currentElement);\n            },\n            $clone: function (to) {\n                var s = to || new (System.Collections.Generic.Stack$1.Enumerator(T))();\n                s._stack = this._stack;\n                s._index = this._index;\n                s._version = this._version;\n                s._currentElement = this._currentElement;\n                return s;\n            }\n        }\n    }; });\n\n    // @source hashHelpers.js\n\n    Bridge.define(\"System.Collections.HashHelpers\", {\n        statics: {\n            fields: {\n                HashPrime: 0,\n                primes: null,\n                MaxPrimeArrayLength: 0\n            },\n            ctors: {\n                init: function () {\n                    this.HashPrime = 101;\n                    this.primes = System.Array.init([\n                        3, \n                        7, \n                        11, \n                        17, \n                        23, \n                        29, \n                        37, \n                        47, \n                        59, \n                        71, \n                        89, \n                        107, \n                        131, \n                        163, \n                        197, \n                        239, \n                        293, \n                        353, \n                        431, \n                        521, \n                        631, \n                        761, \n                        919, \n                        1103, \n                        1327, \n                        1597, \n                        1931, \n                        2333, \n                        2801, \n                        3371, \n                        4049, \n                        4861, \n                        5839, \n                        7013, \n                        8419, \n                        10103, \n                        12143, \n                        14591, \n                        17519, \n                        21023, \n                        25229, \n                        30293, \n                        36353, \n                        43627, \n                        52361, \n                        62851, \n                        75431, \n                        90523, \n                        108631, \n                        130363, \n                        156437, \n                        187751, \n                        225307, \n                        270371, \n                        324449, \n                        389357, \n                        467237, \n                        560689, \n                        672827, \n                        807403, \n                        968897, \n                        1162687, \n                        1395263, \n                        1674319, \n                        2009191, \n                        2411033, \n                        2893249, \n                        3471899, \n                        4166287, \n                        4999559, \n                        5999471, \n                        7199369\n                    ], System.Int32);\n                    this.MaxPrimeArrayLength = 2146435069;\n                }\n            },\n            methods: {\n                isPrime: function (candidate) {\n                    if ((candidate & 1) !== 0) {\n                        var limit = Bridge.Int.clip32(Math.sqrt(candidate));\n                        for (var divisor = 3; divisor <= limit; divisor = (divisor + 2) | 0) {\n                            if ((candidate % divisor) === 0) {\n                                return false;\n                            }\n                        }\n                        return true;\n                    }\n                    return (candidate === 2);\n                },\n                getPrime: function (min) {\n                    if (min < 0) {\n                        throw new System.ArgumentException(\"Hashtable's capacity overflowed and went negative. Check load factor, capacity and the current size of the table.\");\n                    }\n                    for (var i = 0; i < System.Collections.HashHelpers.primes.length; i = (i + 1) | 0) {\n                        var prime = System.Collections.HashHelpers.primes[System.Array.index(i, System.Collections.HashHelpers.primes)];\n                        if (prime >= min) {\n                            return prime;\n                        }\n                    }\n                    for (var i1 = (min | 1); i1 < 2147483647; i1 = (i1 + 2) | 0) {\n                        if (System.Collections.HashHelpers.isPrime(i1) && ((((i1 - 1) | 0)) % System.Collections.HashHelpers.HashPrime !== 0)) {\n                            return i1;\n                        }\n                    }\n                    return min;\n                },\n                getMinPrime: function () {\n                    return System.Collections.HashHelpers.primes[System.Array.index(0, System.Collections.HashHelpers.primes)];\n                },\n                expandPrime: function (oldSize) {\n                    var newSize = Bridge.Int.mul(2, oldSize);\n                    if ((newSize >>> 0) > System.Collections.HashHelpers.MaxPrimeArrayLength && System.Collections.HashHelpers.MaxPrimeArrayLength > oldSize) {\n                        return System.Collections.HashHelpers.MaxPrimeArrayLength;\n                    }\n                    return System.Collections.HashHelpers.getPrime(newSize);\n                }\n            }\n        }\n    });\n\n    // @source End.js\n\n    // module export\n    if (typeof define === \"function\" && define.amd) {\n        // AMD\n        define(\"bridge\", [], function () { return Bridge; });\n    } else if (typeof module !== \"undefined\" && module.exports) {\n        // Node\n        module.exports = Bridge;\n    }\n\n    // @source Finally.js\n\n})(this);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/app/emu/bridge.js\n// module id = 1\n// module chunks = 0","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 2\n// module chunks = 0","function webpackEmptyContext(req) {\n\tthrow new Error(\"Cannot find module '\" + req + \"'.\");\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = 3;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/app/emu\n// module id = 3\n// module chunks = 0","/**\n * @version 1.0.0.0\n * @copyright Copyright ©  2017\n * @compiler Bridge.NET 16.3.2\n */\nBridge.assembly(\"ChiChiCore\", function ($asm, globals) {\n    \"use strict\";\n\n    Bridge.define(\"ChiChiNES.AddressingModes\", {\n        $kind: \"enum\",\n        statics: {\n            fields: {\n                Bullshit: 0,\n                Implicit: 1,\n                Accumulator: 2,\n                Immediate: 3,\n                ZeroPage: 4,\n                ZeroPageX: 5,\n                ZeroPageY: 6,\n                Relative: 7,\n                Absolute: 8,\n                AbsoluteX: 9,\n                AbsoluteY: 10,\n                Indirect: 11,\n                IndexedIndirect: 12,\n                IndirectIndexed: 13,\n                IndirectZeroPage: 14,\n                IndirectAbsoluteX: 15\n            }\n        }\n    });\n\n    Bridge.define(\"ChiChiNES.IClockedMemoryMappedIOElement\", {\n        $kind: \"interface\"\n    });\n\n    Bridge.define(\"ChiChiNES.BeepsBoops.Blip\", {\n        statics: {\n            fields: {\n                bass_shift: 0,\n                end_frame_extra: 0,\n                time_bits: 0,\n                half_width: 0,\n                phase_bits: 0,\n                delta_bits: 0,\n                buf_extra: 0,\n                phase_count: 0,\n                time_unit: 0,\n                bl_step: null\n            },\n            ctors: {\n                init: function () {\n                    this.bass_shift = 8;\n                    this.end_frame_extra = 2;\n                    this.time_bits = 21;\n                    this.half_width = 8;\n                    this.phase_bits = 5;\n                    this.delta_bits = 15;\n                    this.bl_step = System.Array.create(0, [[\n                        43, \n                        -115, \n                        350, \n                        -488, \n                        1136, \n                        -914, \n                        5861, \n                        21022\n                    ], [\n                        44, \n                        -118, \n                        348, \n                        -473, \n                        1076, \n                        -799, \n                        5274, \n                        21001\n                    ], [\n                        45, \n                        -121, \n                        344, \n                        -454, \n                        1011, \n                        -677, \n                        4706, \n                        20936\n                    ], [\n                        46, \n                        -122, \n                        336, \n                        -431, \n                        942, \n                        -549, \n                        4156, \n                        20829\n                    ], [\n                        47, \n                        -123, \n                        327, \n                        -404, \n                        868, \n                        -418, \n                        3629, \n                        20679\n                    ], [\n                        47, \n                        -122, \n                        316, \n                        -375, \n                        792, \n                        -285, \n                        3124, \n                        20488\n                    ], [\n                        47, \n                        -120, \n                        303, \n                        -344, \n                        714, \n                        -151, \n                        2644, \n                        20256\n                    ], [\n                        46, \n                        -117, \n                        289, \n                        -310, \n                        634, \n                        -17, \n                        2188, \n                        19985\n                    ], [\n                        46, \n                        -114, \n                        273, \n                        -275, \n                        553, \n                        117, \n                        1758, \n                        19675\n                    ], [\n                        44, \n                        -108, \n                        255, \n                        -237, \n                        471, \n                        247, \n                        1356, \n                        19327\n                    ], [\n                        43, \n                        -103, \n                        237, \n                        -199, \n                        390, \n                        373, \n                        981, \n                        18944\n                    ], [\n                        42, \n                        -98, \n                        218, \n                        -160, \n                        310, \n                        495, \n                        633, \n                        18527\n                    ], [\n                        40, \n                        -91, \n                        198, \n                        -121, \n                        231, \n                        611, \n                        314, \n                        18078\n                    ], [\n                        38, \n                        -84, \n                        178, \n                        -81, \n                        153, \n                        722, \n                        22, \n                        17599\n                    ], [\n                        36, \n                        -76, \n                        157, \n                        -43, \n                        80, \n                        824, \n                        -241, \n                        17092\n                    ], [\n                        34, \n                        -68, \n                        135, \n                        -3, \n                        8, \n                        919, \n                        -476, \n                        16558\n                    ], [\n                        32, \n                        -61, \n                        115, \n                        34, \n                        -60, \n                        1006, \n                        -683, \n                        16001\n                    ], [\n                        29, \n                        -52, \n                        94, \n                        70, \n                        -123, \n                        1083, \n                        -862, \n                        15422\n                    ], [\n                        27, \n                        -44, \n                        73, \n                        106, \n                        -184, \n                        1152, \n                        -1015, \n                        14824\n                    ], [\n                        25, \n                        -36, \n                        53, \n                        139, \n                        -239, \n                        1211, \n                        -1142, \n                        14210\n                    ], [\n                        22, \n                        -27, \n                        34, \n                        170, \n                        -290, \n                        1261, \n                        -1244, \n                        13582\n                    ], [\n                        20, \n                        -20, \n                        16, \n                        199, \n                        -335, \n                        1301, \n                        -1322, \n                        12942\n                    ], [\n                        18, \n                        -12, \n                        -3, \n                        226, \n                        -375, \n                        1331, \n                        -1376, \n                        12293\n                    ], [\n                        15, \n                        -4, \n                        -19, \n                        250, \n                        -410, \n                        1351, \n                        -1408, \n                        11638\n                    ], [\n                        13, \n                        3, \n                        -35, \n                        272, \n                        -439, \n                        1361, \n                        -1419, \n                        10979\n                    ], [\n                        11, \n                        9, \n                        -49, \n                        292, \n                        -464, \n                        1362, \n                        -1410, \n                        10319\n                    ], [\n                        9, \n                        16, \n                        -63, \n                        309, \n                        -483, \n                        1354, \n                        -1383, \n                        9660\n                    ], [\n                        7, \n                        22, \n                        -75, \n                        322, \n                        -496, \n                        1337, \n                        -1339, \n                        9005\n                    ], [\n                        6, \n                        26, \n                        -85, \n                        333, \n                        -504, \n                        1312, \n                        -1280, \n                        8355\n                    ], [\n                        4, \n                        31, \n                        -94, \n                        341, \n                        -507, \n                        1278, \n                        -1205, \n                        7713\n                    ], [\n                        3, \n                        35, \n                        -102, \n                        347, \n                        -506, \n                        1238, \n                        -1119, \n                        7082\n                    ], [\n                        1, \n                        40, \n                        -110, \n                        350, \n                        -499, \n                        1190, \n                        -1021, \n                        6464\n                    ], [\n                        0, \n                        43, \n                        -115, \n                        350, \n                        -488, \n                        1136, \n                        -914, \n                        5861\n                    ]], System.Int32, 33, 8);\n                },\n                ctor: function () {\n                    ChiChiNES.BeepsBoops.Blip.time_unit = 2097152;\n                    ChiChiNES.BeepsBoops.Blip.buf_extra = 18;\n                    ChiChiNES.BeepsBoops.Blip.phase_count = 32;\n                }\n            }\n        },\n        fields: {\n            _blipBuffer: null\n        },\n        props: {\n            BlipBuffer: {\n                get: function () {\n                    return this._blipBuffer;\n                },\n                set: function (value) {\n                    this._blipBuffer = value;\n                }\n            },\n            blip_samples_avail: {\n                get: function () {\n                    return this._blipBuffer.avail;\n                }\n            }\n        },\n        ctors: {\n            ctor: function (size) {\n                this.$initialize();\n                this.blip_new(size);\n            }\n        },\n        methods: {\n            blip_new: function (size) {\n                this._blipBuffer = new ChiChiNES.BeepsBoops.Blip.blip_buffer_t(size);\n                this._blipBuffer.size = size;\n                this._blipBuffer.factor = 0;\n                this.blip_clear();\n            },\n            blip_set_rates: function (clock_rate, sample_rate) {\n                this._blipBuffer.factor = Bridge.Int.clip32(ChiChiNES.BeepsBoops.Blip.time_unit / clock_rate * sample_rate + (0.9999847412109375));\n\n                /* Fails if clock_rate exceeds maximum, relative to sample_rate */\n                System.Diagnostics.Debug.assert(this._blipBuffer.factor > 0);\n            },\n            blip_clear: function () {\n                this._blipBuffer.offset = 0;\n                this._blipBuffer.avail = 0;\n                this._blipBuffer.integrator = 0;\n                this._blipBuffer.samples = System.Array.init(((this._blipBuffer.size + ChiChiNES.BeepsBoops.Blip.buf_extra) | 0), 0, System.Int32);\n                //memset(BLIP_SAMPLES(s), 0, (s.size + buf_extra) * sizeof(buf_t));\n            },\n            blip_clocks_needed: function (samples) {\n                var needed = (((Bridge.Int.mul(samples, ChiChiNES.BeepsBoops.Blip.time_unit) - this._blipBuffer.offset) | 0)) >>> 0;\n\n                /* Fails if buffer can't hold that many more samples */\n                //assert( s->avail + samples <= s->size );\n\n                return System.Int64.clip32((System.Int64(needed).add(System.Int64(this._blipBuffer.factor)).sub(System.Int64(1))).div(System.Int64(this._blipBuffer.factor)));\n\n            },\n            blip_end_frame: function (t) {\n                var off = (Bridge.Int.mul(t, this._blipBuffer.factor) + this._blipBuffer.offset) | 0;\n                this._blipBuffer.avail = (this._blipBuffer.avail + (off >> ChiChiNES.BeepsBoops.Blip.time_bits)) | 0;\n                this._blipBuffer.offset = off & (((ChiChiNES.BeepsBoops.Blip.time_unit - 1) | 0));\n\n                /* Fails if buffer size was exceeded */\n                //assert(s->avail <= s->size);\n            },\n            remove_samples: function (count) {\n                var remain = (((this._blipBuffer.avail + ChiChiNES.BeepsBoops.Blip.buf_extra) | 0) - count) | 0;\n                this._blipBuffer.avail = (this._blipBuffer.avail - count) | 0;\n\n                System.Array.copy(this._blipBuffer.samples, count, this._blipBuffer.samples, 0, remain);\n                System.Array.fill(this._blipBuffer.samples, 0, remain, count);\n\n                this._blipBuffer.arrayLength = count;\n            },\n            ReadBytes: function (outbuf, count, stereo) {\n                var $t;\n                if (count > this._blipBuffer.avail) {\n                    count = this._blipBuffer.avail;\n                }\n\n                if (count !== 0) {\n                    var step = 2;\n                    //int inPtr  = BLIP_SAMPLES( s );\n                    //buf_t const* end = in + count;\n                    var inPtr = 0, outPtr = 0;\n                    var endPtr = (inPtr + count) | 0;\n                    var sum = this._blipBuffer.integrator;\n\n                    do {\n                        var st = sum >> ChiChiNES.BeepsBoops.Blip.delta_bits; /* assumes right shift preserves sign */\n                        sum = (sum + ($t = this._blipBuffer.samples)[inPtr]) | 0;\n                        inPtr = (inPtr + 1) | 0;\n                        if (Bridge.Int.sxs(st & 65535) !== st) {\n                            st = (st >> 31) ^ 32767;\n                        }\n                        outbuf[outPtr] = st & 255;\n                        outbuf[((outPtr + 1) | 0)] = (st >> 8) & 255;\n                        outPtr = (outPtr + step) | 0;\n                        sum = (sum - (st << (7))) | 0;\n                    } while (inPtr !== endPtr);\n\n                    this._blipBuffer.integrator = sum;\n\n                    this.remove_samples(count);\n                }\n\n                return count;\n            },\n            blip_add_delta: function (time, delta) {\n                var $t, $t1, $t2, $t3, $t4, $t5;\n                if (delta === 0) {\n                    return;\n                }\n                var fixedTime = System.Int64(((Bridge.Int.mul(time, this._blipBuffer.factor) + this._blipBuffer.offset) | 0));\n\n                var outPtr = System.Int64.clip32(System.Int64(this._blipBuffer.avail).add((fixedTime.shr(ChiChiNES.BeepsBoops.Blip.time_bits))));\n\n                var phase_shift = 16;\n                var phase = System.Int64.clip32(fixedTime.shr(phase_shift).and(System.Int64((((ChiChiNES.BeepsBoops.Blip.phase_count - 1) | 0)))));\n\n                var inStep = phase; // bl_step[phase];\n                var rev = (ChiChiNES.BeepsBoops.Blip.phase_count - phase) | 0; // bl_step[phase_count - phase];\n\n                var interp_bits = 15;\n                var interp = System.Int64.clip32(fixedTime.shr((((phase_shift - interp_bits) | 0))).and(System.Int64(((((1 << interp_bits) - 1) | 0)))));\n                var delta2 = (Bridge.Int.mul(delta, interp)) >> interp_bits;\n                delta = (delta - delta2) | 0;\n\n                /* Fails if buffer size was exceeded */\n                //assert( out <= &BLIP_SAMPLES( s ) [s->size] );\n\n                for (var i = 0; i < 8; i = (i + 1) | 0) {\n                    ($t = this._blipBuffer.samples)[($t1 = ((outPtr + i) | 0))] = (($t2 = this._blipBuffer.samples)[$t1] + (((Bridge.Int.mul(ChiChiNES.BeepsBoops.Blip.bl_step.get([inStep, i]), delta) + Bridge.Int.mul(ChiChiNES.BeepsBoops.Blip.bl_step.get([((inStep + 1) | 0), i]), delta2)) | 0))) | 0;\n                    ($t3 = this._blipBuffer.samples)[($t4 = ((outPtr + (((15 - i) | 0))) | 0))] = (($t5 = this._blipBuffer.samples)[$t4] + (((Bridge.Int.mul(ChiChiNES.BeepsBoops.Blip.bl_step.get([rev, i]), delta) + Bridge.Int.mul(ChiChiNES.BeepsBoops.Blip.bl_step.get([((rev - 1) | 0), i]), delta2)) | 0))) | 0;\n                }\n\n            },\n            blip_add_delta_fast: function (time, delta) {\n                var $t, $t1, $t2, $t3, $t4, $t5;\n                var fixedTime = (Bridge.Int.mul(time, this._blipBuffer.factor) + this._blipBuffer.offset) | 0;\n\n                var outPtr = ((this._blipBuffer.avail + (fixedTime >> ChiChiNES.BeepsBoops.Blip.time_bits)) | 0);\n\n                var delta_unit = 32768;\n                var phase_shift = 6;\n                var phase = fixedTime >> phase_shift & (((delta_unit - 1) | 0));\n                var delta2 = Bridge.Int.mul(delta, phase);\n\n                /* Fails if buffer size was exceeded */\n                //assert( out <= &BLIP_SAMPLES( s ) [s->size] );\n\n\n                ($t = this._blipBuffer.samples)[($t1 = ((outPtr + 8) | 0))] = (($t2 = this._blipBuffer.samples)[$t1] + (((Bridge.Int.mul(delta, delta_unit) - delta2) | 0))) | 0;\n                ($t3 = this._blipBuffer.samples)[($t4 = ((outPtr + 9) | 0))] = (($t5 = this._blipBuffer.samples)[$t4] + delta2) | 0;\n                //out [8] += delta * delta_unit - delta2;\n                //out [9] += delta2;\n            }\n        }\n    });\n\n    Bridge.define(\"ChiChiNES.BeepsBoops.Blip.blip_buffer_t\", {\n        fields: {\n            factor: 0,\n            offset: 0,\n            avail: 0,\n            size: 0,\n            integrator: 0,\n            arrayLength: 0,\n            samples: null\n        },\n        ctors: {\n            ctor: function (size) {\n                this.$initialize();\n                this.samples = System.Array.init(size, 0, System.Int32);\n                this.arrayLength = size;\n\n            }\n        }\n    });\n\n    Bridge.define(\"ChiChiNES.BeepsBoops.IAPU\", {\n        $kind: \"interface\"\n    });\n\n    Bridge.define(\"ChiChiNES.BeepsBoops.DMCChannel\", {\n        fields: {\n            _chan: 0,\n            _bleeper: null,\n            LengthCounts: null,\n            _dutyCycle: 0,\n            _length: 0,\n            _timer: 0,\n            _rawTimer: 0,\n            _volume: 0,\n            _time: 0,\n            _envelope: 0,\n            _looping: false,\n            _enabled: false,\n            _amplitude: 0,\n            doodies: null,\n            _sweepShift: 0,\n            _sweepCounter: 0,\n            _sweepDivider: 0,\n            _sweepNegateFlag: false,\n            _sweepEnabled: false,\n            _startSweep: false,\n            _sweepInvalid: false,\n            _irqEnabled: false,\n            rate: 0,\n            dCounter: 0,\n            sampleAddress: 0,\n            _phase: 0,\n            _gain: 0,\n            _envTimer: 0,\n            _envStart: false,\n            _envConstantVolume: false,\n            _envVolume: 0,\n            _sweepComplement: false\n        },\n        props: {\n            Length: {\n                get: function () {\n                    return this._length;\n                },\n                set: function (value) {\n                    this._length = value;\n                }\n            },\n            /**\n             * Duty cycle of current square wave\n             *\n             * @instance\n             * @public\n             * @memberof ChiChiNES.BeepsBoops.DMCChannel\n             * @function DutyCycle\n             * @type number\n             */\n            DutyCycle: {\n                get: function () {\n                    return this._dutyCycle;\n                },\n                set: function (value) {\n                    this._dutyCycle = value;\n                }\n            },\n            /**\n             * Period of current waveform\n             *\n             * @instance\n             * @public\n             * @memberof ChiChiNES.BeepsBoops.DMCChannel\n             * @function Period\n             * @type number\n             */\n            Period: {\n                get: function () {\n                    return this._timer;\n                },\n                set: function (value) {\n                    this._timer = value;\n                }\n            },\n            /**\n             * Volume envelope for current waveform\n             *\n             * @instance\n             * @public\n             * @memberof ChiChiNES.BeepsBoops.DMCChannel\n             * @function Volume\n             * @type number\n             */\n            Volume: {\n                get: function () {\n                    return this._volume;\n                },\n                set: function (value) {\n                    this._volume = value;\n                }\n            },\n            /**\n             * current time in channel\n             *\n             * @instance\n             * @public\n             * @memberof ChiChiNES.BeepsBoops.DMCChannel\n             * @function Time\n             * @type number\n             */\n            Time: {\n                get: function () {\n                    return this._time;\n                },\n                set: function (value) {\n                    this._time = value;\n                }\n            },\n            Envelope: {\n                get: function () {\n                    return this._envelope;\n                },\n                set: function (value) {\n                    this._envelope = value;\n                }\n            },\n            Looping: {\n                get: function () {\n                    return this._looping;\n                },\n                set: function (value) {\n                    this._looping = value;\n                }\n            },\n            Enabled: {\n                get: function () {\n                    return this._enabled;\n                },\n                set: function (value) {\n                    this._enabled = value;\n                }\n            },\n            /**\n             * Master gain\n             *\n             * @instance\n             * @public\n             * @memberof ChiChiNES.BeepsBoops.DMCChannel\n             * @function Gain\n             * @type number\n             */\n            Gain: {\n                get: function () {\n                    return this._gain;\n                },\n                set: function (value) {\n                    this._gain = value;\n                }\n            },\n            /**\n             * True for ones complement, false for twos complement\n             *\n             * @instance\n             * @public\n             * @memberof ChiChiNES.BeepsBoops.DMCChannel\n             * @function SweepComplement\n             * @type boolean\n             */\n            SweepComplement: {\n                get: function () {\n                    return this._sweepComplement;\n                },\n                set: function (value) {\n                    this._sweepComplement = value;\n                }\n            }\n        },\n        ctors: {\n            init: function () {\n                this.LengthCounts = System.Array.init([10, 254, 20, 2, 40, 4, 80, 6, 160, 8, 60, 10, 14, 12, 26, 14, 12, 16, 24, 18, 48, 20, 96, 22, 192, 24, 72, 26, 16, 28, 32, 30], System.Byte);\n                this._enabled = true;\n                this.doodies = System.Array.init([2, 6, 30, 249], System.Byte);\n                this._sweepDivider = 1;\n                this._irqEnabled = false;\n                this._envTimer = 15;\n            },\n            ctor: function (bleeper, chan) {\n                this.$initialize();\n                this._bleeper = bleeper;\n                this._chan = chan;\n            }\n        },\n        methods: {\n            WriteRegister: function (register, data, time) {\n                // Run(time);\n\n                switch (register) {\n                    case 0: \n                        this._irqEnabled = (data & 128) === 128;\n                        this._looping = (data & 64) === 64;\n                        this.rate = data & 15;\n                        break;\n                    case 1: \n                        this.dCounter = data & 127;\n                        break;\n                    case 2: \n                        this.sampleAddress = (data << 6) | 49152;\n                        break;\n                    case 3: \n                        this._timer = data & 255;\n                        this._timer <<= 4;\n                        this._timer &= 1;\n                        break;\n                }\n            },\n            Run: function (end_time) {\n\n                for (; this._time < end_time; this._time++) {\n                    this.UpdateAmplitude((this._dutyCycle >> (this._phase & 7) & 1));\n                }\n                this._phase &= 7;\n            },\n            UpdateAmplitude: function (new_amp) {\n                var delta = new_amp * this._gain - this._amplitude;\n\n                this._amplitude += delta;\n                this._bleeper.blip_add_delta(this._time, delta);\n            },\n            EndFrame: function (time) {\n                this.Run(time);\n\n                this._time = 0;\n            },\n            FrameClock: function (time, step) {\n                this.Run(time);\n\n                if (!this._envStart) {\n                    this._envTimer--;\n                    if (this._envTimer === 0) {\n                        this._envTimer = this._volume + 1;\n                        if (this._envVolume > 0) {\n                            this._envVolume--;\n                        } else {\n                            this._envVolume = this._looping ? 15 : 0;\n                        }\n                    }\n                } else {\n                    this._envStart = false;\n                    this._envTimer = this._volume + 1;\n                    this._envVolume = 15;\n                }\n\n                switch (step) {\n                    case 1: \n                    case 3: \n                        --this._sweepCounter;\n                        if (this._sweepCounter === 0) {\n                            this._sweepCounter = this._sweepDivider + 1;\n                            if (this._sweepEnabled && this._sweepShift > 0) {\n                                var sweep = this._timer >> this._sweepShift;\n                                if (this._sweepComplement) {\n                                    this._timer += this._sweepNegateFlag ? ~sweep : sweep;\n                                } else {\n                                    this._timer += this._sweepNegateFlag ? ~sweep + 1 : sweep;\n                                }\n                                this._sweepInvalid = (this._rawTimer < 8 || (this._timer & 2048) === 2048);\n                                //if (_sweepInvalid)\n                                //{\n                                //    _sweepInvalid = true;\n                                //}\n                            }\n                        }\n                        if (this._startSweep) {\n                            this._startSweep = false;\n                            this._sweepCounter = this._sweepDivider + 1;\n\n                        }\n                        if (!this._looping && this._length > 0) {\n                            this._length--;\n                        }\n                        break;\n                }\n            }\n        }\n    });\n\n    Bridge.define(\"ChiChiNES.BeepsBoops.IWavReader\", {\n        $kind: \"interface\"\n    });\n\n    Bridge.define(\"ChiChiNES.BeepsBoops.IWavWriter\", {\n        inherits: [System.IDisposable],\n        $kind: \"interface\"\n    });\n\n    Bridge.define(\"ChiChiNES.BeepsBoops.NoiseChannel\", {\n        fields: {\n            _bleeper: null,\n            _chan: 0,\n            NoisePeriods: null,\n            LengthCounts: null,\n            _length: 0,\n            _period: 0,\n            _volume: 0,\n            _time: 0,\n            _envConstantVolume: false,\n            _envVolume: 0,\n            _looping: false,\n            _enabled: false,\n            amplitude: 0,\n            _phase: 0,\n            gain: 0,\n            _envTimer: 0,\n            _envStart: false\n        },\n        props: {\n            Length: {\n                get: function () {\n                    return this._length;\n                },\n                set: function (value) {\n                    this._length = value;\n                }\n            },\n            /**\n             * Period of current waveform\n             *\n             * @instance\n             * @public\n             * @memberof ChiChiNES.BeepsBoops.NoiseChannel\n             * @function Period\n             * @type number\n             */\n            Period: {\n                get: function () {\n                    return this._period;\n                },\n                set: function (value) {\n                    this._period = value;\n                }\n            },\n            /**\n             * Volume envelope for current waveform\n             *\n             * @instance\n             * @public\n             * @memberof ChiChiNES.BeepsBoops.NoiseChannel\n             * @function Volume\n             * @type number\n             */\n            Volume: {\n                get: function () {\n                    return this._volume;\n                },\n                set: function (value) {\n                    this._volume = value;\n                }\n            },\n            /**\n             * current time in channel\n             *\n             * @instance\n             * @public\n             * @memberof ChiChiNES.BeepsBoops.NoiseChannel\n             * @function Time\n             * @type number\n             */\n            Time: {\n                get: function () {\n                    return this._time;\n                },\n                set: function (value) {\n                    this._time = value;\n                }\n            },\n            Looping: {\n                get: function () {\n                    return this._looping;\n                },\n                set: function (value) {\n                    this._looping = value;\n                }\n            },\n            Enabled: {\n                get: function () {\n                    return this._enabled;\n                },\n                set: function (value) {\n                    this._enabled = value;\n                }\n            },\n            Gain: {\n                get: function () {\n                    return this.gain;\n                },\n                set: function (value) {\n                    this.gain = value;\n                }\n            }\n        },\n        ctors: {\n            init: function () {\n                this.NoisePeriods = System.Array.init([4, 8, 16, 32, 64, 96, 128, 160, 202, 254, 380, 508, 762, 1016, 2034, 4068], System.Int32);\n                this.LengthCounts = System.Array.init([10, 254, 20, 2, 40, 4, 80, 6, 160, 8, 60, 10, 14, 12, 26, 14, 12, 16, 24, 18, 48, 20, 96, 22, 192, 24, 72, 26, 16, 28, 32, 30], System.Byte);\n                this._enabled = true;\n                this._phase = 1;\n                this._envTimer = 15;\n            },\n            ctor: function (bleeper, chan) {\n                this.$initialize();\n                this._bleeper = bleeper;\n                this._chan = chan;\n            }\n        },\n        methods: {\n            WriteRegister: function (register, data, time) {\n                // Run(time);\n\n                switch (register) {\n                    case 0: \n                        this._envConstantVolume = (data & 16) === 16;\n                        this._volume = data & 15;\n                        this._looping = (data & 128) === 128;\n                        break;\n                    case 1: \n                        break;\n                    case 2: \n                        this._period = this.NoisePeriods[data & 15];\n                        // _period |= data;\n                        break;\n                    case 3: \n                        // setup length\n                        if (this._enabled) {\n                            this._length = this.LengthCounts[(data >> 3) & 31];\n                        }\n                        this._envStart = true;\n                        break;\n                    case 4: \n                        this._enabled = (data !== 0);\n                        if (!this._enabled) {\n                            this._length = 0;\n                        }\n                        break;\n                }\n            },\n            Run: function (end_time) {\n                var volume = this._envConstantVolume ? this._volume : this._envVolume;\n                if (this._length === 0) {\n                    volume = 0;\n                }\n                if (this._period === 0) {\n                    this._time = end_time;\n                    this.UpdateAmplitude(0);\n                    return;\n                }\n\n                if (this._phase === 0) {\n                    this._phase = 1;\n                }\n\n                for (; this._time < end_time; this._time += this._period) {\n                    var new15;\n                    if (this._looping) {\n                        new15 = ((this._phase & 1) ^ ((this._phase >> 6) & 1));\n                    } else {\n                        new15 = ((this._phase & 1) ^ ((this._phase >> 1) & 1));\n                    }\n                    this.UpdateAmplitude(this._phase & 1 * volume);\n                    this._phase = ((this._phase >> 1) | (new15 << 14)) & 65535;\n\n\n\n                }\n            },\n            UpdateAmplitude: function (amp) {\n                var delta = amp * this.gain - this.amplitude;\n                this.amplitude += delta;\n                this._bleeper.blip_add_delta(this._time, delta);\n            },\n            EndFrame: function (time) {\n                this.Run(time);\n                this._time = 0;\n            },\n            FrameClock: function (time, step) {\n                this.Run(time);\n\n                if (!this._envStart) {\n                    this._envTimer--;\n                    if (this._envTimer === 0) {\n                        this._envTimer = this._volume + 1;\n                        if (this._envVolume > 0) {\n                            this._envVolume--;\n                        } else {\n                            this._envVolume = this._looping ? 15 : 0;\n                        }\n\n                    }\n                } else {\n                    this._envStart = false;\n                    this._envTimer = this._volume + 1;\n                    this._envVolume = 15;\n                }\n\n                switch (step) {\n                    case 1: \n                    case 2: \n                        if (!!(!this._looping & this._length > 0)) {\n                            this._length--;\n                        }\n                        break;\n                }\n            }\n        }\n    });\n\n    Bridge.define(\"ChiChiNES.BeepsBoops.SoundStatusChangeEventArgs\", {\n        fields: {\n            muted: false\n        },\n        props: {\n            Muted: {\n                get: function () {\n                    return this.muted;\n                },\n                set: function (value) {\n                    this.muted = value;\n                }\n            }\n        }\n    });\n\n    Bridge.define(\"ChiChiNES.BeepsBoops.SquareChannel\", {\n        fields: {\n            _chan: 0,\n            _bleeper: null,\n            LengthCounts: null,\n            _dutyCycle: 0,\n            _length: 0,\n            _timer: 0,\n            _rawTimer: 0,\n            _volume: 0,\n            _time: 0,\n            _envelope: 0,\n            _looping: false,\n            _enabled: false,\n            _amplitude: 0,\n            doodies: null,\n            _sweepShift: 0,\n            _sweepCounter: 0,\n            _sweepDivider: 0,\n            _sweepNegateFlag: false,\n            _sweepEnabled: false,\n            _startSweep: false,\n            _sweepInvalid: false,\n            _phase: 0,\n            _gain: 0,\n            _envTimer: 0,\n            _envStart: false,\n            _envConstantVolume: false,\n            _envVolume: 0,\n            _sweepComplement: false\n        },\n        props: {\n            Length: {\n                get: function () {\n                    return this._length;\n                },\n                set: function (value) {\n                    this._length = value;\n                }\n            },\n            /**\n             * Duty cycle of current square wave\n             *\n             * @instance\n             * @public\n             * @memberof ChiChiNES.BeepsBoops.SquareChannel\n             * @function DutyCycle\n             * @type number\n             */\n            DutyCycle: {\n                get: function () {\n                    return this._dutyCycle;\n                },\n                set: function (value) {\n                    this._dutyCycle = value;\n                }\n            },\n            /**\n             * Period of current waveform\n             *\n             * @instance\n             * @public\n             * @memberof ChiChiNES.BeepsBoops.SquareChannel\n             * @function Period\n             * @type number\n             */\n            Period: {\n                get: function () {\n                    return this._timer;\n                },\n                set: function (value) {\n                    this._timer = value;\n                }\n            },\n            /**\n             * Volume envelope for current waveform\n             *\n             * @instance\n             * @public\n             * @memberof ChiChiNES.BeepsBoops.SquareChannel\n             * @function Volume\n             * @type number\n             */\n            Volume: {\n                get: function () {\n                    return this._volume;\n                },\n                set: function (value) {\n                    this._volume = value;\n                }\n            },\n            /**\n             * current time in channel\n             *\n             * @instance\n             * @public\n             * @memberof ChiChiNES.BeepsBoops.SquareChannel\n             * @function Time\n             * @type number\n             */\n            Time: {\n                get: function () {\n                    return this._time;\n                },\n                set: function (value) {\n                    this._time = value;\n                }\n            },\n            Envelope: {\n                get: function () {\n                    return this._envelope;\n                },\n                set: function (value) {\n                    this._envelope = value;\n                }\n            },\n            Looping: {\n                get: function () {\n                    return this._looping;\n                },\n                set: function (value) {\n                    this._looping = value;\n                }\n            },\n            Enabled: {\n                get: function () {\n                    return this._enabled;\n                },\n                set: function (value) {\n                    this._enabled = value;\n                }\n            },\n            /**\n             * Master gain\n             *\n             * @instance\n             * @public\n             * @memberof ChiChiNES.BeepsBoops.SquareChannel\n             * @function Gain\n             * @type number\n             */\n            Gain: {\n                get: function () {\n                    return this._gain;\n                },\n                set: function (value) {\n                    this._gain = value;\n                }\n            },\n            /**\n             * True for ones complement, false for twos complement\n             *\n             * @instance\n             * @public\n             * @memberof ChiChiNES.BeepsBoops.SquareChannel\n             * @function SweepComplement\n             * @type boolean\n             */\n            SweepComplement: {\n                get: function () {\n                    return this._sweepComplement;\n                },\n                set: function (value) {\n                    this._sweepComplement = value;\n                }\n            }\n        },\n        ctors: {\n            init: function () {\n                this.LengthCounts = System.Array.init([10, 254, 20, 2, 40, 4, 80, 6, 160, 8, 60, 10, 14, 12, 26, 14, 12, 16, 24, 18, 48, 20, 96, 22, 192, 24, 72, 26, 16, 28, 32, 30], System.Byte);\n                this._enabled = true;\n                this.doodies = System.Array.init([2, 6, 30, 249], System.Byte);\n                this._sweepDivider = 1;\n                this._envTimer = 15;\n            },\n            ctor: function (bleeper, chan) {\n                this.$initialize();\n                this._bleeper = bleeper;\n                this._chan = chan;\n            }\n        },\n        methods: {\n            WriteRegister: function (register, data, time) {\n                // Run(time);\n\n                switch (register) {\n                    case 0: \n                        this._envConstantVolume = (data & 16) === 16;\n                        this._volume = data & 15;\n                        this._dutyCycle = this.doodies[(data >> 6) & 3];\n                        this._looping = (data & 32) === 32;\n                        this._sweepInvalid = false;\n                        break;\n                    case 1: \n                        this._sweepShift = data & 7;\n                        this._sweepNegateFlag = (data & 8) === 8;\n                        this._sweepDivider = (data >> 4) & 7;\n                        this._sweepEnabled = (data & 128) === 128;\n                        this._startSweep = true;\n                        this._sweepInvalid = false;\n                        break;\n                    case 2: \n                        this._timer &= 1792;\n                        this._timer |= data;\n                        this._rawTimer = this._timer;\n                        break;\n                    case 3: \n                        this._timer &= 255;\n                        this._timer |= (data & 7) << 8;\n                        this._rawTimer = this._timer;\n                        this._phase = 0;\n                        // setup length\n                        if (this._enabled) {\n                            this._length = this.LengthCounts[(data >> 3) & 31];\n                        }\n                        this._envStart = true;\n                        break;\n                    case 4: \n                        this._enabled = (data !== 0);\n                        if (!this._enabled) {\n                            this._length = 0;\n                        }\n                        break;\n                }\n            },\n            Run: function (end_time) {\n                var period = this._sweepEnabled ? ((this._timer + 1) & 2047) << 1 : ((this._rawTimer + 1) & 2047) << 1;\n\n                if (period === 0) {\n                    this._time = end_time;\n                    this.UpdateAmplitude(0);\n                    return;\n                }\n\n                var volume = this._envConstantVolume ? this._volume : this._envVolume;\n\n\n                if (this._length === 0 || volume === 0 || this._sweepInvalid) {\n                    this._phase += ((end_time - this._time) / period) & 7;\n                    this._time = end_time;\n                    this.UpdateAmplitude(0);\n                    return;\n                }\n                for (; this._time < end_time; this._time += period, this._phase++) {\n                    this.UpdateAmplitude((this._dutyCycle >> (this._phase & 7) & 1) * volume);\n                }\n                this._phase &= 7;\n            },\n            UpdateAmplitude: function (new_amp) {\n                var delta = new_amp * this._gain - this._amplitude;\n\n                this._amplitude += delta;\n                this._bleeper.blip_add_delta(this._time, delta);\n            },\n            EndFrame: function (time) {\n                this.Run(time);\n\n                this._time = 0;\n            },\n            FrameClock: function (time, step) {\n                this.Run(time);\n\n                if (!this._envStart) {\n                    this._envTimer--;\n                    if (this._envTimer === 0) {\n                        this._envTimer = this._volume + 1;\n                        if (this._envVolume > 0) {\n                            this._envVolume--;\n                        } else {\n                            this._envVolume = this._looping ? 15 : 0;\n                        }\n                    }\n                } else {\n                    this._envStart = false;\n                    this._envTimer = this._volume + 1;\n                    this._envVolume = 15;\n                }\n\n                switch (step) {\n                    case 1: \n                    case 3: \n                        --this._sweepCounter;\n                        if (this._sweepCounter === 0) {\n                            this._sweepCounter = this._sweepDivider + 1;\n                            if (this._sweepEnabled && this._sweepShift > 0) {\n                                var sweep = this._timer >> this._sweepShift;\n                                if (this._sweepComplement) {\n                                    this._timer += this._sweepNegateFlag ? ~sweep : sweep;\n                                } else {\n                                    this._timer += this._sweepNegateFlag ? ~sweep + 1 : sweep;\n                                }\n                                this._sweepInvalid = (this._rawTimer < 8 || (this._timer & 2048) === 2048);\n                                //if (_sweepInvalid)\n                                //{\n                                //    _sweepInvalid = true;\n                                //}\n                            }\n                        }\n                        if (this._startSweep) {\n                            this._startSweep = false;\n                            this._sweepCounter = this._sweepDivider + 1;\n\n                        }\n                        if (!this._looping && this._length > 0) {\n                            this._length--;\n                        }\n                        break;\n                }\n            }\n        }\n    });\n\n    Bridge.define(\"ChiChiNES.BeepsBoops.TriangleChannel\", {\n        fields: {\n            _bleeper: null,\n            _chan: 0,\n            LengthCounts: null,\n            _length: 0,\n            _period: 0,\n            _time: 0,\n            _envelope: 0,\n            _looping: false,\n            _enabled: false,\n            _amplitude: 0,\n            _gain: 0,\n            _linCtr: 0,\n            _phase: 0,\n            _linVal: 0,\n            _linStart: false\n        },\n        props: {\n            Length: {\n                get: function () {\n                    return this._length;\n                },\n                set: function (value) {\n                    this._length = value;\n                }\n            },\n            /**\n             * Period of current waveform\n             *\n             * @instance\n             * @public\n             * @memberof ChiChiNES.BeepsBoops.TriangleChannel\n             * @function Period\n             * @type number\n             */\n            Period: {\n                get: function () {\n                    return this._period;\n                },\n                set: function (value) {\n                    this._period = value;\n                }\n            },\n            /**\n             * current time in channel\n             *\n             * @instance\n             * @public\n             * @memberof ChiChiNES.BeepsBoops.TriangleChannel\n             * @function Time\n             * @type number\n             */\n            Time: {\n                get: function () {\n                    return this._time;\n                },\n                set: function (value) {\n                    this._time = value;\n                }\n            },\n            Envelope: {\n                get: function () {\n                    return this._envelope;\n                },\n                set: function (value) {\n                    this._envelope = value;\n                }\n            },\n            Looping: {\n                get: function () {\n                    return this._looping;\n                },\n                set: function (value) {\n                    this._looping = value;\n                }\n            },\n            Enabled: {\n                get: function () {\n                    return this._enabled;\n                },\n                set: function (value) {\n                    this._enabled = value;\n                }\n            },\n            Amplitude: {\n                get: function () {\n                    return this._amplitude;\n                },\n                set: function (value) {\n                    this._amplitude = value;\n                }\n            },\n            Gain: {\n                get: function () {\n                    return this._gain;\n                },\n                set: function (value) {\n                    this._gain = value;\n                }\n            }\n        },\n        ctors: {\n            init: function () {\n                this.LengthCounts = System.Array.init([10, 254, 20, 2, 40, 4, 80, 6, 160, 8, 60, 10, 14, 12, 26, 14, 12, 16, 24, 18, 48, 20, 96, 22, 192, 24, 72, 26, 16, 28, 32, 30], System.Int32);\n                this._enabled = true;\n            },\n            ctor: function (bleeper, chan) {\n                this.$initialize();\n                this._bleeper = bleeper;\n                this._chan = chan;\n            }\n        },\n        methods: {\n            WriteRegister: function (register, data, time) {\n                //Run(time);\n\n                switch (register) {\n                    case 0: \n                        this._looping = (data & 128) === 128;\n                        this._linVal = data & 127;\n                        break;\n                    case 1: \n                        break;\n                    case 2: \n                        this._period &= 1792;\n                        this._period |= data;\n                        break;\n                    case 3: \n                        this._period &= 255;\n                        this._period |= (data & 7) << 8;\n                        // setup lengthhave\n                        if (this._enabled) {\n                            this._length = this.LengthCounts[(data >> 3) & 31];\n                        }\n                        this._linStart = true;\n                        break;\n                    case 4: \n                        this._enabled = (data !== 0);\n                        if (!this._enabled) {\n                            this._length = 0;\n                        }\n                        break;\n                }\n            },\n            Run: function (end_time) {\n\n                var period = this._period + 1;\n                if (this._linCtr === 0 || this._length === 0 || this._period < 4) {\n                    // leave it at it's current phase\n                    this._time = end_time;\n                    return;\n                }\n\n                for (; this._time < end_time; this._time += period, this._phase = (this._phase + 1) % 32) {\n                    this.UpdateAmplitude(this._phase < 16 ? this._phase : 31 - this._phase);\n                }\n            },\n            UpdateAmplitude: function (new_amp) {\n                var delta = new_amp * this._gain - this._amplitude;\n                this._amplitude += delta;\n                this._bleeper.blip_add_delta(this._time, delta);\n            },\n            EndFrame: function (time) {\n                this.Run(time);\n                this._time = 0;\n            },\n            FrameClock: function (time, step) {\n                this.Run(time);\n\n                if (this._linStart) {\n                    this._linCtr = this._linVal;\n\n                } else {\n                    if (this._linCtr > 0) {\n                        this._linCtr--;\n                    }\n                }\n\n                if (!this._looping) {\n                    this._linStart = false;\n                }\n\n                switch (step) {\n                    case 1: \n                    case 3: \n                        if (this._length > 0 && !this._looping) {\n                            this._length--;\n                        }\n                        break;\n                }\n            }\n        }\n    });\n\n    Bridge.define(\"ChiChiNES.CartDebugEvent\", {\n        fields: {\n            clock: 0,\n            eventType: null\n        },\n        props: {\n            Clock: {\n                get: function () {\n                    return this.clock;\n                },\n                set: function (value) {\n                    this.clock = value;\n                }\n            },\n            EventType: {\n                get: function () {\n                    return this.eventType;\n                },\n                set: function (value) {\n                    this.eventType = value;\n                }\n            }\n        },\n        methods: {\n            toString: function () {\n                return System.String.format(\"{0}: {1}\", this.clock, this.eventType);\n            }\n        }\n    });\n\n    Bridge.define(\"ChiChiNES.ClockedRequestEventArgs\", {\n        props: {\n            Clock: 0\n        }\n    });\n\n    Bridge.define(\"ChiChiNES.ControlByteEventArgs\", {\n        fields: {\n            nextValue: 0\n        },\n        props: {\n            NextValue: {\n                get: function () {\n                    return this.nextValue;\n                },\n                set: function (value) {\n                    this.nextValue = value;\n                }\n            }\n        },\n        ctors: {\n            ctor: function (value) {\n                this.$initialize();\n                this.nextValue = value;\n            }\n        }\n    });\n\n    Bridge.define(\"ChiChiNES.CPU2A03\", {\n        statics: {\n            fields: {\n                cpuTiming: null\n            },\n            ctors: {\n                init: function () {\n                    this.cpuTiming = System.Array.init([7, 6, 0, 0, 3, 2, 5, 0, 3, 2, 2, 0, 6, 4, 6, 0, 2, 5, 0, 0, 3, 3, 6, 0, 2, 4, 2, 0, 6, 4, 7, 0, 6, 6, 0, 0, 3, 2, 5, 0, 3, 2, 2, 0, 4, 4, 6, 0, 2, 5, 0, 0, 3, 3, 6, 0, 2, 4, 2, 0, 6, 4, 7, 0, 6, 6, 0, 0, 3, 2, 5, 0, 3, 2, 2, 0, 3, 4, 6, 0, 2, 5, 0, 0, 0, 3, 6, 0, 2, 4, 2, 0, 6, 4, 6, 0, 6, 6, 0, 0, 3, 3, 5, 0, 3, 2, 2, 0, 5, 4, 6, 0, 2, 5, 0, 0, 0, 4, 6, 0, 2, 4, 2, 0, 6, 4, 7, 0, 3, 6, 3, 0, 3, 3, 3, 0, 2, 3, 2, 0, 4, 4, 4, 0, 2, 6, 0, 0, 4, 4, 4, 0, 2, 5, 2, 0, 0, 5, 0, 0, 2, 6, 2, 0, 3, 3, 3, 0, 2, 2, 2, 0, 4, 4, 4, 0, 2, 5, 0, 0, 4, 4, 4, 0, 2, 4, 2, 0, 4, 4, 4, 0, 2, 6, 3, 0, 3, 2, 5, 0, 2, 2, 2, 0, 4, 4, 6, 0, 2, 5, 0, 0, 3, 4, 6, 0, 2, 4, 2, 0, 6, 4, 7, 0, 2, 6, 3, 0, 3, 3, 5, 0, 2, 2, 2, 0, 4, 4, 6, 0, 2, 5, 0, 0, 3, 4, 6, 0, 2, 4, 2, 0, 6, 4, 7, 0], System.Int32);\n                }\n            }\n        },\n        fields: {\n            _ticks: 0,\n            _operationCounter: 0,\n            _accumulator: 0,\n            _indexRegisterX: 0,\n            _indexRegisterY: 0,\n            _programCounter: 0,\n            _statusRegister: 0,\n            _addressBus: 0,\n            _reset: false,\n            _currentInstruction_AddressingMode: 0,\n            _currentInstruction_Address: 0,\n            _currentInstruction_OpCode: 0,\n            _currentInstruction_Parameters0: 0,\n            _currentInstruction_Parameters1: 0,\n            _currentInstruction_ExtraTiming: 0,\n            clock: 0,\n            systemClock: System.UInt64(0),\n            _handleNMI: false,\n            _handleIRQ: false,\n            nextEvent: 0,\n            runningHard: false,\n            clockcount: null,\n            instruction: null,\n            addressmode: null,\n            memoryPatches: null,\n            genieCodes: null,\n            _cheating: false,\n            lowByte: 0,\n            highByte: 0,\n            Rams: null,\n            _pixelWhizzler: null,\n            _cart: null,\n            _padOne: null,\n            _padTwo: null,\n            soundBopper: null,\n            nmiHandler: null,\n            irqUpdater: null,\n            _stackPointer: 0,\n            instructionUsage: null,\n            _debugging: false,\n            instructionHistoryPointer: 0,\n            _instructionHistory: null\n        },\n        events: {\n            DebugEvent: null\n        },\n        props: {\n            Accumulator: {\n                get: function () {\n                    return this._accumulator;\n                },\n                set: function (value) {\n                    this._accumulator = value;\n                }\n            },\n            IndexRegisterY: {\n                get: function () {\n                    return this._indexRegisterY;\n                },\n                set: function (value) {\n                    this._indexRegisterY = value;\n                }\n            },\n            IndexRegisterX: {\n                get: function () {\n                    return this._indexRegisterX;\n                },\n                set: function (value) {\n                    this._indexRegisterX = value;\n                }\n            },\n            ProgramCounter: {\n                get: function () {\n                    return this._programCounter;\n                },\n                set: function (value) {\n                    this._programCounter = value;\n                }\n            },\n            StatusRegister: {\n                get: function () {\n                    return this._statusRegister;\n                },\n                set: function (value) {\n                    this._statusRegister = value;\n                }\n            },\n            AddressCodePage: {\n                get: function () {\n                    var retval = this.AddressBus >> 8;\n                    return retval;\n                }\n            },\n            AddressLowByte: {\n                get: function () {\n                    return this.AddressBus & 255;\n                }\n            },\n            AddressBus: {\n                get: function () {\n                    return this._addressBus;\n                },\n                set: function (value) {\n                    this._addressBus = value;\n                }\n            },\n            DataBus: 0,\n            MemoryLock: false,\n            ReadWrite: false,\n            Ready: false,\n            Reset: {\n                get: function () {\n                    return this._reset;\n                },\n                set: function (value) {\n                    this._reset = value;\n                    if (this._reset) {\n                        this.ResetCPU();\n                    }\n                }\n            },\n            /**\n             * read only access to the current instruction pointed to by the program counter\n             *\n             * @instance\n             * @public\n             * @readonly\n             * @memberof ChiChiNES.CPU2A03\n             * @function CurrentInstruction\n             * @type ChiChiNES.CPU2A03.Instruction\n             */\n            CurrentInstruction: {\n                get: function () {\n                    return new ChiChiNES.CPU2A03.Instruction.ctor();\n                }\n            },\n            OperationCounter: {\n                get: function () {\n                    return this._operationCounter;\n                }\n            },\n            Clock: {\n                get: function () {\n                    return this.clock;\n                },\n                set: function (value) {\n                    if (value === 0) {\n                        this.systemClock = this.systemClock.add(Bridge.Int.clipu64(this.clock));\n                        this.clock = value;\n                    }\n                }\n            },\n            RunningHard: {\n                get: function () {\n                    return this.runningHard;\n                },\n                set: function (value) {\n                    this.runningHard = value;\n                }\n            },\n            /**\n             * number of full clock ticks elapsed since emulation started\n             *\n             * @instance\n             * @public\n             * @memberof ChiChiNES.CPU2A03\n             * @function Ticks\n             * @type number\n             */\n            Ticks: {\n                get: function () {\n                    return this._ticks;\n                },\n                set: function (value) {\n                    if (value === 2147483647) {\n                        this._ticks = 0;\n                    } else {\n                        this._ticks = value;\n                    }\n                }\n            },\n            MemoryPatches: {\n                get: function () {\n                    return this.memoryPatches;\n                },\n                set: function (value) {\n                    this.memoryPatches = value;\n                }\n            },\n            GenieCodes: {\n                get: function () {\n                    return this.genieCodes;\n                },\n                set: function (value) {\n                    this.genieCodes = value;\n                }\n            },\n            Cheating: {\n                get: function () {\n                    return this._cheating;\n                },\n                set: function (value) {\n                    this._cheating = value;\n                }\n            },\n            SoundBopper: {\n                get: function () {\n                    return this.soundBopper;\n                },\n                set: function (value) {\n                    this.soundBopper = value;\n                    this.soundBopper.ChiChiNES$IClockedMemoryMappedIOElement$NMIHandler = this.irqUpdater;\n                }\n            },\n            PadOne: {\n                get: function () {\n                    return this._padOne;\n                },\n                set: function (value) {\n                    this._padOne = value;\n                }\n            },\n            PadTwo: {\n                get: function () {\n                    return this._padTwo;\n                },\n                set: function (value) {\n                    this._padTwo = value;\n                }\n            },\n            Cart: {\n                get: function () {\n                    return this._cart;\n                },\n                set: function (value) {\n                    this._cart = value;\n                    this._cart.ChiChiNES$IClockedMemoryMappedIOElement$NMIHandler = this.irqUpdater;\n                }\n            },\n            PixelWhizzler: {\n                get: function () {\n                    return this._pixelWhizzler;\n                },\n                set: function (value) {\n                    this._pixelWhizzler = value;\n                    this._pixelWhizzler.ChiChiNES$IPPU$NMIHandler = this.nmiHandler;\n                }\n            },\n            StackPointer: {\n                get: function () {\n                    return this._stackPointer;\n                }\n            },\n            Debugging: {\n                get: function () {\n                    return this._debugging;\n                },\n                set: function (value) {\n                    this._debugging = value;\n                }\n            },\n            InstructionUsage: {\n                get: function () {\n                    return this.instructionUsage;\n                }\n            },\n            InstructionHistoryPointer: {\n                get: function () {\n                    return this.instructionHistoryPointer;\n                }\n            },\n            InstructionHistory: {\n                get: function () {\n                    return this._instructionHistory;\n                }\n            }\n        },\n        ctors: {\n            init: function () {\n                this._ticks = 0;\n                this._operationCounter = 0;\n                this._accumulator = 0;\n                this._indexRegisterX = 0;\n                this._indexRegisterY = 0;\n                this._reset = false;\n                this._currentInstruction_AddressingMode = ChiChiNES.AddressingModes.Bullshit;\n                this._currentInstruction_Address = 0;\n                this._currentInstruction_OpCode = 0;\n                this._currentInstruction_Parameters0 = 0;\n                this._currentInstruction_Parameters1 = 0;\n                this._currentInstruction_ExtraTiming = 0;\n                this.systemClock = System.UInt64(0);\n                this.nextEvent = -1;\n                this.clockcount = System.Array.init(256, 0, System.Int32);\n                this.instruction = System.Array.init(256, 0, System.Int32);\n                this.addressmode = System.Array.init(256, 0, ChiChiNES.AddressingModes);\n                this.memoryPatches = new (System.Collections.Generic.Dictionary$2(System.Int32,ChiChiNES.Hacking.IMemoryPatch))();\n                this.genieCodes = new (System.Collections.Generic.Dictionary$2(System.Int32,System.Int32))();\n                this._cheating = false;\n                this.Rams = System.Array.init(8192, 0, System.Byte);\n                this._stackPointer = 255;\n                this.instructionUsage = System.Array.init(256, 0, System.Int32);\n                this._debugging = false;\n                this.instructionHistoryPointer = 255;\n                this._instructionHistory = System.Array.init(256, null, ChiChiNES.CPU2A03.Instruction);\n            },\n            ctor: function (whizzler, bopper) {\n                this.$initialize();\n                // BuildOpArray();\n\n                this._padOne = new ChiChiNES.InputHandler.ctor();\n                this._padTwo = new ChiChiNES.InputHandler.ctor();\n                this._pixelWhizzler = whizzler;\n\n                this.SoundBopper = bopper;\n                this.nmiHandler = Bridge.fn.cacheBind(this, this.NMIHandler);\n                this.irqUpdater = Bridge.fn.cacheBind(this, this.IRQUpdater);\n                bopper.NMIHandler = Bridge.fn.cacheBind(this, this.IRQUpdater);\n\n                this._pixelWhizzler.ChiChiNES$IPPU$NMIHandler = this.nmiHandler;\n            }\n        },\n        methods: {\n            getSRMask: function (flag) {\n                switch (flag) {\n                    case ChiChiNES.CPUStatusBits.Carry: \n                        return 1;\n                    case ChiChiNES.CPUStatusBits.ZeroResult: \n                        return 2;\n                    case ChiChiNES.CPUStatusBits.InterruptDisable: \n                        return 4;\n                    case ChiChiNES.CPUStatusBits.DecimalMode: \n                        return 8;\n                    case ChiChiNES.CPUStatusBits.BreakCommand: \n                        return 16;\n                    case ChiChiNES.CPUStatusBits.Expansion: \n                        return 32;\n                    case ChiChiNES.CPUStatusBits.Overflow: \n                        return 64;\n                    case ChiChiNES.CPUStatusBits.NegativeResult: \n                        return 128;\n                }\n                return 0;\n            },\n            SetFlag: function (Flag, value) {\n                this._statusRegister = (value ? (this._statusRegister | Flag) : (this._statusRegister & ~Flag));\n\n                this._statusRegister = this._statusRegister | (ChiChiNES.CPUStatusMasks.ExpansionMask);\n            },\n            GetFlag: function (Flag) {\n                var flag = Flag;\n                return ((this._statusRegister & flag) === flag);\n            },\n            InterruptRequest: function () {\n\n                //When an IRQ or NMI occurs, the current status with bit 4 clear and bit 5 \n                //  set is pushed on the stack, then the I flag is set. \n                if (this.GetFlag(ChiChiNES.CPUStatusMasks.InterruptDisableMask)) {\n                    return;\n                }\n                this.SetFlag(ChiChiNES.CPUStatusMasks.InterruptDisableMask, true);\n\n                var newStatusReg = this._statusRegister & -17 | 32;\n\n                // if enabled\n\n                // push pc onto stack (high byte first)\n                this.PushStack(((Bridge.Int.div(this.ProgramCounter, 256)) | 0));\n                this.PushStack(this.ProgramCounter);\n                // push sr onto stack\n                this.PushStack(this.StatusRegister);\n\n                // point pc to interrupt service routine\n\n                this.ProgramCounter = (this.GetByte$1(65534) + (this.GetByte$1(65535) << 8)) | 0;\n\n                // nonOpCodeticks = 7;\n            },\n            NonMaskableInterrupt: function () {\n\n                //When an IRQ or NMI occurs, the current status with bit 4 clear and bit 5 \n                //  set is pushed on the stack, then the I flag is set. \n                var newStatusReg = this._statusRegister & -17 | 32;\n\n                this.SetFlag(ChiChiNES.CPUStatusMasks.InterruptDisableMask, true);\n                // push pc onto stack (high byte first)\n                this.PushStack(this._programCounter >> 8);\n                this.PushStack(this._programCounter & 255);\n                //c7ab\n                // push sr onto stack\n                this.PushStack(newStatusReg);\n                // point pc to interrupt service routine\n                var lowByte = (this.GetByte$1(65530)) & 255;\n                var highByte = (this.GetByte$1(65531)) & 255;\n                var jumpTo = lowByte | (highByte << 8);\n                this.ProgramCounter = jumpTo;\n                //nonOpCodeticks = 7;\n            },\n            CheckEvent: function () {\n                if (this.nextEvent === -1) {\n                    this.FindNextEvent();\n                }\n            },\n            RunFast: function () {\n                while (this.clock < 29780) {\n                    this.Step();\n                }\n            },\n            Step: function () {\n                // int tickCount = 0;\n                this._currentInstruction_ExtraTiming = 0;\n\n                //_pixelWhizzler.DrawTo(clock);\n                if (this.nextEvent <= this.clock) {\n                    this.HandleNextEvent();\n                }\n\n                if (this._handleNMI) {\n                    this._handleNMI = false;\n                    this.clock = (this.clock + 7) | 0;\n                    //NonMaskableInterrupt();\n\n                    //When an IRQ or NMI occurs, the current status with bit 4 clear and bit 5 \n                    //  set is pushed on the stack, then the I flag is set. \n                    var newStatusReg = this._statusRegister & -17 | 32;\n\n                    this.SetFlag(ChiChiNES.CPUStatusMasks.InterruptDisableMask, true);\n                    // push pc onto stack (high byte first)\n                    this.PushStack(this._programCounter >> 8);\n                    this.PushStack(this._programCounter & 255);\n                    //c7ab\n                    // push sr onto stack\n                    this.PushStack(newStatusReg);\n                    // point pc to interrupt service routine\n                    var lowByte = (this.GetByte$1(65530)) & 255;\n                    var highByte = (this.GetByte$1(65531)) & 255;\n                    var jumpTo = lowByte | (highByte << 8);\n                    this.ProgramCounter = jumpTo;\n                    //nonOpCodeticks = 7;\n                } else if (this._handleIRQ) {\n                    this._handleIRQ = false;\n                    this.clock = (this.clock + 7) | 0;\n                    //InterruptRequest();\n                    //When an IRQ or NMI occurs, the current status with bit 4 clear and bit 5 \n                    //  set is pushed on the stack, then the I flag is set. \n                    if (this.GetFlag(ChiChiNES.CPUStatusMasks.InterruptDisableMask)) {\n                        return;\n                    }\n                    this.SetFlag(ChiChiNES.CPUStatusMasks.InterruptDisableMask, true);\n\n                    var newStatusReg1 = this._statusRegister & -17 | 32;\n\n                    // if enabled\n\n                    // push pc onto stack (high byte first)\n                    this.PushStack(((Bridge.Int.div(this.ProgramCounter, 256)) | 0));\n                    this.PushStack(this.ProgramCounter);\n                    // push sr onto stack\n                    this.PushStack(this.StatusRegister);\n\n                    // point pc to interrupt service routine\n\n                    this.ProgramCounter = (this.GetByte$1(65534) + (this.GetByte$1(65535) << 8)) | 0;\n\n                    // nonOpCodeticks = 7;\n\n                }\n\n                //FetchNextInstruction();\n                this._currentInstruction_Address = this._programCounter;\n                this._currentInstruction_OpCode = this.GetByte$1(Bridge.identity(this._programCounter, (this._programCounter = (this._programCounter + 1) | 0)));\n                this._currentInstruction_AddressingMode = this.addressmode[this._currentInstruction_OpCode];\n\n                //FetchInstructionParameters();\n                switch (this._currentInstruction_AddressingMode) {\n                    case ChiChiNES.AddressingModes.Absolute: \n                    case ChiChiNES.AddressingModes.AbsoluteX: \n                    case ChiChiNES.AddressingModes.AbsoluteY: \n                    case ChiChiNES.AddressingModes.Indirect: \n                        // case AddressingModes.IndirectAbsoluteX:\n                        this._currentInstruction_Parameters0 = this.GetByte$1(Bridge.identity(this._programCounter, (this._programCounter = (this._programCounter + 1) | 0)));\n                        this._currentInstruction_Parameters1 = this.GetByte$1(Bridge.identity(this._programCounter, (this._programCounter = (this._programCounter + 1) | 0)));\n                        break;\n                    case ChiChiNES.AddressingModes.ZeroPage: \n                    case ChiChiNES.AddressingModes.ZeroPageX: \n                    case ChiChiNES.AddressingModes.ZeroPageY: \n                    case ChiChiNES.AddressingModes.Relative: \n                    case ChiChiNES.AddressingModes.IndexedIndirect: \n                    case ChiChiNES.AddressingModes.IndirectIndexed: \n                    case ChiChiNES.AddressingModes.IndirectZeroPage: \n                    case ChiChiNES.AddressingModes.Immediate: \n                        this._currentInstruction_Parameters0 = this.GetByte$1(Bridge.identity(this._programCounter, (this._programCounter = (this._programCounter + 1) | 0)));\n                        break;\n                    case ChiChiNES.AddressingModes.Accumulator: \n                    case ChiChiNES.AddressingModes.Implicit: \n                        break;\n                    default: \n                        //  throw new NotImplementedException(\"Invalid address mode!!\");\n                        break;\n                }\n\n                this.Execute();\n\n                //(\"{0:x} {1:x} {2:x}\", _currentInstruction_OpCode, _currentInstruction_AddressingMode, _currentInstruction_Address);\n                if (this._debugging) {\n                    this.WriteInstructionHistoryAndUsage();\n                    this._operationCounter = (this._operationCounter + 1) | 0;\n                }\n\n                this.clock = (this.clock + (((ChiChiNES.CPU2A03.cpuTiming[this._currentInstruction_OpCode] + this._currentInstruction_ExtraTiming) | 0))) | 0;\n            },\n            /**\n             * runs up to x clock cycles, then returns\n             *\n             * @instance\n             * @public\n             * @this ChiChiNES.CPU2A03\n             * @memberof ChiChiNES.CPU2A03\n             * @param   {number}    count\n             * @return  {void}\n             */\n            RunCycles: function (count) {\n                var startCycles = this._ticks;\n\n                while (((this._ticks - startCycles) | 0) < count) {\n                    this.Step();\n                }\n\n            },\n            setupticks: function () {\n\n                this.clockcount[0] = 7;\n                //instruction(0x0] = INS_BRK;\n                this.addressmode[0] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[1] = 6;\n                //instruction(0x1] = INS_ORA;\n                this.addressmode[1] = ChiChiNES.AddressingModes.IndexedIndirect;\n                this.clockcount[2] = 2;\n                //instruction(0x2] = INS_NOP;\n                this.addressmode[2] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[3] = 2;\n                //instruction(0x3] = INS_NOP;\n                this.addressmode[3] = ChiChiNES.AddressingModes.Bullshit;\n                this.clockcount[4] = 3;\n                //instruction(0x4] = INS_NOP;\n                this.addressmode[4] = ChiChiNES.AddressingModes.Bullshit;\n                this.clockcount[5] = 3;\n                //instruction(0x5] = INS_ORA;\n                this.addressmode[5] = ChiChiNES.AddressingModes.ZeroPage;\n                this.clockcount[6] = 5;\n                //instruction(0x6] = INS_ASL;\n\n                this.addressmode[6] = ChiChiNES.AddressingModes.ZeroPage;\n\n                // asl-ora\n                this.clockcount[7] = 2;\n                //instruction(0x7] = INS_NOP;\n                this.addressmode[7] = ChiChiNES.AddressingModes.Bullshit;\n\n                this.clockcount[8] = 3;\n                //instruction(0x8] = INS_PHP;\n                this.addressmode[8] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[9] = 3;\n                //instruction(0x9] = INS_ORA;\n                this.addressmode[9] = ChiChiNES.AddressingModes.Immediate;\n                this.clockcount[10] = 2;\n                //instruction(0xa] = INS_ASLA;\n                this.addressmode[10] = ChiChiNES.AddressingModes.Accumulator;\n                this.clockcount[11] = 2;\n                //instruction(0xb] = AAC;\n                this.addressmode[11] = ChiChiNES.AddressingModes.Immediate;\n                this.clockcount[12] = 4;\n                //instruction(0xc] = INS_NOP;\n                this.addressmode[12] = ChiChiNES.AddressingModes.Absolute;\n                this.clockcount[13] = 4;\n                //instruction(0xd] = INS_ORA;\n                this.addressmode[13] = ChiChiNES.AddressingModes.Absolute;\n                this.clockcount[14] = 6;\n                //instruction(0xe] = INS_ASL;\n                this.addressmode[14] = ChiChiNES.AddressingModes.Absolute;\n                this.clockcount[15] = 2;\n                //instruction(0xf] = INS_NOP;\n                this.addressmode[15] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[16] = 2;\n                //instruction(0x10] = INS_BPL;\n\n                this.addressmode[16] = ChiChiNES.AddressingModes.Relative;\n                this.clockcount[17] = 5;\n                //instruction(0x11] = INS_ORA;\n\n                this.addressmode[17] = ChiChiNES.AddressingModes.IndirectIndexed;\n                this.clockcount[18] = 3;\n                //instruction(0x12] = INS_ORA;\n\n                this.addressmode[18] = ChiChiNES.AddressingModes.IndirectZeroPage;\n                this.clockcount[19] = 2;\n                //instruction(0x13] = INS_NOP;\n                this.addressmode[19] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[20] = 3;\n                //instruction(0x14] = INS_NOP;\n                this.addressmode[20] = ChiChiNES.AddressingModes.ZeroPage;\n                this.clockcount[21] = 4;\n                //instruction(0x15] = INS_ORA;\n                this.addressmode[21] = ChiChiNES.AddressingModes.ZeroPageX;\n                this.clockcount[22] = 6;\n                //instruction(0x16] = INS_ASL;\n                this.addressmode[22] = ChiChiNES.AddressingModes.ZeroPageX;\n                this.clockcount[23] = 2;\n                //instruction(0x17] = INS_NOP;\n                this.addressmode[23] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[24] = 2;\n                //instruction(0x18] = INS_CLC;\n                this.addressmode[24] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[25] = 4;\n                //instruction(0x19] = INS_ORA;\n\n                this.addressmode[25] = ChiChiNES.AddressingModes.AbsoluteY;\n                this.clockcount[26] = 2;\n                //instruction(0x1a] = INS_INA;\n                this.addressmode[26] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[27] = 2;\n                //instruction(0x1b] = INS_NOP;\n                this.addressmode[27] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[28] = 4;\n                //instruction(0x1c] = INS_NOP;\n                this.addressmode[28] = ChiChiNES.AddressingModes.Absolute;\n                this.clockcount[29] = 4;\n                //instruction(0x1d] = INS_ORA;\n                this.addressmode[29] = ChiChiNES.AddressingModes.AbsoluteX;\n                this.clockcount[30] = 7;\n                //instruction(0x1e] = INS_ASL;\n                this.addressmode[30] = ChiChiNES.AddressingModes.AbsoluteX;\n                this.clockcount[31] = 2;\n                //instruction(0x1f] = INS_NOP;\n                this.addressmode[31] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[32] = 6;\n                //instruction(0x20] = INS_JSR;\n                this.addressmode[32] = ChiChiNES.AddressingModes.Absolute;\n                this.clockcount[33] = 6;\n                //instruction(0x21] = INS_AND;\n\n                this.addressmode[33] = ChiChiNES.AddressingModes.IndexedIndirect;\n                this.clockcount[34] = 2;\n                //instruction(0x22] = INS_NOP;\n                this.addressmode[34] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[35] = 2;\n                //instruction(0x23] = INS_NOP;\n                this.addressmode[35] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[36] = 3;\n                //instruction(0x24] = INS_BIT;\n                this.addressmode[36] = ChiChiNES.AddressingModes.ZeroPage;\n                this.clockcount[37] = 3;\n                //instruction(0x25] = INS_AND;\n                this.addressmode[37] = ChiChiNES.AddressingModes.ZeroPage;\n                this.clockcount[38] = 5;\n                //instruction(0x26] = INS_ROL;\n                this.addressmode[38] = ChiChiNES.AddressingModes.ZeroPage;\n                this.clockcount[39] = 2;\n                //instruction(0x27] = INS_NOP;\n                this.addressmode[39] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[40] = 4;\n                //instruction(0x28] = INS_PLP;\n                this.addressmode[40] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[41] = 3;\n                //instruction(0x29] = INS_AND;\n\n                this.addressmode[41] = ChiChiNES.AddressingModes.Immediate;\n                this.clockcount[42] = 2;\n                //instruction(0x2a] = INS_ROLA;\n                this.addressmode[42] = ChiChiNES.AddressingModes.Accumulator;\n\n                // undocumented\n                this.clockcount[43] = 2;\n                //instruction(0x2b] = INS_NOP; AAC\n                this.addressmode[43] = ChiChiNES.AddressingModes.Immediate;\n                this.clockcount[44] = 4;\n                //instruction(0x2c] = INS_BIT;\n                this.addressmode[44] = ChiChiNES.AddressingModes.Absolute;\n                this.clockcount[45] = 4;\n                //instruction(0x2d] = INS_AND;\n                this.addressmode[45] = ChiChiNES.AddressingModes.Absolute;\n                this.clockcount[46] = 6;\n                //instruction(0x2e] = INS_ROL;\n                this.addressmode[46] = ChiChiNES.AddressingModes.Absolute;\n                this.clockcount[47] = 2;\n                //instruction(0x2f] = INS_NOP;\n                this.addressmode[47] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[48] = 2;\n                //instruction(0x30] = INS_BMI;\n                this.addressmode[48] = ChiChiNES.AddressingModes.Relative;\n                this.clockcount[49] = 5;\n                //instruction(0x31] = INS_AND;\n                this.addressmode[49] = ChiChiNES.AddressingModes.IndirectIndexed;\n                this.clockcount[50] = 3;\n                //instruction(0x32] = INS_AND;\n                this.addressmode[50] = ChiChiNES.AddressingModes.IndirectZeroPage;\n                this.clockcount[51] = 2;\n                //instruction(0x33] = INS_NOP;\n                this.addressmode[51] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[52] = 4;\n                //instruction(0x34] = INS_BIT;\n                this.addressmode[52] = ChiChiNES.AddressingModes.ZeroPageX;\n                this.clockcount[53] = 4;\n                //instruction(0x35] = INS_AND;\n                this.addressmode[53] = ChiChiNES.AddressingModes.ZeroPageX;\n                this.clockcount[54] = 6;\n                //instruction(0x36] = INS_ROL;\n                this.addressmode[54] = ChiChiNES.AddressingModes.ZeroPageX;\n                this.clockcount[55] = 2;\n                //instruction(0x37] = INS_NOP;\n                this.addressmode[55] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[56] = 2;\n                //instruction(0x38] = INS_SEC;\n                this.addressmode[56] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[57] = 4;\n                //instruction(0x39] = INS_AND;\n                this.addressmode[57] = ChiChiNES.AddressingModes.AbsoluteY;\n                this.clockcount[58] = 2;\n                //instruction(0x3a] = INS_DEA;\n                this.addressmode[58] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[59] = 2;\n                //instruction(0x3b] = INS_NOP;\n                this.addressmode[59] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[60] = 4;\n                //instruction(0x3c] = INS_BIT;\n                this.addressmode[60] = ChiChiNES.AddressingModes.AbsoluteX;\n                this.clockcount[61] = 4;\n                //instruction(0x3d] = INS_AND;\n                this.addressmode[61] = ChiChiNES.AddressingModes.AbsoluteX;\n                this.clockcount[62] = 7;\n                //instruction(0x3e] = INS_ROL;\n                this.addressmode[62] = ChiChiNES.AddressingModes.AbsoluteX;\n                this.clockcount[63] = 2;\n                //instruction(0x3f] = INS_NOP;\n                this.addressmode[63] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[64] = 6;\n                //instruction(0x40] = INS_RTI;\n                this.addressmode[64] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[65] = 6;\n                //instruction(0x41] = INS_EOR;\n                this.addressmode[65] = ChiChiNES.AddressingModes.IndexedIndirect;\n                this.clockcount[66] = 2;\n                //instruction(0x42] = INS_NOP;\n                this.addressmode[66] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[67] = 2;\n                //instruction(0x43] = INS_NOP;\n                this.addressmode[67] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[68] = 2;\n                //instruction(0x44] = INS_NOP;\n                this.addressmode[68] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[69] = 3;\n                //instruction(0x45] = INS_EOR;\n                this.addressmode[69] = ChiChiNES.AddressingModes.ZeroPage;\n                this.clockcount[70] = 5;\n                //instruction(0x46] = INS_LSR;\n                this.addressmode[70] = ChiChiNES.AddressingModes.ZeroPage;\n                this.clockcount[71] = 2;\n                //instruction(0x47] = INS_NOP;\n                this.addressmode[71] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[72] = 3;\n                //instruction(0x48] = INS_PHA;\n                this.addressmode[72] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[73] = 3;\n                //instruction(0x49] = INS_EOR;\n                this.addressmode[73] = ChiChiNES.AddressingModes.Immediate;\n                this.clockcount[74] = 2;\n                //instruction(0x4a] = INS_LSRA;\n                this.addressmode[74] = ChiChiNES.AddressingModes.Accumulator;\n                this.clockcount[75] = 2;\n                //instruction(0x4b] = INS_ASR;\n                this.addressmode[75] = ChiChiNES.AddressingModes.Immediate;\n                this.clockcount[76] = 3;\n                //instruction(0x4c] = INS_JMP;\n                this.addressmode[76] = ChiChiNES.AddressingModes.Absolute;\n                this.clockcount[77] = 4;\n                //instruction(0x4d] = INS_EOR;\n                this.addressmode[77] = ChiChiNES.AddressingModes.Absolute;\n                this.clockcount[78] = 6;\n                //instruction(0x4e] = INS_LSR;\n                this.addressmode[78] = ChiChiNES.AddressingModes.Absolute;\n                this.clockcount[79] = 2;\n                //instruction(0x4f] = INS_NOP;\n                this.addressmode[79] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[80] = 2;\n                //instruction(0x50] = INS_BVC;\n                this.addressmode[80] = ChiChiNES.AddressingModes.Relative;\n                this.clockcount[81] = 5;\n                //instruction(0x51] = INS_EOR;\n                this.addressmode[81] = ChiChiNES.AddressingModes.IndirectIndexed;\n                this.clockcount[82] = 3;\n                //instruction(0x52] = INS_EOR;\n                this.addressmode[82] = ChiChiNES.AddressingModes.IndirectZeroPage;\n                this.clockcount[83] = 2;\n                //instruction(0x53] = INS_NOP;\n                this.addressmode[83] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[84] = 2;\n                //instruction(0x54] = INS_NOP;\n                this.addressmode[84] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[85] = 4;\n                //instruction(0x55] = INS_EOR;\n                this.addressmode[85] = ChiChiNES.AddressingModes.ZeroPageX;\n                this.clockcount[86] = 6;\n                //instruction(0x56] = INS_LSR;\n                this.addressmode[86] = ChiChiNES.AddressingModes.ZeroPageX;\n                this.clockcount[87] = 2;\n                //instruction(0x57] = INS_NOP;\n                this.addressmode[87] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[88] = 2;\n                //instruction(0x58] = INS_CLI;\n                this.addressmode[88] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[89] = 4;\n                //instruction(0x59] = INS_EOR;\n                this.addressmode[89] = ChiChiNES.AddressingModes.AbsoluteY;\n                this.clockcount[90] = 3;\n                //instruction(0x5a] = INS_PHY;\n                this.addressmode[90] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[91] = 2;\n                //instruction(0x5b] = INS_NOP;\n                this.addressmode[91] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[92] = 2;\n                //instruction(0x5c] = INS_NOP;\n                this.addressmode[92] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[93] = 4;\n                //instruction(0x5d] = INS_EOR;\n                this.addressmode[93] = ChiChiNES.AddressingModes.AbsoluteX;\n                this.clockcount[94] = 7;\n                //instruction(0x5e] = INS_LSR;\n                this.addressmode[94] = ChiChiNES.AddressingModes.AbsoluteX;\n                this.clockcount[95] = 2;\n                //instruction(0x5f] = INS_NOP;\n                this.addressmode[95] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[96] = 6;\n                //instruction(0x60] = INS_RTS;\n                this.addressmode[96] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[97] = 6;\n                //instruction(0x61] = INS_ADC;\n                this.addressmode[97] = ChiChiNES.AddressingModes.IndexedIndirect;\n                this.clockcount[98] = 2;\n                //instruction(0x62] = INS_NOP;\n                this.addressmode[98] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[99] = 2;\n                //instruction(0x63] = INS_NOP;\n                this.addressmode[99] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[100] = 3;\n                //instruction(0x64] = INS_NOP;\n                this.addressmode[100] = ChiChiNES.AddressingModes.ZeroPage;\n                this.clockcount[101] = 3;\n                //instruction(0x65] = INS_ADC;\n                this.addressmode[101] = ChiChiNES.AddressingModes.ZeroPage;\n                this.clockcount[102] = 5;\n                //instruction(0x66] = INS_ROR;\n                this.addressmode[102] = ChiChiNES.AddressingModes.ZeroPage;\n                this.clockcount[103] = 2;\n                //instruction(0x67] = INS_NOP;\n                this.addressmode[103] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[104] = 4;\n                //instruction(0x68] = INS_PLA;\n                this.addressmode[104] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[105] = 3;\n                //instruction(0x69] = INS_ADC;\n                this.addressmode[105] = ChiChiNES.AddressingModes.Immediate;\n                this.clockcount[106] = 2;\n                //instruction(0x6a] = INS_RORA;\n                this.addressmode[106] = ChiChiNES.AddressingModes.Accumulator;\n\n                this.clockcount[107] = 2;\n                //instruction(0x6b] = INS_ARR; U\n                this.addressmode[107] = ChiChiNES.AddressingModes.Immediate;\n\n                this.clockcount[108] = 5;\n                //instruction(0x6c] = INS_JMP;\n\n                this.addressmode[108] = ChiChiNES.AddressingModes.Indirect;\n                this.clockcount[109] = 4;\n                //instruction(0x6d] = INS_ADC;\n                this.addressmode[109] = ChiChiNES.AddressingModes.Absolute;\n                this.clockcount[110] = 6;\n                //instruction(0x6e] = INS_ROR;\n                this.addressmode[110] = ChiChiNES.AddressingModes.Absolute;\n                this.clockcount[111] = 2;\n                //instruction(0x6f] = INS_NOP;\n                this.addressmode[111] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[112] = 2;\n                //instruction(0x70] = INS_BVS;\n                this.addressmode[112] = ChiChiNES.AddressingModes.Relative;\n                this.clockcount[113] = 5;\n                //instruction(0x71] = INS_ADC;\n                this.addressmode[113] = ChiChiNES.AddressingModes.IndirectIndexed;\n                this.clockcount[114] = 3;\n                //instruction(0x72] = INS_ADC;\n                this.addressmode[114] = ChiChiNES.AddressingModes.IndirectZeroPage;\n                this.clockcount[115] = 2;\n                //instruction(0x73] = INS_NOP;\n                this.addressmode[115] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[116] = 4;\n                //instruction(0x74] = INS_NOP;\n                this.addressmode[116] = ChiChiNES.AddressingModes.ZeroPageX;\n                this.clockcount[117] = 4;\n                //instruction(0x75] = INS_ADC;\n                this.addressmode[117] = ChiChiNES.AddressingModes.ZeroPageX;\n                this.clockcount[118] = 6;\n                //instruction(0x76] = INS_ROR;\n                this.addressmode[118] = ChiChiNES.AddressingModes.ZeroPageX;\n                this.clockcount[119] = 2;\n                //instruction(0x77] = INS_NOP;\n                this.addressmode[119] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[120] = 2;\n                //instruction(0x78] = INS_SEI;\n                this.addressmode[120] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[121] = 4;\n                //instruction(0x79] = INS_ADC;\n                this.addressmode[121] = ChiChiNES.AddressingModes.AbsoluteY;\n                this.clockcount[122] = 4;\n                //instruction(0x7a] = INS_PLY;\n                this.addressmode[122] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[123] = 2;\n                //instruction(0x7b] = INS_NOP;\n                this.addressmode[123] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[124] = 6;\n                //instruction(0x7c] = INS_JMP;\n\n                this.addressmode[124] = ChiChiNES.AddressingModes.IndirectAbsoluteX;\n                this.clockcount[125] = 4;\n                //instruction(0x7d] = INS_ADC;\n                this.addressmode[125] = ChiChiNES.AddressingModes.AbsoluteX;\n                this.clockcount[126] = 7;\n                //instruction(0x7e] = INS_ROR;\n                this.addressmode[126] = ChiChiNES.AddressingModes.AbsoluteX;\n                this.clockcount[127] = 2;\n                //instruction(0x7f] = INS_NOP;\n                this.addressmode[127] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[128] = 2;\n                //instruction(0x80] = INS_BRA;\n                this.addressmode[128] = ChiChiNES.AddressingModes.Relative;\n                this.clockcount[129] = 6;\n                //instruction(0x81] = INS_STA;\n                this.addressmode[129] = ChiChiNES.AddressingModes.IndexedIndirect;\n                this.clockcount[130] = 2;\n                //instruction(0x82] = INS_NOP;\n                this.addressmode[130] = ChiChiNES.AddressingModes.Immediate;\n                this.clockcount[131] = 2;\n                //instruction(0x83] = INS_NOP;\n                this.addressmode[131] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[132] = 2;\n                //instruction(0x84] = INS_STY;\n                this.addressmode[132] = ChiChiNES.AddressingModes.ZeroPage;\n                this.clockcount[133] = 2;\n                //instruction(0x85] = INS_STA;\n                this.addressmode[133] = ChiChiNES.AddressingModes.ZeroPage;\n                this.clockcount[134] = 2;\n                //instruction(0x86] = INS_STX;\n                this.addressmode[134] = ChiChiNES.AddressingModes.ZeroPage;\n                this.clockcount[135] = 2;\n                //instruction(0x87] = INS_NOP;\n                this.addressmode[135] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[136] = 2;\n                //instruction(0x88] = INS_DEY;\n                this.addressmode[136] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[137] = 2;\n                //instruction(0x89] = INS_BIT;\n                this.addressmode[137] = ChiChiNES.AddressingModes.Immediate;\n                this.clockcount[138] = 2;\n                //instruction(0x8a] = INS_TXA;\n                this.addressmode[138] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[139] = 2;\n                //instruction(0x8b] = INS_NOP;\n                this.addressmode[139] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[140] = 4;\n                //instruction(0x8c] = INS_STY;\n                this.addressmode[140] = ChiChiNES.AddressingModes.Absolute;\n                this.clockcount[141] = 4;\n                //instruction(0x8d] = INS_STA;\n                this.addressmode[141] = ChiChiNES.AddressingModes.Absolute;\n                this.clockcount[142] = 4;\n                //instruction(0x8e] = INS_STX;\n                this.addressmode[142] = ChiChiNES.AddressingModes.Absolute;\n                this.clockcount[143] = 2;\n                //instruction(0x8f] = INS_NOP;\n                this.addressmode[143] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[144] = 2;\n                //instruction(0x90] = INS_BCC;\n                this.addressmode[144] = ChiChiNES.AddressingModes.Relative;\n                this.clockcount[145] = 6;\n                //instruction(0x91] = INS_STA;\n                this.addressmode[145] = ChiChiNES.AddressingModes.IndirectIndexed;\n                this.clockcount[146] = 3;\n                //instruction(0x92] = INS_STA;\n                this.addressmode[146] = ChiChiNES.AddressingModes.IndirectZeroPage;\n                this.clockcount[147] = 2;\n                //instruction(0x93] = INS_NOP;\n                this.addressmode[147] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[148] = 4;\n                //instruction(0x94] = INS_STY;\n                this.addressmode[148] = ChiChiNES.AddressingModes.ZeroPageX;\n                this.clockcount[149] = 4;\n                //instruction(0x95] = INS_STA;\n                this.addressmode[149] = ChiChiNES.AddressingModes.ZeroPageX;\n                this.clockcount[150] = 4;\n                //instruction(0x96] = INS_STX;\n                this.addressmode[150] = ChiChiNES.AddressingModes.ZeroPageY;\n                this.clockcount[151] = 2;\n                //instruction(0x97] = INS_NOP;\n                this.addressmode[151] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[152] = 2;\n                //instruction(0x98] = INS_TYA;\n                this.addressmode[152] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[153] = 5;\n                //instruction(0x99] = INS_STA;\n                this.addressmode[153] = ChiChiNES.AddressingModes.AbsoluteY;\n                this.clockcount[154] = 2;\n                //instruction(0x9a] = INS_TXS;\n                this.addressmode[154] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[155] = 2;\n                //instruction(0x9b] = INS_NOP;\n                this.addressmode[155] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[156] = 4;\n                //instruction(0x9c] = INS_NOP;\n                this.addressmode[156] = ChiChiNES.AddressingModes.Absolute;\n                this.clockcount[157] = 5;\n                //instruction(0x9d] = INS_STA;\n                this.addressmode[157] = ChiChiNES.AddressingModes.AbsoluteX;\n                this.clockcount[158] = 5;\n                //instruction(0x9e] = INS_NOP;\n                this.addressmode[158] = ChiChiNES.AddressingModes.AbsoluteX;\n                this.clockcount[159] = 2;\n                //instruction(0x9f] = INS_NOP;\n                this.addressmode[159] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[160] = 3;\n                //instruction(0xa0] = INS_LDY;\n                this.addressmode[160] = ChiChiNES.AddressingModes.Immediate;\n                this.clockcount[161] = 6;\n                //instruction(0xa1] = INS_LDA;\n                this.addressmode[161] = ChiChiNES.AddressingModes.IndexedIndirect;\n                this.clockcount[162] = 3;\n                //instruction(0xa2] = INS_LDX;\n                this.addressmode[162] = ChiChiNES.AddressingModes.Immediate;\n                this.clockcount[163] = 2;\n                //instruction(0xa3] = INS_NOP;\n                this.addressmode[163] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[164] = 3;\n                //instruction(0xa4] = INS_LDY;\n                this.addressmode[164] = ChiChiNES.AddressingModes.ZeroPage;\n                this.clockcount[165] = 3;\n                //instruction(0xa5] = INS_LDA;\n                this.addressmode[165] = ChiChiNES.AddressingModes.ZeroPage;\n                this.clockcount[166] = 3;\n                //instruction(0xa6] = INS_LDX;\n                this.addressmode[166] = ChiChiNES.AddressingModes.ZeroPage;\n                this.clockcount[167] = 2;\n                //instruction(0xa7] = INS_NOP;\n                this.addressmode[167] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[168] = 2;\n                //instruction(0xa8] = INS_TAY;\n                this.addressmode[168] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[169] = 3;\n                //instruction(0xa9] = INS_LDA;\n                this.addressmode[169] = ChiChiNES.AddressingModes.Immediate;\n                this.clockcount[170] = 2;\n                //instruction(0xaa] = INS_TAX;\n                this.addressmode[170] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[171] = 2;\n                //instruction(0xab] = INS_NOP; ATX U\n                this.addressmode[171] = ChiChiNES.AddressingModes.Immediate;\n                this.clockcount[172] = 4;\n                //instruction(0xac] = INS_LDY;\n                this.addressmode[172] = ChiChiNES.AddressingModes.Absolute;\n                this.clockcount[173] = 4;\n                //instruction(0xad] = INS_LDA;\n                this.addressmode[173] = ChiChiNES.AddressingModes.Absolute;\n                this.clockcount[174] = 4;\n                //instruction(0xae] = INS_LDX;\n                this.addressmode[174] = ChiChiNES.AddressingModes.Absolute;\n                this.clockcount[175] = 2;\n                //instruction(0xaf] = INS_NOP;\n                this.addressmode[175] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[176] = 2;\n                //instruction(0xb0] = INS_BCS;\n                this.addressmode[176] = ChiChiNES.AddressingModes.Relative;\n                this.clockcount[177] = 5;\n                //instruction(0xb1] = INS_LDA;\n                this.addressmode[177] = ChiChiNES.AddressingModes.IndirectIndexed;\n                this.clockcount[178] = 3;\n                //instruction(0xb2] = INS_LDA;\n                this.addressmode[178] = ChiChiNES.AddressingModes.IndirectZeroPage;\n                this.clockcount[179] = 2;\n                //instruction(0xb3] = INS_NOP;\n                this.addressmode[179] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[180] = 4;\n                //instruction(0xb4] = INS_LDY;\n                this.addressmode[180] = ChiChiNES.AddressingModes.ZeroPageX;\n                this.clockcount[181] = 4;\n                //instruction(0xb5] = INS_LDA;\n                this.addressmode[181] = ChiChiNES.AddressingModes.ZeroPageX;\n                this.clockcount[182] = 4;\n                //instruction(0xb6] = INS_LDX;\n\n                this.addressmode[182] = ChiChiNES.AddressingModes.ZeroPageY;\n                this.clockcount[183] = 2;\n                //instruction(0xb7] = INS_NOP;\n                this.addressmode[183] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[184] = 2;\n                //instruction(0xb8] = INS_CLV;\n                this.addressmode[184] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[185] = 4;\n                //instruction(0xb9] = INS_LDA;\n                this.addressmode[185] = ChiChiNES.AddressingModes.AbsoluteY;\n                this.clockcount[186] = 2;\n                //instruction(0xba] = INS_TSX;\n                this.addressmode[186] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[187] = 2;\n                //instruction(0xbb] = INS_NOP;\n                this.addressmode[187] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[188] = 4;\n                //instruction(0xbc] = INS_LDY;\n                this.addressmode[188] = ChiChiNES.AddressingModes.AbsoluteX;\n                this.clockcount[189] = 4;\n                //instruction(0xbd] = INS_LDA;\n                this.addressmode[189] = ChiChiNES.AddressingModes.AbsoluteX;\n                this.clockcount[190] = 4;\n                //instruction(0xbe] = INS_LDX;\n                this.addressmode[190] = ChiChiNES.AddressingModes.AbsoluteY;\n                this.clockcount[191] = 2;\n                //instruction(0xbf] = INS_NOP;\n                this.addressmode[191] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[192] = 3;\n                //instruction(0xc0] = INS_CPY;\n                this.addressmode[192] = ChiChiNES.AddressingModes.Immediate;\n                this.clockcount[193] = 6;\n                //instruction(0xc1] = INS_CMP;\n                this.addressmode[193] = ChiChiNES.AddressingModes.IndexedIndirect;\n\n                this.clockcount[194] = 2;\n                //instruction(0xc2] = INS_NOP;\n                this.addressmode[194] = ChiChiNES.AddressingModes.Immediate;\n\n                this.clockcount[195] = 2;\n                //instruction(0xc3] = INS_NOP;\n                this.addressmode[195] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[196] = 3;\n                //instruction(0xc4] = INS_CPY;\n                this.addressmode[196] = ChiChiNES.AddressingModes.ZeroPage;\n                this.clockcount[197] = 3;\n                //instruction(0xc5] = INS_CMP;\n                this.addressmode[197] = ChiChiNES.AddressingModes.ZeroPage;\n                this.clockcount[198] = 5;\n                //instruction(0xc6] = INS_DEC;\n                this.addressmode[198] = ChiChiNES.AddressingModes.ZeroPage;\n                this.clockcount[199] = 2;\n                //instruction(0xc7] = INS_NOP;\n                this.addressmode[199] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[200] = 2;\n                //instruction(0xc8] = INS_INY;\n                this.addressmode[200] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[201] = 3;\n                //instruction(0xc9] = INS_CMP;\n                this.addressmode[201] = ChiChiNES.AddressingModes.Immediate;\n                this.clockcount[202] = 2;\n                //instruction(0xca] = INS_DEX;\n                this.addressmode[202] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[203] = 2;\n                //instruction(0xcb] = INS_NOP; AXS\n                this.addressmode[203] = ChiChiNES.AddressingModes.Immediate;\n                this.clockcount[204] = 4;\n                //instruction(0xcc] = INS_CPY;\n                this.addressmode[204] = ChiChiNES.AddressingModes.Absolute;\n                this.clockcount[205] = 4;\n                //instruction(0xcd] = INS_CMP;\n                this.addressmode[205] = ChiChiNES.AddressingModes.Absolute;\n                this.clockcount[206] = 6;\n                //instruction(0xce] = INS_DEC;\n                this.addressmode[206] = ChiChiNES.AddressingModes.Absolute;\n                this.clockcount[207] = 2;\n                //instruction(0xcf] = INS_NOP;\n                this.addressmode[207] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[208] = 2;\n                //instruction(0xd0] = INS_BNE;\n                this.addressmode[208] = ChiChiNES.AddressingModes.Relative;\n                this.clockcount[209] = 5;\n                //instruction(0xd1] = INS_CMP;\n                this.addressmode[209] = ChiChiNES.AddressingModes.IndirectIndexed;\n                this.clockcount[210] = 3;\n                //instruction(0xd2] = INS_CMP;\n                this.addressmode[210] = ChiChiNES.AddressingModes.IndirectZeroPage;\n                this.clockcount[211] = 2;\n                //instruction(0xd3] = INS_NOP;\n                this.addressmode[211] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[212] = 2;\n                //instruction(0xd4] = INS_NOP;\n                this.addressmode[212] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[213] = 4;\n                //instruction(0xd5] = INS_CMP;\n                this.addressmode[213] = ChiChiNES.AddressingModes.ZeroPageX;\n                this.clockcount[214] = 6;\n                //instruction(0xd6] = INS_DEC;\n                this.addressmode[214] = ChiChiNES.AddressingModes.ZeroPageX;\n                this.clockcount[215] = 2;\n                //instruction(0xd7] = INS_NOP;\n                this.addressmode[215] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[216] = 2;\n                //instruction(0xd8] = INS_CLD;\n                this.addressmode[216] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[217] = 4;\n                //instruction(0xd9] = INS_CMP;\n                this.addressmode[217] = ChiChiNES.AddressingModes.AbsoluteY;\n                this.clockcount[218] = 3;\n                //instruction(0xda] = INS_PHX;\n                this.addressmode[218] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[219] = 2;\n                //instruction(0xdb] = INS_NOP;\n                this.addressmode[219] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[220] = 2;\n                //instruction(0xdc] = INS_NOP;\n                this.addressmode[220] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[221] = 4;\n                //instruction(0xdd] = INS_CMP;\n                this.addressmode[221] = ChiChiNES.AddressingModes.AbsoluteX;\n                this.clockcount[222] = 7;\n                //instruction(0xde] = INS_DEC;\n                this.addressmode[222] = ChiChiNES.AddressingModes.AbsoluteX;\n                this.clockcount[223] = 2;\n                //instruction(0xdf] = INS_NOP;\n                this.addressmode[223] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[224] = 3;\n                //instruction(0xe0] = INS_CPX;\n                this.addressmode[224] = ChiChiNES.AddressingModes.Immediate;\n                this.clockcount[225] = 6;\n                //instruction(0xe1] = INS_SBC;\n                this.addressmode[225] = ChiChiNES.AddressingModes.IndexedIndirect;\n                this.clockcount[226] = 2;\n                //instruction(0xe2] = INS_NOP;\n                this.addressmode[226] = ChiChiNES.AddressingModes.Immediate;\n                this.clockcount[227] = 2;\n                //instruction(0xe3] = INS_NOP;\n                this.addressmode[227] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[228] = 3;\n                //instruction(0xe4] = INS_CPX;\n                this.addressmode[228] = ChiChiNES.AddressingModes.ZeroPage;\n                this.clockcount[229] = 3;\n                //instruction(0xe5] = INS_SBC;\n                this.addressmode[229] = ChiChiNES.AddressingModes.ZeroPage;\n                this.clockcount[230] = 5;\n                //instruction(0xe6] = INS_INC;\n                this.addressmode[230] = ChiChiNES.AddressingModes.ZeroPage;\n                this.clockcount[231] = 2;\n                //instruction(0xe7] = INS_NOP;\n                this.addressmode[231] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[232] = 2;\n                //instruction(0xe8] = INS_INX;\n                this.addressmode[232] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[233] = 3;\n                //instruction(0xe9] = INS_SBC;\n                this.addressmode[233] = ChiChiNES.AddressingModes.Immediate;\n                this.clockcount[234] = 2;\n                //instruction(0xea] = INS_NOP;\n                this.addressmode[234] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[235] = 2;\n                //instruction(0xeb] = INS_NOP;\n                this.addressmode[235] = ChiChiNES.AddressingModes.Immediate;\n                this.clockcount[236] = 4;\n                //instruction(0xec] = INS_CPX;\n                this.addressmode[236] = ChiChiNES.AddressingModes.Absolute;\n                this.clockcount[237] = 4;\n                //instruction(0xed] = INS_SBC;\n                this.addressmode[237] = ChiChiNES.AddressingModes.Absolute;\n                this.clockcount[238] = 6;\n                //instruction(0xee] = INS_INC;\n                this.addressmode[238] = ChiChiNES.AddressingModes.Absolute;\n                this.clockcount[239] = 2;\n                //instruction(0xef] = INS_NOP;\n                this.addressmode[239] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[240] = 2;\n                //instruction(0xf0] = INS_BEQ;\n                this.addressmode[240] = ChiChiNES.AddressingModes.Relative;\n                this.clockcount[241] = 5;\n                //instruction(0xf1] = INS_SBC;\n                this.addressmode[241] = ChiChiNES.AddressingModes.IndirectIndexed;\n                this.clockcount[242] = 3;\n                //instruction(0xf2] = INS_SBC;\n                this.addressmode[242] = ChiChiNES.AddressingModes.IndirectZeroPage;\n                this.clockcount[243] = 2;\n                //instruction(0xf3] = INS_NOP;\n                this.addressmode[243] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[244] = 2;\n                //instruction(0xf4] = INS_NOP;\n                this.addressmode[244] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[245] = 4;\n                //instruction(0xf5] = INS_SBC;\n                this.addressmode[245] = ChiChiNES.AddressingModes.ZeroPageX;\n                this.clockcount[246] = 6;\n                //instruction(0xf6] = INS_INC;\n                this.addressmode[246] = ChiChiNES.AddressingModes.ZeroPageX;\n                this.clockcount[247] = 2;\n                //instruction(0xf7] = INS_NOP;\n                this.addressmode[247] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[248] = 2;\n                //instruction(0xf8] = INS_SED;\n                this.addressmode[248] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[249] = 4;\n                //instruction(0xf9] = INS_SBC;\n                this.addressmode[249] = ChiChiNES.AddressingModes.AbsoluteY;\n                this.clockcount[250] = 4;\n                //instruction(0xfa] = INS_PLX;\n                this.addressmode[250] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[251] = 2;\n                //instruction(0xfb] = INS_NOP;\n                this.addressmode[251] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[252] = 2;\n                //instruction(0xfc] = INS_NOP;\n                this.addressmode[252] = ChiChiNES.AddressingModes.Implicit;\n                this.clockcount[253] = 4;\n                //instruction(0xfd] = INS_SBC;\n                this.addressmode[253] = ChiChiNES.AddressingModes.AbsoluteX;\n                this.clockcount[254] = 7;\n                //instruction(0xfe] = INS_INC;\n                this.addressmode[254] = ChiChiNES.AddressingModes.AbsoluteX;\n                this.clockcount[255] = 2;\n                //instruction(0xff] = INS_NOP;\n                this.addressmode[255] = ChiChiNES.AddressingModes.Implicit;\n            },\n            ResetCPU: function () {\n                this._statusRegister = 52;\n                this._operationCounter = 0;\n                this._stackPointer = 253;\n                this.setupticks();\n                this.Ticks = 4;\n                this.ProgramCounter = (this.GetByte$1(65532) + Bridge.Int.mul(this.GetByte$1(65533), 256)) | 0;\n            },\n            PowerOn: function () {\n                // powers up with this state\n                this._statusRegister = 52;\n                this._stackPointer = 253;\n                this._operationCounter = 0;\n                this.setupticks();\n                this.Ticks = 4;\n\n                // wram initialized to 0xFF, with some exceptions\n                // probably doesn't affect games, but why not?\n                for (var i = 0; i < 2048; i = (i + 1) | 0) {\n                    this.Rams[i] = 255;\n                }\n                this.Rams[8] = 247;\n                this.Rams[9] = 239;\n                this.Rams[10] = 223;\n                this.Rams[15] = 191;\n\n                this.ProgramCounter = (this.GetByte$1(65532) + Bridge.Int.mul(this.GetByte$1(65533), 256)) | 0;\n            },\n            GetState: function (outStream) {\n                outStream.enqueue(this._programCounter);\n                outStream.enqueue(this._accumulator);\n                outStream.enqueue(this._indexRegisterX);\n                outStream.enqueue(this._indexRegisterY);\n                outStream.enqueue(this._statusRegister);\n                outStream.enqueue(this._stackPointer);\n                for (var i = 0; i < 2048; i = (i + 4) | 0) {\n                    outStream.enqueue((this.Rams[i] << 24) | (this.Rams[((i + 1) | 0)] << 16) | (this.Rams[((i + 2) | 0)] << 8) | (this.Rams[((i + 3) | 0)]));\n                }\n            },\n            SetState: function (inStream) {\n                this._programCounter = inStream.dequeue();\n                this._accumulator = inStream.dequeue();\n                this._indexRegisterX = inStream.dequeue();\n                this._indexRegisterY = inStream.dequeue();\n                this._statusRegister = inStream.dequeue();\n                this._stackPointer = inStream.dequeue();\n                var packedByte = 0;\n                for (var i = 0; i < 2048; i = (i + 4) | 0) {\n                    packedByte = inStream.dequeue();\n                    this.Rams[i] = (packedByte >> 24) & 255;\n                    this.Rams[((i + 1) | 0)] = (packedByte >> 16) & 255;\n                    this.Rams[((i + 2) | 0)] = (packedByte >> 8) & 255;\n                    this.Rams[((i + 3) | 0)] = packedByte & 255;\n\n                }\n            },\n            DecodeAddress: function () {\n                this._currentInstruction_ExtraTiming = 0;\n                var result = 0;\n                switch (this._currentInstruction_AddressingMode) {\n                    case ChiChiNES.AddressingModes.Absolute: \n                        // two parameters refer to the memory position\n                        result = ((this._currentInstruction_Parameters1 << 8) | this._currentInstruction_Parameters0);\n                        break;\n                    case ChiChiNES.AddressingModes.AbsoluteX: \n                        // absolute, x indexed - two paramaters + Index register x\n                        result = (((((this._currentInstruction_Parameters1 << 8) | this._currentInstruction_Parameters0) + this._indexRegisterX) | 0));\n                        if ((result & 255) < this._indexRegisterX) {\n                            this._currentInstruction_ExtraTiming = 1;\n                        }\n                        break;\n                    case ChiChiNES.AddressingModes.AbsoluteY: \n                        // absolute, y indexed - two paramaters + Index register y\n                        result = (((((this._currentInstruction_Parameters1 << 8) | this._currentInstruction_Parameters0) + this._indexRegisterY) | 0));\n                        if ((result & 255) < this._indexRegisterY) {\n                            this._currentInstruction_ExtraTiming = 1;\n                        }\n                        break;\n                    case ChiChiNES.AddressingModes.ZeroPage: \n                        // first parameter represents offset in zero page\n                        result = this._currentInstruction_Parameters0 & 255;\n                        break;\n                    case ChiChiNES.AddressingModes.ZeroPageX: \n                        result = (((this._currentInstruction_Parameters0 + this._indexRegisterX) | 0)) & 255;\n                        break;\n                    case ChiChiNES.AddressingModes.ZeroPageY: \n                        result = ((((this._currentInstruction_Parameters0 & 255) + (this._indexRegisterY & 255)) | 0)) & 255;\n                        break;\n                    case ChiChiNES.AddressingModes.Indirect: \n                        this.lowByte = this._currentInstruction_Parameters0;\n                        this.highByte = this._currentInstruction_Parameters1 << 8;\n                        var indAddr = (this.highByte | this.lowByte) & 65535;\n                        var indirectAddr = (this.GetByte$1(indAddr));\n                        this.lowByte = (((this.lowByte + 1) | 0)) & 255;\n                        indAddr = (this.highByte | this.lowByte) & 65535;\n                        indirectAddr = indirectAddr | (this.GetByte$1(indAddr) << 8);\n                        result = indirectAddr;\n                        break;\n                    case ChiChiNES.AddressingModes.IndexedIndirect: \n                        var addr = (((this._currentInstruction_Parameters0 + this._indexRegisterX) | 0)) & 255;\n                        this.lowByte = this.GetByte$1(addr);\n                        addr = (addr + 1) | 0;\n                        this.highByte = this.GetByte$1(addr & 255);\n                        this.highByte = this.highByte << 8;\n                        result = this.highByte | this.lowByte;\n                        break;\n                    case ChiChiNES.AddressingModes.IndirectIndexed: \n                        this.lowByte = this.GetByte$1(this._currentInstruction_Parameters0 & 255);\n                        this.highByte = this.GetByte$1((((this._currentInstruction_Parameters0 + 1) | 0)) & 255) << 8;\n                        addr = (this.lowByte | this.highByte);\n                        result = (addr + this._indexRegisterY) | 0;\n                        if ((result & 255) > this._indexRegisterY) {\n                            this._currentInstruction_ExtraTiming = 1;\n                        }\n                        break;\n                    case ChiChiNES.AddressingModes.Relative: \n                        result = (((this._programCounter + this._currentInstruction_Parameters0) | 0));\n                        break;\n                    default: \n                        this.HandleBadOperation();\n                        break;\n                }\n                return (result & 65535);\n            },\n            HandleBadOperation: function () {\n                throw new System.NotImplementedException(\"Executors.DecodeAddress() recieved an invalid addressmode\");\n            },\n            DecodeOperand: function () {\n                switch (this._currentInstruction_AddressingMode) {\n                    case ChiChiNES.AddressingModes.Immediate: \n                        this.DataBus = this._currentInstruction_Parameters0;\n                        return this._currentInstruction_Parameters0;\n                    case ChiChiNES.AddressingModes.Accumulator: \n                        return this._accumulator;\n                    default: \n                        this.DataBus = this.GetByte$1(this.DecodeAddress());\n                        return this.DataBus;\n                }\n            },\n            StoreOperand: function (address) { },\n            Execute: function () {\n                switch (this._currentInstruction_OpCode) {\n                    case 128: \n                    case 130: \n                    case 194: \n                    case 226: \n                    case 4: \n                    case 20: \n                    case 52: \n                    case 68: \n                    case 84: \n                    case 100: \n                    case 116: \n                    case 212: \n                    case 244: \n                    case 12: \n                    case 28: \n                    case 60: \n                    case 92: \n                    case 124: \n                    case 220: \n                    case 252: \n                        //SKB()\n                        //SKW();\n                        this.DecodeAddress();\n                        break;\n                    case 105: \n                    case 101: \n                    case 117: \n                    case 109: \n                    case 125: \n                    case 121: \n                    case 97: \n                    case 113: \n                        this.ADC();\n                        break;\n                    case 41: \n                    case 37: \n                    case 53: \n                    case 45: \n                    case 61: \n                    case 57: \n                    case 33: \n                    case 49: \n                        this.AND();\n                        break;\n                    case 10: \n                    case 6: \n                    case 22: \n                    case 14: \n                    case 30: \n                        this.ASL();\n                        break;\n                    case 144: \n                        this.BCC();\n                        break;\n                    case 176: \n                        this.BCS();\n                        break;\n                    case 240: \n                        this.BEQ();\n                        break;\n                    case 36: \n                    case 44: \n                        this.BIT();\n                        break;\n                    case 48: \n                        this.BMI();\n                        break;\n                    case 208: \n                        this.BNE();\n                        break;\n                    case 16: \n                        this.BPL();\n                        break;\n                    case 0: \n                        this.BRK();\n                        break;\n                    case 80: \n                        this.BVC();\n                        break;\n                    case 112: \n                        this.BVS();\n                        break;\n                    case 24: \n                        this.CLC();\n                        break;\n                    case 216: \n                        this.CLD();\n                        break;\n                    case 88: \n                        this.CLI();\n                        break;\n                    case 184: \n                        this.CLV();\n                        break;\n                    case 201: \n                    case 197: \n                    case 213: \n                    case 205: \n                    case 221: \n                    case 217: \n                    case 193: \n                    case 209: \n                        this.CMP();\n                        break;\n                    case 224: \n                    case 228: \n                    case 236: \n                        this.CPX();\n                        break;\n                    case 192: \n                    case 196: \n                    case 204: \n                        this.CPY();\n                        break;\n                    case 198: \n                    case 214: \n                    case 206: \n                    case 222: \n                        this.DEC();\n                        break;\n                    case 202: \n                        this.DEX();\n                        break;\n                    case 136: \n                        this.DEY();\n                        break;\n                    case 73: \n                    case 69: \n                    case 85: \n                    case 77: \n                    case 93: \n                    case 89: \n                    case 65: \n                    case 81: \n                        this.EOR();\n                        break;\n                    case 230: \n                    case 246: \n                    case 238: \n                    case 254: \n                        this.INC();\n                        break;\n                    case 232: \n                        this.INX();\n                        break;\n                    case 200: \n                        this.INY();\n                        break;\n                    case 76: \n                    case 108: \n                        this.JMP();\n                        break;\n                    case 32: \n                        this.JSR();\n                        break;\n                    case 169: \n                    case 165: \n                    case 181: \n                    case 173: \n                    case 189: \n                    case 185: \n                    case 161: \n                    case 177: \n                        this.LDA();\n                        break;\n                    case 162: \n                    case 166: \n                    case 182: \n                    case 174: \n                    case 190: \n                        this.LDX();\n                        break;\n                    case 160: \n                    case 164: \n                    case 180: \n                    case 172: \n                    case 188: \n                        this.LDY();\n                        break;\n                    case 74: \n                    case 70: \n                    case 86: \n                    case 78: \n                    case 94: \n                        this.LSR();\n                        break;\n                    case 234: \n                    case 26: \n                    case 58: \n                    case 90: \n                    case 122: \n                    case 218: \n                    case 250: \n                    case 137: \n                        //case 0x04:\n                        //case 0x14:\n                        //case 0x34:\n                        //case 0x44:\n                        //case 0x64:\n                        //case 0x80:\n                        //case 0x82:\n                        //case 0xc2:\n                        //case 0xd4:\n                        //case 0xe2:\n                        //case 0xf4:\n                        //case 0x0c:\n                        //case 0x1c:\n                        //case 0x3c:\n                        //case 0x5c:\n                        //case 0x7c:\n                        //case 0xdc:\n                        //case 0xfc:\n                        this.NOP();\n                        break;\n                    case 9: \n                    case 5: \n                    case 21: \n                    case 13: \n                    case 29: \n                    case 25: \n                    case 1: \n                    case 17: \n                        this.ORA();\n                        break;\n                    case 72: \n                        this.PHA();\n                        break;\n                    case 8: \n                        this.PHP();\n                        break;\n                    case 104: \n                        this.PLA();\n                        break;\n                    case 40: \n                        this.PLP();\n                        break;\n                    case 42: \n                    case 38: \n                    case 54: \n                    case 46: \n                    case 62: \n                        this.ROL();\n                        break;\n                    case 106: \n                    case 102: \n                    case 118: \n                    case 110: \n                    case 126: \n                        this.ROR();\n                        break;\n                    case 64: \n                        this.RTI();\n                        break;\n                    case 96: \n                        this.RTS();\n                        break;\n                    case 235: \n                    case 233: \n                    case 229: \n                    case 245: \n                    case 237: \n                    case 253: \n                    case 249: \n                    case 225: \n                    case 241:  // undocumented sbc immediate\n                        this.SBC();\n                        break;\n                    case 56: \n                        this.SEC();\n                        break;\n                    case 248: \n                        this.SED();\n                        break;\n                    case 120: \n                        this.SEI();\n                        break;\n                    case 133: \n                    case 149: \n                    case 141: \n                    case 157: \n                    case 153: \n                    case 129: \n                    case 145: \n                        this.STA();\n                        break;\n                    case 134: \n                    case 150: \n                    case 142: \n                        this.STX();\n                        break;\n                    case 132: \n                    case 148: \n                    case 140: \n                        this.STY();\n                        break;\n                    case 170: \n                        this.TAX();\n                        break;\n                    case 168: \n                        this.TAY();\n                        break;\n                    case 186: \n                        this.TSX();\n                        break;\n                    case 138: \n                        this.TXA();\n                        break;\n                    case 154: \n                        this.TXS();\n                        break;\n                    case 152: \n                        this.TYA();\n                        break;\n                    case 11: \n                    case 43: \n                        this.AAC();\n                        break;\n                    case 75: \n                        this.ASR();\n                        break;\n                    case 107: \n                        this.ARR();\n                        break;\n                    case 171: \n                        this.ATX();\n                        break;\n                }\n            },\n            SetZNFlags: function (data) {\n\n                //zeroResult = (data & 0xFF) == 0;\n                //negativeResult = (data & 0x80) == 0x80;\n\n                if ((data & 255) === 0) {\n                    this._statusRegister = this._statusRegister | 2;\n                } else {\n                    this._statusRegister = this._statusRegister & (-3);\n                } // ((int)CPUStatusMasks.ZeroResultMask);\n\n                if ((data & 128) === 128) {\n                    this._statusRegister = this._statusRegister | 128;\n                } else {\n                    this._statusRegister = this._statusRegister & (-129);\n                } // ((int)CPUStatusMasks.NegativeResultMask);\n                //SetFlag(CPUStatusBits.ZeroResult, (data & 0xFF) == 0);\n                //SetFlag(CPUStatusBits.NegativeResult, (data & 0x80) == 0x80);\n            },\n            LDA: function () {\n\n                this._accumulator = this.DecodeOperand();\n\n                this.SetZNFlags(this._accumulator);\n\n            },\n            LDX: function () {\n\n                this._indexRegisterX = this.DecodeOperand();\n                this.SetZNFlags(this._indexRegisterX);\n            },\n            LDY: function () {\n                this._indexRegisterY = this.DecodeOperand();\n                this.SetZNFlags(this._indexRegisterY);\n            },\n            STA: function () {\n                this.SetByte$1(this.DecodeAddress(), this._accumulator);\n            },\n            STX: function () {\n                this.SetByte$1(this.DecodeAddress(), this._indexRegisterX);\n            },\n            STY: function () {\n                this.SetByte$1(this.DecodeAddress(), this._indexRegisterY);\n            },\n            SED: function () {\n                this.SetFlag(ChiChiNES.CPUStatusMasks.DecimalModeMask, true);\n                // StatusRegister = StatusRegister | 0x8;\n            },\n            CLD: function () {\n                this.SetFlag(ChiChiNES.CPUStatusMasks.DecimalModeMask, false);\n                //            StatusRegister = StatusRegister & 0xF7;\n            },\n            JMP: function () {\n                // 6052 indirect jmp bug\n                if (this._currentInstruction_AddressingMode === ChiChiNES.AddressingModes.Indirect && this._currentInstruction_Parameters0 === 255) {\n                    this._programCounter = 255 | this._currentInstruction_Parameters1 << 8;\n                } else {\n                    this._programCounter = this.DecodeAddress();\n                }\n            },\n            DEC: function () {\n                var val = (this.DecodeOperand()) & 255;\n                val = (val - 1) & 255;\n                this.SetByte$1(this.DecodeAddress(), val);\n                this.SetZNFlags(val);\n            },\n            INC: function () {\n                var val = (this.DecodeOperand()) & 255;\n                val = (val + 1) & 255;\n                this.SetByte$1(this.DecodeAddress(), val);\n                this.SetZNFlags(val);\n            },\n            ADC: function () {\n                // start the read process\n                var data = this.DecodeOperand();\n                var carryFlag = (this._statusRegister & 1);\n                var result = (((((this._accumulator + data) | 0) + carryFlag) | 0));\n\n                // carry flag\n\n                this.SetFlag(ChiChiNES.CPUStatusMasks.CarryMask, result > 255);\n\n                // overflow flag\n                // SetFlag(CPUStatusBits.Overflow, (result > 0x7f || ~result > 0x7f));\n                this.SetFlag(ChiChiNES.CPUStatusMasks.OverflowMask, ((this._accumulator ^ data) & 128) !== 128 && ((this._accumulator ^ result) & 128) === 128);\n\n                // occurs when bit 7 is set\n                this._accumulator = result & 255;\n                this.SetZNFlags(this._accumulator);\n\n            },\n            LSR: function () {\n                var rst = this.DecodeOperand();\n                //LSR shifts all bits right one position. 0 is shifted into bit 7 and the original bit 0 is shifted into the Carry. \n\n                this.SetFlag(ChiChiNES.CPUStatusMasks.CarryMask, (rst & 1) === 1);\n                //target.SetFlag(CPUStatusBits.Carry, (rst & 1) == 1);\n                rst = rst >> 1 & 255;\n\n                this.SetZNFlags(rst);\n\n                if (this._currentInstruction_AddressingMode === ChiChiNES.AddressingModes.Accumulator) {\n                    this._accumulator = rst;\n                } else {\n                    this.SetByte$1(this.DecodeAddress(), rst);\n                }\n            },\n            SKB: function () {\n                // _programCounter++;\n            },\n            SBC: function () {\n                // start the read process\n\n                var data = (this.DecodeOperand()) >>> 0;\n\n                var carryFlag = ((this._statusRegister ^ 1) & 1);\n\n                var result = System.Int64.clipu32(System.Int64(this._accumulator).sub(System.Int64(data)).sub(System.Int64(carryFlag)));\n\n                // set overflow flag if sign bit of accumulator changed\n                this.SetFlag(ChiChiNES.CPUStatusMasks.OverflowMask, ((System.Int64(this._accumulator).xor(System.Int64(result))).and(System.Int64(128))).equals(System.Int64(128)) && ((System.Int64(this._accumulator).xor(System.Int64(data))).and(System.Int64(128))).equals(System.Int64(128)));\n\n                this.SetFlag(ChiChiNES.CPUStatusMasks.CarryMask, (result < 256));\n\n                this._accumulator = result | 0;\n                this.SetZNFlags(this._accumulator);\n\n\n            },\n            AND: function () {\n                this._accumulator = (this._accumulator & this.DecodeOperand());\n                this.SetZNFlags(this._accumulator);\n            },\n            ORA: function () {\n\n                this._accumulator = (this._accumulator | this.DecodeOperand());\n                this.SetZNFlags(this._accumulator);\n            },\n            EOR: function () {\n                this._accumulator = (this._accumulator ^ this.DecodeOperand());\n                this.SetZNFlags(this.Accumulator);\n            },\n            ASL: function () {\n                var data = this.DecodeOperand();\n                // set carry flag\n\n                this.SetFlag(ChiChiNES.CPUStatusMasks.CarryMask, ((data & 128) === 128));\n\n                data = (data << 1) & 254;\n\n                if (this._currentInstruction_AddressingMode === ChiChiNES.AddressingModes.Accumulator) {\n                    this._accumulator = data;\n                } else {\n                    this.SetByte$1(this.DecodeAddress(), data);\n                }\n\n\n                this.SetZNFlags(data);\n            },\n            BIT: function () {\n\n                var operand = this.DecodeOperand();\n                // overflow is bit 6\n                this.SetFlag(ChiChiNES.CPUStatusMasks.OverflowMask, (operand & 64) === 64);\n                //if ((operand & 64) == 64)\n                //{\n                //    _statusRegister = _statusRegister | 0x40;\n                //}\n                //else\n                //{\n                //    _statusRegister = _statusRegister & 0xBF;\n                //}\n\n                // negative is bit 7\n                if ((operand & 128) === 128) {\n                    this._statusRegister = this._statusRegister | 128;\n                } else {\n                    this._statusRegister = this._statusRegister & 127;\n                }\n\n                if ((operand & this.Accumulator) === 0) {\n                    this._statusRegister = this._statusRegister | 2;\n                } else {\n                    this._statusRegister = this._statusRegister & 253;\n                }\n\n            },\n            SEC: function () {\n                // carry flag bit 0\n                this.SetFlag(ChiChiNES.CPUStatusMasks.CarryMask, true);\n            },\n            CLC: function () {\n                this.SetFlag(ChiChiNES.CPUStatusMasks.CarryMask, false);\n            },\n            SEI: function () {\n                //StatusRegister = StatusRegister | 0x4;\n                this.SetFlag(ChiChiNES.CPUStatusMasks.InterruptDisableMask, true);\n            },\n            CLI: function () {\n                //            StatusRegister = StatusRegister & 0xFB;\n                this.SetFlag(ChiChiNES.CPUStatusMasks.InterruptDisableMask, false);\n            },\n            CLV: function () {\n                this.SetFlag(ChiChiNES.CPUStatusMasks.OverflowMask, false);\n\n            },\n            Compare: function (data) {\n                this.SetFlag(ChiChiNES.CPUStatusMasks.CarryMask, data > 255);\n                this.SetZNFlags(data & 255);\n            },\n            CMP: function () {\n                var data = (((((this.Accumulator + 256) | 0) - this.DecodeOperand()) | 0));\n                this.Compare(data);\n            },\n            CPX: function () {\n                var data = (((((this._indexRegisterX + 256) | 0) - this.DecodeOperand()) | 0));\n                this.Compare(data);\n            },\n            CPY: function () {\n                var data = (((((this._indexRegisterY + 256) | 0) - this.DecodeOperand()) | 0));\n                this.Compare(data);\n            },\n            NOP: function () {\n                if (this._currentInstruction_AddressingMode === ChiChiNES.AddressingModes.AbsoluteX) {\n                    this.DecodeAddress();\n                }\n            },\n            Branch: function () {\n                System.Diagnostics.Debug.assert(ChiChiNES.CPU2A03.cpuTiming[this._currentInstruction_OpCode] === 2);\n\n                this._currentInstruction_ExtraTiming = 1;\n                var addr = this._currentInstruction_Parameters0 & 255;\n                if ((addr & 128) === 128) {\n                    addr = (addr - 256) | 0;\n                    this._programCounter = (this._programCounter + addr) | 0;\n                } else {\n                    this._programCounter = (this._programCounter + addr) | 0;\n                }\n\n                if ((this._programCounter & 255) < addr) {\n                    this._currentInstruction_ExtraTiming = 2;\n                }\n\n            },\n            BCC: function () {\n\n                if ((this._statusRegister & 1) !== 1) {\n                    this.Branch();\n                }\n            },\n            BCS: function () {\n                if ((this._statusRegister & 1) === 1) {\n                    this.Branch();\n                }\n            },\n            BPL: function () {\n                if ((this._statusRegister & 128) !== 128) {\n                    this.Branch();\n                }\n            },\n            BMI: function () {\n                if ((this._statusRegister & 128) === 128) {\n                    this.Branch();\n                }\n            },\n            BVC: function () {\n                if ((this._statusRegister & 64) !== 64) {\n                    this.Branch();\n                }\n            },\n            BVS: function () {\n                if ((this._statusRegister & 64) === 64) {\n                    this.Branch();\n                }\n            },\n            BNE: function () {\n                if ((this._statusRegister & 2) !== 2) {\n                    this.Branch();\n                }\n            },\n            BEQ: function () {\n                if ((this._statusRegister & 2) === 2) {\n                    this.Branch();\n                }\n            },\n            DEX: function () {\n                this._indexRegisterX = (this._indexRegisterX - 1) | 0;\n                this._indexRegisterX = this._indexRegisterX & 255;\n                this.SetZNFlags(this._indexRegisterX);\n            },\n            DEY: function () {\n                this._indexRegisterY = (this._indexRegisterY - 1) | 0;\n                this._indexRegisterY = this._indexRegisterY & 255;\n                this.SetZNFlags(this._indexRegisterY);\n            },\n            INX: function () {\n                this._indexRegisterX = (this._indexRegisterX + 1) | 0;\n                this._indexRegisterX = this._indexRegisterX & 255;\n                this.SetZNFlags(this._indexRegisterX);\n            },\n            INY: function () {\n                this._indexRegisterY = (this._indexRegisterY + 1) | 0;\n                this._indexRegisterY = this._indexRegisterY & 255;\n                this.SetZNFlags(this._indexRegisterY);\n            },\n            TAX: function () {\n                this._indexRegisterX = this._accumulator;\n                this.SetZNFlags(this._indexRegisterX);\n\n            },\n            TXA: function () {\n                this._accumulator = this._indexRegisterX;\n                this.SetZNFlags(this._accumulator);\n            },\n            TAY: function () {\n                this._indexRegisterY = this._accumulator;\n                this.SetZNFlags(this._indexRegisterY);\n            },\n            TYA: function () {\n                this._accumulator = this._indexRegisterY;\n                this.SetZNFlags(this._accumulator);\n            },\n            TXS: function () {\n                this._stackPointer = this._indexRegisterX;\n            },\n            TSX: function () {\n                this._indexRegisterX = this._stackPointer;\n                this.SetZNFlags(this._indexRegisterX);\n            },\n            PHA: function () {\n                this.PushStack(this._accumulator);\n            },\n            PLA: function () {\n                this._accumulator = this.PopStack();\n                this.SetZNFlags(this._accumulator);\n            },\n            PHP: function () {\n                //PHP and BRK push the current status with bits 4 and 5 set on the stack; \n                // BRK then sets the I flag.\n                var newStatus = this._statusRegister | 16 | 32;\n                this.PushStack(newStatus);\n            },\n            PLP: function () {\n                this._statusRegister = this.PopStack(); // | 0x20;\n            },\n            JSR: function () {\n                this.PushStack((this._programCounter >> 8) & 255);\n                this.PushStack((((this._programCounter - 1) | 0)) & 255);\n\n                this._programCounter = this.DecodeAddress();\n            },\n            ROR: function () {\n                var data = this.DecodeOperand();\n\n                // old carry bit shifted into bit 7\n                var oldbit = 0;\n                if (this.GetFlag(ChiChiNES.CPUStatusMasks.CarryMask)) {\n                    oldbit = 128;\n                }\n\n                // original bit 0 shifted to carry\n                //            target.SetFlag(CPUStatusBits.Carry, (); \n\n                this.SetFlag(ChiChiNES.CPUStatusMasks.CarryMask, (data & 1) === 1);\n\n                data = (data >> 1) | oldbit;\n\n                this.SetZNFlags(data);\n\n                if (this._currentInstruction_AddressingMode === ChiChiNES.AddressingModes.Accumulator) {\n                    this._accumulator = data;\n                } else {\n                    this.SetByte$1(this.DecodeAddress(), data);\n                }\n            },\n            ROL: function () {\n                var data = this.DecodeOperand();\n\n                var oldbit = 0;\n                if (this.GetFlag(ChiChiNES.CPUStatusMasks.CarryMask)) {\n                    oldbit = 1;\n                }\n                this.SetFlag(ChiChiNES.CPUStatusMasks.CarryMask, (data & 128) === 128);\n\n                data = data << 1;\n                data = data & 255;\n                data = data | oldbit;\n                this.SetZNFlags(data);\n\n                if (this._currentInstruction_AddressingMode === ChiChiNES.AddressingModes.Accumulator) {\n                    this._accumulator = data;\n                } else {\n                    this.SetByte$1(this.DecodeAddress(), data);\n                }\n            },\n            RTS: function () {\n                var high, low;\n                low = (((this.PopStack() + 1) | 0)) & 255;\n                high = this.PopStack();\n                this._programCounter = ((high << 8) | low);\n            },\n            RTI: function () {\n                this._statusRegister = this.PopStack(); // | 0x20;\n                var low = this.PopStack();\n                var high = this.PopStack();\n                this._programCounter = ((((Bridge.Int.mul(256, high)) + low) | 0));\n            },\n            BRK: function () {\n                //BRK causes a non-maskable interrupt and increments the program counter by one. \n                //Therefore an RTI will go to the address of the BRK +2 so that BRK may be used to replace a two-byte instruction \n                // for debugging and the subsequent RTI will be correct. \n                // push pc onto stack (high byte first)\n                this._programCounter = (this._programCounter + 1) | 0;\n                this.PushStack(this._programCounter >> 8 & 255);\n                this.PushStack(this._programCounter & 255);\n                // push sr onto stack\n\n                //PHP and BRK push the current status with bits 4 and 5 set on the stack; \n\n                var newStatus = this._statusRegister | 16 | 32;\n\n                this.PushStack(newStatus);\n\n                // set interrupt disable, and break flags\n                // BRK then sets the I flag.\n                this._statusRegister = this._statusRegister | 20;\n\n                // point pc to interrupt service routine\n                this.AddressBus = 65534;\n                var lowByte = this.GetByte();\n                this.AddressBus = 65535;\n                var highByte = this.GetByte();\n\n                this._programCounter = (lowByte + Bridge.Int.mul(highByte, 256)) | 0;\n            },\n            AAC: function () {\n                //AND byte with accumulator. If result is negative then carry is set.\n                //Status flags: N,Z,C\n                this._accumulator = this.DecodeOperand() & this._accumulator & 255;\n\n                this.SetFlag(ChiChiNES.CPUStatusMasks.CarryMask, (this._accumulator & 128) === 128);\n\n                this.SetZNFlags(this._accumulator);\n\n            },\n            ASR: function () {\n                //AND byte with accumulator, then shift right one bit in accumu-lator.\n                //Status flags: N,Z,C\n                this._accumulator = this.DecodeOperand() & this._accumulator;\n\n                this.SetFlag(ChiChiNES.CPUStatusMasks.CarryMask, (this._accumulator & 1) === 1);\n                this._accumulator = this._accumulator >> 1;\n\n                this.SetZNFlags(this._accumulator);\n\n            },\n            ARR: function () {\n                //AND byte with accumulator, then rotate one bit right in accu - mulator and\n                //  check bit 5 and 6:\n                //If both bits are 1: set C, clear V. 0x30\n                //If both bits are 0: clear C and V.\n                //If only bit 5 is 1: set V, clear C.\n                //If only bit 6 is 1: set C and V.\n                //Status flags: N,V,Z,C\n                this._accumulator = this.DecodeOperand() & this._accumulator;\n\n                if ((this._statusRegister & 1) === 1) {\n                    this._accumulator = (this._accumulator >> 1) | 128;\n                } else {\n                    this._accumulator = (this._accumulator >> 1);\n                }\n\n                // original bit 0 shifted to carry\n                //            target.SetFlag(CPUStatusBits.Carry, (); \n\n                this.SetFlag(ChiChiNES.CPUStatusMasks.CarryMask, (this._accumulator & 1) === 1);\n\n\n                switch (this._accumulator & 48) {\n                    case 48: \n                        this.SetFlag(ChiChiNES.CPUStatusMasks.CarryMask, true);\n                        this.SetFlag(ChiChiNES.CPUStatusMasks.InterruptDisableMask, false);\n                        break;\n                    case 0: \n                        this.SetFlag(ChiChiNES.CPUStatusMasks.CarryMask, false);\n                        this.SetFlag(ChiChiNES.CPUStatusMasks.InterruptDisableMask, false);\n                        break;\n                    case 16: \n                        this.SetFlag(ChiChiNES.CPUStatusMasks.CarryMask, false);\n                        this.SetFlag(ChiChiNES.CPUStatusMasks.InterruptDisableMask, true);\n                        break;\n                    case 32: \n                        this.SetFlag(ChiChiNES.CPUStatusMasks.CarryMask, true);\n                        this.SetFlag(ChiChiNES.CPUStatusMasks.InterruptDisableMask, true);\n                        break;\n                }\n            },\n            ATX: function () {\n                //AND byte with accumulator, then transfer accumulator to X register.\n                //Status flags: N,Z\n                this._indexRegisterX = (this._accumulator = this.DecodeOperand() & this._accumulator);\n                this.SetZNFlags(this._indexRegisterX);\n            },\n            NMIHandler: function () {\n                this._handleNMI = true;\n            },\n            IRQUpdater: function () {\n                this._handleIRQ = !!(this.soundBopper.ChiChiNES$IClockedMemoryMappedIOElement$IRQAsserted | this._cart.ChiChiNES$IClockedMemoryMappedIOElement$IRQAsserted);\n            },\n            LoadBytes: function (offset, bytes) {\n                System.Array.copy(bytes, 0, this.Rams, offset, bytes.length);\n            },\n            LoadBytes$1: function (offset, bytes, length) {\n                System.Array.copy(bytes, 0, this.Rams, offset, length);\n            },\n            PushStack: function (data) {\n                this.Rams[((this._stackPointer + 256) | 0)] = data & 255;\n                this._stackPointer = (this._stackPointer - 1) | 0;\n                if (this._stackPointer < 0) {\n                    this._stackPointer = 255;\n                }\n            },\n            PopStack: function () {\n                this._stackPointer = (this._stackPointer + 1) | 0;\n                if (this._stackPointer > 255) {\n                    this._stackPointer = 0;\n                }\n                return this.Rams[((this._stackPointer + 256) | 0)] & 255;\n            },\n            GetByte: function () {\n                this.DataBus = this.GetByte$1(this.AddressBus);\n                return this.DataBus;\n            },\n            GetByte$1: function (address) {\n                var result = 0;\n\n\n                // check high byte, find appropriate handler\n                switch (address & 61440) {\n                    case 0: \n                    case 4096: \n                        if (address < 2048) {\n                            result = this.Rams[address];\n                        } else {\n                            result = address >> 8;\n                        }\n                        break;\n                    case 8192: \n                    case 12288: \n                        result = this._pixelWhizzler.ChiChiNES$IPPU$GetByte(this.clock, address);\n                        break;\n                    case 16384: \n                        switch (address) {\n                            case 16406: \n                                result = this._padOne.GetByte(this.clock, address);\n                                break;\n                            case 16407: \n                                //result = _padTwo.GetByte(clock, address);\n                                break;\n                            case 16405: \n                                result = this.soundBopper.ChiChiNES$IClockedMemoryMappedIOElement$GetByte(this.clock, address);\n                                break;\n                            default: \n                                // return open bus?\n                                result = address >> 8;\n                                break;\n                        }\n                        break;\n                    case 20480: \n                        // ??\n                        result = address >> 8;\n                        break;\n                    case 24576: \n                    case 28672: \n                    case 32768: \n                    case 36864: \n                    case 40960: \n                    case 45056: \n                    case 49152: \n                    case 53248: \n                    case 57344: \n                    case 61440: \n                        // cart \n                        result = this._cart.ChiChiNES$IClockedMemoryMappedIOElement$GetByte(this.clock, address);\n                        break;\n                    default: \n                        throw new System.Exception(\"Bullshit!\");\n                }\n                if (this._cheating && this.memoryPatches.containsKey(address)) {\n\n                    return this.memoryPatches.get(address).ChiChiNES$Hacking$IMemoryPatch$Activated ? this.memoryPatches.get(address).ChiChiNES$Hacking$IMemoryPatch$GetData(result) & 255 : result & 255;\n                }\n\n                return result & 255;\n            },\n            PeekByte: function (address) {\n                var result = 0;\n\n\n                // check high byte, find appropriate handler\n                switch (address & 61440) {\n                    case 0: \n                    case 4096: \n                        if (address < 2048) {\n                            result = this.Rams[address];\n                        } else {\n                            result = address >> 8;\n                        }\n                        break;\n                    case 8192: \n                    case 12288: \n                        result = this._pixelWhizzler.ChiChiNES$IPPU$GetByte(this.clock, address);\n                        break;\n                    case 16384: \n                        switch (address) {\n                            case 16406: \n                                result = 0; //  _padOne.GetByte(clock, address);\n                                break;\n                            case 16407: \n                                //result = _padTwo.GetByte(clock, address);\n                                break;\n                            case 16405: \n                                result = 0; //  soundBopper.GetByte(clock, address);\n                                break;\n                            default: \n                                // return open bus?\n                                result = address >> 8;\n                                break;\n                        }\n                        break;\n                    case 20480: \n                        // ??\n                        result = address >> 8;\n                        break;\n                    case 24576: \n                    case 28672: \n                    case 32768: \n                    case 36864: \n                    case 40960: \n                    case 45056: \n                    case 49152: \n                    case 53248: \n                    case 57344: \n                    case 61440: \n                        // cart \n                        result = this._cart.ChiChiNES$IClockedMemoryMappedIOElement$GetByte(this.clock, address);\n                        break;\n                    default: \n                        throw new System.Exception(\"Bullshit!\");\n                }\n                if (this._cheating && this.memoryPatches.containsKey(address)) {\n\n                    return this.memoryPatches.get(address).ChiChiNES$Hacking$IMemoryPatch$Activated ? this.memoryPatches.get(address).ChiChiNES$Hacking$IMemoryPatch$GetData(result) & 255 : result & 255;\n                }\n\n                return result & 255;\n            },\n            /**\n             * gets an array of cpu memory, without affecting emulation\n             *\n             * @instance\n             * @public\n             * @this ChiChiNES.CPU2A03\n             * @memberof ChiChiNES.CPU2A03\n             * @param   {number}            start     \n             * @param   {number}            finish\n             * @return  {Array.<number>}\n             */\n            PeekBytes: function (start, finish) {\n                var array = System.Array.init(((finish - start) | 0), 0, System.Int32);\n                for (var i = 0; i < ((finish - start) | 0); i = (i + 1) | 0) {\n                    array[i] = this.PeekByte(((start + i) | 0));\n                }\n                return array;\n            },\n            SetByte: function () {\n\n                this.SetByte$1(this.AddressBus, this.DataBus & 255);\n            },\n            SetByte$1: function (address, data) {\n                // check high byte, find appropriate handler\n                if (address < 2048) {\n                    this.Rams[address & 2047] = data & 255;\n                    return;\n                }\n                switch (address & 61440) {\n                    case 0: \n                    case 4096: \n                        // nes sram\n                        this.Rams[address & 2047] = data & 255;\n                        break;\n                    case 20480: \n                        this.Cart.ChiChiNES$IClockedMemoryMappedIOElement$SetByte(this.clock, address, data);\n                        break;\n                    case 24576: \n                    case 28672: \n                    case 32768: \n                    case 36864: \n                    case 40960: \n                    case 45056: \n                    case 49152: \n                    case 53248: \n                    case 57344: \n                    case 61440: \n                        // cart rom banks\n                        this.Cart.ChiChiNES$IClockedMemoryMappedIOElement$SetByte(this.clock, address, data);\n                        break;\n                    case 8192: \n                    case 12288: \n                        this._pixelWhizzler.ChiChiNES$IPPU$SetByte(this.clock, address, data);\n                        break;\n                    case 16384: \n                        switch (address) {\n                            case 16384: \n                            case 16385: \n                            case 16386: \n                            case 16387: \n                            case 16388: \n                            case 16389: \n                            case 16390: \n                            case 16391: \n                            case 16392: \n                            case 16393: \n                            case 16394: \n                            case 16395: \n                            case 16396: \n                            case 16397: \n                            case 16398: \n                            case 16399: \n                            case 16405: \n                            case 16407: \n                                this.soundBopper.ChiChiNES$IClockedMemoryMappedIOElement$SetByte(this.clock, address, data);\n                                break;\n                            case 16404: \n                                this._pixelWhizzler.ChiChiNES$IPPU$CopySprites(Bridge.ref(this, \"Rams\"), Bridge.Int.mul(data, 256));\n                                this._currentInstruction_ExtraTiming = (this._currentInstruction_ExtraTiming + 512) | 0;\n                                break;\n                            case 16406: \n                                this._padOne.SetByte(this.clock, address, data & 1);\n                                //  _padTwo.SetByte(clock, address, data & 1);\n                                break;\n                        }\n                        break;\n                }\n            },\n            FindNextEvent: function () {\n                // it'll either be the ppu's NMI, or an irq from either the apu or the cart\n                this.nextEvent = (this.clock + this._pixelWhizzler.ChiChiNES$IPPU$NextEventAt) | 0;\n\n            },\n            HandleNextEvent: function () {\n                this._pixelWhizzler.ChiChiNES$IPPU$HandleEvent(this.Clock);\n                this.FindNextEvent();\n            },\n            ResetInstructionHistory: function () {\n                //_instructionHistory = new Instruction[0x100];\n                this.instructionHistoryPointer = 255;\n\n            },\n            WriteInstructionHistoryAndUsage: function () {\n                var $t;\n\n                this._instructionHistory[(Bridge.identity(this.instructionHistoryPointer, (this.instructionHistoryPointer = (this.instructionHistoryPointer - 1) | 0))) & 255] = ($t = new ChiChiNES.CPU2A03.Instruction.ctor(), $t.time = this.systemClock, $t.A = this._accumulator, $t.X = this._indexRegisterX, $t.Y = this._indexRegisterY, $t.SR = this._statusRegister, $t.SP = this._stackPointer, $t.frame = this.clock, $t.OpCode = this._currentInstruction_OpCode, $t.Parameters0 = this._currentInstruction_Parameters0, $t.Parameters1 = this._currentInstruction_Parameters1, $t.Address = this._currentInstruction_Address, $t.AddressingMode = this._currentInstruction_AddressingMode, $t.ExtraTiming = this._currentInstruction_ExtraTiming, $t);\n                this.instructionUsage[this._currentInstruction_OpCode] = (this.instructionUsage[this._currentInstruction_OpCode] + 1) | 0;\n                if ((this.instructionHistoryPointer & 255) === 255) {\n                    this.FireDebugEvent(\"instructionHistoryFull\");\n                }\n\n            },\n            FireDebugEvent: function (s) {\n                !Bridge.staticEquals(this.DebugEvent, null) ? this.DebugEvent(this, { }) : null;\n            },\n            PeekInstruction: function (address) {\n                //TODO: this needs to be non-invasive\n                var inst = new ChiChiNES.CPU2A03.Instruction.ctor();\n\n                //inst.OpCode = GetByte(address++);\n                //inst.AddressingMode = addressmode[inst.OpCode];\n                //inst.Length = 1;\n                //FetchInstructionParameters(ref inst, address);\n                return inst;\n            }\n        }\n    });\n\n    Bridge.define(\"ChiChiNES.CPU2A03.Instruction\", {\n        fields: {\n            AddressingMode: 0,\n            frame: 0,\n            time: System.UInt64(0),\n            A: 0,\n            X: 0,\n            Y: 0,\n            SR: 0,\n            SP: 0,\n            Address: 0,\n            OpCode: 0,\n            Parameters0: 0,\n            Parameters1: 0,\n            ExtraTiming: 0,\n            Length: 0\n        },\n        ctors: {\n            ctor: function () {\n                this.$initialize();\n            },\n            $ctor1: function (inst) {\n                this.$initialize();\n                this.AddressingMode = inst.AddressingMode;\n                this.Address = inst.Address;\n                this.OpCode = inst.OpCode;\n                this.Parameters0 = inst.Parameters0;\n                this.Parameters1 = inst.Parameters1;\n                this.ExtraTiming = inst.ExtraTiming;\n                this.Length = inst.Length;\n\n\n            }\n        }\n    });\n\n    Bridge.define(\"ChiChiNES.CPUStatusBits\", {\n        $kind: \"enum\",\n        statics: {\n            fields: {\n                Carry: 0,\n                ZeroResult: 1,\n                InterruptDisable: 2,\n                DecimalMode: 3,\n                BreakCommand: 4,\n                Expansion: 5,\n                Overflow: 6,\n                NegativeResult: 7\n            }\n        }\n    });\n\n    Bridge.define(\"ChiChiNES.CPUStatusMasks\", {\n        $kind: \"enum\",\n        statics: {\n            fields: {\n                CarryMask: 1,\n                ZeroResultMask: 2,\n                InterruptDisableMask: 4,\n                DecimalModeMask: 8,\n                BreakCommandMask: 16,\n                ExpansionMask: 32,\n                OverflowMask: 64,\n                NegativeResultMask: 128\n            }\n        }\n    });\n\n    Bridge.define(\"ChiChiNES.Hacking.IMemoryPatch\", {\n        $kind: \"interface\"\n    });\n\n    Bridge.define(\"ChiChiNES.IControlPad\", {\n        inherits: [System.IDisposable],\n        $kind: \"interface\"\n    });\n\n    Bridge.define(\"ChiChiNES.IMemoryMappedIOElement\", {\n        $kind: \"interface\"\n    });\n\n    Bridge.define(\"ChiChiNES.Interaction.CallbackType\", {\n        $kind: \"enum\",\n        statics: {\n            fields: {\n                None: 0,\n                NoArgs: 1,\n                Array: 2,\n                IntPtr: 3\n            }\n        }\n    });\n\n    /** @namespace ChiChiNES.Interaction */\n\n    /**\n     * Defines what the main windows interaction with the current renderer\n     *\n     * @abstract\n     * @public\n     * @class ChiChiNES.Interaction.IDisplayContext\n     */\n    Bridge.define(\"ChiChiNES.Interaction.IDisplayContext\", {\n        $kind: \"interface\"\n    });\n\n    Bridge.define(\"ChiChiNES.Interaction.InvalidDisplayContextException\", {\n        inherits: [System.Exception],\n        ctors: {\n            ctor: function (s) {\n                this.$initialize();\n                System.Exception.ctor.call(this, s);\n            },\n            $ctor1: function (s, innerException) {\n                this.$initialize();\n                System.Exception.ctor.call(this, s, innerException);\n            }\n        }\n    });\n\n    Bridge.define(\"ChiChiNES.Interaction.NESDisplayPluginAttribute\", {\n        inherits: [System.Attribute]\n    });\n\n    Bridge.define(\"ChiChiNES.Interaction.NESPixelFormats\", {\n        $kind: \"enum\",\n        statics: {\n            fields: {\n                RGB: 0,\n                BGR: 1,\n                Indexed: 2\n            }\n        }\n    });\n\n    Bridge.define(\"ChiChiNES.IPixelAwareDevice\", {\n        $kind: \"interface\"\n    });\n\n    Bridge.define(\"ChiChiNES.IPPU\", {\n        $kind: \"interface\"\n    });\n\n    Bridge.define(\"ChiChiNES.Machine.ControlPanel.RunningStatuses\", {\n        $kind: \"enum\",\n        statics: {\n            fields: {\n                Unloaded: 0,\n                Off: 1,\n                Running: 2,\n                Frozen: 3,\n                Paused: 4\n            }\n        }\n    });\n\n    Bridge.define(\"ChiChiNES.NameTableMirroring\", {\n        $kind: \"enum\",\n        statics: {\n            fields: {\n                OneScreen: 0,\n                Vertical: 1,\n                Horizontal: 2,\n                FourScreen: 3\n            }\n        }\n    });\n\n    Bridge.define(\"ChiChiNES.NESMachine\", {\n        inherits: [System.IDisposable],\n        fields: {\n            _currCartName: null,\n            runState: 0,\n            lastSaveState: null,\n            currentSaveSlot: 0,\n            _cpu: null,\n            _ppu: null,\n            _cart: null,\n            _sharedWave: null,\n            soundBopper: null,\n            _enableSound: false,\n            breakpointHit: false,\n            tiler: null,\n            soundThreader: null,\n            doDraw: false,\n            isDebugging: false,\n            _totalCPUClocks: 0,\n            frameCount: 0,\n            /**\n             * runs a \"step\", either a pending non-maskable interrupt, maskable interupt, or a sprite DMA transfer,\n              or a regular machine cycle, then runs the appropriate number of PPU clocks based on CPU action\n              ppuclocks = cpuclocks * 3\n             note: this approach relies on very precise cpu timing\n             *\n             * @instance\n             * @private\n             * @memberof ChiChiNES.NESMachine\n             * @default true\n             * @type boolean\n             */\n            frameOn: false,\n            frameJustEnded: false\n        },\n        events: {\n            SoundStatusChanged: null,\n            Drawscreen: null\n        },\n        props: {\n            CurrentCartName: {\n                get: function () {\n                    return this._currCartName;\n                }\n            },\n            RunState: {\n                get: function () {\n                    return this.runState;\n                },\n                set: function (value) {\n                    if (this.runState !== value) {\n                        this.runState = value;\n                        //if (RunStatusChangedEvent != null) RunStatusChangedEvent(this, EventArgs.Empty);\n                    }\n                }\n            },\n            CurrentSaveSlot: {\n                get: function () {\n                    return this.currentSaveSlot;\n                },\n                set: function (value) {\n                    if (value >= 0 && value <= 10) {\n                        this.currentSaveSlot = value;\n                    }\n                }\n            },\n            Cpu: {\n                get: function () {\n                    return this._cpu;\n                },\n                set: function (value) {\n                    this._cpu = value;\n                }\n            },\n            Cart: {\n                get: function () {\n                    return this._cart;\n                }\n            },\n            SoundBopper: {\n                get: function () {\n                    return this.soundBopper;\n                },\n                set: function (value) {\n                    this.soundBopper = value;\n                }\n            },\n            WaveForms: {\n                get: function () {\n                    return this._sharedWave;\n                }\n            },\n            EnableSound: {\n                get: function () {\n                    return this._enableSound;\n                },\n                set: function (value) {\n                    var $t;\n\n                    if (this._enableSound !== value) {\n                        if (!Bridge.staticEquals(this.SoundStatusChanged, null)) {\n                            this.SoundStatusChanged(this, ($t = new ChiChiNES.BeepsBoops.SoundStatusChangeEventArgs(), $t.Muted = !value, $t));\n                        }\n                        this.soundBopper.Muted = !value;\n                        this._enableSound = value;\n                    }\n                }\n            },\n            Tiler: {\n                get: function () {\n                    return this.tiler;\n                }\n            },\n            FrameCount: {\n                get: function () {\n                    return this.frameCount;\n                },\n                set: function (value) {\n                    this.frameCount = value;\n                }\n            },\n            IsRunning: {\n                get: function () {\n                    return true;\n                }\n            },\n            PPU: {\n                get: function () {\n                    return this._ppu;\n                }\n            },\n            PadOne: {\n                get: function () {\n                    return this._cpu.PadOne.ControlPad;\n                },\n                set: function (value) {\n                    this._cpu.PadOne.ControlPad = value;\n                }\n            },\n            PadTwo: {\n                get: function () {\n                    return this._cpu.PadTwo.ControlPad;\n                },\n                set: function (value) {\n                    this._cpu.PadTwo.ControlPad = value;\n                    this.PPU.ChiChiNES$IPPU$PixelAwareDevice = Bridge.as(value, ChiChiNES.IPixelAwareDevice);\n                }\n            },\n            SRAMReader: null,\n            SRAMWriter: null\n        },\n        alias: [\"dispose\", \"System$IDisposable$dispose\"],\n        ctors: {\n            init: function () {\n                this._currCartName = \"\";\n                this.runState = ChiChiNES.Machine.ControlPanel.RunningStatuses.Unloaded;\n                this.lastSaveState = System.Array.init(10, null, System.Array.type(System.Int32));\n                this._enableSound = true;\n                this.breakpointHit = false;\n                this.doDraw = false;\n                this._totalCPUClocks = 0;\n                this.frameCount = 0;\n                this.frameOn = true;\n                this.frameJustEnded = false;\n            },\n            ctor: function (cpu, ppu, tiler, wavSharer, soundBopper, soundThread) {\n                this.$initialize();\n\n                //machineWorkQueue = new MachineQueue(UpdateQueue);\n\n                this._cpu = cpu;\n                this._ppu = ppu;\n                this._ppu.ChiChiNES$IPPU$FrameFinishHandler = Bridge.fn.cacheBind(this, this.FrameFinished);\n                this.tiler = tiler;\n\n                this._sharedWave = wavSharer;\n                this.soundBopper = soundBopper;\n                this._cpu.SoundBopper = soundBopper;\n\n                this.soundThreader = soundThread;\n                this.addSoundStatusChanged(Bridge.fn.cacheBind(this.soundThreader, this.soundThreader.OnSoundStatusChanged));\n\n                this.Initialize();\n            }\n        },\n        methods: {\n            Initialize: function () {\n                this._cpu.Clock = 0;\n                this.frameCount = 0;\n                // SetupTimer();\n            },\n            Reset: function () {\n                if (this._cpu != null && this._cart != null) {\n                    // ForceStop();\n                    this.soundBopper.RebuildSound();\n                    this._ppu.ChiChiNES$IPPU$Initialize();\n                    this._cart.ChiChiNES$INESCart$InitializeCart();\n                    this._cpu.ResetCPU();\n                    this.ClearGenieCodes();\n                    this._cpu.PowerOn();\n                    this.RunState = ChiChiNES.Machine.ControlPanel.RunningStatuses.Running;\n                }\n            },\n            PowerOn: function () {\n                if (this._cpu != null && this._cart != null) {\n\n                    this.soundBopper.RebuildSound();\n                    this._ppu.ChiChiNES$IPPU$Initialize();\n                    this._cart.ChiChiNES$INESCart$InitializeCart();\n                    if (!Bridge.staticEquals(this.SRAMReader, null) && this._cart.ChiChiNES$INESCart$UsesSRAM) {\n                        this._cart.ChiChiNES$INESCart$SRAM = this.SRAMReader(this._cart.ChiChiNES$INESCart$CheckSum);\n                    }\n                    this._cpu.ResetCPU();\n                    this.ClearGenieCodes();\n                    this._cpu.PowerOn();\n                    this.RunState = ChiChiNES.Machine.ControlPanel.RunningStatuses.Running;\n                }\n            },\n            PowerOff: function () {\n                if (this._cart != null && !Bridge.staticEquals(this.SRAMWriter, null) && this._cart.ChiChiNES$INESCart$UsesSRAM) {\n                    this.SRAMWriter(this._cart.ChiChiNES$INESCart$CheckSum, this._cart.ChiChiNES$INESCart$SRAM);\n                }\n                //ThreadStoptendo();\n            },\n            EjectCart: function () {\n                if (this._cart != null && !Bridge.staticEquals(this.SRAMWriter, null) && this._cart.ChiChiNES$INESCart$UsesSRAM) {\n                    this.SRAMWriter(this._cart.ChiChiNES$INESCart$CheckSum, this._cart.ChiChiNES$INESCart$SRAM);\n                }\n                //ForceStop();\n                this._cart = null;\n                this._currCartName = null;\n                this.RunState = ChiChiNES.Machine.ControlPanel.RunningStatuses.Unloaded;\n                //_ppu.CurrentScanLine = 0;\n            },\n            LoadCart: function (rom) {\n\n                this.EjectCart();\n\n\n\n                // if (runState == NES.Machine.ControlPanel.RunningStatuses.Running) ThreadStoptendo();\n\n                this._currCartName = \"Streamed\";\n\n\n                this._cart = ChiChiNES.ROMLoader.iNESFileHandler.LoadROM(this._ppu, rom);\n                if (this._cart != null) {\n\n\n                    this._cpu.Cart = Bridge.cast(this._cart, ChiChiNES.IClockedMemoryMappedIOElement);\n                    this._cpu.Cart.ChiChiNES$IClockedMemoryMappedIOElement$NMIHandler = Bridge.fn.cacheBind(this._cpu, this._cpu.InterruptRequest);\n                    this._ppu.ChiChiNES$IPPU$ChrRomHandler = this._cart;\n\n\n                } else {\n                    throw new ChiChiNES.ROMLoader.CartLoadException.ctor(\"Unsupported ROM type - load failed.\");\n                }\n            },\n            GoTendo_NoThread: function (fileName) {\n                // EjectCart();\n\n                // //if (runState == NES.Machine.ControlPanel.RunningStatuses.Running) ThreadStoptendo();\n\n\n                // _cart = iNESFileHandler.LoadROM(fileName, _ppu);\n                // if (_cart != null)\n                // {\n\n\n                //     _cpu.Cart = (IClockedMemoryMappedIOElement)_cart;\n                //     _cpu.Cart.NMIHandler = _cpu.InterruptRequest;\n                //     _ppu.ChrRomHandler = _cart;\n\n\n                //     PowerOn();\n                //     //while (runState != NES.Machine.ControlPanel.RunningStatuses.Running)\n                //     // ThreadRuntendo();\n                // }\n                // else\n                // {\n                //     throw new CartLoadException(\"Unsupported ROM type - load failed.\");\n                // }\n\n            },\n            GoTendo: function (fileName) {\n                //EjectCart();\n\n                //if (runState == NES.Machine.ControlPanel.RunningStatuses.Running) ThreadStoptendo();\n\n                //_currCartName = Path.GetFileName(fileName);\n\n                //_cart = iNESFileHandler.GetCart(fileName, _ppu);\n                //if (_cart != null)\n                //{\n\n\n                //    _cpu.Cart = (IClockedMemoryMappedIOElement)_cart;\n                //    _cpu.Cart.NMIHandler = _cpu.InterruptRequest;\n                //    _ppu.ChrRomHandler = _cart;\n\n\n                //    PowerOn();\n                //    //while (runState != NES.Machine.ControlPanel.RunningStatuses.Running)\n                //    //ThreadRuntendo();\n                //}\n                //else\n                //{\n                //    throw new CartLoadException(\"Unsupported ROM type - load failed.\");\n                //}\n\n            },\n            HasState: function (index) {\n                return (this.lastSaveState != null && this.lastSaveState[index] != null);\n            },\n            GetState: function (index) {\n                var state = new (System.Collections.Generic.Queue$1(System.Int32)).ctor();\n                state = new (System.Collections.Generic.Queue$1(System.Int32)).ctor();\n                this._cpu.GetState(state);\n                this._ppu.ChiChiNES$IPPU$WriteState(state);\n                this._cart.ChiChiNES$INESCart$WriteState(state);\n                this.lastSaveState[index] = System.Array.init(state.Count, 0, System.Int32);\n                state.copyTo$1(this.lastSaveState[index], 0);\n            },\n            SetState: function (index) {\n                if (this.lastSaveState != null) {\n                    var cloneState = new (System.Collections.Generic.Queue$1(System.Int32)).$ctor1(this.lastSaveState[index]);\n                    this._cpu.SetState(cloneState);\n                    this._ppu.ChiChiNES$IPPU$ReadState(cloneState);\n                    this._cart.ChiChiNES$INESCart$ReadState(cloneState);\n                }\n            },\n            ClearGenieCodes: function () {\n                this._cpu.GenieCodes.clear();\n                this._cpu.Cheating = false;\n            },\n            AddGameGenieCode: function (code, patch) {\n                var $t;\n                var hexCode = System.Array.init(code.length, 0, System.Byte);\n                var i = 0;\n\n\n                $t = Bridge.getEnumerator(code.toUpperCase());\n                try {\n                    while ($t.moveNext()) {\n                        var c = $t.Current;\n                        var digit = 0;\n                        switch (c) {\n                            case 65: \n                                digit = 0;\n                                break;\n                            case 80: \n                                digit = 1;\n                                break;\n                            case 90: \n                                digit = 2;\n                                break;\n                            case 76: \n                                digit = 3;\n                                break;\n                            case 71: \n                                digit = 4;\n                                break;\n                            case 73: \n                                digit = 5;\n                                break;\n                            case 84: \n                                digit = 6;\n                                break;\n                            case 89: \n                                digit = 7;\n                                break;\n                            case 69: \n                                digit = 8;\n                                break;\n                            case 79: \n                                digit = 9;\n                                break;\n                            case 88: \n                                digit = 10;\n                                break;\n                            case 85: \n                                digit = 11;\n                                break;\n                            case 75: \n                                digit = 12;\n                                break;\n                            case 83: \n                                digit = 13;\n                                break;\n                            case 86: \n                                digit = 14;\n                                break;\n                            case 78: \n                                digit = 15;\n                                break;\n                        }\n                        hexCode[Bridge.identity(i, (i = (i + 1) | 0))] = digit;\n                    }\n                } finally {\n                    if (Bridge.is($t, System.IDisposable)) {\n                        $t.System$IDisposable$dispose();\n                    }\n                }\n                // magic spell that makes the genie appear!\n                // http://tuxnes.sourceforge.net/gamegenie.html\n                var address = ((32768 + ((hexCode[3] & 7) << 12)) | 0) | ((hexCode[5] & 7) << 8) | ((hexCode[4] & 8) << 8) | ((hexCode[2] & 7) << 4) | ((hexCode[1] & 8) << 4) | (hexCode[4] & 7) | (hexCode[3] & 8);\n\n\n                var data = 0;\n                var compare = 0;\n                if (hexCode.length === 6) {\n                    data = ((hexCode[1] & 7) << 4) | ((hexCode[0] & 8) << 4) | (hexCode[0] & 7) | (hexCode[5] & 8);\n\n                    patch.v = new ChiChiNES.Hacking.MemoryPatch(address, data);\n                } else if (hexCode.length === 8) {\n                    data = ((hexCode[1] & 7) << 4) | ((hexCode[0] & 8) << 4) | (hexCode[0] & 7) | (hexCode[7] & 8);\n                    compare = ((hexCode[7] & 7) << 4) | ((hexCode[6] & 8) << 4) | (hexCode[6] & 7) | (hexCode[5] & 8);\n\n                    patch.v = new ChiChiNES.Hacking.ComparedMemoryPatch(address, (compare & 255), (data & 255));\n                } else {\n                    // not a genie code!  \n                    patch.v = null;\n                    return false;\n                }\n                try {\n                    patch.v.ChiChiNES$Hacking$IMemoryPatch$Activated = true;\n                    this._cpu.MemoryPatches.add(address, patch.v);\n                    this._cpu.Cheating = true;\n                }\n                catch ($e1) {\n                    $e1 = System.Exception.create($e1);\n                    this._cpu.Cheating = false;\n                }\n                return this._cpu.Cheating;\n            },\n            WriteWAVToFile: function (writer) {\n                this._sharedWave.AppendFile(writer);\n            },\n            StopWritingWAV: function () {\n                this._sharedWave.AppendFile(null);\n            },\n            SetupSound: function () {\n                this._sharedWave = new ChiChiNES.BeepsBoops.WavSharer.ctor();\n                //writer = new wavwriter(44100, \"d:\\\\nesout.wav\");\n                this.soundBopper = new ChiChiNES.BeepsBoops.Bopper(this._sharedWave);\n            },\n            Runtendo: function () {\n                this.isDebugging = false;\n                this.RunFrame();\n            },\n            dispose: function () {\n\n\n                if (this._cart != null && this._cart.ChiChiNES$INESCart$CheckSum != null && !Bridge.staticEquals(this.SRAMWriter, null)) {\n                    this.SRAMWriter(this._cart.ChiChiNES$INESCart$CheckSum, this._cart.ChiChiNES$INESCart$SRAM);\n                }\n\n\n                Bridge.sleep(100);\n                this._sharedWave.Dispose();\n                this.soundThreader.dispose();\n            },\n            Step: function () {\n                if (this.frameJustEnded) {\n                    this._cpu.FindNextEvent();\n                    this.frameOn = true;\n                    this.frameJustEnded = false;\n                }\n                this._cpu.Step();\n\n                if (!this.frameOn) {\n                    this._totalCPUClocks = this._cpu.Clock;\n                    //lock (_sharedWave)\n                    //{\n                    //    soundBopper.FlushFrame(_totalCPUClocks);\n                    //    soundBopper.EndFrame(_totalCPUClocks);\n                    //}\n                    this._totalCPUClocks = 0;\n                    this._cpu.Clock = 0;\n                    this._ppu.ChiChiNES$IPPU$LastcpuClock = 0;\n                    this.frameJustEnded = true;\n                }\n                //_cpu.Clock = _totalCPUClocks;\n                //breakpoints: HandleBreaks();\n\n            },\n            RunFrame: function () {\n\n                this.frameOn = true;\n                this.frameJustEnded = false;\n\n                this._cpu.FindNextEvent();\n                do {\n                    this._cpu.Step();\n                } while (this.frameOn);\n                this._totalCPUClocks = this._cpu.Clock;\n                //lock (_sharedWave)\n                //{\n                //    soundBopper.FlushFrame(_totalCPUClocks);\n                //    soundBopper.EndFrame(_totalCPUClocks);\n                //}\n\n                if (this.PadOne != null) {\n                    this.PadOne.ChiChiNES$IControlPad$refresh();\n                }\n\n                this._totalCPUClocks = 0;\n                this._cpu.Clock = 0;\n                this._ppu.ChiChiNES$IPPU$LastcpuClock = 0;\n\n\n            },\n            FrameFinished: function () {\n                this.frameJustEnded = true;\n                this.frameOn = false;\n                this.Drawscreen(this, { });\n            }\n        }\n    });\n\n    Bridge.define(\"ChiChiNES.NESSprite\", {\n        $kind: \"struct\",\n        statics: {\n            methods: {\n                getDefaultValue: function () { return new ChiChiNES.NESSprite(); }\n            }\n        },\n        fields: {\n            YPosition: 0,\n            XPosition: 0,\n            SpriteNumber: 0,\n            Foreground: false,\n            IsVisible: false,\n            TileIndex: 0,\n            AttributeByte: 0,\n            FlipX: false,\n            FlipY: false,\n            Changed: false\n        },\n        ctors: {\n            ctor: function () {\n                this.$initialize();\n            }\n        },\n        methods: {\n            getHashCode: function () {\n                var h = Bridge.addHash([3351033891, this.YPosition, this.XPosition, this.SpriteNumber, this.Foreground, this.IsVisible, this.TileIndex, this.AttributeByte, this.FlipX, this.FlipY, this.Changed]);\n                return h;\n            },\n            equals: function (o) {\n                if (!Bridge.is(o, ChiChiNES.NESSprite)) {\n                    return false;\n                }\n                return Bridge.equals(this.YPosition, o.YPosition) && Bridge.equals(this.XPosition, o.XPosition) && Bridge.equals(this.SpriteNumber, o.SpriteNumber) && Bridge.equals(this.Foreground, o.Foreground) && Bridge.equals(this.IsVisible, o.IsVisible) && Bridge.equals(this.TileIndex, o.TileIndex) && Bridge.equals(this.AttributeByte, o.AttributeByte) && Bridge.equals(this.FlipX, o.FlipX) && Bridge.equals(this.FlipY, o.FlipY) && Bridge.equals(this.Changed, o.Changed);\n            },\n            $clone: function (to) {\n                var s = to || new ChiChiNES.NESSprite();\n                s.YPosition = this.YPosition;\n                s.XPosition = this.XPosition;\n                s.SpriteNumber = this.SpriteNumber;\n                s.Foreground = this.Foreground;\n                s.IsVisible = this.IsVisible;\n                s.TileIndex = this.TileIndex;\n                s.AttributeByte = this.AttributeByte;\n                s.FlipX = this.FlipX;\n                s.FlipY = this.FlipY;\n                s.Changed = this.Changed;\n                return s;\n            }\n        }\n    });\n\n    Bridge.define(\"ChiChiNES.PortQueueing.PortWriteEntry\", {\n        fields: {\n            time: 0,\n            address: 0,\n            data: 0\n        },\n        ctors: {\n            ctor: function (time, address, data) {\n                this.$initialize();\n                this.time = time;\n                this.address = address;\n                this.data = data;\n            }\n        }\n    });\n\n    Bridge.define(\"ChiChiNES.PPUWriteEvent\", {\n        inherits: [System.ComponentModel.INotifyPropertyChanged],\n        fields: {\n            isWrite: false,\n            scanlineNum: 0,\n            scanlinePos: 0,\n            frameClock: 0,\n            registerAffected: 0,\n            dataWritten: 0\n        },\n        events: {\n            PropertyChanged: null\n        },\n        props: {\n            IsWrite: {\n                get: function () {\n                    return this.isWrite;\n                },\n                set: function (value) {\n                    this.isWrite = value;\n                }\n            },\n            ScanlineNum: {\n                get: function () {\n                    return this.scanlineNum;\n                },\n                set: function (value) {\n                    this.scanlineNum = value;\n                }\n            },\n            ScanlinePos: {\n                get: function () {\n                    return this.scanlinePos;\n                },\n                set: function (value) {\n                    this.scanlinePos = value;\n                }\n            },\n            FrameClock: {\n                get: function () {\n                    return this.frameClock;\n                },\n                set: function (value) {\n                    this.frameClock = value;\n                }\n            },\n            RegisterAffected: {\n                get: function () {\n                    return this.registerAffected;\n                },\n                set: function (value) {\n                    this.registerAffected = value;\n                }\n            },\n            DataWritten: {\n                get: function () {\n                    return this.dataWritten;\n                },\n                set: function (value) {\n                    this.dataWritten = value;\n                }\n            },\n            Text: {\n                get: function () {\n                    return this.toString();\n                }\n            }\n        },\n        alias: [\"addPropertyChanged\", \"System$ComponentModel$INotifyPropertyChanged$addPropertyChanged\",\n        \"removePropertyChanged\", \"System$ComponentModel$INotifyPropertyChanged$removePropertyChanged\"],\n        methods: {\n            toString: function () {\n                return System.String.format(\" {0:x2} written to {1:x4} at {2}, {3}\", this.registerAffected, this.dataWritten, this.scanlineNum, this.scanlinePos);\n            }\n        }\n    });\n\n    Bridge.define(\"ChiChiNES.ROMLoader.CartLoadException\", {\n        inherits: [System.Exception],\n        ctors: {\n            $ctor1: function (message, innerException) {\n                this.$initialize();\n                System.Exception.ctor.call(this, message, innerException);\n            },\n            ctor: function (message) {\n                this.$initialize();\n                System.Exception.ctor.call(this, message);\n            }\n        }\n    });\n\n    Bridge.define(\"ChiChiNES.ROMLoader.iNESFileHandler\", {\n        statics: {\n            methods: {\n                LoadROM: function (ppu, thefile) {\n                    var _cart = null;\n                    var iNesHeader = System.Array.init(16, 0, System.Byte);\n                    var bytesRead = 16;\n                    System.Array.copy(thefile, 0, iNesHeader, 0, 16);\n                    /* \n                    .NES file format\n                    ---------------------------------------------------------------------------\n                    0-3      String \"NES^Z\" used to recognize .NES files.\n                    4        Number of 16kB ROM banks.\n                    5        Number of 8kB VROM banks.\n                    6        bit 0     1 for vertical mirroring, 0 for horizontal mirroring\n                    bit 1     1 for battery-backed RAM at $6000-$7FFF\n                    bit 2     1 for a 512-byte trainer at $7000-$71FF\n                    bit 3     1 for a four-screen VRAM layout \n                    bit 4-7   Four lower bits of ROM Mapper Type.\n                    7        bit 0-3   Reserved, must be zeroes!\n                    bit 4-7   Four higher bits of ROM Mapper Type.\n                    8-15     Reserved, must be zeroes!\n                    16-...   ROM banks, in ascending order. If a trainer is present, its\n                    512 bytes precede the ROM bank contents.\n                    ...-EOF  VROM banks, in ascending order.\n                    ---------------------------------------------------------------------------\n                    */\n                    var mapperId = (iNesHeader[6] & 240);\n                    mapperId = (Bridge.Int.div(mapperId, 16)) | 0;\n                    mapperId = (mapperId + iNesHeader[7]) | 0;\n\n                    var prgRomCount = iNesHeader[4];\n                    var chrRomCount = iNesHeader[5];\n\n                    var theRom = System.Array.init(Bridge.Int.mul(prgRomCount, 16384), 0, System.Byte);\n                    var chrRom = System.Array.init(Bridge.Int.mul(chrRomCount, 16384), 0, System.Byte);\n\n                    var chrOffset = 0;\n\n                    //bytesRead = zipStream.Read(theRom, 0, theRom.Length);\n                    System.Array.copy(thefile, 16, theRom, 0, theRom.length);\n                    chrOffset = (16 + theRom.length) | 0;\n                    var len = chrRom.length;\n                    if (((chrOffset + chrRom.length) | 0) > thefile.length) {\n                        len = (thefile.length - chrOffset) | 0;\n                    }\n                    System.Array.copy(thefile, chrOffset, chrRom, 0, len);\n                    //zipStream.Read(chrRom, 0, chrRom.Length);\n                    switch (mapperId) {\n                        case 0: \n                        case 2: \n                        case 3: \n                        case 7: \n                            _cart = new ChiChiNES.CPU.NESCart();\n                            break;\n                        case 1: \n                            _cart = new ChiChiNES.NesCartMMC1();\n                            break;\n                        case 4: \n                            _cart = new ChiChiNES.NesCartMMC3();\n                            break;\n                    }\n\n                    if (_cart != null) {\n                        _cart.ChiChiNES$INESCart$Whizzler = ppu;\n                        ppu.ChiChiNES$IPPU$ChrRomHandler = _cart;\n                        _cart.ChiChiNES$INESCart$ROMHashFunction = null; //Hashers.HashFunction;\n                        _cart.ChiChiNES$INESCart$LoadiNESCart(iNesHeader, prgRomCount, chrRomCount, theRom, chrRom, chrOffset);\n                    }\n\n                    return _cart;\n\n                }\n            }\n        }\n    });\n\n    Bridge.define(\"ChiChiNES.Sound.IWavStreamer\", {\n        inherits: [System.IDisposable],\n        $kind: \"interface\"\n    });\n\n    Bridge.define(\"ChiChiNES.Sound.SoundThreader\", {\n        inherits: [System.IDisposable],\n        fields: {\n            _wavePlayer: null\n        },\n        props: {\n            WavePlayer: {\n                get: function () {\n                    return this._wavePlayer;\n                },\n                set: function (value) {\n                    this._wavePlayer = value;\n                }\n            }\n        },\n        alias: [\"dispose\", \"System$IDisposable$dispose\"],\n        ctors: {\n            ctor: function (streamer) {\n                this.$initialize();\n\n                this._wavePlayer = streamer;\n\n                //ThreadPool.QueueUserWorkItem(PlaySound, null);\n\n            }\n        },\n        methods: {\n            OnSoundStatusChanged: function (sender, e) {\n                this._wavePlayer.ChiChiNES$Sound$IWavStreamer$Muted = e.Muted;\n            },\n            PlaySound: function (o) {\n                this._wavePlayer.ChiChiNES$Sound$IWavStreamer$playPCM();\n            },\n            dispose: function () {\n                this._wavePlayer.System$IDisposable$dispose();\n            }\n        }\n    });\n\n    Bridge.define(\"ChiChiNES.TileDoodler\", {\n        fields: {\n            _ppu: null,\n            currentNameTableEntries: null,\n            currentPatternTableEntries: null\n        },\n        props: {\n            XOffset: 0,\n            YOffset: 0\n        },\n        ctors: {\n            init: function () {\n                this.currentNameTableEntries = System.Array.init(32, null, System.Array.type(System.Array.type(System.Int32)));\n                this.currentPatternTableEntries = System.Array.init(2, null, System.Array.type(System.Array.type(System.Array.type(System.Int32))));\n            },\n            ctor: function (ppu) {\n                var $t, $t1, $t2, $t3;\n                this.$initialize();\n                this._ppu = ppu;\n\n                this.currentPatternTableEntries = System.Array.init(2, null, System.Array.type(System.Array.type(System.Array.type(System.Int32))));\n                for (var pt = 0; pt < 2; pt = (pt + 1) | 0) {\n                    this.currentPatternTableEntries[pt] = System.Array.init(32, null, System.Array.type(System.Array.type(System.Int32)));\n                    for (var x = 0; x < 32; x = (x + 1) | 0) {\n                        ($t = this.currentPatternTableEntries[pt])[x] = System.Array.init(30, null, System.Array.type(System.Int32));\n                        for (var y = 0; y < 30; y = (y + 1) | 0) {\n                            ($t1 = ($t2 = this.currentPatternTableEntries[pt])[x])[y] = System.Array.init(8, 0, System.Int32);\n                        }\n\n                    }\n                }\n\n                this.currentNameTableEntries = System.Array.init(32, null, System.Array.type(System.Array.type(System.Int32)));\n                for (var i = 0; i < 32; i = (i + 1) | 0) {\n                    this.currentNameTableEntries[i] = System.Array.init(30, null, System.Array.type(System.Int32));\n                    for (var j = 0; j < 30; j = (j + 1) | 0) {\n                        ($t3 = this.currentNameTableEntries[i])[j] = System.Array.init(8, 0, System.Int32);\n                    }\n                }\n\n            }\n        },\n        methods: {\n            GetPatternTableEntry: function (PatternTable, TileIndex, attributeByte, actualAddress) {\n                var $t, $t1, $t2;\n                // 8x8 tile\n                var result = System.Array.init(64, 0, System.Int32);\n\n                actualAddress.v = System.Array.init(8, 0, System.Int32);\n\n                for (var i = 0; i < 8; i = (i + 1) | 0) {\n                    var patternEntry = this._ppu.ChiChiNES$IPPU$ChrRomHandler.ChiChiNES$INESCart$GetPPUByte(0, ((((PatternTable + Bridge.Int.mul(TileIndex, 16)) | 0) + i) | 0));\n\n                    actualAddress.v[i] = this._ppu.ChiChiNES$IPPU$ChrRomHandler.ChiChiNES$INESCart$ActualChrRomOffset(((((PatternTable + Bridge.Int.mul(TileIndex, 16)) | 0) + i) | 0));\n\n                    var patternEntryBit2 = this._ppu.ChiChiNES$IPPU$ChrRomHandler.ChiChiNES$INESCart$GetPPUByte(0, ((((((PatternTable + Bridge.Int.mul(TileIndex, 16)) | 0) + i) | 0) + 8) | 0));\n\n                    for (var bit = 0; bit < 8; bit = (bit + 1) | 0) {\n                        if ((patternEntry & ($t = ChiChiNES.PixelWhizzler.PowersOfTwo)[bit]) !== 0) {\n                            result[(((Bridge.Int.mul(i, 8)) + bit) | 0)] = 1 | attributeByte;\n                        }\n                        if ((patternEntryBit2 & ($t1 = ChiChiNES.PixelWhizzler.PowersOfTwo)[bit]) !== 0) {\n                            result[($t2 = (((Bridge.Int.mul(i, 8)) + bit) | 0))] = result[$t2] | (2 | attributeByte);\n                        }\n                    }\n\n                }\n\n                return result;\n            },\n            GetSprite: function (PatternTable, TileIndex, attributeByte, flipX, flipY) {\n                var $t, $t1, $t2, $t3, $t4, $t5;\n                // 8x8 tile\n                var result = System.Array.init(64, 0, System.Int32);\n                var yMultiplyer = 8;\n\n\n                for (var i = 0; i < 8; i = (i + 1) | 0) {\n                    var patternEntry;\n                    var patternEntryBit2;\n                    if (flipY) {\n                        patternEntry = this._ppu.ChiChiNES$IPPU$VidRAM_GetNTByte(((((((PatternTable + Bridge.Int.mul(TileIndex, 16)) | 0) + 7) | 0) - i) | 0));\n                        patternEntryBit2 = this._ppu.ChiChiNES$IPPU$VidRAM_GetNTByte(((((((((PatternTable + Bridge.Int.mul(TileIndex, 16)) | 0) + 7) | 0) - i) | 0) + 8) | 0));\n                    } else {\n\n                        patternEntry = this._ppu.ChiChiNES$IPPU$VidRAM_GetNTByte(((((PatternTable + Bridge.Int.mul(TileIndex, 16)) | 0) + i) | 0));\n                        patternEntryBit2 = this._ppu.ChiChiNES$IPPU$VidRAM_GetNTByte(((((((PatternTable + Bridge.Int.mul(TileIndex, 16)) | 0) + i) | 0) + 8) | 0));\n                    }\n                    if (flipX) {\n                        for (var bit = 7; bit >= 0; bit = (bit - 1) | 0) {\n                            if ((patternEntry & ($t = ChiChiNES.PixelWhizzler.PowersOfTwo)[bit]) !== 0) {\n                                result[(((((Bridge.Int.mul(i, yMultiplyer)) + 7) | 0) - bit) | 0)] = 1 | attributeByte;\n                            }\n                            if ((patternEntryBit2 & ($t1 = ChiChiNES.PixelWhizzler.PowersOfTwo)[bit]) !== 0) {\n                                result[($t2 = (((((Bridge.Int.mul(i, yMultiplyer)) + 7) | 0) - bit) | 0))] = result[$t2] | (2 | attributeByte);\n                            }\n                        }\n                    } else {\n                        for (var bit1 = 0; bit1 < 8; bit1 = (bit1 + 1) | 0) {\n                            if ((patternEntry & ($t3 = ChiChiNES.PixelWhizzler.PowersOfTwo)[bit1]) !== 0) {\n                                result[(((Bridge.Int.mul(i, 8)) + bit1) | 0)] = 1 | attributeByte;\n                            }\n                            if ((patternEntryBit2 & ($t4 = ChiChiNES.PixelWhizzler.PowersOfTwo)[bit1]) !== 0) {\n                                result[($t5 = (((Bridge.Int.mul(i, 8)) + bit1) | 0))] = result[$t5] | (2 | attributeByte);\n                            }\n                        }\n                    }\n\n                }\n                return result;\n            },\n            TryGetSprite: function (result, PatternTable, TileIndex, attributeByte, flipX, flipY) {\n                var $t, $t1, $t2, $t3, $t4, $t5;\n                // 8x8 tile\n                var yMultiplyer = 8;\n                var hasData = false;\n\n                for (var i = 0; i < 8; i = (i + 1) | 0) {\n                    var patternEntry;\n                    var patternEntryBit2;\n                    if (flipY) {\n                        patternEntry = this._ppu.ChiChiNES$IPPU$VidRAM_GetNTByte(((((((PatternTable + Bridge.Int.mul(TileIndex, 16)) | 0) + 7) | 0) - i) | 0));\n                        patternEntryBit2 = this._ppu.ChiChiNES$IPPU$VidRAM_GetNTByte(((((((((PatternTable + Bridge.Int.mul(TileIndex, 16)) | 0) + 7) | 0) - i) | 0) + 8) | 0));\n                    } else {\n                        patternEntry = this._ppu.ChiChiNES$IPPU$VidRAM_GetNTByte(((((PatternTable + Bridge.Int.mul(TileIndex, 16)) | 0) + i) | 0));\n                        patternEntryBit2 = this._ppu.ChiChiNES$IPPU$VidRAM_GetNTByte(((((((PatternTable + Bridge.Int.mul(TileIndex, 16)) | 0) + i) | 0) + 8) | 0));\n                    }\n\n                    if (flipX) {\n                        for (var bit = 7; bit >= 0; bit = (bit - 1) | 0) {\n                            result[(((((Bridge.Int.mul(i, yMultiplyer)) + 7) | 0) - bit) | 0)] = 0;\n                            if ((patternEntry & ($t = ChiChiNES.PixelWhizzler.PowersOfTwo)[bit]) !== 0) {\n                                result[(((((Bridge.Int.mul(i, yMultiplyer)) + 7) | 0) - bit) | 0)] = 1 | attributeByte;\n                                hasData = true;\n                            }\n                            if ((patternEntryBit2 & ($t1 = ChiChiNES.PixelWhizzler.PowersOfTwo)[bit]) !== 0) {\n                                result[($t2 = (((((Bridge.Int.mul(i, yMultiplyer)) + 7) | 0) - bit) | 0))] = result[$t2] | (2 | attributeByte);\n                                hasData = true;\n                            }\n                        }\n                    } else {\n                        for (var bit1 = 0; bit1 < 8; bit1 = (bit1 + 1) | 0) {\n                            result[(((Bridge.Int.mul(i, 8)) + bit1) | 0)] = 0;\n                            if ((patternEntry & ($t3 = ChiChiNES.PixelWhizzler.PowersOfTwo)[bit1]) !== 0) {\n                                result[(((Bridge.Int.mul(i, 8)) + bit1) | 0)] = 1 | attributeByte;\n                                hasData = true;\n                            }\n                            if ((patternEntryBit2 & ($t4 = ChiChiNES.PixelWhizzler.PowersOfTwo)[bit1]) !== 0) {\n                                result[($t5 = (((Bridge.Int.mul(i, 8)) + bit1) | 0))] = result[$t5] | (2 | attributeByte);\n                                hasData = true;\n                            }\n                        }\n                    }\n                }\n                return hasData;\n            },\n            /**\n             * Gets a 1x8 line from a particular pattern table\n             *\n             * @instance\n             * @public\n             * @this ChiChiNES.TileDoodler\n             * @memberof ChiChiNES.TileDoodler\n             * @param   {System.Int32}    result           \n             * @param   {number}          startPosition    \n             * @param   {number}          LineNumber       \n             * @param   {number}          PatternTable     \n             * @param   {number}          TileIndex        \n             * @param   {number}          attributeByte\n             * @return  {void}\n             */\n            GetPatternTableLine: function (result, startPosition, LineNumber, PatternTable, TileIndex, attributeByte) {\n                var $t, $t1, $t2;\n                // 8x8 tile\n\n                var patternEntry = this._ppu.ChiChiNES$IPPU$VidRAM_GetNTByte(((((PatternTable + Bridge.Int.mul(TileIndex, 16)) | 0) + LineNumber) | 0));\n                var patternEntryBit2 = this._ppu.ChiChiNES$IPPU$VidRAM_GetNTByte(((((((PatternTable + Bridge.Int.mul(TileIndex, 16)) | 0) + LineNumber) | 0) + 8) | 0));\n\n                for (var bit = 0; bit < 8; bit = (bit + 1) | 0) {\n                    if ((patternEntry & ($t = ChiChiNES.PixelWhizzler.PowersOfTwo)[bit]) !== 0) {\n                        result.v[(((Bridge.Int.mul(LineNumber, 8)) + bit) | 0)] = 1 | attributeByte;\n                    }\n                    if ((patternEntryBit2 & ($t1 = ChiChiNES.PixelWhizzler.PowersOfTwo)[bit]) !== 0) {\n                        result.v[($t2 = (((Bridge.Int.mul(LineNumber, 8)) + bit) | 0))] = result.v[$t2] | (2 | attributeByte);\n                    }\n                }\n            },\n            DrawRect: function (newData, width, height, xPos, yPos) {\n                var $t;\n\n                for (var j = 0; j < height; j = (j + 1) | 0) {\n                    for (var i = 0; i < width; i = (i + 1) | 0) {\n\n                        var xPosition = (((xPos + 8) | 0) - i) | 0;\n                        var yPosition = (yPos + j) | 0;\n\n                        if (xPosition >= 256 || yPosition >= 240) {\n                            return;\n                        }\n                        ($t = this._ppu.ChiChiNES$IPPU$CurrentFrame)[((Bridge.Int.mul(yPosition, 256) + xPosition) | 0)] = (newData[(((Bridge.Int.mul(j, width)) + i) | 0)]) & 255;\n                    }\n                }\n            },\n            MergeRect: function (newData, width, height, xPos, yPos, inFront) {\n                var $t;\n\n                if (inFront) {\n                    this.MergeRectBehind(newData, width, height, xPos, yPos);\n                    return;\n                }\n\n                for (var j = 0; j < height; j = (j + 1) | 0) {\n                    for (var i = 0; i < width; i = (i + 1) | 0) {\n\n                        var xPosition = (((xPos + 8) | 0) - i) | 0;\n                        var yPosition = (yPos + j) | 0;\n\n                        if (xPosition >= 256 || yPosition >= 240) {\n                            return;\n                        }\n                        if (newData[(((Bridge.Int.mul(j, width)) + i) | 0)] !== 0) {\n                            ($t = this._ppu.ChiChiNES$IPPU$CurrentFrame)[((Bridge.Int.mul(yPosition, 256) + xPosition) | 0)] = (this._ppu.ChiChiNES$IPPU$VidRAM_GetNTByte((((newData[(((Bridge.Int.mul(j, width)) + i) | 0)]) + 16128) | 0))) & 255;\n                        }\n                    }\n                }\n            },\n            MergeRectBehind: function (newData, width, height, xPos, yPos) {\n                var $t, $t1;\n\n                for (var j = 0; j < height; j = (j + 1) | 0) {\n                    for (var i = 0; i < width; i = (i + 1) | 0) {\n\n                        var xPosition = (((xPos + 8) | 0) - i) | 0;\n                        var yPosition = (yPos + j) | 0;\n\n                        if (xPosition >= 256 || yPosition >= 240) {\n                            return;\n                        }\n                        if (($t = this._ppu.ChiChiNES$IPPU$CurrentFrame)[((Bridge.Int.mul(yPosition, 256) + xPosition) | 0)] === this._ppu.ChiChiNES$IPPU$VidRAM_GetNTByte(16128)) {\n                            ($t1 = this._ppu.ChiChiNES$IPPU$CurrentFrame)[((Bridge.Int.mul(yPosition, 256) + xPosition) | 0)] = (this._ppu.ChiChiNES$IPPU$VidRAM_GetNTByte((((newData[(((Bridge.Int.mul(j, width)) + i) | 0)]) + 16128) | 0))) & 255;\n                        }\n                    }\n                }\n            },\n            DrawAllTiles: function () {\n                var $t;\n                if (this.YOffset > 256) {\n                    this.YOffset = this.YOffset & 255;\n                }\n                if (this.XOffset > 256) {\n                    this.XOffset = this.XOffset & 255;\n                }\n\n                //_ppu.RawBuffer = new byte[_ppu.RawBuffer.Length + 1];\n\n                var NameTable = (8192 + (Bridge.Int.mul(1024, (this._ppu.ChiChiNES$IPPU$PPUControlByte0 & 3)))) | 0;\n                var nt2 = (Bridge.Int.div((NameTable & 3072), 1024)) | 0;\n\n                //int PatternTable;\n                //if ((_ppu.PPUControlByte0 & 0x10) != 0)\n                //    PatternTable = 0x1000;\n                //else\n                //    PatternTable = 0;\n\n                for (var i = 0; i < 32; i = (i + 1) | 0) {\n                    for (var j = 0; j < 30; j = (j + 1) | 0) {\n                        //int TileIndex = (byte)_ppu.NameTable[_ppu.Mirror[nt2], i + (j * 32)];\n                        var TileIndex = (this._ppu.ChiChiNES$IPPU$VidRAM_GetNTByte(((((((8192 + this._ppu.ChiChiNES$IPPU$NameTableMemoryStart) | 0) + i) | 0) + (Bridge.Int.mul(j, 32))) | 0))) & 255;\n\n                        var addToCol = this.GetAttributeTableEntry(this._ppu.ChiChiNES$IPPU$NameTableMemoryStart, i, j);\n                        this.DrawRect(this.GetPatternTableEntry(this._ppu.ChiChiNES$IPPU$PatternTableIndex, TileIndex, addToCol, Bridge.ref(($t = this.currentNameTableEntries[i]), j)), 8, 8, (((Bridge.Int.mul(i, 8)) + this.XOffset) | 0), (((Bridge.Int.mul(j, 8)) + this.YOffset) | 0));\n\n                    }\n                }\n            },\n            GetAttributeTableEntry: function (ppuNameTableMemoryStart, i, j) {\n                //int LookUp = _ppu.NameTable[_ppu.Mirror[nameTableIndex],\n                //    0x3C0 + (i / 4) + ((j / 4) * 0x8)];\n\n                var LookUp = this._ppu.ChiChiNES$IPPU$VidRAM_GetNTByte(((((((((8192 + ppuNameTableMemoryStart) | 0) + 960) | 0) + (((Bridge.Int.div(i, 4)) | 0))) | 0) + (Bridge.Int.mul((((Bridge.Int.div(j, 4)) | 0)), 8))) | 0));\n\n                var AttribByte = 0;\n                switch ((i & 2) | Bridge.Int.mul((j & 2), 2)) {\n                    case 0: \n                        AttribByte = (LookUp << 2) & 12;\n                        break;\n                    case 2: \n                        AttribByte = LookUp & 12;\n                        break;\n                    case 4: \n                        AttribByte = (LookUp >> 2) & 12;\n                        break;\n                    case 6: \n                        AttribByte = (LookUp >> 4) & 12;\n                        break;\n                }\n                return AttribByte;\n            },\n            /**\n             * Returns a pixel\n             *\n             * @instance\n             * @public\n             * @this ChiChiNES.TileDoodler\n             * @memberof ChiChiNES.TileDoodler\n             * @param   {number}    xPosition    X position of pixel (0 to 255)\n             * @param   {number}    yPosition    Y position of pixel (0 to 239)\n             * @return  {number}\n             */\n            GetNameTablePixel: function (xPosition, yPosition) {\n                var ppuNameTableMemoryStart = this._ppu.ChiChiNES$IPPU$NameTableMemoryStart;\n                //yPosition += 1;\n                xPosition = (xPosition + this._ppu.ChiChiNES$IPPU$HScroll) | 0;\n\n                if (xPosition > 255) {\n                    xPosition = (xPosition - 256) | 0;\n                    // from loopy's doc\n                    // you can think of bits 0,1,2,3,4 of the vram address as the \"x scroll\"(*8)\n                    //that the ppu increments as it draws.  as it wraps from 31 to 0, bit 10 is\n                    //switched.  you should see how this causes horizontal wrapping between name\n                    //tables (0,1) and (2,3).\n\n                    ppuNameTableMemoryStart = ppuNameTableMemoryStart ^ 1024;\n\n\n                }\n                var xTilePosition = (Bridge.Int.div(xPosition, 8)) | 0;\n                // index of this pixels bit in pattern table\n                var patternTableEntryIndex = (7 - (xPosition & 7)) | 0;\n\n                yPosition = (yPosition + this._ppu.ChiChiNES$IPPU$VScroll) | 0;\n                if (yPosition > 240) {\n                    yPosition = (yPosition - 241) | 0;\n                    ppuNameTableMemoryStart = ppuNameTableMemoryStart ^ 2048;\n                }\n\n                var yTilePosition = (Bridge.Int.div(yPosition, 8)) | 0;\n\n                var patternTableYOffset = yPosition & 7;\n\n\n                //int mirrorIndexLookup = (nameTableMemoryStart & 0xC00) / 0x400;\n                //int TileIndex = (byte)_ppu.NameTable[_ppu.CurrentNameTable, xTilePosition + (yTilePosition * 32)];\n\n                var TileIndex = (this._ppu.ChiChiNES$IPPU$VidRAM_GetNTByte(((((((8192 + ppuNameTableMemoryStart) | 0) + xTilePosition) | 0) + ((Bridge.Int.mul(yTilePosition, 32)))) | 0))) & 255;\n\n                var patternEntry = this._ppu.ChiChiNES$IPPU$VidRAM_GetNTByte(((((this._ppu.ChiChiNES$IPPU$PatternTableIndex + Bridge.Int.mul(TileIndex, 16)) | 0) + patternTableYOffset) | 0));\n                var patternEntryByte2 = this._ppu.ChiChiNES$IPPU$VidRAM_GetNTByte(((((((this._ppu.ChiChiNES$IPPU$PatternTableIndex + Bridge.Int.mul(TileIndex, 16)) | 0) + 8) | 0) + patternTableYOffset) | 0));\n\n                var attributeByte = this.GetAttributeTableEntry(ppuNameTableMemoryStart, xTilePosition, yTilePosition);\n\n                // i want the patternTableEntryIndex'th bit of patternEntry in the 1st bit of pixel\n                return ((((patternEntry >> patternTableEntryIndex) & 1) | (Bridge.Int.mul(((patternEntryByte2 >> patternTableEntryIndex) & 1), 2)) | attributeByte) & 255);\n            },\n            SpriteZeroHit: function (xPosition, yPosition) {\n                var $t, $t1, $t2, $t3;\n                var y = ($t = this._ppu.ChiChiNES$IPPU$SpriteRam)[0];\n                var yLine = yPosition % 8;\n                var xPos = xPosition % 8;\n                if (yPosition > y && yPosition <= ((y + 9) | 0)) {\n                    var tileIndex = ($t1 = this._ppu.ChiChiNES$IPPU$SpriteRam)[1];\n                    var patternEntry = this._ppu.ChiChiNES$IPPU$VidRAM_GetNTByte(((((((this._ppu.ChiChiNES$IPPU$PatternTableIndex + Bridge.Int.mul(tileIndex, 16)) | 0) + 7) | 0) - yLine) | 0));\n                    var patternEntryBit2 = this._ppu.ChiChiNES$IPPU$VidRAM_GetNTByte(((((((((this._ppu.ChiChiNES$IPPU$PatternTableIndex + Bridge.Int.mul(tileIndex, 16)) | 0) + 7) | 0) - yLine) | 0) + 8) | 0));\n\n                    if (((patternEntry & ($t2 = ChiChiNES.PixelWhizzler.PowersOfTwo)[xPos]) !== 0) || ((patternEntryBit2 & ($t3 = ChiChiNES.PixelWhizzler.PowersOfTwo)[xPos]) !== 0)) {\n                        return true;\n                    }\n                }\n                return false;\n            },\n            DrawSprite: function (spriteNum) {\n                var $t, $t1, $t2, $t3;\n                var spriteAddress = Bridge.Int.mul(4, spriteNum);\n                var y = ($t = this._ppu.ChiChiNES$IPPU$SpriteRam)[spriteAddress];\n                var attributeByte = ($t1 = this._ppu.ChiChiNES$IPPU$SpriteRam)[((spriteAddress + 2) | 0)];\n                var x = ($t2 = this._ppu.ChiChiNES$IPPU$SpriteRam)[((spriteAddress + 3) | 0)];\n                var tileIndex = ($t3 = this._ppu.ChiChiNES$IPPU$SpriteRam)[((spriteAddress + 1) | 0)];\n\n                var attrColor = ((attributeByte & 3) << 2) | 16;\n                var isInFront = (attributeByte & 32) === 32;\n                var flipX = (attributeByte & 64) === 64;\n                var flipY = (attributeByte & 128) === 128;\n\n                var spritePatternTable = 0;\n                // if these are 8x16 sprites, read high and low, draw\n                if ((this._ppu.ChiChiNES$IPPU$PPUControlByte0 & 32) === 32) {\n                    if ((tileIndex & 1) === 1) {\n                        spritePatternTable = 4096;\n                    }\n                    var getPatternTableEntry = this.GetSprite(spritePatternTable, tileIndex, attrColor, flipX, flipY);\n                    // spritePatternTable = spritePatternTable ^ 0x1000;\n                    tileIndex = (tileIndex + 1) | 0;\n                    var getPatternTableEntryBottom = this.GetSprite(spritePatternTable, tileIndex, attrColor, flipX, flipY);\n\n                    if (flipY) {\n                        this.MergeRect(getPatternTableEntryBottom, 8, 8, ((x - 1) | 0), ((y + 1) | 0), isInFront);\n                        this.MergeRect(getPatternTableEntry, 8, 8, ((x - 1) | 0), ((y + 9) | 0), isInFront);\n                    } else {\n                        this.MergeRect(getPatternTableEntry, 8, 8, ((x - 1) | 0), ((y + 1) | 0), isInFront);\n                        this.MergeRect(getPatternTableEntryBottom, 8, 8, ((x - 1) | 0), ((y + 9) | 0), isInFront);\n                    }\n                } else {\n                    // 8x8 sprites\n                    if ((this._ppu.ChiChiNES$IPPU$PPUControlByte0 & 8) === 8) {\n                        spritePatternTable = 4096;\n                    }\n                    var getPatternTableEntry1 = this.GetSprite(spritePatternTable, tileIndex, attrColor, flipX, flipY);\n\n                    this.MergeRect(getPatternTableEntry1, 8, 8, ((x - 1) | 0), ((y + 1) | 0), isInFront);\n                }\n\n                return;\n            },\n            DrawAllSprites: function () {\n                for (var i = 63; i >= 0; i = (i - 1) | 0) {\n\n                    this.DrawSprite(i);\n                }\n            },\n            /**\n             * returns a 128x128 buffer for the tiles\n             *\n             * @instance\n             * @public\n             * @this ChiChiNES.TileDoodler\n             * @memberof ChiChiNES.TileDoodler\n             * @param   {number}            PatternTable\n             * @return  {Array.<number>}\n             */\n            DoodlePatternTable: function (PatternTable) {\n                var $t, $t1;\n                var patTable = 0;\n                switch (PatternTable) {\n                    case 4096: \n                        patTable = 1;\n                        break;\n                    case 0: \n                        patTable = 0;\n                        break;\n                }\n\n                // return a 16x16 x 64 per tile pattern table for display\n                var patterns = { v : System.Array.init(16384, 0, System.Int32) };\n                var tile;\n                for (var j = 0; j < 16; j = (j + 1) | 0) {\n                    for (var i = 0; i < 16; i = (i + 1) | 0) {\n                        tile = this.GetPatternTableEntry(PatternTable, (((i) + Bridge.Int.mul(j, 16)) | 0), 0, Bridge.ref(($t = ($t1 = this.currentPatternTableEntries[patTable])[i]), j));\n                        this.DrawTile(patterns, 128, 128, tile, Bridge.Int.mul(i, 8), Bridge.Int.mul(j, 8));\n                    }\n                }\n                return patterns.v;\n            },\n            /**\n             * returns a pixel array representing a current nametable in memory\n             nametable will be 0,0x400, 0x800, 0xC00, mapped to 0x200 + Nametable\n             *\n             * @instance\n             * @public\n             * @this ChiChiNES.TileDoodler\n             * @memberof ChiChiNES.TileDoodler\n             * @param   {number}            NameTable\n             * @return  {Array.<number>}\n             */\n            DoodleNameTable: function (NameTable) {\n                var $t;\n\n                var result = { v : System.Array.init(61440, 0, System.Int32) };\n\n                for (var i = 0; i < 32; i = (i + 1) | 0) {\n                    for (var j = 0; j < 30; j = (j + 1) | 0) {\n\n                        var address = (((((8192 + NameTable) | 0) + i) | 0) + (Bridge.Int.mul(j, 32))) | 0;\n                        var TileIndex = this._ppu.ChiChiNES$IPPU$ChrRomHandler.ChiChiNES$INESCart$GetPPUByte(0, address);\n\n                        var addToCol = this.GetAttributeTableEntry(NameTable, i, j);\n                        var tile = this.GetPatternTableEntry(this._ppu.ChiChiNES$IPPU$PatternTableIndex, TileIndex, addToCol, Bridge.ref(($t = this.currentNameTableEntries[i]), j));\n                        this.DrawTile(result, 256, 240, tile, Bridge.Int.mul(i, 8), Bridge.Int.mul(j, 8));\n                    }\n                }\n                return result.v;\n            },\n            DrawTile: function (destBuffer, width, height, tile, xPos, yPos) {\n\n                for (var j = 0; j < 8; j = (j + 1) | 0) {\n                    for (var i = 0; i < 8; i = (i + 1) | 0) {\n\n                        var xPosition = (((xPos + 8) | 0) - i) | 0;\n                        var yPosition = Bridge.Int.mul((((yPos + j) | 0)), width);\n\n                        if (xPos > height) {\n                            break;\n                        }\n                        if (((yPosition + xPosition) | 0) >= destBuffer.v.length) {\n                            break;\n                        }\n\n                        destBuffer.v[((yPosition + xPosition) | 0)] = (tile[(((Bridge.Int.mul(j, 8)) + i) | 0)]) & 255;\n                    }\n                }\n            },\n            GetNameTableEntryLocation: function (x, y) {\n                var $t, $t1;\n                return ($t = ($t1 = this.currentNameTableEntries[((Bridge.Int.div(x, 32)) | 0)])[((Bridge.Int.div(y, 30)) | 0)])[y & 7];\n            },\n            GetPatternEntryLocation: function (table, x, y) {\n                var $t, $t1, $t2;\n                return ($t = ($t1 = ($t2 = this.currentPatternTableEntries[table])[((Bridge.Int.div(x, 32)) | 0)])[((Bridge.Int.div(y, 30)) | 0)])[y & 7];\n            }\n        }\n    });\n\n    Bridge.define(\"ChiChiNES.INESCart\", {\n        inherits: [ChiChiNES.IClockedMemoryMappedIOElement],\n        $kind: \"interface\"\n    });\n\n    Bridge.define(\"ChiChiNES.BeepsBoops.Bopper\", {\n        inherits: [ChiChiNES.IClockedMemoryMappedIOElement,ChiChiNES.BeepsBoops.IAPU],\n        statics: {\n            fields: {\n                master_vol: 0,\n                clock_rate: 0\n            },\n            ctors: {\n                init: function () {\n                    this.master_vol = 4369;\n                    this.clock_rate = 1789772.727;\n                }\n            }\n        },\n        fields: {\n            square0: null,\n            square1: null,\n            triangle: null,\n            noise: null,\n            writer: null,\n            dmc: null,\n            myBlipper: null,\n            _throwingIRQs: false,\n            registers: null,\n            _sampleRate: 0,\n            square0Gain: 0,\n            square1Gain: 0,\n            triangleGain: 0,\n            noiseGain: 0,\n            reg15: 0,\n            muted: false,\n            lastFrameHit: 0,\n            _writeBuffer: null,\n            _interruptRaised: false,\n            lastClock: 0\n        },\n        props: {\n            SampleRate: {\n                get: function () {\n                    return this._sampleRate;\n                },\n                set: function (value) {\n                    this._sampleRate = value;\n                    this.RebuildSound();\n                }\n            },\n            Muted: {\n                get: function () {\n                    return this.muted;\n                },\n                set: function (value) {\n                    this.muted = value;\n                }\n            },\n            WriteBuffer: {\n                get: function () {\n                    return this._writeBuffer;\n                },\n                set: function (value) {\n                    this._writeBuffer = value;\n                }\n            },\n            InterruptRaised: {\n                get: function () {\n                    return this._interruptRaised;\n                },\n                set: function (value) {\n                    this._interruptRaised = value;\n                }\n            },\n            EnableSquare0: {\n                get: function () {\n                    return (this.square0.Gain !== 0);\n                },\n                set: function (value) {\n                    this.square0.Gain = (value) ? this.square0Gain : 0;\n                }\n            },\n            EnableSquare1: {\n                get: function () {\n                    return (this.square1.Gain !== 0);\n                },\n                set: function (value) {\n                    this.square1.Gain = (value) ? this.square1Gain : 0;\n                }\n            },\n            EnableTriangle: {\n                get: function () {\n                    return (this.triangle.Gain !== 0);\n                },\n                set: function (value) {\n                    this.triangle.Gain = (value) ? this.triangleGain : 0;\n                }\n            },\n            EnableNoise: {\n                get: function () {\n                    return (this.noise.Gain !== 0);\n                },\n                set: function (value) {\n                    this.noise.Gain = (value) ? this.noiseGain : 0;\n                }\n            },\n            NMIHandler: {\n                get: function () {\n                    return null;\n                },\n                set: function (value) { }\n            },\n            IRQAsserted: {\n                get: function () {\n                    return false;\n                },\n                set: function (value) {\n                    // throw new NotImplementedException();\n                }\n            },\n            NextEventAt: {\n                get: function () {\n                    return 7445 * (this.lastFrameHit + 1) - this.lastClock;\n                }\n            }\n        },\n        alias: [\n            \"GetByte\", \"ChiChiNES$IClockedMemoryMappedIOElement$GetByte\",\n            \"SetByte\", \"ChiChiNES$IClockedMemoryMappedIOElement$SetByte\",\n            \"Muted\", \"ChiChiNES$BeepsBoops$IAPU$Muted\",\n            \"UpdateFrame\", \"ChiChiNES$BeepsBoops$IAPU$UpdateFrame\",\n            \"EndFrame\", \"ChiChiNES$BeepsBoops$IAPU$EndFrame\",\n            \"InterruptRaised\", \"ChiChiNES$BeepsBoops$IAPU$InterruptRaised\",\n            \"EnableSquare0\", \"ChiChiNES$BeepsBoops$IAPU$EnableSquare0\",\n            \"EnableSquare1\", \"ChiChiNES$BeepsBoops$IAPU$EnableSquare1\",\n            \"EnableTriangle\", \"ChiChiNES$BeepsBoops$IAPU$EnableTriangle\",\n            \"EnableNoise\", \"ChiChiNES$BeepsBoops$IAPU$EnableNoise\",\n            \"NMIHandler\", \"ChiChiNES$IClockedMemoryMappedIOElement$NMIHandler\",\n            \"IRQAsserted\", \"ChiChiNES$IClockedMemoryMappedIOElement$IRQAsserted\",\n            \"NextEventAt\", \"ChiChiNES$IClockedMemoryMappedIOElement$NextEventAt\",\n            \"HandleEvent\", \"ChiChiNES$IClockedMemoryMappedIOElement$HandleEvent\",\n            \"ResetClock\", \"ChiChiNES$IClockedMemoryMappedIOElement$ResetClock\"\n        ],\n        ctors: {\n            init: function () {\n                this.registers = new ChiChiNES.PortQueueing.QueuedPort();\n                this._sampleRate = 11025;\n                this.square0Gain = 873;\n                this.square1Gain = 873;\n                this.triangleGain = 1004;\n                this.noiseGain = 567;\n                this.muted = false;\n                this.lastFrameHit = 0;\n                this._writeBuffer = System.Array.init(1024, 0, System.Int16);\n            },\n            ctor: function (output) {\n                this.$initialize();\n\n                this.writer = output;\n                this._sampleRate = output.Frequency;\n                this.RebuildSound();\n            }\n        },\n        methods: {\n            RebuildSound: function () {\n                var $t;\n                this.myBlipper = new ChiChiNES.BeepsBoops.Blip(this._sampleRate / 5);\n                this.myBlipper.blip_set_rates(ChiChiNES.BeepsBoops.Bopper.clock_rate, this._sampleRate);\n\n\n                this.registers.clear();\n                this._interruptRaised = false;\n                this.square0Gain = 873;\n                this.square1Gain = 873;\n                this.triangleGain = 1004;\n                this.noiseGain = 567;\n\n                this.square0 = ($t = new ChiChiNES.BeepsBoops.SquareChannel(this.myBlipper, 0), $t.Gain = this.square0Gain, $t.Period = 10, $t.SweepComplement = true, $t);\n                this.square1 = ($t = new ChiChiNES.BeepsBoops.SquareChannel(this.myBlipper, 1), $t.Gain = this.square1Gain, $t.Period = 10, $t.SweepComplement = false, $t);\n                this.triangle = ($t = new ChiChiNES.BeepsBoops.TriangleChannel(this.myBlipper, 2), $t.Gain = this.triangleGain, $t.Period = 0, $t);\n                this.noise = ($t = new ChiChiNES.BeepsBoops.NoiseChannel(this.myBlipper, 3), $t.Gain = this.noiseGain, $t.Period = 0, $t);\n                this.dmc = ($t = new ChiChiNES.BeepsBoops.DMCChannel(this.myBlipper, 4), $t.Gain = 873, $t.Period = 10, $t);\n            },\n            GetByte: function (Clock, address) {\n                if (address === 16384) {\n                    this._interruptRaised = false;\n                }\n                if (address === 16405) {\n                    return this.ReadStatus();\n                } else {\n                    return 66;\n                }\n            },\n            ReadStatus: function () {\n                return ((this.square0.Length > 0) ? 1 : 0) | ((this.square1.Length > 0) ? 2 : 0) | ((this.triangle.Length > 0) ? 4 : 0) | ((this.square0.Length > 0) ? 8 : 0) | (this._interruptRaised ? 64 : 0);\n            },\n            SetByte: function (Clock, address, data) {\n                if (address === 16384) {\n                    this._interruptRaised = false;\n                }\n                //DoSetByte( Clock,  address,  data);\n                // registers.Enqueue(new PortWriteEntry(Clock, (ushort)address, (byte)data));\n\n\n            },\n            DoSetByte: function (Clock, address, data) {\n                switch (address) {\n                    case 16384: \n                    case 16385: \n                    case 16386: \n                    case 16387: \n                        this.square0.WriteRegister(address - 16384, data, Clock);\n                        break;\n                    case 16388: \n                    case 16389: \n                    case 16390: \n                    case 16391: \n                        this.square1.WriteRegister(address - 16388, data, Clock);\n                        break;\n                    case 16392: \n                    case 16393: \n                    case 16394: \n                    case 16395: \n                        this.triangle.WriteRegister(address - 16392, data, Clock);\n                        break;\n                    case 16396: \n                    case 16397: \n                    case 16398: \n                    case 16399: \n                        this.noise.WriteRegister(address - 16396, data, Clock);\n                        break;\n                    case 16400: \n                    case 16401: \n                    case 16402: \n                    case 16403: \n                        // dmc.WriteRegister(address - 0x40010, data, Clock);\n                        break;\n                    case 16405: \n                        this.reg15 = data;\n                        this.square0.WriteRegister(4, data & 1, Clock);\n                        this.square1.WriteRegister(4, data & 2, Clock);\n                        this.triangle.WriteRegister(4, data & 4, Clock);\n                        this.noise.WriteRegister(4, data & 8, Clock);\n                        break;\n                    case 16407: \n                        this._throwingIRQs = ((data & 64) !== 64);\n                        this.lastFrameHit = 0;\n                        break;\n                }\n            },\n            UpdateFrame: function (time) {\n                if (this.muted) {\n                    return;\n                }\n\n                this.RunFrameEvents(time, this.lastFrameHit);\n                if (this.lastFrameHit === 3) {\n\n                    if (this._throwingIRQs) {\n                        this._interruptRaised = true;\n                    }\n                    this.lastFrameHit = 0;\n                    //EndFrame(time);\n                } else {\n                    this.lastFrameHit++;\n                }\n\n\n            },\n            RunFrameEvents: function (time, step) {\n                this.triangle.FrameClock(time, step);\n                this.noise.FrameClock(time, step);\n                this.square0.FrameClock(time, step);\n                this.square1.FrameClock(time, step);\n                // dmc.FrameClock(time, step);\n            },\n            EndFrame: function (time) {\n\n                this.square0.EndFrame(time);\n                this.square1.EndFrame(time);\n                this.triangle.EndFrame(time);\n                this.noise.EndFrame(time);\n\n                if (!this.muted) {\n                    this.myBlipper.blip_end_frame(time);\n                }\n\n                this.writer.Locker;\n                {\n                    var count = this.myBlipper.ReadBytes(this.writer.SharedBuffer, this.writer.SharedBuffer.length / 2, 0);\n                    this.writer.WavesWritten(count);\n                }\n            },\n            FlushFrame: function (time) {\n                var currentClock = 0;\n                var frameClocker = 0;\n                var currentEntry;\n                while (this.registers.Count > 0) {\n                    currentEntry = this.registers.dequeue();\n                    if (frameClocker > 7445) {\n                        frameClocker -= 7445;\n                        this.UpdateFrame(7445);\n                    }\n                    this.DoSetByte(currentEntry.time, currentEntry.address, currentEntry.data);\n                    currentClock = currentEntry.time;\n                    frameClocker = currentEntry.time;\n                }\n\n                // hit the latest frame boundary, maybe too much math for too little reward\n                var clockDelta = currentClock % 7445;\n\n                if (this.lastFrameHit === 0) {\n                    this.UpdateFrame(7445);\n                }\n                while (this.lastFrameHit > 0) {\n                    this.UpdateFrame(7445 * (this.lastFrameHit + 1));\n                }\n            },\n            HandleEvent: function (Clock) {\n                this.UpdateFrame(Clock);\n                this.lastClock = Clock;\n\n                if (Clock > 29780) {\n                    this.writer;\n                    {\n                        this.EndFrame(Clock);\n                    }\n                }\n            },\n            ResetClock: function (Clock) {\n                this.lastClock = Clock;\n            }\n        }\n    });\n\n    Bridge.define(\"ChiChiNES.BeepsBoops.WavSharer\", {\n        inherits: [ChiChiNES.BeepsBoops.IWavReader],\n        statics: {\n            fields: {\n                sample_size: 0\n            },\n            ctors: {\n                init: function () {\n                    this.sample_size = 2;\n                }\n            }\n        },\n        fields: {\n            _NESTooFast: false,\n            Locker: null,\n            frequency: 0,\n            _sharedBuffer: null,\n            _sharedBufferLength: 0,\n            _bufferAvailable: false,\n            appendToFile: null,\n            fileWriting: false,\n            bufferWasRead: false,\n            bytesWritten: null\n        },\n        props: {\n            NESTooFast: {\n                get: function () {\n                    return this._NESTooFast;\n                },\n                set: function (value) {\n                    this._NESTooFast = value;\n                }\n            },\n            Frequency: {\n                get: function () {\n                    return this.frequency;\n                }\n            },\n            SharedBuffer: {\n                get: function () {\n                    return this._sharedBuffer;\n                },\n                set: function (value) {\n                    this._sharedBuffer = value;\n                }\n            },\n            SharedBufferLength: {\n                get: function () {\n                    return this._sharedBufferLength;\n                },\n                set: function (value) {\n                    this._sharedBufferLength = value;\n                }\n            },\n            BufferAvailable: {\n                get: function () {\n                    return this._bufferAvailable;\n                }\n            },\n            BytesWritten: {\n                get: function () {\n                    return this.bytesWritten;\n                },\n                set: function (value) {\n                    this.bytesWritten = value;\n                }\n            }\n        },\n        alias: [\n            \"Frequency\", \"ChiChiNES$BeepsBoops$IWavReader$Frequency\",\n            \"SharedBuffer\", \"ChiChiNES$BeepsBoops$IWavReader$SharedBuffer\",\n            \"SharedBufferLength\", \"ChiChiNES$BeepsBoops$IWavReader$SharedBufferLength\",\n            \"BufferAvailable\", \"ChiChiNES$BeepsBoops$IWavReader$BufferAvailable\",\n            \"StartReadWaves\", \"ChiChiNES$BeepsBoops$IWavReader$StartReadWaves\",\n            \"ReadWaves\", \"ChiChiNES$BeepsBoops$IWavReader$ReadWaves\",\n            \"BytesWritten\", \"ChiChiNES$BeepsBoops$IWavReader$BytesWritten\",\n            \"SetSharedBuffer\", \"ChiChiNES$BeepsBoops$IWavReader$SetSharedBuffer\"\n        ],\n        ctors: {\n            init: function () {\n                this.Locker = { };\n                this.frequency = 22050;\n            },\n            $ctor1: function (frequency) {\n                ChiChiNES.BeepsBoops.WavSharer.ctor.call(this);\n                this.frequency = frequency;\n            },\n            ctor: function () {\n                this.$initialize();\n                // should hold a frame worth\n                //pendingWaves = new Queue<byte>(1500);\n\n                this._sharedBuffer = System.Array.init(8192, 0, System.Byte);\n            }\n        },\n        methods: {\n            WavesWritten: function (remain) {\n                var n = (Bridge.Int.div(this._sharedBuffer.length, ChiChiNES.BeepsBoops.WavSharer.sample_size)) | 0;\n                if (n > remain) {\n                    n = remain;\n                }\n                this._sharedBufferLength = Bridge.Int.mul(n, 2);\n\n                //if (fileWriting)\n                //{\n                //        appendToFile.WriteWaves(_sharedBuffer, _sharedBufferLength);\n                //}\n                this.bufferWasRead = false;\n                this._bufferAvailable = true;\n                this.WroteBytes();\n            },\n            AppendFile: function (writer) {\n                this.appendToFile = writer;\n                this.fileWriting = (this.appendToFile != null);\n            },\n            Dispose: function () {\n                if (null != this.appendToFile) {\n                    this.appendToFile.System$IDisposable$dispose();\n                }\n            },\n            StartReadWaves: function () { },\n            ReadWaves: function () {\n\n                this._bufferAvailable = false;\n                this._sharedBufferLength = 0;\n                this.bufferWasRead = true;\n                // bufferReadResetEvent.Set();\n            },\n            WroteBytes: function () {\n                if (!Bridge.staticEquals(this.bytesWritten, null)) {\n                    this.bytesWritten(this, { });\n                }\n            },\n            SetSharedBuffer: function (values) {\n                this._sharedBuffer = values;\n            }\n        }\n    });\n\n    Bridge.define(\"ChiChiNES.Hacking.ComparedMemoryPatch\", {\n        inherits: [ChiChiNES.Hacking.IMemoryPatch],\n        fields: {\n            _CompareData: 0,\n            _ReplaceData: 0\n        },\n        props: {\n            Activated: false,\n            Address: 0\n        },\n        alias: [\n            \"Activated\", \"ChiChiNES$Hacking$IMemoryPatch$Activated\",\n            \"Address\", \"ChiChiNES$Hacking$IMemoryPatch$Address\",\n            \"GetData\", \"ChiChiNES$Hacking$IMemoryPatch$GetData\"\n        ],\n        ctors: {\n            ctor: function (Address, CompareToData, ReplaceWithData) {\n                this.$initialize();\n                this._CompareData = CompareToData;\n                this._ReplaceData = ReplaceWithData;\n                this.Address = Address;\n            }\n        },\n        methods: {\n            GetData: function (data) {\n                return (data === this._CompareData) ? this._ReplaceData : data;\n            },\n            toString: function () {\n                return System.String.format(\"{0} = {1} if {2} Activated: {3}\", this.Address, this._ReplaceData, this._CompareData, this.Activated);\n            }\n        }\n    });\n\n    Bridge.define(\"ChiChiNES.Hacking.MemoryPatch\", {\n        inherits: [ChiChiNES.Hacking.IMemoryPatch],\n        fields: {\n            _data: 0\n        },\n        props: {\n            Activated: false,\n            Address: 0\n        },\n        alias: [\n            \"Activated\", \"ChiChiNES$Hacking$IMemoryPatch$Activated\",\n            \"Address\", \"ChiChiNES$Hacking$IMemoryPatch$Address\",\n            \"GetData\", \"ChiChiNES$Hacking$IMemoryPatch$GetData\"\n        ],\n        ctors: {\n            ctor: function (Address, Data) {\n                this.$initialize();\n                this._data = Data;\n                this.Address = Address;\n            }\n        },\n        methods: {\n            GetData: function (data) {\n                return this._data;\n            },\n            toString: function () {\n                return System.String.format(\"{0} = {1}  Activated: {2}\", this.Address, this._data, this.Activated);\n            }\n        }\n    });\n\n    Bridge.define(\"ChiChiNES.InputHandler\", {\n        inherits: [ChiChiNES.IClockedMemoryMappedIOElement],\n        fields: {\n            currentByte: 0,\n            nextByte: 0,\n            controlPad: null,\n            isZapper: false,\n            inputLock: null\n        },\n        props: {\n            IsZapper: {\n                get: function () {\n                    return this.isZapper;\n                },\n                set: function (value) {\n                    this.isZapper = value;\n                }\n            },\n            ControlPad: {\n                get: function () {\n                    return this.controlPad;\n                },\n                set: function (value) {\n                    this.controlPad = value;\n                }\n            },\n            CurrentByte: {\n                get: function () {\n\n                    return this.currentByte;\n                },\n                set: function (value) {\n                    this.currentByte = value;\n                }\n            },\n            NMIHandler: {\n                get: function () {\n                    throw new System.NotImplementedException();\n                },\n                set: function (value) {\n                    throw new System.NotImplementedException();\n                }\n            },\n            IRQAsserted: {\n                get: function () {\n                    throw new System.NotImplementedException();\n                },\n                set: function (value) {\n                    throw new System.NotImplementedException();\n                }\n            },\n            NextEventAt: {\n                get: function () {\n                    throw new System.NotImplementedException();\n                }\n            }\n        },\n        alias: [\n            \"GetByte\", \"ChiChiNES$IClockedMemoryMappedIOElement$GetByte\",\n            \"SetByte\", \"ChiChiNES$IClockedMemoryMappedIOElement$SetByte\",\n            \"NMIHandler\", \"ChiChiNES$IClockedMemoryMappedIOElement$NMIHandler\",\n            \"IRQAsserted\", \"ChiChiNES$IClockedMemoryMappedIOElement$IRQAsserted\",\n            \"NextEventAt\", \"ChiChiNES$IClockedMemoryMappedIOElement$NextEventAt\",\n            \"HandleEvent\", \"ChiChiNES$IClockedMemoryMappedIOElement$HandleEvent\",\n            \"ResetClock\", \"ChiChiNES$IClockedMemoryMappedIOElement$ResetClock\"\n        ],\n        ctors: {\n            init: function () {\n                this.isZapper = false;\n                this.inputLock = { };\n            },\n            ctor: function () {\n                this.$initialize();\n                this.controlPad = null;\n            },\n            $ctor1: function (padOne) {\n                this.$initialize();\n                this.ControlPad = padOne;\n            }\n        },\n        methods: {\n            controlPad_NextControlByteSet: function (sender, e) {\n                this.SetNextControlByte(e.NextValue);\n            },\n            GetByte: function (clock, address) {\n                return this.controlPad.ChiChiNES$IControlPad$getByte(clock);\n\n\n            },\n            SetByte: function (clock, address, data) {\n                this.controlPad.ChiChiNES$IControlPad$setByte(clock, data);\n            },\n            SetNextControlByte: function (data) {\n\n                this.nextByte = data;\n\n            },\n            HandleEvent: function (Clock) {\n                throw new System.NotImplementedException();\n            },\n            ResetClock: function (Clock) {\n                throw new System.NotImplementedException();\n            }\n        }\n    });\n\n    /** @namespace ChiChiNES */\n\n    /**\n     * plugs up a nes control port, when nothing else is using it\n     *\n     * @public\n     * @class ChiChiNES.NullControlPad\n     * @implements  ChiChiNES.IControlPad\n     */\n    Bridge.define(\"ChiChiNES.NullControlPad\", {\n        inherits: [ChiChiNES.IControlPad],\n        props: {\n            CurrentByte: {\n                get: function () {\n                    return 0;\n                },\n                set: function (value) { }\n            }\n        },\n        alias: [\n            \"CurrentByte\", \"ChiChiNES$IControlPad$CurrentByte\",\n            \"refresh\", \"ChiChiNES$IControlPad$refresh\",\n            \"getByte\", \"ChiChiNES$IControlPad$getByte\",\n            \"setByte\", \"ChiChiNES$IControlPad$setByte\",\n            \"dispose\", \"System$IDisposable$dispose\"\n        ],\n        methods: {\n            refresh: function () { },\n            getByte: function (clock) {\n                return 0;\n            },\n            setByte: function (clock, data) { },\n            dispose: function () { }\n        }\n    });\n\n    Bridge.define(\"ChiChiNES.PixelWhizzler\", {\n        inherits: [ChiChiNES.IPPU,ChiChiNES.IClockedMemoryMappedIOElement],\n        statics: {\n            fields: {\n                ScanlinePreRenderDummyScanline: 0,\n                ScanlineRenderingStartsOn: 0,\n                ScanlineRenderingEndsOn: 0,\n                ScanlineLastRenderedPixel: 0,\n                ScanlineTotalLength: 0,\n                ScanlineEventPPUXIncremented: 0,\n                ScanlineEventPPUXReset: 0,\n                ScanlineEventPPUYIncremented: 0,\n                vBufferWidth: 0,\n                _powersOfTwo: null,\n                pal: null,\n                frameClockEnd: 0\n            },\n            props: {\n                PowersOfTwo: {\n                    get: function () {\n                        return ChiChiNES.PixelWhizzler._powersOfTwo;\n                    }\n                }\n            },\n            ctors: {\n                init: function () {\n                    this.ScanlinePreRenderDummyScanline = 20;\n                    this.ScanlineRenderingStartsOn = 21;\n                    this.ScanlineRenderingEndsOn = 260;\n                    this.ScanlineLastRenderedPixel = 255;\n                    this.ScanlineTotalLength = 340;\n                    this.ScanlineEventPPUXIncremented = 3;\n                    this.ScanlineEventPPUXReset = 257;\n                    this.ScanlineEventPPUYIncremented = 251;\n                    this.vBufferWidth = 256;\n                    this._powersOfTwo = System.Array.init(32, 0, System.Int32);\n                    this.pal = System.Array.init([7961465, 10626572, 11407400, 10554206, 7733552, 2753820, 725017, 271983, 278855, 284436, 744967, 3035906, 7161605, 0, 131586, 131586, 12566719, 14641430, 15614283, 14821245, 12196292, 6496468, 2176980, 875189, 293472, 465210, 1597716, 5906953, 11090185, 2961197, 197379, 197379, 16316149, 16298569, 16588080, 16415170, 15560682, 12219892, 7115511, 4563694, 2277591, 2151458, 4513360, 1957181, 14604331, 6579811, 263172, 263172, 16447992, 16441012, 16634316, 16500447, 16236786, 14926838, 12831991, 11393781, 2287340, 5500370, 11858360, 14283440, 15921318, 13158344, 328965, 328965, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], System.Int32);\n                    this.frameClockEnd = 89342;\n                },\n                ctor: function () {\n                    for (var i = 0; i < 32; i = (i + 1) | 0) {\n                        ChiChiNES.PixelWhizzler._powersOfTwo[i] = Bridge.Int.clip32(Math.pow(2.0, i));\n                    }\n                }\n            },\n            methods: {\n                \n                GetPalRGBA: function () {\n                    //Open App.Path & \"\\\" + file For Binary As #FileNum\n                    for (var n = 0; n < 64; n = (n + 1) | 0) {\n                        ChiChiNES.PixelWhizzler.pal[((n + 64) | 0)] = ChiChiNES.PixelWhizzler.pal[n];\n                        ChiChiNES.PixelWhizzler.pal[((n + 128) | 0)] = ChiChiNES.PixelWhizzler.pal[n];\n                        ChiChiNES.PixelWhizzler.pal[((n + 192) | 0)] = ChiChiNES.PixelWhizzler.pal[n];\n                    }\n                    return ChiChiNES.PixelWhizzler.pal;\n                }\n            }\n        },\n        fields: {\n            currentXPosition: 0,\n            currentYPosition: 0,\n            scanlineNum: 0,\n            scanlinePos: 0,\n            _isDebugging: false,\n            shouldRender: false,\n            vBuffer: null,\n            nameTableIndex: 0,\n            _frames: 0,\n            hitSprite: false,\n            _PPUControlByte0: 0,\n            _PPUControlByte1: 0,\n            _spritesAreVisible: false,\n            _tilesAreVisible: false,\n            _PPUStatus: 0,\n            _PPUAddress: 0,\n            ppuReadBuffer: 0,\n            PPUAddressLatchIsHigh: false,\n            /**\n             * Initializes the rendering pallette with the bytes in a BGR format, instead of the default RGB format\n             *\n             * @instance\n             * @private\n             * @memberof ChiChiNES.PixelWhizzler\n             * @type Array.<number>\n             */\n            p32: null,\n            _backgroundPatternTableIndex: 0,\n            needToDraw: false,\n            isRendering: false,\n            frameClock: 0,\n            FrameEnded: false,\n            frameOn: false,\n            framePalette: null,\n            nameTableMemoryStart: 0,\n            lastcpuClock: 0,\n            rgb32OutBuffer: null,\n            byteOutBuffer: null,\n            outBuffer: null,\n            vbufLocation: 0,\n            drawInfo: null,\n            pixelDevices: null,\n            _clipTiles: false,\n            _clipSprites: false,\n            nameTableBits: 0,\n            vidRamIsRam: false,\n            _palette: null,\n            _openBus: 0,\n            currentPalette: 0,\n            nmiHandler: null,\n            frameFinished: null,\n            NMIHasBeenThrownThisFrame: false,\n            _hScroll: 0,\n            _vScroll: 0,\n            lockedHScroll: 0,\n            lockedVScroll: 0,\n            spriteChanges: false,\n            _spriteCopyHasHappened: false,\n            sprite0scanline: 0,\n            sprite0x: 0,\n            spriteZeroHit: false,\n            isForegroundPixel: false,\n            currentSprites: null,\n            unpackedSprites: null,\n            _maxSpritesPerScanline: 0,\n            spriteRAM: null,\n            _spriteAddress: 0,\n            spritesOnThisScanline: 0,\n            spriteSize: 0,\n            spritesOnLine: null,\n            patternEntry: 0,\n            patternEntryByte2: 0,\n            currentAttributeByte: 0,\n            currentTileIndex: 0,\n            xNTXor: 0,\n            yNTXor: 0,\n            fetchTile: false,\n            xPosition: 0,\n            yPosition: 0,\n            chrRomHandler: null,\n            events: null\n        },\n        props: {\n            CurrentYPosition: {\n                get: function () {\n                    return this.currentYPosition;\n                }\n            },\n            CurrentXPosition: {\n                get: function () {\n                    return this.currentXPosition;\n                }\n            },\n            ScanlinePos: {\n                get: function () {\n                    return this.scanlinePos;\n                }\n            },\n            ScanlineNum: {\n                get: function () {\n                    return this.scanlineNum;\n                }\n            },\n            IsDebugging: {\n                get: function () {\n                    return this._isDebugging;\n                },\n                set: function (value) {\n                    this._isDebugging = value;\n                }\n            },\n            ShouldRender: {\n                get: function () {\n                    return this.shouldRender;\n                },\n                set: function (value) {\n                    this.shouldRender = value;\n                }\n            },\n            Frames: {\n                get: function () {\n                    return this._frames;\n                }\n            },\n            HandleVBlankIRQ: false,\n            VROM: null,\n            PPUControlByte0: {\n                get: function () {\n                    return this._PPUControlByte0;\n                },\n                set: function (value) {\n                    if (this._PPUControlByte0 !== value) {\n                        this._PPUControlByte0 = value;\n                        this.UpdatePPUControlByte0();\n                    }\n                }\n            },\n            NMIIsThrown: {\n                get: function () {\n                    return (this._PPUControlByte0 & 128) === 128;\n                }\n            },\n            PPUControlByte1: {\n                get: function () {\n                    return this._PPUControlByte1;\n                },\n                set: function (value) {\n                    this._PPUControlByte1 = value;\n                }\n            },\n            BackgroundVisible: {\n                get: function () {\n                    return this._tilesAreVisible;\n                }\n            },\n            SpritesAreVisible: {\n                get: function () {\n                    return this._spritesAreVisible;\n                }\n            },\n            PPUStatus: {\n                get: function () {\n                    return this._PPUStatus;\n                },\n                set: function (value) {\n                    this._PPUStatus = value;\n                }\n            },\n            PPUAddress: {\n                get: function () {\n                    return this._PPUAddress;\n                },\n                set: function (value) {\n                    this._PPUAddress = value;\n                }\n            },\n            PatternTableIndex: {\n                get: function () {\n                    return this._backgroundPatternTableIndex;\n                }\n            },\n            NeedToDraw: {\n                get: function () {\n                    return this.needToDraw;\n                }\n            },\n            IsRendering: {\n                get: function () {\n                    return this.isRendering;\n                }\n            },\n            FrameOn: {\n                get: function () {\n                    return this.frameOn;\n                },\n                set: function (value) {\n                    this.frameOn = value;\n                }\n            },\n            NameTableMemoryStart: {\n                get: function () {\n                    return this.nameTableMemoryStart;\n                },\n                set: function (value) {\n                    this.nameTableMemoryStart = value;\n                }\n            },\n            CurrentFrame: {\n                get: function () {\n                    return this.vBuffer;\n                }\n            },\n            LastcpuClock: {\n                get: function () {\n                    return this.lastcpuClock;\n                },\n                set: function (value) {\n                    this.lastcpuClock = value;\n                }\n            },\n            OutBuffer: {\n                get: function () {\n                    return this.outBuffer;\n                }\n            },\n            VideoBuffer: {\n                get: function () {\n                    return this.rgb32OutBuffer;\n                }\n            },\n            PixelAwareDevice: {\n                get: function () {\n                    return this.pixelDevices;\n                },\n                set: function (value) {\n                    this.pixelDevices = value;\n                }\n            },\n            ByteOutBuffer: {\n                get: function () {\n                    return this.byteOutBuffer;\n                },\n                set: function (value) {\n                    this.byteOutBuffer = value;\n                }\n            },\n            Palette: {\n                get: function () {\n                    return this._palette;\n                },\n                set: function (value) {\n                    this._palette = value;\n                }\n            },\n            CurrentPalette: {\n                get: function () {\n                    return this.currentPalette;\n                }\n            },\n            NMIHandler: {\n                get: function () {\n                    return this.nmiHandler;\n                },\n                set: function (value) {\n                    this.nmiHandler = value;\n                }\n            },\n            /**\n             * ppu doesnt throw irq's\n             *\n             * @instance\n             * @public\n             * @memberof ChiChiNES.PixelWhizzler\n             * @function IRQAsserted\n             * @type boolean\n             */\n            IRQAsserted: {\n                get: function () {\n                    throw new System.NotImplementedException();\n                },\n                set: function (value) {\n                    throw new System.NotImplementedException();\n                }\n            },\n            NextEventAt: {\n                get: function () {\n                    if (this.frameClock < 6820) {\n                        return ((Bridge.Int.div((((6820 - this.frameClock) | 0)), 3)) | 0);\n                    } else {\n                        return (((Bridge.Int.div((((Bridge.Int.div((((89345 - this.frameClock) | 0)), 341)) | 0)), 3)) | 0));\n                    }\n                    //}\n                    //else\n                    //{\n                    //    return (6823 - frameClock) / 3;\n                    //}\n                }\n            },\n            FrameFinishHandler: {\n                get: function () {\n                    return this.frameFinished;\n                },\n                set: function (value) {\n                    this.frameFinished = value;\n                }\n            },\n            NMIOccurred: {\n                get: function () {\n                    return (this._PPUStatus & 128) === 128;\n                }\n            },\n            HScroll: {\n                get: function () {\n                    return this.lockedHScroll;\n                }\n            },\n            VScroll: {\n                get: function () {\n                    return this.lockedVScroll;\n                }\n            },\n            SpriteCopyHasHappened: {\n                get: function () {\n                    return this._spriteCopyHasHappened;\n                },\n                set: function (value) {\n                    this._spriteCopyHasHappened = value;\n                }\n            },\n            MaxSpritesPerScanline: {\n                get: function () {\n                    return this._maxSpritesPerScanline;\n                },\n                set: function (value) {\n                    this._maxSpritesPerScanline = value;\n                }\n            },\n            SpriteRam: {\n                get: function () {\n                    return this.spriteRAM;\n                }\n            },\n            SpritesOnLine: {\n                get: function () {\n                    return this.spritesOnLine;\n                }\n            },\n            ChrRomHandler: {\n                get: function () {\n                    return this.chrRomHandler;\n                },\n                set: function (value) {\n                    this.chrRomHandler = value;\n                }\n            },\n            Events: {\n                get: function () {\n                    return this.events;\n                }\n            }\n        },\n        alias: [\n            \"ScanlinePos\", \"ChiChiNES$IPPU$ScanlinePos\",\n            \"ScanlineNum\", \"ChiChiNES$IPPU$ScanlineNum\",\n            \"Initialize\", \"ChiChiNES$IPPU$Initialize\",\n            \"WriteState\", \"ChiChiNES$IPPU$WriteState\",\n            \"ReadState\", \"ChiChiNES$IPPU$ReadState\",\n            \"VidRAM_GetNTByte\", \"ChiChiNES$IPPU$VidRAM_GetNTByte\",\n            \"PPUControlByte0\", \"ChiChiNES$IPPU$PPUControlByte0\",\n            \"PPUControlByte1\", \"ChiChiNES$IPPU$PPUControlByte1\",\n            \"SpritesAreVisible\", \"ChiChiNES$IPPU$SpritesAreVisible\",\n            \"SetupBufferForDisplay\", \"ChiChiNES$IPPU$SetupBufferForDisplay\",\n            \"PatternTableIndex\", \"ChiChiNES$IPPU$PatternTableIndex\",\n            \"NameTableMemoryStart\", \"ChiChiNES$IPPU$NameTableMemoryStart\",\n            \"CurrentFrame\", \"ChiChiNES$IPPU$CurrentFrame\",\n            \"RenderScanline\", \"ChiChiNES$IPPU$RenderScanline\",\n            \"LastcpuClock\", \"ChiChiNES$IPPU$LastcpuClock\",\n            \"DrawTo\", \"ChiChiNES$IPPU$DrawTo\",\n            \"VideoBuffer\", \"ChiChiNES$IPPU$VideoBuffer\",\n            \"SetVideoBuffer\", \"ChiChiNES$IPPU$SetVideoBuffer\",\n            \"UpdatePixelInfo\", \"ChiChiNES$IPPU$UpdatePixelInfo\",\n            \"PixelAwareDevice\", \"ChiChiNES$IPPU$PixelAwareDevice\",\n            \"ByteOutBuffer\", \"ChiChiNES$IPPU$ByteOutBuffer\",\n            \"Palette\", \"ChiChiNES$IPPU$Palette\",\n            \"SetByte\", \"ChiChiNES$IClockedMemoryMappedIOElement$SetByte\",\n            \"SetByte\", \"ChiChiNES$IPPU$SetByte\",\n            \"GetByte\", \"ChiChiNES$IClockedMemoryMappedIOElement$GetByte\",\n            \"GetByte\", \"ChiChiNES$IPPU$GetByte\",\n            \"NMIHandler\", \"ChiChiNES$IClockedMemoryMappedIOElement$NMIHandler\",\n            \"NMIHandler\", \"ChiChiNES$IPPU$NMIHandler\",\n            \"IRQAsserted\", \"ChiChiNES$IClockedMemoryMappedIOElement$IRQAsserted\",\n            \"NextEventAt\", \"ChiChiNES$IClockedMemoryMappedIOElement$NextEventAt\",\n            \"NextEventAt\", \"ChiChiNES$IPPU$NextEventAt\",\n            \"HandleEvent\", \"ChiChiNES$IClockedMemoryMappedIOElement$HandleEvent\",\n            \"HandleEvent\", \"ChiChiNES$IPPU$HandleEvent\",\n            \"ResetClock\", \"ChiChiNES$IClockedMemoryMappedIOElement$ResetClock\",\n            \"ResetClock\", \"ChiChiNES$IPPU$ResetClock\",\n            \"FrameFinishHandler\", \"ChiChiNES$IPPU$FrameFinishHandler\",\n            \"SetupVINT\", \"ChiChiNES$IPPU$SetupVINT\",\n            \"HScroll\", \"ChiChiNES$IPPU$HScroll\",\n            \"VScroll\", \"ChiChiNES$IPPU$VScroll\",\n            \"SpriteRam\", \"ChiChiNES$IPPU$SpriteRam\",\n            \"CopySprites\", \"ChiChiNES$IPPU$CopySprites\",\n            \"SpritesOnLine\", \"ChiChiNES$IPPU$SpritesOnLine\",\n            \"PreloadSprites\", \"ChiChiNES$IPPU$PreloadSprites\",\n            \"ChrRomHandler\", \"ChiChiNES$IPPU$ChrRomHandler\"\n        ],\n        ctors: {\n            init: function () {\n                this.currentXPosition = 0;\n                this.currentYPosition = 0;\n                this.scanlineNum = 0;\n                this.scanlinePos = 0;\n                this.shouldRender = false;\n                this._frames = 0;\n                this.hitSprite = false;\n                this.PPUAddressLatchIsHigh = true;\n                this.p32 = System.Array.init(256, 0, System.Int32);\n                this.needToDraw = true;\n                this.isRendering = true;\n                this.frameClock = 0;\n                this.FrameEnded = false;\n                this.frameOn = false;\n                this.framePalette = System.Array.init(256, 0, System.Int32);\n                this.rgb32OutBuffer = System.Array.init(65536, 0, System.Int32);\n                this.byteOutBuffer = System.Array.init(262144, 0, System.Byte);\n                this.outBuffer = System.Array.init(65536, 0, System.Int32);\n                this.drawInfo = System.Array.init(65536, 0, System.Int32);\n                this.nameTableBits = 0;\n                this.vidRamIsRam = true;\n                this._palette = System.Array.init(32, 0, System.Byte);\n                this._openBus = 0;\n                this.currentPalette = 0;\n                this.NMIHasBeenThrownThisFrame = false;\n                this._hScroll = 0;\n                this._vScroll = 0;\n                this.lockedHScroll = 0;\n                this.lockedVScroll = 0;\n                this.sprite0scanline = -1;\n                this.sprite0x = -1;\n                this._maxSpritesPerScanline = 64;\n                this.spriteRAM = System.Array.init(256, 0, System.Byte);\n                this.spritesOnLine = System.Array.init(512, 0, System.Int32);\n                this.patternEntry = 0;\n                this.patternEntryByte2 = 0;\n                this.currentTileIndex = 0;\n                this.xNTXor = 0;\n                this.yNTXor = 0;\n                this.fetchTile = true;\n                this.events = new (System.Collections.Generic.Queue$1(ChiChiNES.PPUWriteEvent)).ctor();\n            },\n            ctor: function () {\n                this.$initialize();\n                this.InitSprites();\n\n                this.vBuffer = System.Array.init(61440, 0, System.Byte);\n\n                ChiChiNES.PixelWhizzler.GetPalRGBA();\n\n                //for (int i = 0; i < 256; ++i)\n                //    palCache[i] = new byte[32];\n            }\n        },\n        methods: {\n            Initialize: function () {\n                this._PPUAddress = 0;\n                this._PPUStatus = 0;\n                this._PPUControlByte0 = 0;\n                this._PPUControlByte1 = 0;\n                this._hScroll = 0;\n                this.scanlineNum = 0;\n                this.scanlinePos = 0;\n                this._spriteAddress = 0;\n            },\n            WriteState: function (writer) {\n\n                writer.enqueue(this._PPUStatus);\n                writer.enqueue(this._PPUControlByte0);\n                writer.enqueue(this._hScroll);\n                writer.enqueue(this._vScroll);\n                writer.enqueue(this.scanlineNum);\n                writer.enqueue(this.scanlinePos);\n                writer.enqueue(this.currentYPosition);\n                writer.enqueue(this.currentXPosition);\n                writer.enqueue(this.nameTableIndex);\n                writer.enqueue(this._backgroundPatternTableIndex);\n\n\n                writer.enqueue(this.patternEntry);\n                writer.enqueue(this.patternEntryByte2);\n                writer.enqueue(this.currentAttributeByte);\n                writer.enqueue(this.xNTXor);\n                writer.enqueue(this.yNTXor);\n                writer.enqueue(this.fetchTile ? 0 : 1);\n                writer.enqueue(this.xPosition);\n                writer.enqueue(this.yPosition);\n\n\n                writer.enqueue(this.lastcpuClock);\n                writer.enqueue(this.vbufLocation);\n\n\n                for (var i = 0; i < 16384; i = (i + 4) | 0) {\n\n                    writer.enqueue(this.chrRomHandler.ChiChiNES$INESCart$GetPPUByte(0, i) << 24 | (this.chrRomHandler.ChiChiNES$INESCart$GetPPUByte(0, ((i + 1) | 0)) << 16) | (this.chrRomHandler.ChiChiNES$INESCart$GetPPUByte(0, ((i + 2) | 0)) << 8) | (this.chrRomHandler.ChiChiNES$INESCart$GetPPUByte(0, ((i + 3) | 0)) << 0));\n                }\n                writer.enqueue(this._spriteAddress);\n\n                for (var i1 = 0; i1 < 256; i1 = (i1 + 4) | 0) {\n\n                    writer.enqueue((this.spriteRAM[i1] << 24) | (this.spriteRAM[((i1 + 1) | 0)] << 16) | (this.spriteRAM[((i1 + 2) | 0)] << 8) | (this.spriteRAM[((i1 + 3) | 0)]));\n                }\n\n                for (var i2 = 0; i2 < ChiChiNES.PixelWhizzler.pal.length; i2 = (i2 + 4) | 0) {\n\n                    writer.enqueue((ChiChiNES.PixelWhizzler.pal[i2] << 24) | (ChiChiNES.PixelWhizzler.pal[((i2 + 1) | 0)] << 16) | (ChiChiNES.PixelWhizzler.pal[((i2 + 2) | 0)] << 8) | (ChiChiNES.PixelWhizzler.pal[((i2 + 3) | 0)]));\n                }\n\n                for (var i3 = 0; i3 < this._palette.length; i3 = (i3 + 4) | 0) {\n\n                    writer.enqueue((this._palette[i3] << 24) | (this._palette[((i3 + 1) | 0)] << 16) | (this._palette[((i3 + 2) | 0)] << 8) | (this._palette[((i3 + 3) | 0)]));\n                }\n\n            },\n            ReadState: function (state) {\n                this._PPUStatus = state.dequeue();\n                this._PPUControlByte0 = state.dequeue();\n                this._hScroll = state.dequeue();\n                this._vScroll = state.dequeue();\n                this.scanlineNum = state.dequeue();\n                this.scanlinePos = state.dequeue();\n                this.currentYPosition = state.dequeue();\n                this.currentXPosition = state.dequeue();\n                this.nameTableIndex = state.dequeue();\n                this._backgroundPatternTableIndex = state.dequeue();\n                //_mirroring= state.Dequeue();\n                //oneScreenMirrorOffset= state.Dequeue();\n                //currentMirrorMask= state.Dequeue();\n\n                this.patternEntry = state.dequeue();\n                this.patternEntryByte2 = state.dequeue();\n                this.currentAttributeByte = state.dequeue();\n                this.xNTXor = state.dequeue();\n                this.yNTXor = state.dequeue();\n                this.fetchTile = (state.dequeue() === 1);\n                this.xPosition = state.dequeue();\n                this.yPosition = state.dequeue();\n\n                this.lastcpuClock = state.dequeue();\n                this.vbufLocation = state.dequeue();\n\n                var packedByte = 0;\n                for (var i = 0; i < 16384; i = (i + 4) | 0) {\n                    packedByte = state.dequeue();\n                    this.chrRomHandler.ChiChiNES$IClockedMemoryMappedIOElement$SetByte(0, i, ((packedByte >> 24) & 255));\n                    this.chrRomHandler.ChiChiNES$IClockedMemoryMappedIOElement$SetByte(0, ((i + 1) | 0), ((packedByte >> 16) & 255));\n                    this.chrRomHandler.ChiChiNES$IClockedMemoryMappedIOElement$SetByte(0, ((i + 2) | 0), ((packedByte >> 8) & 255));\n                    this.chrRomHandler.ChiChiNES$IClockedMemoryMappedIOElement$SetByte(0, ((i + 3) | 0), (packedByte & 255));\n                }\n\n                this._spriteAddress = state.dequeue();\n\n                for (var i1 = 0; i1 < 256; i1 = (i1 + 4) | 0) {\n                    packedByte = state.dequeue();\n                    this.spriteRAM[i1] = (packedByte >> 24) & 255;\n                    this.spriteRAM[((i1 + 1) | 0)] = (packedByte >> 16) & 255;\n                    this.spriteRAM[((i1 + 2) | 0)] = (packedByte >> 8) & 255;\n                    this.spriteRAM[((i1 + 3) | 0)] = packedByte & 255;\n                }\n\n                for (var i2 = 0; i2 < ChiChiNES.PixelWhizzler.pal.length; i2 = (i2 + 4) | 0) {\n                    packedByte = state.dequeue();\n                    ChiChiNES.PixelWhizzler.pal[i2] = (packedByte >> 24) & 255;\n                    ChiChiNES.PixelWhizzler.pal[((i2 + 1) | 0)] = (packedByte >> 16) & 255;\n                    ChiChiNES.PixelWhizzler.pal[((i2 + 2) | 0)] = (packedByte >> 8) & 255;\n                    ChiChiNES.PixelWhizzler.pal[((i2 + 3) | 0)] = packedByte & 255;\n                }\n\n                for (var i3 = 0; i3 < this._palette.length; i3 = (i3 + 4) | 0) {\n                    packedByte = state.dequeue();\n                    this._palette[i3] = (packedByte >> 24) & 255;\n                    this._palette[((i3 + 1) | 0)] = (packedByte >> 16) & 255;\n                    this._palette[((i3 + 2) | 0)] = (packedByte >> 8) & 255;\n                    this._palette[((i3 + 3) | 0)] = packedByte & 255;\n                }\n\n                this.UnpackSprites();\n                this.PreloadSprites(this.scanlineNum);\n\n            },\n            VidRAM_GetNTByte: function (address) {\n                var result = 0;\n                if (address >= 8192 && address < 12288) {\n\n                    result = this.chrRomHandler.ChiChiNES$INESCart$GetPPUByte(0, address);\n\n                } else {\n                    result = this.chrRomHandler.ChiChiNES$INESCart$GetPPUByte(0, address);\n                }\n                return result;\n            },\n            UpdatePPUControlByte0: function () {\n                if ((this._PPUControlByte0 & 16) === 16) {\n                    this._backgroundPatternTableIndex = 4096;\n                } else {\n                    this._backgroundPatternTableIndex = 0;\n                }\n            },\n            /**\n             * Fills an external buffer with rgb color values, relative to current state of PPU's pallete ram\n             *\n             * @instance\n             * @public\n             * @this ChiChiNES.PixelWhizzler\n             * @memberof ChiChiNES.PixelWhizzler\n             * @param   {System.Int32}    buffer\n             * @return  {void}\n             */\n            SetupBufferForDisplay: function (buffer) {\n                for (var i = 0; i < 30; i = (i + 1) | 0) {\n                    this.p32[i] = ChiChiNES.PixelWhizzler.pal[i]; // pal[_vidRAM[i + 0x3F00]];\n                }\n\n                for (var i1 = 0; i1 < buffer.v.length; i1 = (i1 + 4) | 0) {\n                    buffer.v[i1] = this.p32[buffer.v[i1]];\n                    buffer.v[((i1 + 1) | 0)] = this.p32[buffer.v[((i1 + 1) | 0)] & 255];\n                    buffer.v[((i1 + 2) | 0)] = this.p32[buffer.v[((i1 + 2) | 0)] & 255];\n                    buffer.v[((i1 + 3) | 0)] = this.p32[buffer.v[((i1 + 3) | 0)] & 255];\n                }\n            },\n            RenderScanline: function (scanlineNum) {\n                throw new System.NotImplementedException();\n            },\n            /**\n             * draws from the lastcpuClock to the current one\n             *\n             * @instance\n             * @public\n             * @this ChiChiNES.PixelWhizzler\n             * @memberof ChiChiNES.PixelWhizzler\n             * @param   {number}    cpuClockNum\n             * @return  {void}\n             */\n            DrawTo: function (cpuClockNum) {\n                var frClock = (cpuClockNum - this.lastcpuClock) * 3;\n\n                if (this.frameClock < 6820) {\n                    // if the frameclock +frClock is in vblank (< 6820) dont do nothing, just update it\n                    if (this.frameClock + frClock < 6820) {\n                        this.frameClock += frClock;\n                        frClock = 0;\n                    } else {\n                        //find number of pixels to draw since frame start\n                        frClock += this.frameClock - 6820;\n                        this.frameClock = 6820;\n                    }\n                }\n                for (var i = 0; i < frClock; ++i) {\n                    switch (this.frameClock++) {\n                        case 0: \n                            //frameFinished();\n                            break;\n                        case 6820: \n                            this.ClearVINT();\n                            this.frameOn = true;\n                            //\n                            this.ClearNESPalette();\n                            this.chrRomHandler.ChiChiNES$INESCart$ResetBankStartCache();\n                            // setFrameOn();\n                            if (this.spriteChanges) {\n                                this.UnpackSprites();\n                                this.spriteChanges = false;\n                            }\n                            break;\n                        case 7161: \n                            //lockedVScroll = _vScroll;\n                            this.vbufLocation = 0;\n                            //curBufPos = bufStart;\n                            this.xNTXor = 0;\n                            this.yNTXor = 0;\n                            this.currentXPosition = 0;\n                            this.currentYPosition = 0;\n                            break;\n                        case ChiChiNES.PixelWhizzler.frameClockEnd: \n                            //if (fillRGB) FillBuffer();\n                            this.shouldRender = true;\n                            this.frameFinished();\n                            this.SetupVINT();\n                            this.frameOn = false;\n                            this.frameClock = 0;\n                            if (this._isDebugging) {\n                                this.events.clear();\n                            }\n                            break;\n                    }\n\n                    if (this.frameClock >= 7161 && this.frameClock <= 89342) {\n\n\n                        if (this.currentXPosition < 256 && this.vbufLocation < 61440) {\n                            /* update x position */\n                            this.xPosition = this.currentXPosition + this.lockedHScroll;\n\n\n                            if ((this.xPosition & 7) === 0) {\n                                this.xNTXor = ((this.xPosition & 256) === 256) ? 1024 : 0;\n                                this.xPosition &= 255;\n\n                                /* fetch next tile */\n                                var ppuNameTableMemoryStart = this.nameTableMemoryStart ^ this.xNTXor ^ this.yNTXor;\n\n                                var xTilePosition = this.xPosition >> 3;\n\n                                //int tileRow = (yPosition >> 3) % 30 << 5;\n\n                                //int tileNametablePosition = 0x2000 + ppuNameTableMemoryStart + xTilePosition + tileRow;\n\n                                var TileIndex = this.chrRomHandler.ChiChiNES$INESCart$GetPPUByte(0, 8192 + ppuNameTableMemoryStart + xTilePosition + ((this.yPosition >> 3) % 30 << 5));\n\n                                var patternTableYOffset = this.yPosition & 7;\n\n                                var patternID = this._backgroundPatternTableIndex + (TileIndex * 16) + patternTableYOffset;\n\n                                this.patternEntry = this.chrRomHandler.ChiChiNES$INESCart$GetPPUByte(0, patternID);\n                                this.patternEntryByte2 = this.chrRomHandler.ChiChiNES$INESCart$GetPPUByte(0, patternID + 8);\n\n                                this.currentAttributeByte = this.GetAttributeTableEntry(ppuNameTableMemoryStart, xTilePosition, this.yPosition >> 3);\n                                /* end fetch next tile */\n\n                            }\n\n                            /* draw pixel */\n                            var tilePixel = this._tilesAreVisible ? this.GetNameTablePixel() : 0;\n                            var foregroundPixel = { v : false };\n                            var spritePixel = this._spritesAreVisible ? this.GetSpritePixel(foregroundPixel) : 0;\n\n                            if (!this.hitSprite && this.spriteZeroHit && tilePixel !== 0) {\n                                this.hitSprite = true;\n                                this._PPUStatus = this._PPUStatus | 64;\n                            }\n\n                            //var x = pal[_palette[(foregroundPixel || (tilePixel == 0 && spritePixel != 0)) ? spritePixel : tilePixel]];\n                            //var x = \n\n                            this.byteOutBuffer[this.vbufLocation * 4] = this._palette[(foregroundPixel.v || (tilePixel === 0 && spritePixel !== 0)) ? spritePixel : tilePixel];\n                            //byteOutBuffer[(vbufLocation * 4) + 1] = x;// (byte)(x >> 8);\n                            //byteOutBuffer[(vbufLocation * 4) + 2] = x;//  (byte)(x >> 16);\n                            //byteOutBuffer[(vbufLocation * 4) + 3] = 0xFF;// (byte)(x);// (byte)rgb32OutBuffer[vbufLocation];\n\n                            this.vbufLocation++;\n                        }\n                        if (this.currentXPosition === 256) {\n                            this.chrRomHandler.ChiChiNES$INESCart$UpdateScanlineCounter();\n                        }\n                        this.currentXPosition++;\n\n                        if (this.currentXPosition > 340) {\n\n                            this.currentXPosition = 0;\n                            this.currentYPosition++;\n\n                            this.PreloadSprites(this.currentYPosition);\n                            if (this.spritesOnThisScanline >= 7) {\n                                this._PPUStatus = this._PPUStatus | 32;\n                            }\n\n                            this.lockedHScroll = this._hScroll;\n\n                            this.UpdatePixelInfo();\n                            this.RunNewScanlineEvents();\n\n                        }\n\n                    }\n\n                }\n                this.lastcpuClock = cpuClockNum;\n            },\n            BumpScanline: function () {\n\n\n            },\n            UpdateXPosition: function () {\n\n            },\n            FillBuffer: function () {\n\n                //int i = 0;\n                //while (i < 256 * 240 )\n                //{\n                //    int tile = (outBuffer[i] & 0x0F);\n                //    int sprite = ((outBuffer[i] >> 4) & 0x0F) + 16;\n                //    int isSprite = (outBuffer[i] >> 8) & 64;\n                //    int curPal = (outBuffer[i] >> 24) & 0xFF;\n\n                //    uint pixel;\n                //    if (isSprite > 0)\n                //    {\n                //        pixel = palCache[curPal][sprite];\n                //    }\n                //    else\n                //    {\n                //        pixel = palCache[curPal][tile];\n                //    }\n                //    rgb32OutBuffer[i] = pal[pixel];\n                //    i++;\n                //}\n            },\n            SetVideoBuffer: function (inBuffer) {\n                this.rgb32OutBuffer = inBuffer;\n            },\n            DrawPixel: function () {\n\n            },\n            UpdatePixelInfo: function () {\n                this.nameTableMemoryStart = Bridge.Int.mul(this.nameTableBits, 1024);\n            },\n            ClippingTilePixels: function () {\n                return this._clipTiles;\n            },\n            ClippingSpritePixels: function () {\n                return this._clipSprites;\n            },\n            SetByte: function (Clock, address, data) {\n                var $t;\n                // DrawTo(Clock);\n                if (this._isDebugging) {\n                    this.Events.enqueue(($t = new ChiChiNES.PPUWriteEvent(), $t.IsWrite = true, $t.DataWritten = data, $t.FrameClock = this.frameClock, $t.RegisterAffected = address, $t.ScanlineNum = ((Bridge.Int.div(this.frameClock, 341)) | 0), $t.ScanlinePos = this.frameClock % 341, $t));\n                }\n                this.needToDraw = true;\n                //Writable 2C02 registers\n                //-----------------------\n\n                //4 \t-\treturns object attribute memory \n                //      location indexed by port 3, then increments port 3.\n\n                //6\t    -\tPPU address port to access with port 7.\n\n                //7\t    -\tPPU memory write port.\n\n\n                switch (address & 7) {\n                    case 0: \n                        this.DrawTo(Clock);\n                        this._PPUControlByte0 = data;\n                        this._openBus = data;\n                        this.nameTableBits = this._PPUControlByte0 & 3;\n                        this._backgroundPatternTableIndex = Bridge.Int.mul(((this._PPUControlByte0 & 16) >> 4), 4096);\n                        // if we toggle /vbl we can throw multiple NMIs in a vblank period\n                        //if ((data & 0x80) == 0x80 && NMIHasBeenThrownThisFrame)\n                        //{\n                        //     NMIHasBeenThrownThisFrame = false;\n                        //}\n                        //UpdatePixelInfo();\n                        this.nameTableMemoryStart = Bridge.Int.mul(this.nameTableBits, 1024);\n                        break;\n                    case 1: \n                        //1\t    0\tdisable composite colorburst (when 1). Effectively causes gfx to go black & white.\n                        //      1\tleft side screen column (8 pixels wide) playfield clipping (when 0).\n                        //      2\tleft side screen column (8 pixels wide) object clipping (when 0).\n                        //      3\tenable playfield display (on 1).\n                        //      4\tenable objects display (on 1).\n                        //      5\tR (to be documented)\n                        //      6\tG (to be documented)\n                        //      7\tB (to be documented)\n                        this.DrawTo(Clock);\n                        this.isRendering = (data & 24) !== 0;\n                        this._PPUControlByte1 = data;\n                        this._spritesAreVisible = (this._PPUControlByte1 & 16) === 16;\n                        this._tilesAreVisible = (this._PPUControlByte1 & 8) === 8;\n                        this._clipTiles = (this._PPUControlByte1 & 2) !== 2;\n                        this._clipSprites = (this._PPUControlByte1 & 4) !== 4;\n                        //UpdatePixelInfo();\n                        this.nameTableMemoryStart = Bridge.Int.mul(this.nameTableBits, 1024);\n                        break;\n                    case 2: \n                        this.ppuReadBuffer = data;\n                        this._openBus = data;\n                        break;\n                    case 3: \n                        //3\t    -\tinternal object attribute memory index pointer \n                        //          (64 attributes, 32 bits each, byte granular access). \n                        //          stored value post-increments on access to port 4.\n                        this._spriteAddress = data & 255;\n                        this._openBus = this._spriteAddress;\n                        break;\n                    case 4: \n                        this.spriteRAM[this._spriteAddress] = data & 255;\n                        // UnpackSprite(_spriteAddress / 4);\n                        this._spriteAddress = (((this._spriteAddress + 1) | 0)) & 255;\n                        this.unpackedSprites[((Bridge.Int.div(this._spriteAddress, 4)) | 0)].Changed = true;\n                        this.spriteChanges = true;\n                        break;\n                    case 5: \n                        //5\t    -\tscroll offset port.\n                        // on 1st read (high), bits 0,1,2 go to fine horizonal scroll, rest to select tile\n                        // on 2nd read, bits 0,1,2 go to fine vertical scroll, rest to select tile\n                        // during render, writes to FH are applied immediately\n                        if (this.PPUAddressLatchIsHigh) {\n                            //if (isRendering)\n                            //{\n                            //    fineHorizontalScroll = data & 0x7;\n                            //    horizontalTileIndex = data >> 3;\n                            //}  \n                            this.DrawTo(Clock);\n                            this._hScroll = data;\n\n                            this.lockedHScroll = this._hScroll & 7;\n                            this.UpdatePixelInfo();\n\n                            this.PPUAddressLatchIsHigh = false;\n                        } else {\n                            // during rendering, a write here will not post to the rendering counter\n                            this.DrawTo(Clock);\n                            this._vScroll = data;\n                            if (data > 240) {\n                                this._vScroll = (data - 256) | 0;\n                            }\n\n                            if (!this.frameOn || (this.frameOn && !this.isRendering)) {\n                                this.lockedVScroll = this._vScroll;\n                            }\n\n                            this.PPUAddressLatchIsHigh = true;\n                            this.UpdatePixelInfo();\n\n                        }\n                        break;\n                    case 6: \n                        //Since the PPU's external address bus is only 14 bits in width, \n                        //the top two bits of the value written are ignored. \n                        if (this.PPUAddressLatchIsHigh) {\n                            //            //a) Write upper address byte into $2006\n                            this._PPUAddress = (this._PPUAddress & 255) | ((data & 63) << 8);\n                            this.PPUAddressLatchIsHigh = false;\n                        } else {\n                            //            //b) Write lower address byte into $2006\n                            this._PPUAddress = (this._PPUAddress & 32512) | data & 255;\n                            this.PPUAddressLatchIsHigh = true;\n\n                            // writes here during rendering directly affect the scroll counter\n                            // from Marat Fazulamans doc\n\n                            //Address Written into $2006\n                            //xxYYSSYYYYYXXXXX\n                            //   | |  |     |\n                            //   | |  |     +---- Horizontal scroll in tiles (i.e. 1 = 8 pixels)\n                            //   | |  +--------- Vertical scroll in tiles (i.e. 1 = 8 pixels)\n                            //   | +------------ Number of Name Table ($2000,$2400,$2800,$2C00)\n                            //   +-------------- Additional vertical scroll in pixels (0..3)\n\n                            // on second write during frame, loopy t (_hscroll, _vscroll) is copied to loopy_v (lockedHscroll, lockedVScroll)\n\n                            this.DrawTo(Clock);\n                            this._hScroll = ((this._PPUAddress & 31) << 3); // +(currentXPosition & 7);\n                            this._vScroll = (((this._PPUAddress >> 5) & 31) << 3);\n                            this._vScroll = this._vScroll | ((this._PPUAddress >> 12) & 3);\n\n                            this.nameTableBits = ((this._PPUAddress >> 10) & 3);\n                            if (this.frameOn) {\n\n                                this.lockedHScroll = this._hScroll;\n                                this.lockedVScroll = this._vScroll;\n                                this.lockedVScroll = (this.lockedVScroll - this.currentYPosition) | 0;\n\n                            }\n                            this.UpdatePixelInfo();\n                            // relock vscroll during render when this happens\n                        }\n                        break;\n                    case 7: \n                        //            //Writing to PPU memory:\n                        //            //c) Write data into $2007. After each write, the\n                        //            //   address will increment either by 1 (bit 2 of\n                        //            //   $2000 is 0) or by 32 (bit 2 of $2000 is 1).\n                        // ppuLatch = data;\n                        if ((this._PPUAddress & 65280) === 16128) {\n                            this.DrawTo(Clock);\n                            this.WriteToNESPalette(this._PPUAddress, (data & 255));\n                            // these palettes are all mirrored every 0x10 bytes\n                            this.UpdatePixelInfo();\n\n                            // _vidRAM[_PPUAddress ^ 0x1000] = (byte)data;\n                        } else {\n                            // if its a nametable byte, mask it according to current mirroring\n                            if ((this._PPUAddress & 61440) === 8192) {\n                                this.chrRomHandler.ChiChiNES$INESCart$SetPPUByte(Clock, this._PPUAddress, (data & 255));\n                            } else {\n                                if (this.vidRamIsRam) {\n                                    this.chrRomHandler.ChiChiNES$INESCart$SetPPUByte(Clock, this._PPUAddress, (data & 255));\n                                }\n                            }\n                        }\n                        // if controlbyte0.4, set ppuaddress + 32, else inc\n                        if ((this.PPUControlByte0 & 4) === 4) {\n                            this._PPUAddress = (((this._PPUAddress + 32) | 0));\n                        } else {\n                            this._PPUAddress = (((this._PPUAddress + 1) | 0));\n                        }\n                        // reset the flag which makex xxx6 set the high byte of address\n                        this.PPUAddressLatchIsHigh = true;\n                        this.PPUAddress = (this.PPUAddress & 16383);\n                        break;\n                }\n            },\n            GetByte: function (Clock, address) {\n                var $t;\n                if (this._isDebugging) {\n                    this.Events.enqueue(($t = new ChiChiNES.PPUWriteEvent(), $t.IsWrite = false, $t.DataWritten = 0, $t.FrameClock = this.frameClock, $t.RegisterAffected = address, $t.ScanlineNum = ((Bridge.Int.div(this.frameClock, 341)) | 0), $t.ScanlinePos = this.frameClock % 341, $t));\n                }\n\n                switch (address & 7) {\n                    case 3: \n                    case 0: \n                    case 1: \n                    case 5: \n                    case 6: \n                        return this._openBus;\n                    case 2: \n                        var ret;\n                        this.PPUAddressLatchIsHigh = true;\n                        // bit 7 is set to 0 after a read occurs\n                        // return lower 5 latched bits, and the status\n                        ret = (this.ppuReadBuffer & 31) | this._PPUStatus;\n                        //ret = _PPUStatus;\n                        //{\n                        //If read during HBlank and Bit #7 of $2000 is set to 0, then switch to Name Table #0\n                        //if ((PPUControlByte0 & 0x80) == 0 && scanlinePos > 0xFF)\n                        //{\n                        //    nameTableMemoryStart = 0;\n                        //}\n                        // clear vblank flag if read\n                        this.DrawTo(Clock);\n                        if ((ret & 128) === 128) {\n\n\n                            this._PPUStatus = this._PPUStatus & -129;\n\n                        }\n                        this.UpdatePixelInfo();\n                        //}\n                        this._openBus = ret;\n                        return ret;\n                    case 4: \n                        var tmp = this.spriteRAM[this._spriteAddress];\n                        //ppuLatch = spriteRAM[SpriteAddress];\n                        // should not increment on read ?\n                        //SpriteAddress = (SpriteAddress + 1) & 0xFF;\n                        this._openBus = tmp;\n                        return tmp;\n                    case 7: \n                        //        If Mapper = 9 Then\n                        //            If PPUAddress < &H2000& Then\n                        //                map9_latch tmp, (PPUAddress And &H1000&)\n                        //            End If\n                        //        End If\n                        // palette reads shouldn't be buffered like regular vram reads, they re internal\n                        if ((this.PPUAddress & 65280) === 16128) {\n                            // these palettes are all mirrored every 0x10 bytes\n                            tmp = this._palette[this.PPUAddress & 31];\n                            // palette read should also read vram into read buffer\n\n                            // info i found on the nesdev forums\n\n                            // When you read PPU $3F00-$3FFF, you get immediate data from Palette RAM \n                            // (without the 1-read delay usually present when reading from VRAM) and the PPU \n                            // will also fetch nametable data from the corresponding address (which is mirrored from PPU $2F00-$2FFF). \n\n                            // note: writes do not work this way \n                            this.ppuReadBuffer = this.chrRomHandler.ChiChiNES$INESCart$GetPPUByte(Clock, ((this._PPUAddress - 4096) | 0));\n                        } else {\n                            tmp = this.ppuReadBuffer;\n                            if (!!(this._PPUAddress >= 8192 & this._PPUAddress <= 12287)) {\n                                this.ppuReadBuffer = this.chrRomHandler.ChiChiNES$INESCart$GetPPUByte(Clock, this._PPUAddress);\n                            } else {\n                                this.ppuReadBuffer = this.chrRomHandler.ChiChiNES$INESCart$GetPPUByte(Clock, this._PPUAddress & 16383);\n                            }\n                        }\n                        if ((this._PPUControlByte0 & 4) === 4) {\n                            this._PPUAddress = (this._PPUAddress + 32) | 0;\n                        } else {\n                            this._PPUAddress = (this._PPUAddress + 1) | 0;\n                        }\n                        this._PPUAddress = (this._PPUAddress & 16383);\n                        return tmp;\n                }\n                //throw new NotImplementedException(string.Format(\"PPU.GetByte() recieved invalid address {0,4:x}\", address));\n                return 0;\n            },\n            ClearNESPalette: function () {\n                //currentPalette = 0;\n                //palCache[currentPalette] = new byte[32];\n                //Array.Copy(_palette, 0, palCache[currentPalette], 0, 32);\n            },\n            WriteToNESPalette: function (address, data) {\n                var palAddress = (address) & 31;\n                this._palette[palAddress] = data;\n                // rgb32OutBuffer[255 * 256 + palAddress] = data;\n                if ((this._PPUAddress & 65519) === 16128) {\n                    this._palette[(palAddress ^ 16) & 31] = data;\n                    // rgb32OutBuffer[255 * 256 + palAddress ^ 0x10] = data;\n                }\n            },\n            HandleEvent: function (Clock) {\n                this.DrawTo(Clock);\n            },\n            ResetClock: function (Clock) {\n                this.lastcpuClock = Clock;\n            },\n            SetupVINT: function () {\n                this._PPUStatus = this._PPUStatus | 128;\n                this.NMIHasBeenThrownThisFrame = false;\n                // HandleVBlankIRQ = true;\n                this._frames = (this._frames + 1) | 0;\n                //isRendering = false;\n                this.needToDraw = false;\n\n                if (this.NMIIsThrown) {\n                    this.nmiHandler();\n                    this.HandleVBlankIRQ = true;\n                    this.NMIHasBeenThrownThisFrame = true;\n                }\n\n            },\n            ClearVINT: function () {\n                this._PPUStatus = 0;\n                this.hitSprite = false;\n                this.spriteSize = ((this._PPUControlByte0 & 32) === 32) ? 16 : 8;\n                if ((this._PPUControlByte1 & 24) !== 0) {\n                    this.isRendering = true;\n                }\n                //scanlineNum = ScanlinePreRenderDummyScanline;\n                //scanlinePos = 0;\n\n                //RunNewScanlineEvents();\n\n            },\n            RunEndOfScanlineRenderEvents: function () {\n\n            },\n            RunNewScanlineEvents: function () {\n\n\n\n\n                this.yPosition = (this.currentYPosition + this.lockedVScroll) | 0;\n\n                if (this.yPosition < 0) {\n                    this.yPosition = (this.yPosition + 240) | 0;\n                }\n                if (this.yPosition >= 240) {\n                    this.yPosition = (this.yPosition - 240) | 0;\n                    this.yNTXor = 2048;\n                } else {\n                    this.yNTXor = 0;\n                }\n\n\n            },\n            UpdateSprites: function () {\n                // sprite enable\n                // left col object clipping\n                // active object pattern table\n                // color bits\n                // b/w color\n            },\n            UpdateTiles: function () {\n                // color bits\n                // b/w color\n                // background enable\n                // left col bg clipping\n                // scroll regs\n                // x/y nametable \n                // pattern table\n            },\n            CopySprites: function (source, copyFrom) {\n                // should copy 0x100 items from source to spriteRAM, \n                // starting at SpriteAddress, and wrapping around\n                // should set spriteDMA flag\n                for (var i = 0; i < 256; i = (i + 1) | 0) {\n                    var spriteLocation = (((this._spriteAddress + i) | 0)) & 255;\n                    if (this.spriteRAM[spriteLocation] !== source.v[((copyFrom + i) | 0)]) {\n                        this.spriteRAM[spriteLocation] = source.v[((copyFrom + i) | 0)];\n                        this.unpackedSprites[((Bridge.Int.div(spriteLocation, 4)) | 0)].Changed = true;\n                    }\n                }\n                this._spriteCopyHasHappened = true;\n                this.spriteChanges = true;\n\n            },\n            InitSprites: function () {\n                this.currentSprites = System.Array.init(this._maxSpritesPerScanline, function (){\n                    return new ChiChiNES.NESSprite();\n                }, ChiChiNES.NESSprite);\n                for (var i = 0; i < this._maxSpritesPerScanline; i = (i + 1) | 0) {\n                    this.currentSprites[i] = new ChiChiNES.NESSprite();\n                }\n\n                this.unpackedSprites = System.Array.init(64, function (){\n                    return new ChiChiNES.NESSprite();\n                }, ChiChiNES.NESSprite);\n\n                for (var i1 = 0; i1 < 64; i1 = (i1 + 1) | 0) {\n                    this.unpackedSprites[i1] = new ChiChiNES.NESSprite();\n                }\n\n            },\n            GetSpritePixel: function (isForegroundPixel) {\n                isForegroundPixel.v = false;\n                this.spriteZeroHit = false;\n                var result = 0;\n                var yLine = 0;\n                var xPos = 0;\n                var tileIndex = 0;\n\n                for (var i = 0; i < this.spritesOnThisScanline; i = (i + 1) | 0) {\n                    var currSprite = this.currentSprites[i];\n                    if (currSprite.XPosition > 0 && this.currentXPosition >= currSprite.XPosition && this.currentXPosition < ((currSprite.XPosition + 8) | 0)) {\n\n                        var spritePatternTable = 0;\n                        if ((this._PPUControlByte0 & 8) === 8) {\n                            spritePatternTable = 4096;\n                        }\n                        xPos = (this.currentXPosition - currSprite.XPosition) | 0;\n                        yLine = (((this.currentYPosition - currSprite.YPosition) | 0) - 1) | 0;\n\n                        yLine = yLine & (((this.spriteSize - 1) | 0));\n\n                        tileIndex = currSprite.TileIndex;\n\n                        if ((this._PPUControlByte0 & 32) === 32) {\n                            if ((tileIndex & 1) === 1) {\n                                spritePatternTable = 4096;\n                                tileIndex = tileIndex ^ 1;\n                            } else {\n                                spritePatternTable = 0;\n                            }\n                        }\n\n                        //result = WhissaSpritePixel(spritePatternTable, xPos, yLine, ref currSprite, tileIndex);\n                        // 8x8 tile\n                        var patternEntry;\n                        var patternEntryBit2;\n\n                        if (currSprite.FlipY) {\n                            yLine = (((this.spriteSize - yLine) | 0) - 1) | 0;\n                        }\n\n                        if (yLine >= 8) {\n                            yLine = (yLine + 8) | 0;\n                        }\n\n                        patternEntry = this.chrRomHandler.ChiChiNES$INESCart$GetPPUByte(0, ((((spritePatternTable + Bridge.Int.mul(tileIndex, 16)) | 0) + yLine) | 0));\n                        patternEntryBit2 = this.chrRomHandler.ChiChiNES$INESCart$GetPPUByte(0, ((((((spritePatternTable + Bridge.Int.mul(tileIndex, 16)) | 0) + yLine) | 0) + 8) | 0));\n\n                        result = (currSprite.FlipX ? ((patternEntry >> xPos) & 1) | (((patternEntryBit2 >> xPos) << 1) & 2) : ((patternEntry >> ((7 - xPos) | 0)) & 1) | (((patternEntryBit2 >> ((7 - xPos) | 0)) << 1) & 2)) & 255;\n\n                        if (result !== 0) {\n                            if (currSprite.SpriteNumber === 0) {\n                                this.spriteZeroHit = true;\n                            }\n                            isForegroundPixel.v = currSprite.Foreground;\n                            return ((result | currSprite.AttributeByte) & 255);\n                        }\n                    }\n                }\n                return 0;\n            },\n            WhissaSpritePixel: function (patternTableIndex, x, y, sprite, tileIndex) {\n                // 8x8 tile\n                var patternEntry;\n                var patternEntryBit2;\n\n                if (sprite.v.FlipY) {\n                    y = (((this.spriteSize - y) | 0) - 1) | 0;\n                }\n\n                if (y >= 8) {\n                    y = (y + 8) | 0;\n                }\n\n                patternEntry = this.chrRomHandler.ChiChiNES$INESCart$GetPPUByte(0, ((((patternTableIndex + Bridge.Int.mul(tileIndex, 16)) | 0) + y) | 0));\n                patternEntryBit2 = this.chrRomHandler.ChiChiNES$INESCart$GetPPUByte(0, ((((((patternTableIndex + Bridge.Int.mul(tileIndex, 16)) | 0) + y) | 0) + 8) | 0));\n\n                return ((sprite.v.FlipX ? ((patternEntry >> x) & 1) | (((patternEntryBit2 >> x) << 1) & 2) : ((patternEntry >> ((7 - x) | 0)) & 1) | (((patternEntryBit2 >> ((7 - x) | 0)) << 1) & 2)) & 255);\n            },\n            /**\n             * populates the currentSpritesXXX arrays with the first 8 visible sprites on the \n             denoted scanline.\n             *\n             * @instance\n             * @public\n             * @this ChiChiNES.PixelWhizzler\n             * @memberof ChiChiNES.PixelWhizzler\n             * @param   {number}    scanline    the scanline to preload sprites for\n             * @return  {void}\n             */\n            PreloadSprites: function (scanline) {\n                var $t, $t1;\n                this.spritesOnThisScanline = 0;\n                this.sprite0scanline = -1;\n\n                var yLine = (this.currentYPosition - 1) | 0;\n                this.outBuffer[(((64768) + yLine) | 0)] = 0;\n                this.outBuffer[(((65024) + yLine) | 0)] = 0;\n                //spritesOnLine[2 * yLine] = 0;\n                //spritesOnLine[2 * yLine + 1] = 0;\n                for (var spriteNum = 0; spriteNum < 256; spriteNum = (spriteNum + 4) | 0) {\n                    var spriteID = ((((spriteNum + this._spriteAddress) | 0)) & 255) >> 2;\n\n                    var y = (this.unpackedSprites[spriteID].YPosition + 1) | 0;\n\n                    if (scanline >= y && scanline < ((y + this.spriteSize) | 0)) {\n                        if (spriteID === 0) {\n                            this.sprite0scanline = scanline;\n                            this.sprite0x = this.unpackedSprites[spriteID].XPosition;\n                        }\n\n                        var spId = (Bridge.Int.div(spriteNum, 4)) | 0;\n                        if (spId < 32) {\n                            this.outBuffer[($t = (((64768) + yLine) | 0))] = this.outBuffer[$t] | (1 << spId);\n                        } else {\n                            this.outBuffer[($t1 = (((65024) + yLine) | 0))] = this.outBuffer[$t1] | (1 << (((spId - 32) | 0)));\n                        }\n\n                        this.currentSprites[this.spritesOnThisScanline] = this.unpackedSprites[spriteID];\n                        this.currentSprites[this.spritesOnThisScanline].IsVisible = true;\n\n                        this.spritesOnThisScanline = (this.spritesOnThisScanline + 1) | 0;\n                        if (this.spritesOnThisScanline === this._maxSpritesPerScanline) {\n                            break;\n                        }\n                    }\n                }\n                if (this.spritesOnThisScanline > 7) {\n                    this._PPUStatus = this._PPUStatus | 32;\n                }\n\n            },\n            UnpackSprites: function () {\n                //Buffer.BlockCopy\n                var outBufferloc = 65280;\n                for (var i = 0; i < 256; i = (i + 4) | 0) {\n                    this.outBuffer[outBufferloc] = (this.spriteRAM[i] << 24) | (this.spriteRAM[((i + 1) | 0)] << 16) | (this.spriteRAM[((i + 2) | 0)] << 8) | (this.spriteRAM[((i + 3) | 0)] << 0);\n                    outBufferloc = (outBufferloc + 1) | 0;\n                }\n                // Array.Copy(spriteRAM, 0, outBuffer, 255 * 256 * 4, 256);\n                for (var currSprite = 0; currSprite < this.unpackedSprites.length; currSprite = (currSprite + 1) | 0) {\n                    if (this.unpackedSprites[currSprite].Changed) {\n                        this.UnpackSprite(currSprite);\n                    }\n                }\n            },\n            UnpackSprite: function (currSprite) {\n                var attrByte = this.spriteRAM[((Bridge.Int.mul(currSprite, 4) + 2) | 0)];\n                this.unpackedSprites[currSprite].IsVisible = true;\n                this.unpackedSprites[currSprite].AttributeByte = ((attrByte & 3) << 2) | 16;\n                this.unpackedSprites[currSprite].YPosition = this.spriteRAM[Bridge.Int.mul(currSprite, 4)];\n                this.unpackedSprites[currSprite].XPosition = this.spriteRAM[((Bridge.Int.mul(currSprite, 4) + 3) | 0)];\n                this.unpackedSprites[currSprite].SpriteNumber = currSprite;\n                this.unpackedSprites[currSprite].Foreground = (attrByte & 32) !== 32;\n                this.unpackedSprites[currSprite].FlipX = (attrByte & 64) === 64;\n                this.unpackedSprites[currSprite].FlipY = (attrByte & 128) === 128;\n                this.unpackedSprites[currSprite].TileIndex = this.spriteRAM[((Bridge.Int.mul(currSprite, 4) + 1) | 0)];\n                this.unpackedSprites[currSprite].Changed = false;\n            },\n            /**\n             * Returns a pixel\n             *\n             * @instance\n             * @public\n             * @this ChiChiNES.PixelWhizzler\n             * @memberof ChiChiNES.PixelWhizzler\n             * @return  {number}\n             */\n            GetNameTablePixel: function () {\n                var result = ((this.patternEntry & 128) >> 7) | ((this.patternEntryByte2 & 128) >> 6);\n                this.patternEntry = this.patternEntry << 1;\n                this.patternEntryByte2 = this.patternEntryByte2 << 1;\n                if (result > 0) {\n                    result = result | this.currentAttributeByte;\n                }\n                return (result & 255);\n            },\n            FetchNextTile: function () {\n                var ppuNameTableMemoryStart = this.nameTableMemoryStart ^ this.xNTXor ^ this.yNTXor;\n\n                var xTilePosition = this.xPosition >> 3;\n\n                var tileRow = (this.yPosition >> 3) % 30 << 5;\n\n                var tileNametablePosition = (((((8192 + ppuNameTableMemoryStart) | 0) + xTilePosition) | 0) + tileRow) | 0;\n\n                var TileIndex = this.chrRomHandler.ChiChiNES$INESCart$GetPPUByte(0, tileNametablePosition);\n\n                var patternTableYOffset = this.yPosition & 7;\n\n                var patternID = (((this._backgroundPatternTableIndex + (Bridge.Int.mul(TileIndex, 16))) | 0) + patternTableYOffset) | 0;\n\n                this.patternEntry = this.chrRomHandler.ChiChiNES$INESCart$GetPPUByte(0, patternID);\n                this.patternEntryByte2 = this.chrRomHandler.ChiChiNES$INESCart$GetPPUByte(0, ((patternID + 8) | 0));\n\n                this.currentAttributeByte = this.GetAttributeTableEntry(ppuNameTableMemoryStart, xTilePosition, this.yPosition >> 3);\n            },\n            GetNameTablePixelOld: function () {\n                var xPosition = this.currentXPosition, yPosition = this.currentYPosition;\n                // int patternTableIndex = PatternTableIndex;\n\n                var ppuNameTableMemoryStart = this.nameTableMemoryStart;\n                //yPosition = 1;\n                xPosition = (xPosition + this.lockedHScroll) | 0;\n\n                if (xPosition > 255) {\n                    xPosition = (xPosition - 256) | 0;\n                    // from loopy's doc\n                    // you can think of bits 0,1,2,3,4 of the vram address as the \"x scroll\"(*8)\n                    //that the ppu increments as it draws.  as it wraps from 31 to 0, bit 10 is\n                    //switched.  you should see how this causes horizontal wrapping between name\n                    //tables (0,1) and (2,3).\n\n                    ppuNameTableMemoryStart = ppuNameTableMemoryStart ^ 1024;\n                }\n                // index of this pixels bit in pattern table\n                var patternTableEntryIndex = (7 - (xPosition & 7)) | 0;\n\n\n                yPosition = (yPosition + this.lockedVScroll) | 0;\n                if (yPosition < 0) {\n                    yPosition = (yPosition + 240) | 0;\n                }\n                if (yPosition >= 240) {\n                    yPosition = (yPosition - 240) | 0;\n                    ppuNameTableMemoryStart = ppuNameTableMemoryStart ^ 2048;\n                }\n\n                var tileRow = (((Bridge.Int.div(yPosition, 8)) | 0)) % 30;\n\n                var tileNametablePosition = (((((8192 + ppuNameTableMemoryStart) | 0) + (((Bridge.Int.div(xPosition, 8)) | 0))) | 0) + (Bridge.Int.mul(tileRow, 32))) | 0;\n\n                var TileIndex = this.chrRomHandler.ChiChiNES$INESCart$GetPPUByte(0, tileNametablePosition);\n\n\n                var patternTableYOffset = yPosition & 7;\n\n\n                var patternEntry = this.chrRomHandler.ChiChiNES$INESCart$GetPPUByte(0, ((((this._backgroundPatternTableIndex + (Bridge.Int.mul(TileIndex, 16))) | 0) + patternTableYOffset) | 0));\n                var patternEntryByte2 = this.chrRomHandler.ChiChiNES$INESCart$GetPPUByte(0, ((((((this._backgroundPatternTableIndex + (Bridge.Int.mul(TileIndex, 16))) | 0) + 8) | 0) + patternTableYOffset) | 0));\n\n\n                // i want the patternTableEntryIndex'th bit of patternEntry in the 1st bit of pixel\n                var result = (((patternEntry >> patternTableEntryIndex) & 1) | (Bridge.Int.mul(((patternEntryByte2 >> patternTableEntryIndex) & 1), 2))) & 255;\n\n                if (result > 0) {\n                    result = (result | ((this.GetAttributeTableEntry(ppuNameTableMemoryStart, ((Bridge.Int.div(xPosition, 8)) | 0), ((Bridge.Int.div(yPosition, 8)) | 0))) & 255)) & 255;\n                }\n                return result;\n            },\n            GetAttributeTableEntry: function (ppuNameTableMemoryStart, i, j) {\n                var LookUp = this.chrRomHandler.ChiChiNES$INESCart$GetPPUByte(0, ((((((((8192 + ppuNameTableMemoryStart) | 0) + 960) | 0) + (((Bridge.Int.div(i, 4)) | 0))) | 0) + (Bridge.Int.mul((((Bridge.Int.div(j, 4)) | 0)), 8))) | 0));\n\n                switch ((i & 2) | Bridge.Int.mul((j & 2), 2)) {\n                    case 0: \n                        return (LookUp << 2) & 12;\n                    case 2: \n                        return LookUp & 12;\n                    case 4: \n                        return (LookUp >> 2) & 12;\n                    case 6: \n                        return (LookUp >> 4) & 12;\n                }\n                return 0;\n            }\n        }\n    });\n\n    Bridge.define(\"ChiChiNES.PortQueueing.QueuedPort\", {\n        inherits: [System.Collections.Generic.Queue$1(ChiChiNES.PortQueueing.PortWriteEntry)],\n        ctors: {\n            ctor: function () {\n                this.$initialize();\n                System.Collections.Generic.Queue$1(ChiChiNES.PortQueueing.PortWriteEntry).$ctor2.call(this, 256);\n            }\n        }\n    });\n\n    Bridge.define(\"ChiChiNES.BaseCart\", {\n        inherits: [ChiChiNES.INESCart],\n        fields: {\n            pixelEffects: null,\n            debugging: false,\n            debugEvents: null,\n            iNesHeader: null,\n            romControlBytes: null,\n            nesCart: null,\n            chrRom: null,\n            /**\n             * @instance\n             * @memberof ChiChiNES.BaseCart\n             * @type number\n             */\n            current8: 0,\n            currentA: 0,\n            currentC: 0,\n            currentE: 0,\n            SRAMCanWrite: false,\n            SRAMEnabled: false,\n            SRAMCanSave: false,\n            prgRomCount: 0,\n            chrRomCount: 0,\n            mapperId: 0,\n            bank8start: 0,\n            bankAstart: 0,\n            bankCstart: 0,\n            bankEstart: 0,\n            prgRomBank6: null,\n            _ROMHashfunction: null,\n            chrRomOffset: 0,\n            chrRamStart: 0,\n            whizzler: null,\n            irqRaised: false,\n            checkSum: null,\n            mirroring: 0,\n            updateIRQ: null,\n            ppuBankStarts: null,\n            bankStartCache: null,\n            currentBank: 0,\n            bankSwitchesChanged: false,\n            nullEffect: null,\n            oneScreenOffset: 0\n        },\n        props: {\n            Debugging: {\n                get: function () {\n                    return this.debugging;\n                },\n                set: function (value) {\n                    this.debugging = value;\n                }\n            },\n            DebugEvents: {\n                get: function () {\n                    return this.debugEvents;\n                },\n                set: function (value) {\n                    this.debugEvents = value;\n                }\n            },\n            ChrRom: {\n                get: function () {\n                    return this.chrRom;\n                },\n                set: function (value) {\n                    this.chrRom = value;\n                }\n            },\n            ChrRomCount: {\n                get: function () {\n                    return this.chrRomCount;\n                }\n            },\n            PrgRomCount: {\n                get: function () {\n                    return this.prgRomCount;\n                }\n            },\n            ROMHashFunction: {\n                get: function () {\n                    return this._ROMHashfunction;\n                },\n                set: function (value) {\n                    this._ROMHashfunction = value;\n                }\n            },\n            Whizzler: {\n                get: function () {\n                    return this.whizzler;\n                },\n                set: function (value) {\n                    this.whizzler = value;\n                }\n            },\n            IrqRaised: {\n                get: function () {\n                    return this.irqRaised;\n                },\n                set: function (value) {\n                    this.irqRaised = value;\n                }\n            },\n            CheckSum: {\n                get: function () {\n                    return this.checkSum;\n                }\n            },\n            CPU: {\n                get: function () {\n                    throw new System.NotImplementedException();\n                },\n                set: function (value) {\n                    throw new System.NotImplementedException();\n                }\n            },\n            SRAM: {\n                get: function () {\n                    return this.prgRomBank6;\n                },\n                set: function (value) {\n                    if (value != null && value.length === this.prgRomBank6.length) {\n                        this.prgRomBank6 = value;\n                    }\n                }\n            },\n            CartName: null,\n            NumberOfPrgRoms: {\n                get: function () {\n                    return this.prgRomCount;\n                }\n            },\n            NumberOfChrRoms: {\n                get: function () {\n                    return this.chrRomCount;\n                }\n            },\n            MapperID: {\n                get: function () {\n                    return this.mapperId;\n                }\n            },\n            Mirroring: {\n                get: function () {\n                    return this.mirroring;\n                }\n            },\n            NMIHandler: {\n                get: function () {\n                    return this.updateIRQ;\n                },\n                set: function (value) {\n                    this.updateIRQ = value;\n                }\n            },\n            IRQAsserted: {\n                get: function () {\n                    return false;\n                },\n                set: function (value) {\n\n                }\n            },\n            NextEventAt: {\n                get: function () {\n                    return -1;\n                }\n            },\n            PpuBankStarts: {\n                get: function () {\n                    return this.ppuBankStarts;\n                },\n                set: function (value) {\n                    this.ppuBankStarts = value;\n                }\n            },\n            BankStartCache: {\n                get: function () {\n                    return this.bankStartCache;\n                }\n            },\n            CurrentBank: {\n                get: function () {\n                    return this.currentBank;\n                }\n            },\n            BankSwitchesChanged: {\n                get: function () {\n                    return this.bankSwitchesChanged;\n                },\n                set: function (value) {\n                    this.bankSwitchesChanged = value;\n                }\n            },\n            OneScreenOffset: {\n                get: function () {\n                    return this.oneScreenOffset;\n                },\n                set: function (value) {\n                    this.oneScreenOffset = value;\n                }\n            },\n            UsesSRAM: false,\n            ChrRamStart: {\n                get: function () {\n                    return this.chrRamStart;\n                }\n            },\n            PPUBankStarts: {\n                get: function () {\n                    return this.ppuBankStarts;\n                },\n                set: function (value) {\n                    throw new System.NotImplementedException();\n                }\n            }\n        },\n        alias: [\n            \"ChrRom\", \"ChiChiNES$INESCart$ChrRom\",\n            \"ROMHashFunction\", \"ChiChiNES$INESCart$ROMHashFunction\",\n            \"LoadiNESCart\", \"ChiChiNES$INESCart$LoadiNESCart\",\n            \"Whizzler\", \"ChiChiNES$INESCart$Whizzler\",\n            \"UpdateScanlineCounter\", \"ChiChiNES$INESCart$UpdateScanlineCounter\",\n            \"GetByte\", \"ChiChiNES$IClockedMemoryMappedIOElement$GetByte\",\n            \"CheckSum\", \"ChiChiNES$INESCart$CheckSum\",\n            \"WriteState\", \"ChiChiNES$INESCart$WriteState\",\n            \"ReadState\", \"ChiChiNES$INESCart$ReadState\",\n            \"CPU\", \"ChiChiNES$INESCart$CPU\",\n            \"SRAM\", \"ChiChiNES$INESCart$SRAM\",\n            \"CartName\", \"ChiChiNES$INESCart$CartName\",\n            \"NumberOfPrgRoms\", \"ChiChiNES$INESCart$NumberOfPrgRoms\",\n            \"NumberOfChrRoms\", \"ChiChiNES$INESCart$NumberOfChrRoms\",\n            \"MapperID\", \"ChiChiNES$INESCart$MapperID\",\n            \"Mirroring\", \"ChiChiNES$INESCart$Mirroring\",\n            \"NMIHandler\", \"ChiChiNES$IClockedMemoryMappedIOElement$NMIHandler\",\n            \"IRQAsserted\", \"ChiChiNES$IClockedMemoryMappedIOElement$IRQAsserted\",\n            \"NextEventAt\", \"ChiChiNES$IClockedMemoryMappedIOElement$NextEventAt\",\n            \"HandleEvent\", \"ChiChiNES$IClockedMemoryMappedIOElement$HandleEvent\",\n            \"ResetClock\", \"ChiChiNES$IClockedMemoryMappedIOElement$ResetClock\",\n            \"BankStartCache\", \"ChiChiNES$INESCart$BankStartCache\",\n            \"CurrentBank\", \"ChiChiNES$INESCart$CurrentBank\",\n            \"ResetBankStartCache\", \"ChiChiNES$INESCart$ResetBankStartCache\",\n            \"UpdateBankStartCache\", \"ChiChiNES$INESCart$UpdateBankStartCache\",\n            \"BankSwitchesChanged\", \"ChiChiNES$INESCart$BankSwitchesChanged\",\n            \"GetPPUByte\", \"ChiChiNES$INESCart$GetPPUByte\",\n            \"ActualChrRomOffset\", \"ChiChiNES$INESCart$ActualChrRomOffset\",\n            \"SetPPUByte\", \"ChiChiNES$INESCart$SetPPUByte\",\n            \"FetchPixelEffect\", \"ChiChiNES$INESCart$FetchPixelEffect\",\n            \"UsesSRAM\", \"ChiChiNES$INESCart$UsesSRAM\",\n            \"ChrRamStart\", \"ChiChiNES$INESCart$ChrRamStart\",\n            \"PPUBankStarts\", \"ChiChiNES$INESCart$PPUBankStarts\"\n        ],\n        ctors: {\n            init: function () {\n                this.pixelEffects = new (System.Collections.Generic.Dictionary$2(System.Int32,System.Array.type(System.Byte)))();\n                this.debugging = false;\n                this.debugEvents = new (System.Collections.Generic.List$1(ChiChiNES.CartDebugEvent)).ctor();\n                this.iNesHeader = System.Array.init(16, 0, System.Byte);\n                this.romControlBytes = System.Array.init(2, 0, System.Byte);\n                this.current8 = -1;\n                this.currentA = -1;\n                this.currentC = -1;\n                this.currentE = -1;\n                this.prgRomBank6 = System.Array.init(8192, 0, System.Byte);\n                this.chrRomOffset = 0;\n                this.chrRamStart = 0;\n                this.mirroring = -1;\n                this.ppuBankStarts = System.Array.init(16, 0, System.Int32);\n                this.bankStartCache = System.Array.init(4096, 0, System.Int32);\n                this.currentBank = 0;\n                this.bankSwitchesChanged = false;\n                this.nullEffect = System.Array.init([0, 0, 0, 0, 0, 0, 0, 0], System.Byte);\n            },\n            ctor: function () {\n                this.$initialize();\n\n                var effect = System.Array.init([1, 1, 1, 1, 1, 1, 1, 1], System.Byte);\n                this.pixelEffects.add(3408, effect);\n                this.pixelEffects.add(0, effect);\n\n                for (var i = 21264; i < 21696; i = (i + 1) | 0) {\n                    this.pixelEffects.add(((i - 16400) | 0), effect);\n                }\n\n                for (var i1 = 0; i1 < 16; i1 = (i1 + 1) | 0) {\n                    this.ppuBankStarts[i1] = Bridge.Int.mul(i1, 1024);\n                }\n            }\n        },\n        methods: {\n            ClearDebugEvents: function () {\n                this.debugEvents.clear();\n            },\n            LoadiNESCart: function (header, prgRoms, chrRoms, prgRomData, chrRomData, chrRomOffset) {\n                this.romControlBytes[0] = header[6];\n                this.romControlBytes[1] = header[7];\n\n                this.mapperId = (this.romControlBytes[0] & 240) >> 4;\n                this.mapperId = (this.mapperId + (this.romControlBytes[1] & 240)) | 0;\n                this.chrRomOffset = chrRomOffset;\n                /* \n                .NES file format\n                ---------------------------------------------------------------------------\n                0-3      String \"NES^Z\" used to recognize .NES files.\n                4        Number of 16kB ROM banks.\n                5        Number of 8kB VROM banks.\n                6        bit 0     1 for vertical mirroring, 0 for horizontal mirroring\n                        bit 1     1 for battery-backed RAM at $6000-$7FFF\n                        bit 2     1 for a 512-byte trainer at $7000-$71FF\n                        bit 3     1 for a four-screen VRAM layout \n                        bit 4-7   Four lower bits of ROM Mapper Type.\n                7        bit 0-3   Reserved, must be zeroes!\n                        bit 4-7   Four higher bits of ROM Mapper Type.\n                8-15     Reserved, must be zeroes!\n                16-...   ROM banks, in ascending order. If a trainer i6s present, its\n                        512 bytes precede the ROM bank contents.\n                ...-EOF  VROM banks, in ascending order.\n                ---------------------------------------------------------------------------\n                */\n\n                System.Array.copy(header, 0, this.iNesHeader, 0, header.length);\n                this.prgRomCount = prgRoms;\n                this.chrRomCount = chrRoms;\n\n                this.nesCart = System.Array.init(prgRomData.length, 0, System.Byte);\n                System.Array.copy(prgRomData, 0, this.nesCart, 0, prgRomData.length);\n\n                if (this.chrRomCount === 0) {\n                    // chrRom is going to be RAM\n                    chrRomData = System.Array.init(32768, 0, System.Byte);\n                }\n\n\n                this.chrRom = System.Array.init(((chrRomData.length + 4096) | 0), 0, System.Byte);\n\n                this.chrRamStart = chrRomData.length;\n\n                System.Array.copy(chrRomData, 0, this.chrRom, 0, chrRomData.length);\n\n                this.prgRomCount = this.iNesHeader[4];\n                this.chrRomCount = this.iNesHeader[5];\n\n\n                this.romControlBytes[0] = this.iNesHeader[6];\n                this.romControlBytes[1] = this.iNesHeader[7];\n\n                this.SRAMCanSave = (this.romControlBytes[0] & 2) === 2;\n                this.SRAMEnabled = true;\n\n                this.UsesSRAM = (this.romControlBytes[0] & 2) === 2;\n\n                // rom0.0=0 is horizontal mirroring, rom0.0=1 is vertical mirroring\n\n                // by default we have to call Mirror() at least once to set up the bank offsets\n                this.Mirror(0, 0);\n                if ((this.romControlBytes[0] & 1) === 1) {\n                    this.Mirror(0, 1);\n                } else {\n                    this.Mirror(0, 2);\n                }\n\n                if ((this.romControlBytes[0] & 8) === 8) {\n                    this.Mirror(0, 3);\n                }\n\n\n                this.checkSum = \"\"; //ROMHashFunction(nesCart, chrRom);\n\n                this.InitializeCart();\n\n            },\n            UpdateScanlineCounter: function () { },\n            GetByte: function (clock, address) {\n                var bank = 0;\n\n                switch (address & 57344) {\n                    case 24576: \n                        return this.prgRomBank6[address & 8191];\n                    case 32768: \n                        bank = this.bank8start;\n                        break;\n                    case 40960: \n                        bank = this.bankAstart;\n                        break;\n                    case 49152: \n                        bank = this.bankCstart;\n                        break;\n                    case 57344: \n                        bank = this.bankEstart;\n                        break;\n                }\n                // if cart is half sized, adjust\n                if (((bank + (address & 8191)) | 0) > this.nesCart.length) {\n                    throw new System.Exception(\"THis is broken!\");\n                }\n                return this.nesCart[((bank + (address & 8191)) | 0)];\n\n\n            },\n            SetupBankStarts: function (reg8, regA, regC, regE) {\n                reg8 = this.MaskBankAddress(reg8);\n                regA = this.MaskBankAddress(regA);\n                regC = this.MaskBankAddress(regC);\n                regE = this.MaskBankAddress(regE);\n\n                this.current8 = reg8;\n                this.currentA = regA;\n                this.currentC = regC;\n                this.currentE = regE;\n                this.bank8start = Bridge.Int.mul(reg8, 8192);\n                this.bankAstart = Bridge.Int.mul(regA, 8192);\n                this.bankCstart = Bridge.Int.mul(regC, 8192);\n                this.bankEstart = Bridge.Int.mul(regE, 8192);\n\n            },\n            MaskBankAddress: function (bank) {\n                if (bank >= Bridge.Int.mul(this.prgRomCount, 2)) {\n                    var i = 255;\n                    while ((bank & i) >= Bridge.Int.mul(this.prgRomCount, 2)) {\n                        i = i >> 1;\n                    }\n                    return (bank & i);\n                } else {\n                    return bank;\n                }\n            },\n            WriteState: function (state) {\n                state.enqueue(this.SRAMCanWrite ? 1 : 0);\n                state.enqueue(this.SRAMEnabled ? 1 : 0);\n                state.enqueue(this.SRAMCanSave ? 1 : 0);\n\n                state.enqueue(this.prgRomCount);\n                state.enqueue(this.chrRomCount);\n\n                state.enqueue(this.mapperId);\n\n                state.enqueue(this.bank8start);\n                state.enqueue(this.bankAstart);\n                state.enqueue(this.bankCstart);\n                state.enqueue(this.bankEstart);\n\n                for (var i = 0; i < 8192; i = (i + 4) | 0) {\n\n                    state.enqueue((this.prgRomBank6[i] << 24) | (this.prgRomBank6[((i + 1) | 0)] << 16) | (this.prgRomBank6[((i + 2) | 0)] << 8) | (this.prgRomBank6[((i + 3) | 0)]));\n                }\n            },\n            ReadState: function (state) {\n                this.SRAMCanWrite = state.dequeue() === 1;\n                this.SRAMEnabled = state.dequeue() === 1;\n                this.SRAMCanSave = state.dequeue() === 1;\n\n                this.prgRomCount = state.dequeue();\n                this.chrRomCount = state.dequeue();\n\n                this.mapperId = state.dequeue();\n\n                this.bank8start = state.dequeue();\n                this.bankAstart = state.dequeue();\n                this.bankCstart = state.dequeue();\n                this.bankEstart = state.dequeue();\n\n                var packedByte = 0;\n                for (var i = 0; i < 8192; i = (i + 4) | 0) {\n                    packedByte = state.dequeue();\n                    this.prgRomBank6[i] = (packedByte >> 24) & 255;\n                    this.prgRomBank6[((i + 1) | 0)] = (packedByte >> 16) & 255;\n                    this.prgRomBank6[((i + 2) | 0)] = (packedByte >> 8) & 255;\n                    this.prgRomBank6[((i + 3) | 0)] = packedByte & 255;\n\n                }\n            },\n            HandleEvent: function (Clock) { },\n            ResetClock: function (Clock) { },\n            ResetBankStartCache: function () {\n                // if (currentBank > 0)\n                this.currentBank = 0;\n                // Array.Clear(bankStartCache, 0, 16 * 256 * 256);\n                System.Array.copy(this.ppuBankStarts, 0, this.bankStartCache, 0, 16);\n\n                //Mirror(-1, this.mirroring);\n                //chrRamStart = ppuBankStarts[8];\n                //Array.Copy(ppuBankStarts, 0, bankStartCache[0], 0, 16 * 4);\n                //bankSwitchesChanged = false;\n            },\n            UpdateBankStartCache: function () {\n                this.currentBank = (this.currentBank + 1) | 0;\n                System.Array.copy(this.ppuBankStarts, 0, this.bankStartCache, Bridge.Int.mul(this.currentBank, 16), 16);\n                this.whizzler.ChiChiNES$IPPU$UpdatePixelInfo();\n                return this.currentBank;\n\n            },\n            GetPPUByte: function (clock, address) {\n                var bank = (Bridge.Int.div(address, 1024)) | 0;\n                var newAddress = (this.ppuBankStarts[bank] + (address & 1023)) | 0;\n\n                //while (newAddress > chrRamStart)\n                //{\n                //    newAddress -= chrRamStart;\n                //}\n                return this.chrRom[newAddress];\n            },\n            ActualChrRomOffset: function (address) {\n                var bank = (Bridge.Int.div(address, 1024)) | 0;\n                //int newAddress = ppuBankStarts[bank] + (address & 0x3FF);\n                var newAddress = (this.bankStartCache[(((Bridge.Int.mul(this.currentBank, 16)) + bank) | 0)] + (address & 1023)) | 0;\n\n                return newAddress;\n            },\n            SetPPUByte: function (clock, address, data) {\n                var bank = (Bridge.Int.div(address, 1024)) | 0;\n                var newAddress = (this.bankStartCache[(((Bridge.Int.mul(this.currentBank, 16)) + bank) | 0)] + (address & 1023)) | 0; // ppuBankStarts[bank] + (address & 0x3FF);\n                this.chrRom[newAddress] = data;\n            },\n            FetchPixelEffect: function (vramAddress) {\n                var bank = (Bridge.Int.div(vramAddress, 1024)) | 0;\n                var newAddress = (this.ppuBankStarts[bank] + (vramAddress & 1023)) | 0;\n\n                if (this.pixelEffects.containsKey(newAddress)) {\n                    return this.pixelEffects.get(newAddress);\n                } else {\n                    return this.nullEffect;\n                }\n\n            },\n            Mirror: function (clockNum, mirroring) {\n                var $t;\n                //    //            A11 A10 Effect\n                //    //----------------------------------------------------------\n                //    // 0   0  All four screen buffers are mapped to the same\n                //    //        area of memory which repeats at $2000, $2400,\n                //    //        $2800, and $2C00.\n                //    // 0   x  \"Upper\" and \"lower\" screen buffers are mapped to\n                //    //        separate areas of memory at $2000, $2400 and\n                //    //        $2800, $2C00. ( horizontal mirroring)\n                //    // x   0  \"Left\" and \"right\" screen buffers are mapped to\n                //    //        separate areas of memory at $2000, $2800 and\n                //    //        $2400,$2C00.  (vertical mirroring)\n                //    // x   x  All four screen buffers are mapped to separate\n                //    //        areas of memory. In this case, the cartridge\n                //    //        must contain 2kB of additional VRAM (i got vram up the wazoo)\n                //    // 0xC00 = 110000000000\n                //    // 0x800 = 100000000000\n                //    // 0x400 = 010000000000\n                //    // 0x000 = 000000000000\n\n                if (this.debugging) {\n                    this.DebugEvents.add(($t = new ChiChiNES.CartDebugEvent(), $t.Clock = clockNum, $t.EventType = System.String.format(\"Mirror set to {0}\", mirroring), $t));\n                }\n\n                //if (mirroring == this.mirroring) return;\n\n                this.mirroring = mirroring;\n\n                if (clockNum > -1) {\n                    this.whizzler.ChiChiNES$IPPU$DrawTo(clockNum);\n                }\n\n                //Console.WriteLine(\"Mirroring set to {0}\", mirroring);\n\n                switch (mirroring) {\n                    case 0: \n                        this.ppuBankStarts[8] = (((this.chrRamStart + 0) | 0) + this.oneScreenOffset) | 0;\n                        this.ppuBankStarts[9] = (((this.chrRamStart + 0) | 0) + this.oneScreenOffset) | 0;\n                        this.ppuBankStarts[10] = (((this.chrRamStart + 0) | 0) + this.oneScreenOffset) | 0;\n                        this.ppuBankStarts[11] = (((this.chrRamStart + 0) | 0) + this.oneScreenOffset) | 0;\n                        break;\n                    case 1: \n                        this.ppuBankStarts[8] = (this.chrRamStart + 0) | 0;\n                        this.ppuBankStarts[9] = (this.chrRamStart + 1024) | 0;\n                        this.ppuBankStarts[10] = (this.chrRamStart + 0) | 0;\n                        this.ppuBankStarts[11] = (this.chrRamStart + 1024) | 0;\n                        break;\n                    case 2: \n                        this.ppuBankStarts[8] = (this.chrRamStart + 0) | 0;\n                        this.ppuBankStarts[9] = (this.chrRamStart + 0) | 0;\n                        this.ppuBankStarts[10] = (this.chrRamStart + 1024) | 0;\n                        this.ppuBankStarts[11] = (this.chrRamStart + 1024) | 0;\n                        break;\n                    case 3: \n                        this.ppuBankStarts[8] = (this.chrRamStart + 0) | 0;\n                        this.ppuBankStarts[9] = (this.chrRamStart + 1024) | 0;\n                        this.ppuBankStarts[10] = (this.chrRamStart + 2048) | 0;\n                        this.ppuBankStarts[11] = (this.chrRamStart + 3072) | 0;\n                        break;\n                }\n                this.UpdateBankStartCache();\n                this.whizzler.ChiChiNES$IPPU$UpdatePixelInfo();\n\n            }\n        }\n    });\n\n    Bridge.define(\"ChiChiNES.CPU.NESCart\", {\n        inherits: [ChiChiNES.BaseCart],\n        fields: {\n            prgRomBank6$1: null,\n            prevBSSrc: null\n        },\n        alias: [\n            \"InitializeCart\", \"ChiChiNES$INESCart$InitializeCart\",\n            \"SetByte\", \"ChiChiNES$IClockedMemoryMappedIOElement$SetByte\"\n        ],\n        ctors: {\n            init: function () {\n                this.prgRomBank6$1 = System.Array.init(2048, 0, System.Byte);\n                this.prevBSSrc = System.Array.init(8, 0, System.Int32);\n            }\n        },\n        methods: {\n            InitializeCart: function () {\n\n                for (var i = 0; i < 8; i = (i + 1) | 0) {\n                    this.prevBSSrc[i] = -1;\n                }\n                //SRAMEnabled = SRAMCanSave;\n\n\n                switch (this.mapperId) {\n                    case 0: \n                    case 1: \n                    case 2: \n                    case 3: \n                        if (this.ChrRomCount > 0) {\n                            this.CopyBanks(0, 0, 0, 1);\n                        }\n                        this.SetupBankStarts(0, 1, ((Bridge.Int.mul(this.PrgRomCount, 2) - 2) | 0), ((Bridge.Int.mul(this.PrgRomCount, 2) - 1) | 0));\n                        break;\n                    case 7: \n                        //SetupBanks(0, 1, 2, 3);\n                        this.SetupBankStarts(0, 1, 2, 3);\n                        this.Mirror(0, 0);\n                        break;\n                    default: \n                        throw new System.NotImplementedException(\"Mapper \" + (this.mapperId.toString() || \"\") + \" not implemented.\");\n                }\n            },\n            CopyBanks: function (clock, dest, src, numberOf8kBanks) {\n\n                if (dest >= this.ChrRomCount) {\n                    dest = (this.ChrRomCount - 1) | 0;\n                }\n\n                var oneKsrc = Bridge.Int.mul(src, 8);\n                var oneKdest = Bridge.Int.mul(dest, 8);\n                //TODO: get whizzler reading ram from INesCart.GetPPUByte then be calling this\n                //  setup ppuBankStarts in 0x400 block chunks \n                for (var i = 0; i < (Bridge.Int.mul(numberOf8kBanks, 8)); i = (i + 1) | 0) {\n                    this.ppuBankStarts[((oneKdest + i) | 0)] = Bridge.Int.mul((((oneKsrc + i) | 0)), 1024);\n\n                }\n                this.UpdateBankStartCache();\n            },\n            SetByte: function (clock, address, val) {\n                if (address >= 24576 && address <= 32767) {\n                    if (this.SRAMEnabled) {\n                        this.prgRomBank6$1[address & 8191] = val & 255;\n                    }\n\n                    return;\n                }\n\n                if (this.mapperId === 7) {\n                    // val selects which bank to swap, 32k at a time\n                    var newbank8 = 0;\n                    newbank8 = Bridge.Int.mul(4, (val & 15));\n\n                    this.SetupBankStarts(newbank8, ((newbank8 + 1) | 0), ((newbank8 + 2) | 0), ((newbank8 + 3) | 0));\n                    // whizzler.DrawTo(clock);\n                    if ((val & 16) === 16) {\n                        this.OneScreenOffset = 1024;\n                    } else {\n                        this.OneScreenOffset = 0;\n                    }\n                    this.Mirror(clock, 0);\n                }\n\n                if (this.mapperId === 3 && address >= 32768) {\n\n                    this.CopyBanks(clock, 0, val, 1);\n                }\n\n                if (this.mapperId === 2 && address >= 32768) {\n                    var newbank81 = 0;\n\n                    newbank81 = (Bridge.Int.mul((val), 2));\n                    // keep two high banks, swap low banks\n\n                    // SetupBanks(newbank8, newbank8 + 1, currentC, currentE);\n                    this.SetupBankStarts(newbank81, ((newbank81 + 1) | 0), this.currentC, this.currentE);\n                }\n\n\n\n\n\n            }\n        }\n    });\n\n    Bridge.define(\"ChiChiNES.NesCartMMC1\", {\n        inherits: [ChiChiNES.BaseCart],\n        fields: {\n            sequence: 0,\n            accumulator: 0,\n            bank_select: 0,\n            _registers: null,\n            lastwriteAddress: 0,\n            lastClock: 0\n        },\n        alias: [\n            \"InitializeCart\", \"ChiChiNES$INESCart$InitializeCart\",\n            \"SetByte\", \"ChiChiNES$IClockedMemoryMappedIOElement$SetByte\"\n        ],\n        ctors: {\n            init: function () {\n                this.sequence = 0;\n                this.accumulator = 0;\n                this.bank_select = 0;\n                this._registers = System.Array.init(4, 0, System.Int32);\n                this.lastwriteAddress = 0;\n            }\n        },\n        methods: {\n            InitializeCart: function () {\n\n                if (this.ChrRomCount > 0) {\n                    this.CopyBanks(0, 0, 4);\n                }\n                this._registers[0] = 12;\n                this._registers[1] = 0;\n                this._registers[2] = 0;\n                this._registers[3] = 0;\n\n                this.SetupBankStarts(0, 1, ((Bridge.Int.mul(this.PrgRomCount, 2) - 2) | 0), ((Bridge.Int.mul(this.PrgRomCount, 2) - 1) | 0));\n\n                this.sequence = 0;\n                this.accumulator = 0;\n            },\n            MaskBankAddress$1: function (bank) {\n                if (bank >= Bridge.Int.mul(this.PrgRomCount, 2)) {\n                    var i;\n                    i = 255;\n                    while ((bank & i) >= Bridge.Int.mul(this.PrgRomCount, 2)) {\n\n                        i = (Bridge.Int.div(i, 2)) | 0;\n                    }\n\n                    return (bank & i);\n                } else {\n                    return bank;\n                }\n            },\n            CopyBanks: function (dest, src, numberOf4kBanks) {\n                if (this.ChrRomCount > 0) {\n                    var oneKdest = Bridge.Int.mul(dest, 4);\n                    var oneKsrc = Bridge.Int.mul(src, 4);\n                    //TODO: get whizzler reading ram from INesCart.GetPPUByte then be calling this\n                    //  setup ppuBankStarts in 0x400 block chunks \n                    for (var i = 0; i < (Bridge.Int.mul(numberOf4kBanks, 4)); i = (i + 1) | 0) {\n                        this.ppuBankStarts[((oneKdest + i) | 0)] = Bridge.Int.mul((((oneKsrc + i) | 0)), 1024);\n                    }\n\n                    //Array.Copy(chrRom, src * 0x1000, whizzler.cartCopyVidRAM, dest * 0x1000, numberOf4kBanks * 0x1000);\n                }\n                this.UpdateBankStartCache();\n            },\n            SetByte: function (clock, address, val) {\n                // if write is to a different register, reset\n                this.lastClock = clock;\n                switch (address & 61440) {\n                    case 24576: \n                    case 28672: \n                        this.prgRomBank6[address & 8191] = val & 255;\n                        break;\n                    default: \n                        this.lastwriteAddress = address;\n                        if ((val & 128) === 128) {\n                            this._registers[0] = this._registers[0] | 12;\n                            this.accumulator = 0; // _registers[(address / 0x2000) & 3];\n                            this.sequence = 0;\n                        } else {\n                            if ((val & 1) === 1) {\n                                this.accumulator = this.accumulator | (1 << this.sequence);\n                            }\n                            this.sequence = (this.sequence + 1) | 0;\n                        }\n                        if (this.sequence === 5) {\n                            var regnum = (address & 32767) >> 13;\n                            this._registers[(address & 32767) >> 13] = this.accumulator;\n                            this.sequence = 0;\n                            this.accumulator = 0;\n\n                            switch (regnum) {\n                                case 0: \n                                    this.SetMMC1Mirroring(clock);\n                                    break;\n                                case 1: \n                                case 2: \n                                    this.SetMMC1ChrBanking(clock);\n                                    break;\n                                case 3: \n                                    this.SetMMC1PrgBanking();\n                                    break;\n                            }\n\n                        }\n                        break;\n                }\n\n            },\n            SetMMC1ChrBanking: function (clock) {\n                //\tbit 4 - sets 8KB or 4KB CHRROM switching mode\n                // 0 = 8KB CHRROM banks, 1 = 4KB CHRROM banks\n                this.whizzler.ChiChiNES$IPPU$DrawTo(clock);\n                if ((this._registers[0] & 16) === 16) {\n                    this.CopyBanks(0, this._registers[1], 1);\n                    this.CopyBanks(1, this._registers[2], 1);\n                } else {\n                    //CopyBanks(0, _registers[1], 2);\n                    this.CopyBanks(0, this._registers[1], 1);\n                    this.CopyBanks(1, ((this._registers[1] + 1) | 0), 1);\n                }\n                this.BankSwitchesChanged = true;\n\n                this.whizzler.ChiChiNES$IPPU$UpdatePixelInfo();\n            },\n            SetMMC1PrgBanking: function () {\n                var reg;\n                if (this.PrgRomCount === 32) {\n                    this.bank_select = (this._registers[1] & 16) << 1;\n\n                } else {\n                    this.bank_select = 0;\n                }\n\n\n                if ((this._registers[0] & 8) === 0) {\n                    reg = (Bridge.Int.mul(4, ((this._registers[3] >> 1) & 15)) + this.bank_select) | 0;\n                    this.SetupBankStarts(reg, ((reg + 1) | 0), ((reg + 2) | 0), ((reg + 3) | 0));\n                } else {\n                    reg = (Bridge.Int.mul(2, (this._registers[3])) + this.bank_select) | 0;\n                    //bit 2 - toggles between low PRGROM area switching and high\n                    //PRGROM area switching\n                    //0 = high PRGROM switching, 1 = low PRGROM switching\n                    if ((this._registers[0] & 4) === 4) {\n                        // select 16k bank in register 3 (setupbankstarts switches 8k banks)\n                        this.SetupBankStarts(reg, ((reg + 1) | 0), ((Bridge.Int.mul(this.PrgRomCount, 2) - 2) | 0), ((Bridge.Int.mul(this.PrgRomCount, 2) - 1) | 0));\n                        //SetupBanks(reg8, reg8 + 1, 0xFE, 0xFF);\n                    } else {\n                        this.SetupBankStarts(0, 1, reg, ((reg + 1) | 0));\n                    }\n                }\n            },\n            SetMMC1Mirroring: function (clock) {\n                //bit 1 - toggles between H/V and \"one-screen\" mirroring\n                //0 = one-screen mirroring, 1 = H/V mirroring\n                this.whizzler.ChiChiNES$IPPU$DrawTo(clock);\n                switch (this._registers[0] & 3) {\n                    case 0: \n                        this.OneScreenOffset = 0;\n                        this.Mirror(clock, 0);\n                        break;\n                    case 1: \n                        this.OneScreenOffset = 1024;\n                        this.Mirror(clock, 0);\n                        break;\n                    case 2: \n                        this.Mirror(clock, 1); // vertical\n                        break;\n                    case 3: \n                        this.Mirror(clock, 2); // horizontal\n                        break;\n                }\n                this.BankSwitchesChanged = true;\n                this.whizzler.ChiChiNES$IPPU$UpdatePixelInfo();\n            }\n        }\n    });\n\n    Bridge.define(\"ChiChiNES.NesCartMMC3\", {\n        inherits: [ChiChiNES.BaseCart],\n        fields: {\n            _registers: null,\n            chr2kBank0: 0,\n            chr2kBank1: 0,\n            chr1kBank0: 0,\n            chr1kBank1: 0,\n            chr1kBank2: 0,\n            chr1kBank3: 0,\n            prgSwap: 0,\n            prgSwitch1: 0,\n            prgSwitch2: 0,\n            prevBSSrc: null,\n            _mmc3Command: 0,\n            _mmc3ChrAddr: 0,\n            _mmc3IrqVal: 0,\n            _mmc3TmpVal: 0,\n            scanlineCounter: 0,\n            _mmc3IrcOn: false,\n            ppuBankSwap: false,\n            PPUBanks: null\n        },\n        props: {\n            IRQAsserted: {\n                get: function () {\n                    return this.irqRaised;\n                },\n                set: function (value) {\n                    this.irqRaised = value;\n                }\n            }\n        },\n        alias: [\n            \"InitializeCart\", \"ChiChiNES$INESCart$InitializeCart\",\n            \"IRQAsserted\", \"ChiChiNES$IClockedMemoryMappedIOElement$IRQAsserted\",\n            \"SetByte\", \"ChiChiNES$IClockedMemoryMappedIOElement$SetByte\",\n            \"UpdateScanlineCounter\", \"ChiChiNES$INESCart$UpdateScanlineCounter\"\n        ],\n        ctors: {\n            init: function () {\n                this._registers = System.Array.init(4, 0, System.Int32);\n                this.chr2kBank0 = 0;\n                this.chr2kBank1 = 1;\n                this.chr1kBank0 = 0;\n                this.chr1kBank1 = 0;\n                this.chr1kBank2 = 0;\n                this.chr1kBank3 = 0;\n                this.prgSwap = 0;\n                this.prgSwitch1 = 0;\n                this.prgSwitch2 = 0;\n                this.prevBSSrc = System.Array.init(8, 0, System.Int32);\n                this._mmc3Command = 0;\n                this._mmc3ChrAddr = 0;\n                this._mmc3IrqVal = 0;\n                this._mmc3TmpVal = 0;\n                this.scanlineCounter = 0;\n                this._mmc3IrcOn = false;\n                this.ppuBankSwap = false;\n                this.PPUBanks = System.Array.init(8, 0, System.Int32);\n            }\n        },\n        methods: {\n            InitializeCart: function () {\n\n                this.prgSwap = 1;\n\n                //SetupBanks(0, 1, 0xFE, 0xFF);\n                this.prgSwitch1 = 0;\n                this.prgSwitch2 = 1;\n                this.SwapPrgRomBanks();\n                this._mmc3IrqVal = 0;\n                this._mmc3IrcOn = false;\n                this._mmc3TmpVal = 0;\n\n                this.chr2kBank0 = 0;\n                this.chr2kBank1 = 0;\n\n                this.chr1kBank0 = 0;\n                this.chr1kBank1 = 0;\n                this.chr1kBank2 = 0;\n                this.chr1kBank3 = 0;\n\n                if (this.ChrRomCount > 0) {\n                    this.CopyBanks(0, 0, 8);\n                }\n            },\n            MaskBankAddress: function (bank) {\n\n                if (bank >= Bridge.Int.mul(this.PrgRomCount, 2)) {\n                    var i = 255;\n                    while ((bank & i) >= Bridge.Int.mul(this.PrgRomCount, 2)) {\n                        i = i >> 1;\n                    }\n                    return (bank & i);\n                } else {\n                    return bank;\n                }\n            },\n            CopyBanks: function (dest, src, numberOf1kBanks) {\n                var $t;\n                if (this.ChrRomCount > 0) {\n                    for (var i = 0; i < numberOf1kBanks; i = (i + 1) | 0) {\n                        ($t = this.PpuBankStarts)[((dest + i) | 0)] = Bridge.Int.mul((((src + i) | 0)), 1024);\n                    }\n                    this.BankSwitchesChanged = true;\n                    //Array.Copy(chrRom, src * 0x400, whizzler.cartCopyVidRAM, dest * 0x400, numberOf1kBanks * 0x400);\n                }\n            },\n            SetByte: function (clock, address, val) {\n                if (address >= 24576 && address < 32768) {\n                    if (this.SRAMEnabled && this.SRAMCanWrite) {\n                        this.prgRomBank6[address & 8191] = val & 255;\n                    }\n                    return;\n                }\n                //Bank select ($8000-$9FFE, even)\n\n                //7  bit  0\n                //---- ----\n                //CPxx xRRR\n                //||    |||\n                //||    +++- Specify which bank register to update on next write to Bank Data register\n                //_mmc3Command\n                //||         0: Select 2 KB CHR bank at PPU $0000-$07FF (or $1000-$17FF);\n                //||         1: Select 2 KB CHR bank at PPU $0800-$0FFF (or $1800-$1FFF);\n                //||         2: Select 1 KB CHR bank at PPU $1000-$13FF (or $0000-$03FF);\n                //||         3: Select 1 KB CHR bank at PPU $1400-$17FF (or $0400-$07FF);\n                //||         4: Select 1 KB CHR bank at PPU $1800-$1BFF (or $0800-$0BFF);\n                //||         5: Select 1 KB CHR bank at PPU $1C00-$1FFF (or $0C00-$0FFF);\n                //||         6: Select 8 KB PRG bank at $8000-$9FFF (or $C000-$DFFF);\n                //||         7: Select 8 KB PRG bank at $A000-$BFFF\n\n                //|+-------- PRG ROM bank configuration (0: $8000-$9FFF swappable, $C000-$DFFF fixed to second-last bank;\n                //|                                      1: $C000-$DFFF swappable, $8000-$9FFF fixed to second-last bank)\n                //+--------- CHR ROM bank configuration (0: two 2 KB banks at $0000-$0FFF, four 1 KB banks at $1000-$1FFF;\n                //                                       1: four 1 KB banks at $0000-$0FFF, two 2 KB banks at $1000-$1FFF)\n                switch (address & 57345) {\n                    case 32768: \n                        this._mmc3Command = val & 7;\n                        if ((val & 128) === 128) {\n                            this.ppuBankSwap = true;\n                            this._mmc3ChrAddr = 4096;\n                        } else {\n                            this.ppuBankSwap = false;\n                            this._mmc3ChrAddr = 0;\n                        }\n                        if ((val & 64) === 64) {\n                            this.prgSwap = 1;\n                        } else {\n                            this.prgSwap = 0;\n                        }\n                        this.SwapPrgRomBanks();\n                        break;\n                    case 32769: \n                        switch (this._mmc3Command) {\n                            case 0: \n                                this.chr2kBank0 = val;\n                                this.SwapChrBanks();\n                                // CopyBanks(0, val, 1);\n                                // CopyBanks(1, val + 1, 1);\n                                break;\n                            case 1: \n                                this.chr2kBank1 = val;\n                                this.SwapChrBanks();\n                                // CopyBanks(2, val, 1);\n                                // CopyBanks(3, val + 1, 1);\n                                break;\n                            case 2: \n                                this.chr1kBank0 = val;\n                                this.SwapChrBanks();\n                                //CopyBanks(4, val, 1);\n                                break;\n                            case 3: \n                                this.chr1kBank1 = val;\n                                this.SwapChrBanks();\n                                //CopyBanks(5, val, 1);\n                                break;\n                            case 4: \n                                this.chr1kBank2 = val;\n                                this.SwapChrBanks();\n                                //CopyBanks(6, val, 1);\n                                break;\n                            case 5: \n                                this.chr1kBank3 = val;\n                                this.SwapChrBanks();\n                                //CopyBanks(7, val, 1);\n                                break;\n                            case 6: \n                                this.prgSwitch1 = val;\n                                this.SwapPrgRomBanks();\n                                break;\n                            case 7: \n                                this.prgSwitch2 = val;\n                                this.SwapPrgRomBanks();\n                                break;\n                        }\n                        break;\n                    case 40960: \n                        if ((val & 1) === 1) {\n                            this.Mirror(clock, 2);\n                        } else {\n                            this.Mirror(clock, 1);\n                        }\n                        break;\n                    case 40961: \n                        //PRG RAM protect ($A001-$BFFF, odd)\n                        //7  bit  0\n                        //---- ----\n                        //RWxx xxxx\n                        //||\n                        //|+-------- Write protection (0: allow writes; 1: deny writes)\n                        //+--------- Chip enable (0: disable chip; 1: enable chip)\n                        this.SRAMCanWrite = ((val & 64) === 0);\n                        this.SRAMEnabled = ((val & 128) === 128);\n                        break;\n                    case 49152: \n                        this._mmc3IrqVal = val;\n                        if (val === 0) {\n                            // special treatment for one-time irq handling\n                            this.scanlineCounter = 0;\n                        }\n                        break;\n                    case 49153: \n                        this._mmc3TmpVal = this._mmc3IrqVal;\n                        break;\n                    case 57344: \n                        this._mmc3IrcOn = false;\n                        this._mmc3IrqVal = this._mmc3TmpVal;\n                        this.irqRaised = false;\n                        if (!Bridge.staticEquals(this.updateIRQ, null)) {\n                            this.updateIRQ();\n                        }\n                        break;\n                    case 57345: \n                        this._mmc3IrcOn = true;\n                        break;\n                }\n            },\n            SwapChrBanks: function () {\n                if (this.ppuBankSwap) {\n                    this.CopyBanks(0, this.chr1kBank0, 1);\n                    this.CopyBanks(1, this.chr1kBank1, 1);\n                    this.CopyBanks(2, this.chr1kBank2, 1);\n                    this.CopyBanks(3, this.chr1kBank3, 1);\n                    this.CopyBanks(4, this.chr2kBank0, 2);\n                    this.CopyBanks(6, this.chr2kBank1, 2);\n                } else {\n                    this.CopyBanks(4, this.chr1kBank0, 1);\n                    this.CopyBanks(5, this.chr1kBank1, 1);\n                    this.CopyBanks(6, this.chr1kBank2, 1);\n                    this.CopyBanks(7, this.chr1kBank3, 1);\n                    this.CopyBanks(0, this.chr2kBank0, 2);\n                    this.CopyBanks(2, this.chr2kBank1, 2);\n                }\n            },\n            SwapPrgRomBanks: function () {\n                //|+-------- PRG ROM bank configuration (0: $8000-$9FFF swappable, $C000-$DFFF fixed to second-last bank;\n                //|                                      1: $C000-$DFFF swappable, $8000-$9FFF fixed to second-last bank)\n\n                if (this.prgSwap === 1) {\n\n                    this.SetupBankStarts(((Bridge.Int.mul(this.PrgRomCount, 2) - 2) | 0), this.prgSwitch2, this.prgSwitch1, ((Bridge.Int.mul(this.PrgRomCount, 2) - 1) | 0));\n                } else {\n                    this.SetupBankStarts(this.prgSwitch1, this.prgSwitch2, ((Bridge.Int.mul(this.PrgRomCount, 2) - 2) | 0), ((Bridge.Int.mul(this.PrgRomCount, 2) - 1) | 0));\n                }\n\n            },\n            UpdateScanlineCounter: function () {\n                //if (scanlineCounter == -1) return;\n\n                if (this.scanlineCounter === 0) {\n                    this.scanlineCounter = this._mmc3IrqVal;\n                    //Writing $00 to $C000 will result in a single IRQ being generated on the next rising edge of PPU A12. \n                    //No more IRQs will be generated until $C000 is changed to a non-zero value, upon which the \n                    // counter will start counting from the new value, generating an IRQ once it reaches zero. \n                    if (this._mmc3IrqVal === 0) {\n                        if (this._mmc3IrcOn) {\n                            this.irqRaised = true;\n                            this.updateIRQ();\n                        }\n                        this.scanlineCounter = -1;\n                        return;\n                    }\n                }\n\n                if (this._mmc3TmpVal !== 0) {\n                    this.scanlineCounter = this._mmc3TmpVal;\n                    this._mmc3TmpVal = 0;\n                } else {\n                    this.scanlineCounter = (((this.scanlineCounter - 1) | 0)) & 255;\n                }\n\n                if (this.scanlineCounter === 0) {\n                    if (this._mmc3IrcOn) {\n                        this.irqRaised = true;\n                        if (!Bridge.staticEquals(this.updateIRQ, null)) {\n                            this.updateIRQ();\n                        }\n                    }\n                    if (this._mmc3IrqVal > 0) {\n                        this.scanlineCounter = this._mmc3IrqVal;\n                    }\n                }\n\n            }\n        }\n    });\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/app/emu/ChiChiCore.js\n// module id = 4\n// module chunks = 0","// Provide a \"System\" global.\r\nmodule.exports = {\r\n\t// Make sure import is only used as \"System.import\"\r\n\timport: function() {\r\n\t\tthrow new Error(\"System.import cannot be used indirectly\");\r\n\t}\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/system.js\n// module id = 5\n// module chunks = 0"],"sourceRoot":""}