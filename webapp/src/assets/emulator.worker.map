{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 2b79598913f880c76aaf","webpack:///./emulator.worker.ts","webpack:////home/jhartrick/projects/cc/chichines/chichilib/chichi.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;AC7DA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,oCAAoC;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,wGAAwG;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,0GAA0G;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,4BAA4B,qBAAqB,EAAE,mB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;AClTA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,0BAA0B,EAAE;AAC/D,yCAAyC,eAAe;AACxD;AACA;AACA;AACA;AACA;AACA,8DAA8D,+DAA+D;AAC7H;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;;AAEA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4EAA4E;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,6GAA6G;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;AAGA,OAAO;AACP;AACA;;AAEA;;AAEA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,0JAA0J;AAC1M;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,wJAAwJ;AACxM;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE,uBAAuB,iCAAiC;AACxD;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,gCAAgC;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iBAAiB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,SAAS;AAClC;AACA;AACA;AACA;AACA,gCAAgC,0CAA0C;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,aAAa;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE;AAChE,gEAAgE;AAChE,mEAAmE,aAAa;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;AAGA,OAAO;AACP;AACA;;AAEA;;AAEA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,uBAAuB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,gDAAgD,8BAA8B;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA,qDAAqD;AACrD;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qCAAqC;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,IAAI,EAAE,IAAI,EAAE,IAAI;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,UAAU;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,6BAA6B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;AAGA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA,UAAU,gBAAgB,sCAAsC,iBAAiB,EAAE;AACnF,yBAAyB,uDAAuD;AAChF;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA,0GAA0G;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA,0GAA0G;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,qFAAqF;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,SAAS;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,gGAAgG;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kJAAkJ,EAAE;AACpJ;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,EAAE;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,OAAO;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,4BAA4B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,4BAA4B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,+BAA+B,EAAE;AACzG,uEAAuE,+BAA+B,EAAE;AACxG,yEAAyE,+BAA+B,EAAE;AAC1G;AACA,uBAAuB,8BAA8B;AACrD;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA,6BAA6B;AAC7B;AACA,2BAA2B;AAC3B;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,4BAA4B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,4BAA4B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,qBAAqB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;AAGA,OAAO;AACP;AACA;;AAEA;;AAEA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,YAAY;AACrC;AACA;AACA;AACA,yBAAyB,UAAU;AACnC;AACA,W;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,uBAAuB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,uBAAuB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,uBAAuB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;AAGA,OAAO;AACP;AACA;;AAEA;;AAEA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;AAGA,OAAO;AACP;AACA;;AAEA;;AAEA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA,UAAU,gBAAgB,sCAAsC,iBAAiB,EAAE;AACnF,yBAAyB,uDAAuD;AAChF;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA,CAAC;AACD,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,uBAAuB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,+BAA+B,EAAE;AACzG,uEAAuE,+BAA+B,EAAE;AACxG,yEAAyE,+BAA+B,EAAE;AAC1G;AACA;AACA,uBAAuB,2BAA2B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;AAGA,OAAO;AACP,Y","file":"emulator.worker.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"emulator.worker\"] = factory();\n\telse\n\t\troot[\"emulator.worker\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 2b79598913f880c76aaf","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar chichi_1 = require(\"chichi\");\r\nvar NesInfo = (function () {\r\n    function NesInfo() {\r\n        this.bufferupdate = false;\r\n        this.stateupdate = true;\r\n        this.runStatus = {};\r\n        this.cartInfo = {};\r\n        this.sound = {};\r\n        this.Cpu = {};\r\n        this.Cart = {};\r\n        this.debug = {\r\n            currentCpuStatus: {\r\n                PC: 0,\r\n                A: 0,\r\n                X: 0,\r\n                Y: 0,\r\n                SP: 0,\r\n                SR: 0\r\n            },\r\n            currentPPUStatus: {}\r\n        };\r\n    }\r\n    return NesInfo;\r\n}());\r\nvar tendoWrapper = (function () {\r\n    function tendoWrapper() {\r\n        this.framesRendered = 0;\r\n        this.startTime = 0;\r\n        this.runTimeout = 0;\r\n        this.Debugging = false;\r\n        this.frameFinished = false;\r\n        this.ready = false;\r\n        this.framesPerSecond = 0;\r\n        this.iops = new Int32Array(16);\r\n        this.cartName = 'unk';\r\n        this.sharedAudioBufferPos = 0;\r\n        this.audioBytesWritten = 0;\r\n        this.machine = new chichi_1.ChiChiMachine();\r\n    }\r\n    tendoWrapper.prototype.createMachine = function () {\r\n        var _this = this;\r\n        this.machine = new chichi_1.ChiChiMachine();\r\n        this.machine.Drawscreen = function () {\r\n            // flush audio\r\n            // globals.postMessage({ frame: true, fps: framesPerSecond });\r\n        };\r\n        this.ready = true;\r\n        this.machine.Cpu.addDebugEvent(function () {\r\n            var info = new NesInfo();\r\n            info.debug = {\r\n                currentCpuStatus: _this.machine.Cpu.GetStatus ? _this.machine.Cpu.GetStatus() : {\r\n                    PC: 0,\r\n                    A: 0,\r\n                    X: 0,\r\n                    Y: 0,\r\n                    SP: 0,\r\n                    SR: 0\r\n                },\r\n                currentPPUStatus: _this.machine.ppu.GetPPUStatus ? _this.machine.ppu.GetPPUStatus() : {},\r\n                InstructionHistory: {\r\n                    Buffer: _this.machine.Cpu.InstructionHistory.slice(0),\r\n                    Index: _this.machine.Cpu.InstructionHistoryPointer,\r\n                    Finish: false\r\n                }\r\n            };\r\n            postMessage(info);\r\n            //this.updateState();\r\n        });\r\n        this.machine.Cpu.Debugging = false;\r\n    };\r\n    tendoWrapper.prototype.updateBuffers = function () {\r\n        var machine = this.machine;\r\n        var info = new NesInfo();\r\n        info.bufferupdate = true;\r\n        info.stateupdate = false;\r\n        if (this.machine && this.machine.Cart) {\r\n            info.Cpu = {\r\n                Rams: this.machine.Cpu.Rams,\r\n                spriteRAM: this.machine.Cpu.ppu.spriteRAM\r\n            };\r\n            info.Cart = {\r\n                //buffers\r\n                chrRom: this.machine.Cart.chrRom,\r\n                prgRomBank6: this.machine.Cart.prgRomBank6,\r\n                ppuBankStarts: this.machine.Cart.ppuBankStarts,\r\n                bankStartCache: this.machine.Cart.bankStartCache,\r\n            };\r\n            info.sound = {\r\n                waveForms_controlBuffer: this.machine.WaveForms.controlBuffer\r\n            };\r\n        }\r\n        postMessage(info);\r\n    };\r\n    tendoWrapper.prototype.updateState = function () {\r\n        var machine = this.machine;\r\n        var info = new NesInfo();\r\n        if (this.machine && this.machine.Cart) {\r\n            info.Cpu = {\r\n                //Rams: this.machine.Cpu.Rams,\r\n                status: this.machine.Cpu.GetStatus(),\r\n                ppuStatus: this.machine.Cpu.ppu.GetPPUStatus(),\r\n                backgroundPatternTableIndex: this.machine.Cpu.ppu.backgroundPatternTableIndex,\r\n                _PPUControlByte0: this.machine.Cpu.ppu._PPUControlByte0,\r\n                _PPUControlByte1: this.machine.Cpu.ppu._PPUControlByte1\r\n            };\r\n            info.cartInfo = {\r\n                mapperId: this.machine.Cart.MapperID,\r\n                name: this.cartName,\r\n                prgRomCount: this.machine.Cart.NumberOfPrgRoms,\r\n                chrRomCount: this.machine.Cart.NumberOfChrRoms\r\n            };\r\n            info.Cart = {\r\n                //buffers\r\n                //chrRom: (<any>this.machine.Cart).chrRom,\r\n                //prgRomBank6: (<any>this.machine.Cart).prgRomBank6,\r\n                //ppuBankStarts: (<any>this.machine.Cart).ppuBankStarts,\r\n                //bankStartCache: (<any>this.machine.Cart).bankStartCache,\r\n                CurrentBank: this.machine.Cart.CurrentBank,\r\n                // integers\r\n                current8: this.machine.Cart.current8,\r\n                currentA: this.machine.Cart.currentA,\r\n                currentC: this.machine.Cart.currentC,\r\n                currentE: this.machine.Cart.currentE,\r\n                bank8start: this.machine.Cart.bank8start,\r\n                bankAstart: this.machine.Cart.bankAstart,\r\n                bankCstart: this.machine.Cart.bankCstart,\r\n                bankEstart: this.machine.Cart.bankEstart\r\n            };\r\n        }\r\n        if (machine) {\r\n            if (machine.SoundBopper && machine.SoundBopper.audioSettings) {\r\n                info.sound = {\r\n                    soundEnabled: machine.EnableSound,\r\n                    settings: machine.SoundBopper.audioSettings\r\n                };\r\n            }\r\n            if (this.machine.Cpu.Debugging) {\r\n                info.debug = {\r\n                    currentCpuStatus: this.machine.Cpu.GetStatus ? this.machine.Cpu.GetStatus() : {\r\n                        PC: 0,\r\n                        A: 0,\r\n                        X: 0,\r\n                        Y: 0,\r\n                        SP: 0,\r\n                        SR: 0\r\n                    },\r\n                    currentPPUStatus: this.machine.ppu.GetPPUStatus ? this.machine.ppu.GetPPUStatus() : {},\r\n                    InstructionHistory: {\r\n                        Buffer: this.machine.Cpu.InstructionHistory.slice(0),\r\n                        Index: this.machine.Cpu.InstructionHistoryPointer,\r\n                        Finish: true\r\n                    }\r\n                };\r\n            }\r\n        }\r\n        postMessage(info);\r\n    };\r\n    tendoWrapper.prototype.drawScreen = function () { };\r\n    tendoWrapper.prototype.stop = function () {\r\n        clearInterval(this.interval);\r\n        this.machine.PowerOff();\r\n        this.runStatus = this.machine.RunState;\r\n    };\r\n    tendoWrapper.prototype.flushAudio = function () {\r\n        //  debugger;\r\n        var len = this.machine.WaveForms.SharedBufferLength;\r\n        for (var i = 0; i < len; ++i) {\r\n            this.sharedAudioBufferPos++;\r\n            if (this.sharedAudioBufferPos >= this.sharedAudioBuffer.length) {\r\n                this.sharedAudioBufferPos = 0;\r\n            }\r\n            this.sharedAudioBuffer[this.sharedAudioBufferPos] = this.machine.WaveForms.SharedBuffer[i];\r\n            this.audioBytesWritten++;\r\n        }\r\n        while (this.audioBytesWritten >= this.sharedAudioBuffer.length >> 2) {\r\n            Atomics.store(this.iops, 3, this.audioBytesWritten);\r\n            Atomics.wait(this.iops, 3, this.audioBytesWritten);\r\n            this.audioBytesWritten = Atomics.load(this.iops, 3);\r\n        }\r\n    };\r\n    tendoWrapper.prototype.runInnerLoop = function () {\r\n        this.machine.PadOne.padOneState = this.iops[2] & 0xFF;\r\n        this.machine.PadTwo.padOneState = (this.iops[2] >> 8) & 0xFF;\r\n        this.machine.RunFrame();\r\n        this.framesPerSecond = 0;\r\n        //this.flushAudio();\r\n        if ((this.framesRendered++) === 60) {\r\n            // this.updateState();\r\n            this.framesPerSecond = ((this.framesRendered / (new Date().getTime() - this.startTime)) * 1000);\r\n            this.framesRendered = 0;\r\n            this.startTime = new Date().getTime();\r\n            this.iops[1] = this.framesPerSecond;\r\n            // if (this.framesPerSecond < 60 && this.runTimeout > 0) {\r\n            //     this.runTimeout--;\r\n            // } else if (this.runTimeout < 50) {\r\n            //     this.runTimeout++;\r\n            // }\r\n        }\r\n        //this.runInnerLoop();\r\n        //setTimeout(() => { this.runInnerLoop(); }, this.runTimeout); \r\n    };\r\n    tendoWrapper.prototype.run = function (reset) {\r\n        var _this = this;\r\n        this.iops[3] = 12312312;\r\n        var framesRendered = 0;\r\n        var machine = this.machine;\r\n        if (reset) {\r\n            machine.Reset();\r\n        }\r\n        machine.Cpu.Debugging = false;\r\n        this.startTime = new Date().getTime();\r\n        clearInterval(this.interval);\r\n        this.interval = setInterval(function () {\r\n            _this.iops[0] = 1;\r\n            while (_this.iops[0] == 1) {\r\n                _this.runInnerLoop();\r\n            }\r\n        }, 1);\r\n        this.runStatus = machine.RunState; // runStatuses.Running;\r\n    };\r\n    tendoWrapper.prototype.runFrame = function () {\r\n        clearInterval(this.interval);\r\n        this.frameFinished = false;\r\n        var machine = this.machine;\r\n        machine.Cpu.Debugging = this.Debugging;\r\n        // intervalId = setInterval(() => \r\n        machine.RunFrame();\r\n        this.runStatus = this.machine.RunState;\r\n        this.frameFinished = true;\r\n    };\r\n    tendoWrapper.prototype.reset = function () {\r\n        var machine = this.machine;\r\n        machine.Cpu.Debugging = this.Debugging;\r\n        machine.Reset();\r\n        this.runStatus = this.machine.RunState;\r\n    };\r\n    tendoWrapper.prototype.step = function () {\r\n        clearInterval(this.interval);\r\n        var machine = this.machine;\r\n        machine.Cpu.Debugging = this.Debugging;\r\n        machine.Step();\r\n        this.runStatus = this.machine.RunState;\r\n    };\r\n    tendoWrapper.prototype.handleMessage = function (event) {\r\n        var machine = this.machine;\r\n        switch (event.data.command) {\r\n            case 'create':\r\n                this.createMachine();\r\n                this.machine.Cpu.ppu.byteOutBuffer = event.data.vbuffer;\r\n                this.machine.SoundBopper.writer.SharedBuffer = this.sharedAudioBuffer = event.data.abuffer;\r\n                this.machine.SoundBopper.audioSettings = event.data.audioSettings;\r\n                this.sharedAudioBufferPos = 0;\r\n                this.iops = event.data.iops;\r\n                break;\r\n            case 'loadrom':\r\n                this.stop();\r\n                //this.createMachine();\r\n                this.machine.EnableSound = false;\r\n                this.machine.LoadCart(event.data.rom);\r\n                this.updateBuffers();\r\n                break;\r\n            case 'loadnsf':\r\n                this.stop();\r\n                //this.createNsfMachine();\r\n                this.updateBuffers();\r\n                break;\r\n            case 'audiosettings':\r\n                this.machine.SoundBopper.audioSettings = event.data.settings;\r\n                break;\r\n            case 'mute':\r\n                this.machine.EnableSound = false;\r\n                break;\r\n            case 'unmute':\r\n                this.machine.EnableSound = true;\r\n                break;\r\n            case 'run':\r\n                this.Debugging = false;\r\n                this.run(true);\r\n                break;\r\n            case 'runframe':\r\n                this.Debugging = true;\r\n                this.runFrame();\r\n                break;\r\n            case 'step':\r\n                this.Debugging = true;\r\n                this.step();\r\n                break;\r\n            case 'continue':\r\n                this.run(false);\r\n                break;\r\n            case 'stop':\r\n                this.machine.EnableSound = false;\r\n                this.stop();\r\n                break;\r\n            case 'reset':\r\n                this.reset();\r\n                break;\r\n            default:\r\n                return;\r\n        }\r\n        this.updateState();\r\n    };\r\n    return tendoWrapper;\r\n}());\r\nexports.tendoWrapper = tendoWrapper;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./emulator.worker.ts\n// module id = 0\n// module chunks = 0","module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 6);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// utility classes\nvar RunningStatuses;\n(function (RunningStatuses) {\n    RunningStatuses[RunningStatuses[\"Unloaded\"] = 0] = \"Unloaded\";\n    RunningStatuses[RunningStatuses[\"Off\"] = 1] = \"Off\";\n    RunningStatuses[RunningStatuses[\"Running\"] = 2] = \"Running\";\n    RunningStatuses[RunningStatuses[\"Frozen\"] = 3] = \"Frozen\";\n    RunningStatuses[RunningStatuses[\"Paused\"] = 4] = \"Paused\";\n})(RunningStatuses = exports.RunningStatuses || (exports.RunningStatuses = {}));\nvar ChiChiCPPU_AddressingModes;\n(function (ChiChiCPPU_AddressingModes) {\n    ChiChiCPPU_AddressingModes[ChiChiCPPU_AddressingModes[\"Bullshit\"] = 0] = \"Bullshit\";\n    ChiChiCPPU_AddressingModes[ChiChiCPPU_AddressingModes[\"Implicit\"] = 1] = \"Implicit\";\n    ChiChiCPPU_AddressingModes[ChiChiCPPU_AddressingModes[\"Accumulator\"] = 2] = \"Accumulator\";\n    ChiChiCPPU_AddressingModes[ChiChiCPPU_AddressingModes[\"Immediate\"] = 3] = \"Immediate\";\n    ChiChiCPPU_AddressingModes[ChiChiCPPU_AddressingModes[\"ZeroPage\"] = 4] = \"ZeroPage\";\n    ChiChiCPPU_AddressingModes[ChiChiCPPU_AddressingModes[\"ZeroPageX\"] = 5] = \"ZeroPageX\";\n    ChiChiCPPU_AddressingModes[ChiChiCPPU_AddressingModes[\"ZeroPageY\"] = 6] = \"ZeroPageY\";\n    ChiChiCPPU_AddressingModes[ChiChiCPPU_AddressingModes[\"Relative\"] = 7] = \"Relative\";\n    ChiChiCPPU_AddressingModes[ChiChiCPPU_AddressingModes[\"Absolute\"] = 8] = \"Absolute\";\n    ChiChiCPPU_AddressingModes[ChiChiCPPU_AddressingModes[\"AbsoluteX\"] = 9] = \"AbsoluteX\";\n    ChiChiCPPU_AddressingModes[ChiChiCPPU_AddressingModes[\"AbsoluteY\"] = 10] = \"AbsoluteY\";\n    ChiChiCPPU_AddressingModes[ChiChiCPPU_AddressingModes[\"Indirect\"] = 11] = \"Indirect\";\n    ChiChiCPPU_AddressingModes[ChiChiCPPU_AddressingModes[\"IndexedIndirect\"] = 12] = \"IndexedIndirect\";\n    ChiChiCPPU_AddressingModes[ChiChiCPPU_AddressingModes[\"IndirectIndexed\"] = 13] = \"IndirectIndexed\";\n    ChiChiCPPU_AddressingModes[ChiChiCPPU_AddressingModes[\"IndirectZeroPage\"] = 14] = \"IndirectZeroPage\";\n    ChiChiCPPU_AddressingModes[ChiChiCPPU_AddressingModes[\"IndirectAbsoluteX\"] = 15] = \"IndirectAbsoluteX\";\n})(ChiChiCPPU_AddressingModes = exports.ChiChiCPPU_AddressingModes || (exports.ChiChiCPPU_AddressingModes = {}));\nvar CpuStatus = /** @class */ (function () {\n    function CpuStatus() {\n        this.PC = 0;\n        this.A = 0;\n        this.X = 0;\n        this.Y = 0;\n        this.SP = 0;\n        this.SR = 0;\n    }\n    return CpuStatus;\n}());\nexports.CpuStatus = CpuStatus;\nvar PpuStatus = /** @class */ (function () {\n    function PpuStatus() {\n        this.status = 0;\n        this.controlByte0 = 0;\n        this.controlByte1 = 0;\n        this.nameTableStart = 0;\n        this.currentTile = 0;\n        this.lockedVScroll = 0;\n        this.lockedHScroll = 0;\n        this.X = 0;\n        this.Y = 0;\n    }\n    return PpuStatus;\n}());\nexports.PpuStatus = PpuStatus;\nvar ChiChiInstruction = /** @class */ (function () {\n    function ChiChiInstruction() {\n        this.AddressingMode = 0;\n        this.frame = 0;\n        this.time = 0;\n        this.A = 0;\n        this.X = 0;\n        this.Y = 0;\n        this.SR = 0;\n        this.SP = 0;\n        this.Address = 0;\n        this.OpCode = 0;\n        this.Parameters0 = 0;\n        this.Parameters1 = 0;\n        this.ExtraTiming = 0;\n        this.Length = 0;\n    }\n    return ChiChiInstruction;\n}());\nexports.ChiChiInstruction = ChiChiInstruction;\nvar ChiChiSprite = /** @class */ (function () {\n    function ChiChiSprite() {\n        this.YPosition = 0;\n        this.XPosition = 0;\n        this.SpriteNumber = 0;\n        this.Foreground = false;\n        this.IsVisible = false;\n        this.TileIndex = 0;\n        this.AttributeByte = 0;\n        this.FlipX = false;\n        this.FlipY = false;\n        this.Changed = false;\n    }\n    return ChiChiSprite;\n}());\nexports.ChiChiSprite = ChiChiSprite;\nvar AudioSettings = /** @class */ (function () {\n    function AudioSettings() {\n        this.sampleRate = 44100;\n        this.master_volume = 0.0;\n        this.enableSquare0 = true;\n        this.enableSquare1 = true;\n        this.enableTriangle = true;\n        this.enableNoise = true;\n        this.enablePCM = true;\n    }\n    return AudioSettings;\n}());\nexports.AudioSettings = AudioSettings;\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ChiChiTypes_1 = __webpack_require__(0);\nvar ChiChiMemMap = /** @class */ (function () {\n    function ChiChiMemMap() {\n    }\n    ChiChiMemMap.prototype.getByte = function (address) {\n        return 0;\n    };\n    ChiChiMemMap.prototype.setByte = function (address, data) {\n    };\n    return ChiChiMemMap;\n}());\nexports.ChiChiMemMap = ChiChiMemMap;\nvar ChiChiPPU = /** @class */ (function () {\n    function ChiChiPPU() {\n        this.LastcpuClock = 0;\n        // private members\n        // scanline position\n        this.yPosition = 0;\n        this.xPosition = 0;\n        // current draw location in outbuffer    \n        this.vbufLocation = 0;\n        this.currentAttributeByte = 0;\n        // sprite info\n        this.spriteSize = 0;\n        this.spritesOnThisScanline = 0;\n        this._spriteCopyHasHappened = false;\n        this.spriteZeroHit = false;\n        this.isForegroundPixel = false;\n        this.spriteChanges = false;\n        this.ppuReadBuffer = 0;\n        this._clipSprites = false;\n        this._clipTiles = false;\n        this._tilesAreVisible = false;\n        this._spritesAreVisible = false;\n        this.nameTableMemoryStart = 0;\n        this.backgroundPatternTableIndex = 0;\n        //PPU implementation\n        this._PPUAddress = 0;\n        this._PPUStatus = 0;\n        this._PPUControlByte0 = 0;\n        this._PPUControlByte1 = 0;\n        this._spriteAddress = 0;\n        this.currentXPosition = 0;\n        this.currentYPosition = 0;\n        this._hScroll = 0;\n        this._vScroll = 0;\n        this.lockedHScroll = 0;\n        this.lockedVScroll = 0;\n        //private scanlineNum = 0;\n        //private scanlinePos = 0;\n        this.shouldRender = false;\n        //private NMIHasBeenThrownThisFrame = false;\n        this._frames = 0;\n        this.hitSprite = false;\n        this.PPUAddressLatchIsHigh = true;\n        this.p32 = new Uint32Array(256); // System.Array.init(256, 0, System.Int32);\n        this.isRendering = true;\n        this.frameClock = 0;\n        this.FrameEnded = false;\n        this.frameOn = false;\n        //private framePalette = System.Array.init(256, 0, System.Int32);\n        this.nameTableBits = 0;\n        this.vidRamIsRam = true;\n        this._palette = new Uint8Array(32); // System.Array.init(32, 0, System.Int32);\n        this._openBus = 0;\n        this.sprite0scanline = 0;\n        this.sprite0x = 0;\n        this._maxSpritesPerScanline = 64;\n        this.xNTXor = 0;\n        this.yNTXor = 0;\n        this.spriteRAMBuffer = new SharedArrayBuffer(256 * Uint8Array.BYTES_PER_ELEMENT);\n        this.spriteRAM = new Uint8Array(this.spriteRAMBuffer); // System.Array.init(256, 0, System.Int32);\n        this.spritesOnLine = new Array(512); // System.Array.init(512, 0, System.Int32);\n        this.currentTileIndex = 0;\n        this.fetchTile = true;\n        // tile bytes currently latched in ppu\n        this.patternEntry = 0;\n        this.patternEntryByte2 = 0;\n        //\n        this.outBuffer = new Uint8Array(65536);\n        // 'internal\n        this.byteOutBuffer = new Uint8Array(256 * 256 * 4); // System.Array.init(262144, 0, System.Int32);\n    }\n    Object.defineProperty(ChiChiPPU.prototype, \"ChrRomHandler\", {\n        get: function () {\n            return this.chrRomHandler;\n        },\n        set: function (value) {\n            this.chrRomHandler = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ChiChiPPU.prototype, \"NextEventAt\", {\n        get: function () {\n            if (this.frameClock < 6820) {\n                return (6820 - this.frameClock) / 3;\n            }\n            else {\n                return (((89345 - this.frameClock) / 341) / 3);\n            }\n            //}\n            //else\n            //{\n            //    return (6823 - frameClock) / 3;\n            //}\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ChiChiPPU.prototype.GetPPUStatus = function () {\n        return {\n            status: this._PPUStatus,\n            controlByte0: this._PPUControlByte0,\n            controlByte1: this._PPUControlByte1,\n            nameTableStart: this.nameTableMemoryStart,\n            currentTile: this.currentTileIndex,\n            lockedVScroll: this.lockedVScroll,\n            lockedHScroll: this.lockedHScroll,\n            X: this.currentXPosition,\n            Y: this.currentYPosition\n        };\n    };\n    Object.defineProperty(ChiChiPPU.prototype, \"PPU_FrameFinishHandler\", {\n        get: function () {\n            return this.frameFinished;\n        },\n        set: function (value) {\n            this.frameFinished = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ChiChiPPU.prototype, \"PPU_NameTableMemoryStart\", {\n        get: function () {\n            return this.nameTableMemoryStart;\n        },\n        set: function (value) {\n            this.nameTableMemoryStart = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ChiChiPPU.prototype, \"PatternTableIndex\", {\n        get: function () {\n            return this.backgroundPatternTableIndex;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ChiChiPPU.prototype, \"SpritePatternTableIndex\", {\n        get: function () {\n            var spritePatternTable = 0;\n            if ((this._PPUControlByte0 & 32) === 32) {\n                spritePatternTable = 4096;\n            }\n            return spritePatternTable;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ChiChiPPU.prototype.Initialize = function () {\n        this._PPUAddress = 0;\n        this._PPUStatus = 0;\n        this._PPUControlByte0 = 0;\n        this._PPUControlByte1 = 0;\n        this._hScroll = 0;\n        this._vScroll = 0;\n        //this.scanlineNum = 0;\n        //this.scanlinePos = 0;\n        this._spriteAddress = 0;\n    };\n    ChiChiPPU.prototype.WriteState = function (writer) {\n        throw new Error('Method not implemented.');\n    };\n    ChiChiPPU.prototype.ReadState = function (state) {\n        throw new Error('Method not implemented.');\n    };\n    Object.defineProperty(ChiChiPPU.prototype, \"NMIIsThrown\", {\n        get: function () {\n            return (this._PPUControlByte0 & 128) === 128;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ChiChiPPU.prototype.SetupVINT = function () {\n        this._PPUStatus = this._PPUStatus | 128;\n        //this.NMIHasBeenThrownThisFrame = false;\n        // HandleVBlankIRQ = true;\n        this._frames = this._frames + 1;\n        //isRendering = false;\n        if (this.NMIIsThrown) {\n            this.NMIHandler();\n            //this._handleNMI = true;\n            //this.HandleVBlankIRQ = true;\n            //this.NMIHasBeenThrownThisFrame = true;\n        }\n    };\n    ChiChiPPU.prototype.VidRAM_GetNTByte = function (address) {\n        var result = 0;\n        if (address >= 8192 && address < 12288) {\n            result = this.chrRomHandler.GetPPUByte(0, address);\n        }\n        else {\n            result = this.chrRomHandler.GetPPUByte(0, address);\n        }\n        return result;\n    };\n    ChiChiPPU.prototype.UpdatePPUControlByte0 = function () {\n        if ((this._PPUControlByte0 & 16)) {\n            this.backgroundPatternTableIndex = 4096;\n        }\n        else {\n            this.backgroundPatternTableIndex = 0;\n        }\n    };\n    ChiChiPPU.prototype.SetByte = function (Clock, address, data) {\n        // DrawTo(Clock);\n        //if (_isDebugging)\n        //{\n        //    Events.Enqueue(new PPUWriteEvent { IsWrite = true, DataWritten = data, FrameClock = frameClock, RegisterAffected = address, ScanlineNum = frameClock / 341, ScanlinePos = frameClock % 341 });\n        //}\n        //Writable 2C02 registers\n        //-----------------------\n        //4 \t-\treturns object attribute memory \n        //      location indexed by port 3, then increments port 3.\n        //6\t    -\tPPU address port to access with port 7.\n        //7\t    -\tPPU memory write port.\n        switch (address & 7) {\n            case 0:\n                this.DrawTo(Clock);\n                this._PPUControlByte0 = data;\n                this._openBus = data;\n                this.nameTableBits = this._PPUControlByte0 & 3;\n                this.backgroundPatternTableIndex = ((this._PPUControlByte0 & 16) >> 4) * 0x1000;\n                // if we toggle /vbl we can throw multiple NMIs in a vblank period\n                //if ((data & 0x80) == 0x80 && NMIHasBeenThrownThisFrame)\n                //{\n                //     NMIHasBeenThrownThisFrame = false;\n                //}\n                //UpdatePixelInfo();\n                this.nameTableMemoryStart = this.nameTableBits * 0x400;\n                break;\n            case 1:\n                //1\t    0\tdisable composite colorburst (when 1). Effectively causes gfx to go black & white.\n                //      1\tleft side screen column (8 pixels wide) playfield clipping (when 0).\n                //      2\tleft side screen column (8 pixels wide) object clipping (when 0).\n                //      3\tenable playfield display (on 1).\n                //      4\tenable objects display (on 1).\n                //      5\tR (to be documented)\n                //      6\tG (to be documented)\n                //      7\tB (to be documented)\n                this.DrawTo(Clock);\n                this.isRendering = (data & 0x18) !== 0;\n                this._PPUControlByte1 = data;\n                this._spritesAreVisible = (this._PPUControlByte1 & 0x10) === 0x10;\n                this._tilesAreVisible = (this._PPUControlByte1 & 0x08) === 0x08;\n                this._clipTiles = (this._PPUControlByte1 & 0x02) !== 0x02;\n                this._clipSprites = (this._PPUControlByte1 & 0x04) !== 0x04;\n                //UpdatePixelInfo();\n                this.nameTableMemoryStart = this.nameTableBits * 0x400;\n                break;\n            case 2:\n                this.ppuReadBuffer = data;\n                this._openBus = data;\n                break;\n            case 3:\n                //3\t    -\tinternal object attribute memory index pointer \n                //          (64 attributes, 32 bits each, byte granular access). \n                //          stored value post-increments on access to port 4.\n                this._spriteAddress = data & 0xFF;\n                this._openBus = this._spriteAddress;\n                break;\n            case 4:\n                this.spriteRAM[this._spriteAddress] = data;\n                // UnpackSprite(_spriteAddress / 4);\n                this._spriteAddress = (this._spriteAddress + 1) & 255;\n                this.unpackedSprites[this._spriteAddress >> 2].Changed = true;\n                this.spriteChanges = true;\n                break;\n            case 5:\n                //5\t    -\tscroll offset port.\n                // on 1st read (high), bits 0,1,2 go to fine horizonal scroll, rest to select tile\n                // on 2nd read, bits 0,1,2 go to fine vertical scroll, rest to select tile\n                // during render, writes to FH are applied immediately\n                if (this.PPUAddressLatchIsHigh) {\n                    //if (isRendering)\n                    //{\n                    //    fineHorizontalScroll = data & 0x7;\n                    //    horizontalTileIndex = data >> 3;\n                    //}  \n                    this.DrawTo(Clock);\n                    this._hScroll = data;\n                    this.lockedHScroll = this._hScroll & 7;\n                    this.UpdatePixelInfo();\n                    this.PPUAddressLatchIsHigh = false;\n                }\n                else {\n                    // during rendering, a write here will not post to the rendering counter\n                    this.DrawTo(Clock);\n                    this._vScroll = data;\n                    if (data > 240) {\n                        this._vScroll = data - 256;\n                    }\n                    if (!this.frameOn || (this.frameOn && !this.isRendering)) {\n                        this.lockedVScroll = this._vScroll;\n                    }\n                    this.PPUAddressLatchIsHigh = true;\n                    this.UpdatePixelInfo();\n                }\n                break;\n            case 6:\n                //Since the PPU's external address bus is only 14 bits in width, \n                //the top two bits of the value written are ignored. \n                if (this.PPUAddressLatchIsHigh) {\n                    //            //a) Write upper address byte into $2006\n                    this._PPUAddress = (this._PPUAddress & 0xFF) | ((data & 0x3F) << 8);\n                    this.PPUAddressLatchIsHigh = false;\n                }\n                else {\n                    //            //b) Write lower address byte into $2006\n                    this._PPUAddress = (this._PPUAddress & 0x7F00) | data & 0xFF;\n                    this.PPUAddressLatchIsHigh = true;\n                    // writes here during rendering directly affect the scroll counter\n                    // from Marat Fazulamans doc\n                    //Address Written into $2006\n                    //xxYYSSYYYYYXXXXX\n                    //   | |  |     |\n                    //   | |  |     +---- Horizontal scroll in tiles (i.e. 1 = 8 pixels)\n                    //   | |  +--------- Vertical scroll in tiles (i.e. 1 = 8 pixels)\n                    //   | +------------ Number of Name Table ($2000,$2400,$2800,$2C00)\n                    //   +-------------- Additional vertical scroll in pixels (0..3)\n                    // on second write during frame, loopy t (_hscroll, _vscroll) is copied to loopy_v (lockedHscroll, lockedVScroll)\n                    this.DrawTo(Clock);\n                    this._hScroll = ((this._PPUAddress & 0x1F) << 3); // +(currentXPosition & 7);\n                    this._vScroll = (((this._PPUAddress >> 5) & 0x1F) << 3);\n                    this._vScroll |= ((this._PPUAddress >> 12) & 3);\n                    this.nameTableBits = ((this._PPUAddress >> 10) & 3);\n                    if (this.frameOn) {\n                        this.lockedHScroll = this._hScroll;\n                        this.lockedVScroll = this._vScroll;\n                        this.lockedVScroll = this.lockedVScroll - this.currentYPosition;\n                    }\n                    this.UpdatePixelInfo();\n                    // relock vscroll during render when this happens\n                }\n                break;\n            case 7:\n                //            //Writing to PPU memory:\n                //            //c) Write data into $2007. After each write, the\n                //            //   address will increment either by 1 (bit 2 of\n                //            //   $2000 is 0) or by 32 (bit 2 of $2000 is 1).\n                // ppuLatch = data;\n                if ((this._PPUAddress & 0xFF00) === 0x3F00) {\n                    this.DrawTo(Clock);\n                    //WriteToNESPalette(_PPUAddress, (byte)data);\n                    var palAddress = (this._PPUAddress) & 0x1F;\n                    this._palette[palAddress] = data;\n                    // rgb32OutBuffer[255 * 256 + palAddress] = data;\n                    if ((this._PPUAddress & 0xFFEF) === 0x3F00) {\n                        this._palette[(palAddress ^ 16) & 0x1F] = data;\n                    }\n                    // these palettes are all mirrored every 0x10 bytes\n                    this.UpdatePixelInfo();\n                }\n                else {\n                    // if its a nametable byte, mask it according to current mirroring\n                    if ((this._PPUAddress & 0xF000) === 0x2000) {\n                        this.chrRomHandler.SetPPUByte(Clock, this._PPUAddress, data);\n                    }\n                    else {\n                        if (this.vidRamIsRam) {\n                            this.chrRomHandler.SetPPUByte(Clock, this._PPUAddress, data);\n                        }\n                    }\n                }\n                // if controlbyte0.4, set ppuaddress + 32, else inc\n                if ((this._PPUControlByte0 & 4) === 4) {\n                    this._PPUAddress = (this._PPUAddress + 32);\n                }\n                else {\n                    this._PPUAddress = (this._PPUAddress + 1);\n                }\n                // reset the flag which makex xxx6 set the high byte of address\n                this.PPUAddressLatchIsHigh = true;\n                this._PPUAddress = (this._PPUAddress & 0x3FFF);\n                break;\n        }\n    };\n    ChiChiPPU.prototype.GetByte = function (Clock, address) {\n        //if (_isDebugging)\n        //{\n        //    Events.Enqueue(new PPUWriteEvent { IsWrite = false, DataWritten = 0, FrameClock = frameClock, RegisterAffected = address, ScanlineNum = frameClock / 341, ScanlinePos = frameClock % 341 });\n        //}\n        switch (address & 7) {\n            case 3:\n            case 0:\n            case 1:\n            case 5:\n            case 6:\n                return this._openBus;\n            case 2:\n                var ret = 0;\n                this.PPUAddressLatchIsHigh = true;\n                // bit 7 is set to 0 after a read occurs\n                // return lower 5 latched bits, and the status\n                ret = (this.ppuReadBuffer & 0x1F) | this._PPUStatus;\n                this.DrawTo(Clock);\n                if ((ret & 0x80) === 0x80) {\n                    this._PPUStatus = this._PPUStatus & ~0x80;\n                }\n                this.UpdatePixelInfo();\n                //}\n                //this._openBus = ret;\n                return ret;\n            case 4:\n                var tmp = this.spriteRAM[this._spriteAddress];\n                //ppuLatch = spriteRAM[SpriteAddress];\n                // should not increment on read ?\n                //SpriteAddress = (SpriteAddress + 1) & 0xFF;\n                //this._openBus = tmp;\n                return tmp;\n            case 7:\n                // palette reads shouldn't be buffered like regular vram reads, they re internal\n                if ((this._PPUAddress & 0xFF00) === 0x3F00) {\n                    // these palettes are all mirrored every 0x10 bytes\n                    tmp = this._palette[this._PPUAddress & 0x1F];\n                    // palette read should also read vram into read buffer\n                    // info i found on the nesdev forums\n                    // When you read PPU $3F00-$3FFF, you get immediate data from Palette RAM \n                    // (without the 1-read delay usually present when reading from VRAM) and the PPU \n                    // will also fetch nametable data from the corresponding address (which is mirrored from PPU $2F00-$2FFF). \n                    // note: writes do not work this way \n                    this.ppuReadBuffer = this.chrRomHandler.GetPPUByte(Clock, this._PPUAddress - 4096);\n                }\n                else {\n                    tmp = this.ppuReadBuffer;\n                    if (this._PPUAddress >= 0x2000 && this._PPUAddress <= 0x2FFF) {\n                        this.ppuReadBuffer = this.chrRomHandler.GetPPUByte(Clock, this._PPUAddress);\n                    }\n                    else {\n                        this.ppuReadBuffer = this.chrRomHandler.GetPPUByte(Clock, this._PPUAddress & 0x3FFF);\n                    }\n                }\n                if ((this._PPUControlByte0 & 4) === 4) {\n                    this._PPUAddress = this._PPUAddress + 32;\n                }\n                else {\n                    this._PPUAddress = this._PPUAddress + 1;\n                }\n                this._PPUAddress = (this._PPUAddress & 0x3FFF);\n                return tmp;\n        }\n        return 0;\n    };\n    ChiChiPPU.prototype.HandleEvent = function (Clock) {\n        this.DrawTo(Clock);\n    };\n    ChiChiPPU.prototype.ResetClock = function (Clock) {\n        this.LastcpuClock = Clock;\n    };\n    ChiChiPPU.prototype.CopySprites = function (copyFrom) {\n        // should copy 0x100 items from source to spriteRAM, \n        // starting at SpriteAddress, and wrapping around\n        // should set spriteDMA flag\n        for (var i = 0; i < 256; ++i) {\n            var spriteLocation = (this._spriteAddress + i) & 255;\n            if (this.spriteRAM[spriteLocation] !== this.cpu.Rams[copyFrom + i]) {\n                this.spriteRAM[spriteLocation] = this.cpu.Rams[copyFrom + i];\n                this.unpackedSprites[(spriteLocation >> 2) & 255].Changed = true;\n            }\n        }\n        this._spriteCopyHasHappened = true;\n        this.spriteChanges = true;\n    };\n    ChiChiPPU.prototype.InitSprites = function () {\n        this.currentSprites = new Array(this._maxSpritesPerScanline); //ChiChiSprite;\n        for (var i = 0; i < this._maxSpritesPerScanline; ++i) {\n            this.currentSprites[i] = new ChiChiTypes_1.ChiChiSprite();\n        }\n        this.unpackedSprites = new Array(64);\n        for (var i = 0; i < 64; ++i) {\n            this.unpackedSprites[i] = new ChiChiTypes_1.ChiChiSprite();\n        }\n    };\n    ChiChiPPU.prototype.GetSpritePixel = function () {\n        this.isForegroundPixel = false;\n        this.spriteZeroHit = false;\n        var result = 0;\n        var yLine = 0;\n        var xPos = 0;\n        var tileIndex = 0;\n        for (var i = 0; i < this.spritesOnThisScanline; ++i) {\n            var currSprite = this.currentSprites[i];\n            if (currSprite.XPosition > 0 && this.currentXPosition >= currSprite.XPosition && this.currentXPosition < currSprite.XPosition + 8) {\n                var spritePatternTable = 0;\n                if ((this._PPUControlByte0 & 8) === 8) {\n                    spritePatternTable = 4096;\n                }\n                xPos = this.currentXPosition - currSprite.XPosition;\n                yLine = this.currentYPosition - currSprite.YPosition - 1;\n                yLine = yLine & (this.spriteSize - 1);\n                tileIndex = currSprite.TileIndex;\n                if ((this._PPUControlByte0 & 32) === 32) {\n                    if ((tileIndex & 1) === 1) {\n                        spritePatternTable = 4096;\n                        tileIndex = tileIndex ^ 1;\n                    }\n                    else {\n                        spritePatternTable = 0;\n                    }\n                }\n                //result = WhissaSpritePixel(spritePatternTable, xPos, yLine, ref currSprite, tileIndex);\n                // 8x8 tile\n                var patternEntry;\n                var patternEntryBit2;\n                if (currSprite.FlipY) {\n                    yLine = this.spriteSize - yLine - 1;\n                }\n                if (yLine >= 8) {\n                    yLine += 8;\n                }\n                patternEntry = this.chrRomHandler.GetPPUByte(0, spritePatternTable + tileIndex * 16 + yLine);\n                patternEntryBit2 = this.chrRomHandler.GetPPUByte(0, spritePatternTable + tileIndex * 16 + yLine + 8);\n                result = (currSprite.FlipX ? ((patternEntry >> xPos) & 1) | (((patternEntryBit2 >> xPos) << 1) & 2) : ((patternEntry >> 7 - xPos) & 1) | (((patternEntryBit2 >> 7 - xPos) << 1) & 2)) & 255;\n                if (result !== 0) {\n                    if (currSprite.SpriteNumber === 0) {\n                        this.spriteZeroHit = true;\n                    }\n                    this.isForegroundPixel = currSprite.Foreground;\n                    return (result | currSprite.AttributeByte);\n                }\n            }\n        }\n        return 0;\n    };\n    ChiChiPPU.prototype.WhissaSpritePixel = function (patternTableIndex, x, y, sprite, tileIndex) {\n        // 8x8 tile\n        var patternEntry = 0;\n        var patternEntryBit2 = 0;\n        if (sprite.v.FlipY) {\n            y = this.spriteSize - y - 1;\n        }\n        if (y >= 8) {\n            y += 8;\n        }\n        patternEntry = this.chrRomHandler.GetPPUByte(0, patternTableIndex + tileIndex * 16 + y);\n        patternEntryBit2 = this.chrRomHandler.GetPPUByte(0, patternTableIndex + tileIndex * 16 + y + 8);\n        return (sprite.v.FlipX ? ((patternEntry >> x) & 1) | (((patternEntryBit2 >> x) << 1) & 2) : ((patternEntry >> 7 - x) & 1) | (((patternEntryBit2 >> 7 - x) << 1) & 2));\n    };\n    ChiChiPPU.prototype.PreloadSprites = function (scanline) {\n        this.spritesOnThisScanline = 0;\n        this.sprite0scanline = -1;\n        var yLine = this.currentYPosition - 1;\n        this.outBuffer[(64768) + yLine] = 0;\n        this.outBuffer[(65024) + yLine] = 0;\n        //spritesOnLine[2 * yLine] = 0;\n        //spritesOnLine[2 * yLine + 1] = 0;\n        for (var spriteNum = 0; spriteNum < 256; spriteNum += 4) {\n            var spriteID = ((spriteNum + this._spriteAddress) & 255) >> 2;\n            var y = this.unpackedSprites[spriteID].YPosition + 1;\n            if (scanline >= y && scanline < y + this.spriteSize) {\n                if (spriteID === 0) {\n                    this.sprite0scanline = scanline;\n                    this.sprite0x = this.unpackedSprites[spriteID].XPosition;\n                }\n                var spId = spriteNum >> 2;\n                if (spId < 32) {\n                    this.outBuffer[(64768) + yLine] |= 1 << spId;\n                }\n                else {\n                    this.outBuffer[(65024) + yLine] |= 1 << (spId - 32);\n                }\n                this.currentSprites[this.spritesOnThisScanline] = this.unpackedSprites[spriteID];\n                this.currentSprites[this.spritesOnThisScanline].IsVisible = true;\n                this.spritesOnThisScanline++;\n                if (this.spritesOnThisScanline === this._maxSpritesPerScanline) {\n                    break;\n                }\n            }\n        }\n        if (this.spritesOnThisScanline > 7) {\n            this._PPUStatus = this._PPUStatus | 32;\n        }\n    };\n    ChiChiPPU.prototype.UnpackSprites = function () {\n        //Buffer.BlockCopy\n        //var outBufferloc = 65280;\n        //for (var i = 0; i < 256; i += 4) {\n        //    this.outBuffer[outBufferloc] = (this.spriteRAM[i] << 24) | (this.spriteRAM[i + 1] << 16) | (this.spriteRAM[i + 2] << 8) | (this.spriteRAM[i + 3] << 0);\n        //    outBufferloc++;\n        //}\n        // Array.Copy(spriteRAM, 0, outBuffer, 255 * 256 * 4, 256);\n        for (var currSprite = 0; currSprite < this.unpackedSprites.length; ++currSprite) {\n            if (this.unpackedSprites[currSprite].Changed) {\n                this.UnpackSprite(currSprite);\n            }\n        }\n    };\n    ChiChiPPU.prototype.UnpackSprite = function (currSprite) {\n        var attrByte = this.spriteRAM[(currSprite << 2) + 2 | 0];\n        this.unpackedSprites[currSprite].IsVisible = true;\n        this.unpackedSprites[currSprite].AttributeByte = ((attrByte & 3) << 2) | 16;\n        this.unpackedSprites[currSprite].YPosition = this.spriteRAM[currSprite * 4];\n        this.unpackedSprites[currSprite].XPosition = this.spriteRAM[currSprite * 4 + 3];\n        this.unpackedSprites[currSprite].SpriteNumber = currSprite;\n        this.unpackedSprites[currSprite].Foreground = (attrByte & 32) !== 32;\n        this.unpackedSprites[currSprite].FlipX = (attrByte & 64) === 64;\n        this.unpackedSprites[currSprite].FlipY = (attrByte & 128) === 128;\n        this.unpackedSprites[currSprite].TileIndex = this.spriteRAM[currSprite * 4 + 1];\n        this.unpackedSprites[currSprite].Changed = false;\n    };\n    ChiChiPPU.prototype.GetNameTablePixel = function () {\n        var result = ((this.patternEntry & 128) >> 7) | ((this.patternEntryByte2 & 128) >> 6);\n        this.patternEntry <<= 1;\n        this.patternEntryByte2 <<= 1;\n        if (result > 0) {\n            result |= this.currentAttributeByte;\n        }\n        return result & 255;\n    };\n    ChiChiPPU.prototype.FetchNextTile = function () {\n        var ppuNameTableMemoryStart = this.nameTableMemoryStart ^ this.xNTXor ^ this.yNTXor;\n        var xTilePosition = this.xPosition >> 3;\n        var tileRow = (this.yPosition >> 3) % 30 << 5;\n        var tileNametablePosition = 8192 + ppuNameTableMemoryStart + xTilePosition + tileRow;\n        var TileIndex = this.chrRomHandler.GetPPUByte(0, tileNametablePosition);\n        var patternTableYOffset = this.yPosition & 7;\n        var patternID = this.backgroundPatternTableIndex + (TileIndex * 16) + patternTableYOffset;\n        this.patternEntry = this.chrRomHandler.GetPPUByte(0, patternID);\n        this.patternEntryByte2 = this.chrRomHandler.GetPPUByte(0, patternID + 8);\n        this.currentAttributeByte = this.GetAttributeTableEntry(ppuNameTableMemoryStart, xTilePosition, this.yPosition >> 3);\n    };\n    ChiChiPPU.prototype.GetAttributeTableEntry = function (ppuNameTableMemoryStart, i, j) {\n        var LookUp = this.chrRomHandler.GetPPUByte(0, 8192 + ppuNameTableMemoryStart + 960 + (i >> 2) + ((j >> 2) * 8));\n        switch ((i & 2) | (j & 2) * 2) {\n            case 0:\n                return (LookUp << 2) & 12;\n            case 2:\n                return LookUp & 12;\n            case 4:\n                return (LookUp >> 2) & 12;\n            case 6:\n                return (LookUp >> 4) & 12;\n        }\n        return 0;\n    };\n    ChiChiPPU.prototype.DrawTo = function (cpuClockNum) {\n        var frClock = (cpuClockNum - this.LastcpuClock) * 3;\n        if (this.frameClock < 6820) {\n            // if the frameclock +frClock is in vblank (< 6820) dont do nothing, just update it\n            if (this.frameClock + frClock < 6820) {\n                this.frameClock += frClock;\n                frClock = 0;\n            }\n            else {\n                //find number of pixels to draw since frame start\n                frClock += this.frameClock - 6820;\n                this.frameClock = 6820;\n            }\n        }\n        for (var i = 0; i < frClock; ++i) {\n            switch (this.frameClock++) {\n                case 0:\n                    break;\n                case 6820:\n                    this._PPUStatus = 0;\n                    this.hitSprite = false;\n                    this.spriteSize = ((this._PPUControlByte0 & 0x20) === 0x20) ? 16 : 8;\n                    if ((this._PPUControlByte1 & 0x18) !== 0) {\n                        this.isRendering = true;\n                    }\n                    this.frameOn = true;\n                    this.chrRomHandler.ResetBankStartCache();\n                    // setFrameOn();\n                    if (this.spriteChanges) {\n                        this.UnpackSprites();\n                        this.spriteChanges = false;\n                    }\n                    break;\n                case 7161:\n                    //lockedVScroll = _vScroll;\n                    this.vbufLocation = 0;\n                    //curBufPos = bufStart;\n                    this.xNTXor = 0;\n                    this.yNTXor = 0;\n                    this.currentXPosition = 0;\n                    this.currentYPosition = 0;\n                    break;\n                case 89342://ChiChiNES.CPU2A03.frameClockEnd:\n                    this.shouldRender = true;\n                    //__frameFinished = true;\n                    this.frameFinished();\n                    this.SetupVINT();\n                    this.frameOn = false;\n                    this.frameClock = 0;\n                    //if (_isDebugging)\n                    //    events.Clear();\n                    break;\n            }\n            if (this.frameClock >= 7161 && this.frameClock <= 89342) {\n                if (this.currentXPosition < 256 && this.vbufLocation < 61440) {\n                    /* update x position */\n                    this.xPosition = this.currentXPosition + this.lockedHScroll;\n                    if ((this.xPosition & 7) === 0) {\n                        this.xNTXor = (this.xPosition & 0x100) ? 0x400 : 0;\n                        this.xPosition &= 0xFF;\n                        /* fetch next tile */\n                        var ppuNameTableMemoryStart = this.nameTableMemoryStart ^ this.xNTXor ^ this.yNTXor;\n                        var xTilePosition = this.xPosition >> 3;\n                        var tileRow = (this.yPosition >> 3) % 30 << 5;\n                        var tileNametablePosition = 0x2000 + ppuNameTableMemoryStart + xTilePosition + tileRow;\n                        var TileIndex = this.chrRomHandler.GetPPUByte(0, tileNametablePosition);\n                        var patternTableYOffset = this.yPosition & 7;\n                        var patternID = this.backgroundPatternTableIndex + (TileIndex * 16) + patternTableYOffset;\n                        this.patternEntry = this.chrRomHandler.GetPPUByte(0, patternID);\n                        this.patternEntryByte2 = this.chrRomHandler.GetPPUByte(0, patternID + 8);\n                        this.currentAttributeByte = this.GetAttributeTableEntry(ppuNameTableMemoryStart, xTilePosition, this.yPosition >> 3);\n                        /* end fetch next tile */\n                    }\n                    /* draw pixel */\n                    var tilePixel = this._tilesAreVisible ? this.GetNameTablePixel() : 0;\n                    // bool foregroundPixel = isForegroundPixel;\n                    var spritePixel = this._spritesAreVisible ? this.GetSpritePixel() : 0;\n                    if (!this.hitSprite && this.spriteZeroHit && tilePixel !== 0) {\n                        this.hitSprite = true;\n                        this._PPUStatus = this._PPUStatus | 64;\n                    }\n                    //var x = pal[_palette[(foregroundPixel || (tilePixel == 0 && spritePixel != 0)) ? spritePixel : tilePixel]];\n                    //var x = \n                    this.byteOutBuffer[this.vbufLocation * 4] = this._palette[(this.isForegroundPixel || (tilePixel === 0 && spritePixel !== 0)) ? spritePixel : tilePixel];\n                    //byteOutBuffer[(vbufLocation * 4) + 1] = x;// (byte)(x >> 8);\n                    //byteOutBuffer[(vbufLocation * 4) + 2] = x;//  (byte)(x >> 16);\n                    //byteOutBuffer[(vbufLocation * 4) + 3] = 0xFF;// (byte)(x);// (byte)rgb32OutBuffer[vbufLocation];\n                    this.vbufLocation++;\n                }\n                if (this.currentXPosition === 324) {\n                    this.chrRomHandler.UpdateScanlineCounter();\n                }\n                this.currentXPosition++;\n                if (this.currentXPosition > 340) {\n                    this.currentXPosition = 0;\n                    this.currentYPosition++;\n                    this.PreloadSprites(this.currentYPosition);\n                    if (this.spritesOnThisScanline >= 7) {\n                        this._PPUStatus = this._PPUStatus | 32;\n                    }\n                    this.lockedHScroll = this._hScroll;\n                    this.UpdatePixelInfo();\n                    //RunNewScanlineEvents \n                    this.yPosition = this.currentYPosition + this.lockedVScroll;\n                    if (this.yPosition < 0) {\n                        this.yPosition += 240;\n                    }\n                    if (this.yPosition >= 240) {\n                        this.yPosition -= 240;\n                        this.yNTXor = 2048;\n                    }\n                    else {\n                        this.yNTXor = 0;\n                    }\n                }\n            }\n        }\n        this.LastcpuClock = cpuClockNum;\n    };\n    ChiChiPPU.prototype.UpdatePixelInfo = function () {\n        this.nameTableMemoryStart = this.nameTableBits * 0x400;\n    };\n    ChiChiPPU.pal = new Uint32Array([7961465, 10626572, 11407400, 10554206, 7733552, 2753820, 725017, 271983, 278855, 284436, 744967, 3035906, 7161605, 0, 131586, 131586, 12566719, 14641430, 15614283, 14821245, 12196292, 6496468, 2176980, 875189, 293472, 465210, 1597716, 5906953, 11090185, 2961197, 197379, 197379, 16316149, 16298569, 16588080, 16415170, 15560682, 12219892, 7115511, 4563694, 2277591, 2151458, 4513360, 1957181, 14604331, 6579811, 263172, 263172, 16447992, 16441012, 16634316, 16500447, 16236786, 14926838, 12831991, 11393781, 2287340, 5500370, 11858360, 14283440, 15921318, 13158344, 328965, 328965, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\n    return ChiChiPPU;\n}());\nexports.ChiChiPPU = ChiChiPPU;\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ChiChiCarts_1 = __webpack_require__(3);\nvar ChiChiAudio_1 = __webpack_require__(4);\nvar ChiChiTypes_1 = __webpack_require__(0);\nvar ChiChiControl_1 = __webpack_require__(5);\nvar ChiChiPPU_1 = __webpack_require__(1);\n//machine wrapper\nvar ChiChiMachine = /** @class */ (function () {\n    function ChiChiMachine(cpu) {\n        var _this = this;\n        this.frameJustEnded = true;\n        this.frameOn = false;\n        this.totalCPUClocks = 0;\n        this._enableSound = false;\n        var wavSharer = new ChiChiAudio_1.WavSharer();\n        this.SoundBopper = new ChiChiAudio_1.ChiChiBopper(wavSharer);\n        this.WaveForms = wavSharer;\n        this.ppu = new ChiChiPPU_1.ChiChiPPU();\n        this.Cpu = cpu ? cpu : new ChiChiCPPU(this.SoundBopper, this.ppu);\n        this.ppu.cpu = this.Cpu;\n        this.ppu.NMIHandler = function () {\n            _this.Cpu.NMIHandler();\n        };\n        this.ppu.frameFinished = function () { _this.FrameFinished(); };\n    }\n    ChiChiMachine.prototype.Drawscreen = function () {\n    };\n    Object.defineProperty(ChiChiMachine.prototype, \"Cart\", {\n        get: function () {\n            return this.Cpu.Cart;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ChiChiMachine.prototype, \"EnableSound\", {\n        get: function () {\n            return this._enableSound;\n        },\n        set: function (value) {\n            this.SoundBopper.Muted = !value;\n            this._enableSound = value;\n            if (this._enableSound) {\n                this.SoundBopper.RebuildSound();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ChiChiMachine.prototype, \"PadOne\", {\n        get: function () {\n            return this.Cpu.PadOne.ControlPad;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ChiChiMachine.prototype, \"PadTwo\", {\n        get: function () {\n            return this.Cpu.PadTwo.ControlPad;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ChiChiMachine.prototype.Reset = function () {\n        if (this.Cpu != null && this.Cart != null) {\n            // ForceStop();\n            this.SoundBopper.RebuildSound();\n            this.ppu.Initialize();\n            this.Cart.InitializeCart();\n            this.Cpu.ResetCPU();\n            //ClearGenieCodes();\n            this.Cpu.PowerOn();\n            this.RunState = ChiChiTypes_1.RunningStatuses.Running;\n        }\n    };\n    ChiChiMachine.prototype.PowerOn = function () {\n        if (this.Cpu != null && this.Cart != null) {\n            this.Cpu.ppu.Initialize();\n            this.Cart.InitializeCart();\n            // if (this.SRAMReader !=  null && this.Cart.UsesSRAM) {\n            //     this.Cart.SRAM = this.SRAMReader(this.Cart.ChiChiNES$INESCart$CheckSum);\n            // }\n            this.Cpu.ResetCPU();\n            //ClearGenieCodes();\n            this.Cpu.PowerOn();\n            this.SoundBopper.RebuildSound();\n            this.RunState = ChiChiTypes_1.RunningStatuses.Running;\n        }\n    };\n    ChiChiMachine.prototype.PowerOff = function () {\n        this.RunState = ChiChiTypes_1.RunningStatuses.Off;\n    };\n    ChiChiMachine.prototype.Step = function () {\n        if (this.frameJustEnded) {\n            this.Cpu.FindNextEvent();\n            this.frameOn = true;\n            this.frameJustEnded = false;\n        }\n        this.Cpu.Step();\n        if (!this.frameOn) {\n            this.totalCPUClocks = this.Cpu.Clock;\n            this.totalCPUClocks = 0;\n            this.Cpu.Clock = 0;\n            this.ppu.LastcpuClock = 0;\n            this.frameJustEnded = true;\n        }\n        //_cpu.Clock = _totalCPUClocks;\n        //breakpoints: HandleBreaks();        \n    };\n    ChiChiMachine.prototype.RunFrame = function () {\n        this.frameOn = true;\n        this.frameJustEnded = false;\n        //_cpu.RunFrame();\n        this.Cpu.FindNextEvent();\n        do {\n            this.Cpu.Step();\n        } while (this.frameOn);\n        this.totalCPUClocks = this.Cpu.Clock;\n        this.SoundBopper.FlushFrame(this.totalCPUClocks);\n        this.SoundBopper.EndFrame(this.totalCPUClocks);\n        //this.SoundBopper.writer.ReadWaves();\n        this.totalCPUClocks = 0;\n        this.Cpu.Clock = 0;\n        this.ppu.LastcpuClock = 0;\n    };\n    ChiChiMachine.prototype.EjectCart = function () {\n        this.Cpu.Cart = null;\n        this.ppu.ChrRomHandler = null;\n    };\n    ChiChiMachine.prototype.LoadNSF = function (rom) {\n    };\n    ChiChiMachine.prototype.LoadCart = function (rom) {\n        var _this = this;\n        this.EjectCart();\n        var cart = ChiChiCarts_1.iNESFileHandler.LoadROM(this.Cpu, rom);\n        if (cart != null) {\n            this.Cpu.Cart = cart; // Bridge.cast(this.Cart, ChiChiNES.IClockedMemoryMappedIOElement);\n            this.Cart.NMIHandler = function () { _this.Cpu.InterruptRequest(); };\n            this.ppu.ChrRomHandler = this.Cart;\n        }\n        else {\n            throw new Error(\"Unsupported ROM type - load failed.\");\n        }\n    };\n    ChiChiMachine.prototype.HasState = function (index) {\n        throw new Error(\"Method not implemented.\");\n    };\n    ChiChiMachine.prototype.GetState = function (index) {\n        throw new Error(\"Method not implemented.\");\n    };\n    ChiChiMachine.prototype.SetState = function (index) {\n        throw new Error(\"Method not implemented.\");\n    };\n    ChiChiMachine.prototype.SetupSound = function () {\n        throw new Error(\"Method not implemented.\");\n    };\n    ChiChiMachine.prototype.FrameFinished = function () {\n        this.frameJustEnded = true;\n        this.frameOn = false;\n        this.Drawscreen();\n    };\n    ChiChiMachine.prototype.dispose = function () {\n    };\n    return ChiChiMachine;\n}());\nexports.ChiChiMachine = ChiChiMachine;\n//chichipig\nvar ChiChiCPPU = /** @class */ (function () {\n    function ChiChiCPPU(bopper, ppu) {\n        this.SRMasks_CarryMask = 0x01;\n        this.SRMasks_ZeroResultMask = 0x02;\n        this.SRMasks_InterruptDisableMask = 0x04;\n        this.SRMasks_DecimalModeMask = 0x08;\n        this.SRMasks_BreakCommandMask = 0x10;\n        this.SRMasks_ExpansionMask = 0x20;\n        this.SRMasks_OverflowMask = 0x40;\n        this.SRMasks_NegativeResultMask = 0x80;\n        this._reset = false;\n        //timing\n        this.clock = 0;\n        this._ticks = 0;\n        // CPU Status\n        this._statusRegister = 0;\n        this._programCounter = 0;\n        this._handleNMI = false;\n        this._handleIRQ = false;\n        // CPU Op info\n        this._addressBus = 0;\n        this._dataBus = 0;\n        this._operationCounter = 0;\n        this._accumulator = 0;\n        this._indexRegisterX = 0;\n        this._indexRegisterY = 0;\n        // Current Instruction\n        this._currentInstruction_AddressingMode = ChiChiTypes_1.ChiChiCPPU_AddressingModes.Bullshit;\n        this._currentInstruction_Address = 0;\n        this._currentInstruction_OpCode = 0;\n        this._currentInstruction_Parameters0 = 0;\n        this._currentInstruction_Parameters1 = 0;\n        this._currentInstruction_ExtraTiming = 0;\n        this.systemClock = 0;\n        this.nextEvent = -1;\n        //tbi\n        this._cheating = false;\n        this.__frameFinished = true;\n        // system ram\n        this._ramsBuffer = new SharedArrayBuffer(8192 * Uint8Array.BYTES_PER_ELEMENT);\n        this.Rams = new Uint8Array(this._ramsBuffer); // System.Array.init(vv, 0, System.Int32);\n        this._stackPointer = 255;\n        // debug helpers\n        this.instructionUsage = new Uint32Array(256); //System.Array.init(256, 0, System.Int32);\n        this._debugging = false;\n        this.instructionHistoryPointer = 255;\n        this._instructionHistory = new Array(256); //System.Array.init(256, null, ChiChiInstruction);\n        // ppu events\n        // ppu variables \n        this.backgroundPatternTableIndex = 0;\n        //private PPU_HandleVBlankIRQ: boolean;\n        this._PPUAddress = 0;\n        this._PPUStatus = 0;\n        this._PPUControlByte0 = 0;\n        this._PPUControlByte1 = 0;\n        this._spriteAddress = 0;\n        this.currentXPosition = 0;\n        this.currentYPosition = 0;\n        this._hScroll = 0;\n        this._vScroll = 0;\n        this.lockedHScroll = 0;\n        this.lockedVScroll = 0;\n        //private scanlineNum = 0;\n        //private scanlinePos = 0;\n        this.shouldRender = false;\n        //private NMIHasBeenThrownThisFrame = false;\n        this._frames = 0;\n        this.hitSprite = false;\n        this.PPUAddressLatchIsHigh = true;\n        this.p32 = new Uint32Array(256); // System.Array.init(256, 0, System.Int32);\n        this.isRendering = true;\n        this.frameClock = 0;\n        this.FrameEnded = false;\n        this.frameOn = false;\n        //private framePalette = System.Array.init(256, 0, System.Int32);\n        this.nameTableBits = 0;\n        this.vidRamIsRam = true;\n        this._palette = new Uint8Array(32); // System.Array.init(32, 0, System.Int32);\n        this._openBus = 0;\n        this.sprite0scanline = 0;\n        this.sprite0x = 0;\n        this._maxSpritesPerScanline = 64;\n        this.xNTXor = 0;\n        this.yNTXor = 0;\n        this.spriteRAMBuffer = new SharedArrayBuffer(256 * Uint8Array.BYTES_PER_ELEMENT);\n        this.spriteRAM = new Uint8Array(this.spriteRAMBuffer); // System.Array.init(256, 0, System.Int32);\n        this.spritesOnLine = new Array(512); // System.Array.init(512, 0, System.Int32);\n        this.currentTileIndex = 0;\n        this.fetchTile = true;\n        // tile bytes currently latched in ppu\n        this.patternEntry = 0;\n        this.patternEntryByte2 = 0;\n        //\n        this.outBuffer = new Uint8Array(65536);\n        // 'internal\n        this.byteOutBuffer = new Uint8Array(256 * 256 * 4); // System.Array.init(262144, 0, System.Int32);\n        this.debugEvents = new Array();\n        //this.$initialize();\n        // BuildOpArray();\n        this.SoundBopper = bopper;\n        bopper.NMIHandler = this.IRQUpdater;\n        // init PPU\n        this.ppu = ppu;\n        this.ppu.InitSprites();\n        this._padOne = new ChiChiControl_1.ChiChiInputHandler();\n        this._padTwo = new ChiChiControl_1.ChiChiInputHandler();\n        for (var i = 0; i < this._instructionHistory.length; ++i) {\n            this._instructionHistory[i] = new ChiChiTypes_1.ChiChiInstruction();\n        }\n        //this.vBuffer = System.Array.init(61440, 0, System.Byte);\n        //ChiChiNES.CPU2A03.GetPalRGBA();\n    }\n    Object.defineProperty(ChiChiCPPU.prototype, \"Debugging\", {\n        get: function () {\n            return this._debugging;\n        },\n        set: function (value) {\n            this._debugging = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ChiChiCPPU.prototype, \"InstructionHistory\", {\n        get: function () {\n            return this._instructionHistory;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ChiChiCPPU.prototype, \"InstructionHistoryPointer\", {\n        get: function () {\n            return this.instructionHistoryPointer;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ChiChiCPPU.prototype, \"PadOne\", {\n        get: function () {\n            return this._padOne;\n        },\n        set: function (value) {\n            this._padOne = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ChiChiCPPU.prototype, \"PadTwo\", {\n        get: function () {\n            return this._padTwo;\n        },\n        set: function (value) {\n            this._padTwo = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ChiChiCPPU.prototype.addDebugEvent = function (value) {\n        this.debugEvents.push(value);\n    };\n    ChiChiCPPU.prototype.removeDebugEvent = function (value) {\n        // throw new Error('Method not implemented.');\n    };\n    Object.defineProperty(ChiChiCPPU.prototype, \"Clock\", {\n        get: function () {\n            return this.clock;\n        },\n        set: function (value) {\n            this.clock = value;\n            if (value === 0) {\n                this.systemClock = (this.systemClock + this.clock) & 0xFFFFFFFFFF;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ChiChiCPPU.prototype.SetFlag = function (Flag, value) {\n        this._statusRegister = (value ? (this._statusRegister | Flag) : (this._statusRegister & ~Flag));\n        this._statusRegister |= 32; // (int)CPUStatusMasks.ExpansionMask;\n    };\n    ChiChiCPPU.prototype.GetFlag = function (flag) {\n        return ((this._statusRegister & flag) === flag);\n    };\n    ChiChiCPPU.prototype.InterruptRequest = function () {\n        //When an IRQ or NMI occurs, the current status with bit 4 clear and bit 5 \n        //  set is pushed on the stack, then the I flag is set. \n        if (!this.GetFlag(this.SRMasks_InterruptDisableMask)) {\n            this.SetFlag(this.SRMasks_InterruptDisableMask, true);\n            var newStatusReg1 = this._statusRegister & ~0x10 | 0x20;\n            // if enabled\n            // push pc onto stack (high byte first)\n            this.PushStack(this._programCounter >> 8);\n            this.PushStack(this._programCounter);\n            // push sr onto stack\n            this.PushStack(this._statusRegister);\n            // point pc to interrupt service routine\n            this._programCounter = this.GetByte(0xFFFE) + (this.GetByte(0xFFFF) << 8);\n            // nonOpCodeticks = 7;\n        }\n    };\n    ChiChiCPPU.prototype.NonMaskableInterrupt = function () {\n        //When an IRQ or NMI occurs, the current status with bit 4 clear and bit 5 \n        //  set is pushed on the stack, then the I flag is set. \n        var newStatusReg = this._statusRegister & ~0x10 | 0x20;\n        this.SetFlag(this.SRMasks_InterruptDisableMask, true);\n        // push pc onto stack (high byte first)\n        this.PushStack(this._programCounter >> 8);\n        this.PushStack(this._programCounter & 0xFF);\n        //c7ab\n        // push sr onto stack\n        this.PushStack(newStatusReg);\n        // point pc to interrupt service routine\n        var lowByte = this.GetByte(0xFFFA);\n        var highByte = this.GetByte(0xFFFB);\n        var jumpTo = lowByte | (highByte << 8);\n        this._programCounter = jumpTo;\n        //nonOpCodeticks = 7;\n    };\n    ChiChiCPPU.prototype.CheckEvent = function () {\n        if (this.nextEvent === -1) {\n            this.FindNextEvent();\n        }\n    };\n    ChiChiCPPU.prototype.RunFast = function () {\n        while (this.clock < 29780) {\n            this.Step();\n        }\n    };\n    ChiChiCPPU.prototype.Step = function () {\n        //let tickCount = 0;\n        this._currentInstruction_ExtraTiming = 0;\n        // this.ppu.DrawTo(this.clock);\n        if (this.nextEvent <= this.clock) {\n            this.HandleNextEvent();\n        }\n        if (this._handleNMI) {\n            this._handleNMI = false;\n            this.clock += 7;\n            this.NonMaskableInterrupt();\n        }\n        else if (this._handleIRQ) {\n            this._handleIRQ = false;\n            this.clock += 7;\n            this.InterruptRequest();\n        }\n        //FetchNextInstruction();\n        this._currentInstruction_Address = this._programCounter;\n        this._currentInstruction_OpCode = this.GetByte(this._programCounter++);\n        this._currentInstruction_AddressingMode = ChiChiCPPU.addressModes[this._currentInstruction_OpCode];\n        //FetchInstructionParameters();\n        switch (this._currentInstruction_AddressingMode) {\n            case ChiChiTypes_1.ChiChiCPPU_AddressingModes.Absolute:\n            case ChiChiTypes_1.ChiChiCPPU_AddressingModes.AbsoluteX:\n            case ChiChiTypes_1.ChiChiCPPU_AddressingModes.AbsoluteY:\n            case ChiChiTypes_1.ChiChiCPPU_AddressingModes.Indirect:\n                // case AddressingModes.IndirectAbsoluteX:\n                this._currentInstruction_Parameters0 = this.GetByte(this._programCounter++);\n                this._currentInstruction_Parameters1 = this.GetByte(this._programCounter++);\n                break;\n            case ChiChiTypes_1.ChiChiCPPU_AddressingModes.ZeroPage:\n            case ChiChiTypes_1.ChiChiCPPU_AddressingModes.ZeroPageX:\n            case ChiChiTypes_1.ChiChiCPPU_AddressingModes.ZeroPageY:\n            case ChiChiTypes_1.ChiChiCPPU_AddressingModes.Relative:\n            case ChiChiTypes_1.ChiChiCPPU_AddressingModes.IndexedIndirect:\n            case ChiChiTypes_1.ChiChiCPPU_AddressingModes.IndirectIndexed:\n            case ChiChiTypes_1.ChiChiCPPU_AddressingModes.IndirectZeroPage:\n            case ChiChiTypes_1.ChiChiCPPU_AddressingModes.Immediate:\n                this._currentInstruction_Parameters0 = this.GetByte(this._programCounter++);\n                break;\n            case ChiChiTypes_1.ChiChiCPPU_AddressingModes.Accumulator:\n            case ChiChiTypes_1.ChiChiCPPU_AddressingModes.Implicit:\n                break;\n            default:\n                //  throw new Error(\"Invalid address mode!!\");\n                break;\n        }\n        this.Execute();\n        //(\"{0:x} {1:x} {2:x}\", _currentInstruction_OpCode, _currentInstruction_AddressingMode, _currentInstruction_Address);\n        if (this._debugging) {\n            this.WriteInstructionHistoryAndUsage();\n            this._operationCounter++;\n        }\n        this.clock += ChiChiCPPU.cpuTiming[this._currentInstruction_OpCode] + this._currentInstruction_ExtraTiming;\n    };\n    ChiChiCPPU.prototype.ResetCPU = function () {\n        this._statusRegister = 52;\n        this._operationCounter = 0;\n        this._stackPointer = 253;\n        this._programCounter = this.GetByte(0xFFFC) | (this.GetByte(0xFFFD) << 8);\n        this._ticks = 4;\n    };\n    ChiChiCPPU.prototype.PowerOn = function () {\n        // powers up with this state\n        this._statusRegister = 52;\n        this._stackPointer = 253;\n        this._operationCounter = 0;\n        this._ticks = 4;\n        // wram initialized to 0xFF, with some exceptions\n        // probably doesn't affect games, but why not?\n        for (var i = 0; i < 2048; ++i) {\n            this.Rams[i] = 255;\n        }\n        this.Rams[8] = 247;\n        this.Rams[9] = 239;\n        this.Rams[10] = 223;\n        this.Rams[15] = 191;\n        this._programCounter = this.GetByte(0xFFFC) | (this.GetByte(0xFFFD) << 8);\n    };\n    ChiChiCPPU.prototype.GetState = function (outStream) {\n        //throw new Error('Method not implemented.');\n    };\n    ChiChiCPPU.prototype.SetState = function (inStream) {\n        // throw new Error('Method not implemented.');\n    };\n    ChiChiCPPU.prototype.RunFrame = function () {\n        this.FindNextEvent();\n        do {\n            this.Step();\n        } while (!this.__frameFinished);\n    };\n    ChiChiCPPU.prototype.DecodeAddress = function () {\n        this._currentInstruction_ExtraTiming = 0;\n        var result = 0;\n        var lowByte = 0;\n        var highByte = 0;\n        switch (this._currentInstruction_AddressingMode) {\n            case ChiChiTypes_1.ChiChiCPPU_AddressingModes.Absolute:\n                // two parameters refer to the memory position\n                result = ((this._currentInstruction_Parameters1 << 8) | this._currentInstruction_Parameters0);\n                break;\n            case ChiChiTypes_1.ChiChiCPPU_AddressingModes.AbsoluteX:\n                // absolute, x indexed - two paramaters + Index register x\n                result = (((((this._currentInstruction_Parameters1 << 8) | this._currentInstruction_Parameters0) + this._indexRegisterX) | 0));\n                if ((result & 0xFF) < this._indexRegisterX) {\n                    this._currentInstruction_ExtraTiming = 1;\n                }\n                break;\n            case ChiChiTypes_1.ChiChiCPPU_AddressingModes.AbsoluteY:\n                // absolute, y indexed - two paramaters + Index register y\n                result = (((((this._currentInstruction_Parameters1 << 8) | this._currentInstruction_Parameters0) + this._indexRegisterY) | 0));\n                if ((result & 0xFF) < this._indexRegisterY) {\n                    this._currentInstruction_ExtraTiming = 1;\n                }\n                break;\n            case ChiChiTypes_1.ChiChiCPPU_AddressingModes.ZeroPage:\n                // first parameter represents offset in zero page\n                result = this._currentInstruction_Parameters0;\n                break;\n            case ChiChiTypes_1.ChiChiCPPU_AddressingModes.ZeroPageX:\n                result = (((this._currentInstruction_Parameters0 + this._indexRegisterX) | 0)) & 0xFF;\n                break;\n            case ChiChiTypes_1.ChiChiCPPU_AddressingModes.ZeroPageY:\n                result = ((((this._currentInstruction_Parameters0 & 0xFF) + (this._indexRegisterY & 0xFF)) | 0)) & 0xFF;\n                break;\n            case ChiChiTypes_1.ChiChiCPPU_AddressingModes.Indirect:\n                lowByte = this._currentInstruction_Parameters0;\n                highByte = this._currentInstruction_Parameters1 << 8;\n                var indAddr = (highByte | lowByte) & 65535;\n                var indirectAddr = (this.GetByte(indAddr));\n                lowByte = (((lowByte + 1) | 0)) & 0xFF;\n                indAddr = (highByte | lowByte) & 65535;\n                indirectAddr = indirectAddr | (this.GetByte(indAddr) << 8);\n                result = indirectAddr;\n                break;\n            case ChiChiTypes_1.ChiChiCPPU_AddressingModes.IndexedIndirect:\n                var addr = (((this._currentInstruction_Parameters0 + this._indexRegisterX) | 0)) & 0xFF;\n                lowByte = this.GetByte(addr);\n                addr = (addr + 1) | 0;\n                highByte = this.GetByte(addr & 0xFF);\n                highByte = highByte << 8;\n                result = highByte | lowByte;\n                break;\n            case ChiChiTypes_1.ChiChiCPPU_AddressingModes.IndirectIndexed:\n                lowByte = this.GetByte(this._currentInstruction_Parameters0);\n                highByte = this.GetByte((((this._currentInstruction_Parameters0 + 1) | 0)) & 0xFF) << 8;\n                addr = (lowByte | highByte);\n                result = (addr + this._indexRegisterY) | 0;\n                if ((result & 0xFF) > this._indexRegisterY) {\n                    this._currentInstruction_ExtraTiming = 1;\n                }\n                break;\n            case ChiChiTypes_1.ChiChiCPPU_AddressingModes.Relative:\n                result = (((this._programCounter + this._currentInstruction_Parameters0) | 0));\n                break;\n            default:\n                this.HandleBadOperation();\n                break;\n        }\n        return result & 65535;\n    };\n    ChiChiCPPU.prototype.HandleBadOperation = function () {\n        throw new Error('Method not implemented.');\n    };\n    ChiChiCPPU.prototype.DecodeOperand = function () {\n        switch (this._currentInstruction_AddressingMode) {\n            case ChiChiTypes_1.ChiChiCPPU_AddressingModes.Immediate:\n                this._dataBus = this._currentInstruction_Parameters0;\n                return this._currentInstruction_Parameters0;\n            case ChiChiTypes_1.ChiChiCPPU_AddressingModes.Accumulator:\n                return this._accumulator;\n            default:\n                this._dataBus = this.GetByte(this.DecodeAddress());\n                return this._dataBus;\n        }\n    };\n    ChiChiCPPU.prototype.Execute = function () {\n        var data = 0;\n        var lowByte = 0;\n        var highByte = 0;\n        var carryFlag = 0;\n        var result = 0;\n        var oldbit = 0;\n        switch (this._currentInstruction_OpCode) {\n            case 128:\n            case 130:\n            case 194:\n            case 226:\n            case 4:\n            case 20:\n            case 52:\n            case 68:\n            case 84:\n            case 100:\n            case 116:\n            case 212:\n            case 244:\n            case 12:\n            case 28:\n            case 60:\n            case 92:\n            case 124:\n            case 220:\n            case 252:\n                //SKB, SKW, DOP, - undocumented noops\n                this.DecodeAddress();\n                break;\n            case 105:\n            case 101:\n            case 117:\n            case 109:\n            case 125:\n            case 121:\n            case 97:\n            case 113:\n                //ADC\n                data = this.DecodeOperand();\n                carryFlag = (this._statusRegister & 1);\n                result = (this._accumulator + data + carryFlag) | 0;\n                // carry flag\n                this.SetFlag(this.SRMasks_CarryMask, result > 255);\n                // overflow flag\n                this.SetFlag(this.SRMasks_OverflowMask, ((this._accumulator ^ data) & 128) !== 128 && ((this._accumulator ^ result) & 128) === 128);\n                // occurs when bit 7 is set\n                this._accumulator = result & 0xFF;\n                this.SetZNFlags(this._accumulator);\n                break;\n            case 41:\n            case 37:\n            case 53:\n            case 45:\n            case 61:\n            case 57:\n            case 33:\n            case 49:\n                //AND\n                this._accumulator = (this._accumulator & this.DecodeOperand());\n                this.SetZNFlags(this._accumulator);\n                break;\n            case 10:\n            case 6:\n            case 22:\n            case 14:\n            case 30:\n                //ASL\n                data = this.DecodeOperand();\n                // set carry flag\n                this.SetFlag(this.SRMasks_CarryMask, ((data & 128) === 128));\n                data = (data << 1) & 254;\n                if (this._currentInstruction_AddressingMode === ChiChiTypes_1.ChiChiCPPU_AddressingModes.Accumulator) {\n                    this._accumulator = data;\n                }\n                else {\n                    this.SetByte(this.DecodeAddress(), data);\n                }\n                this.SetZNFlags(data);\n                break;\n            case 144:\n                //BCC\n                if ((this._statusRegister & 1) !== 1) {\n                    this.Branch();\n                }\n                break;\n            case 176:\n                //BCS();\n                if ((this._statusRegister & 1) === 1) {\n                    this.Branch();\n                }\n                break;\n            case 240:\n                //BEQ();\n                if ((this._statusRegister & 2) === 2) {\n                    this.Branch();\n                }\n                break;\n            case 36:\n            case 44:\n                //BIT();\n                data = this.DecodeOperand();\n                // overflow is bit 6\n                this.SetFlag(this.SRMasks_OverflowMask, (data & 64) === 64);\n                // negative is bit 7\n                if ((data & 128) === 128) {\n                    this._statusRegister = this._statusRegister | 128;\n                }\n                else {\n                    this._statusRegister = this._statusRegister & 127;\n                }\n                if ((data & this._accumulator) === 0) {\n                    this._statusRegister = this._statusRegister | 2;\n                }\n                else {\n                    this._statusRegister = this._statusRegister & 253;\n                }\n                break;\n            case 48:\n                //BMI();\n                if ((this._statusRegister & 128) === 128) {\n                    this.Branch();\n                }\n                break;\n            case 208:\n                //BNE();\n                if ((this._statusRegister & 2) !== 2) {\n                    this.Branch();\n                }\n                break;\n            case 16:\n                //BPL();\n                if ((this._statusRegister & 128) !== 128) {\n                    this.Branch();\n                }\n                break;\n            case 0:\n                //BRK();\n                //BRK causes a non-maskable interrupt and increments the program counter by one. \n                //Therefore an RTI will go to the address of the BRK +2 so that BRK may be used to replace a two-byte instruction \n                // for debugging and the subsequent RTI will be correct. \n                // push pc onto stack (high byte first)\n                this._programCounter = this._programCounter + 1;\n                this.PushStack(this._programCounter >> 8 & 0xFF);\n                this.PushStack(this._programCounter & 0xFF);\n                // push sr onto stack\n                //PHP and BRK push the current status with bits 4 and 5 set on the stack; \n                data = this._statusRegister | 16 | 32;\n                this.PushStack(data);\n                // set interrupt disable, and break flags\n                // BRK then sets the I flag.\n                this._statusRegister = this._statusRegister | 20;\n                // point pc to interrupt service routine\n                this._addressBus = 65534;\n                lowByte = this.GetByte(this._addressBus);\n                this._addressBus = 65535;\n                highByte = this.GetByte(this._addressBus);\n                this._programCounter = lowByte + highByte * 256;\n                break;\n            case 80:\n                //BVC();\n                if ((this._statusRegister & 64) !== 64) {\n                    this.Branch();\n                }\n                break;\n            case 112:\n                //BVS();\n                if ((this._statusRegister & 64) === 64) {\n                    this.Branch();\n                }\n                break;\n            case 24:\n                //CLC();\n                this.SetFlag(this.SRMasks_CarryMask, false);\n                break;\n            case 216:\n                //CLD();\n                this.SetFlag(this.SRMasks_DecimalModeMask, false);\n                break;\n            case 88:\n                //CLI();\n                this.SetFlag(this.SRMasks_InterruptDisableMask, false);\n                break;\n            case 184:\n                //CLV();\n                this.SetFlag(this.SRMasks_OverflowMask, false);\n                break;\n            case 201:\n            case 197:\n            case 213:\n            case 205:\n            case 221:\n            case 217:\n            case 193:\n            case 209:\n                //CMP();\n                data = (this._accumulator + 256 - this.DecodeOperand());\n                this.Compare(data);\n                break;\n            case 224:\n            case 228:\n            case 236:\n                //CPX();\n                data = (this._indexRegisterX + 256 - this.DecodeOperand());\n                this.Compare(data);\n                break;\n            case 192:\n            case 196:\n            case 204:\n                //CPY();\n                data = (this._indexRegisterY + 256 - this.DecodeOperand());\n                this.Compare(data);\n                break;\n            case 198:\n            case 214:\n            case 206:\n            case 222:\n                //DEC();\n                data = this.DecodeOperand();\n                data = (data - 1) & 0xFF;\n                this.SetByte(this.DecodeAddress(), data);\n                this.SetZNFlags(data);\n                break;\n            case 202:\n                //DEX();\n                this._indexRegisterX = this._indexRegisterX - 1;\n                this._indexRegisterX = this._indexRegisterX & 0xFF;\n                this.SetZNFlags(this._indexRegisterX);\n                break;\n            case 136:\n                //DEY();\n                this._indexRegisterY = this._indexRegisterY - 1;\n                this._indexRegisterY = this._indexRegisterY & 0xFF;\n                this.SetZNFlags(this._indexRegisterY);\n                break;\n            case 73:\n            case 69:\n            case 85:\n            case 77:\n            case 93:\n            case 89:\n            case 65:\n            case 81:\n                //EOR();\n                this._accumulator = (this._accumulator ^ this.DecodeOperand());\n                this.SetZNFlags(this._accumulator);\n                break;\n            case 230:\n            case 246:\n            case 238:\n            case 254:\n                //INC();\n                data = this.DecodeOperand();\n                data = (data + 1) & 0xFF;\n                this.SetByte(this.DecodeAddress(), data);\n                this.SetZNFlags(data);\n                break;\n            case 232:\n                //INX();\n                this._indexRegisterX = this._indexRegisterX + 1;\n                this._indexRegisterX = this._indexRegisterX & 0xFF;\n                this.SetZNFlags(this._indexRegisterX);\n                break;\n            case 200:\n                this._indexRegisterY = this._indexRegisterY + 1;\n                this._indexRegisterY = this._indexRegisterY & 0xFF;\n                this.SetZNFlags(this._indexRegisterY);\n                break;\n            case 76:\n            case 108:\n                // JMP();\n                // 6052 indirect jmp bug\n                if (this._currentInstruction_AddressingMode === ChiChiTypes_1.ChiChiCPPU_AddressingModes.Indirect && this._currentInstruction_Parameters0 === 255) {\n                    this._programCounter = 255 | this._currentInstruction_Parameters1 << 8;\n                }\n                else {\n                    this._programCounter = this.DecodeAddress();\n                }\n                break;\n            case 32:\n                //JSR();\n                this.PushStack((this._programCounter >> 8) & 0xFF);\n                this.PushStack((this._programCounter - 1) & 0xFF);\n                this._programCounter = this.DecodeAddress();\n                break;\n            case 169:\n            case 165:\n            case 181:\n            case 173:\n            case 189:\n            case 185:\n            case 161:\n            case 177:\n                //LDA();\n                this._accumulator = this.DecodeOperand();\n                this.SetZNFlags(this._accumulator);\n                break;\n            case 162:\n            case 166:\n            case 182:\n            case 174:\n            case 190:\n                //LDX();\n                this._indexRegisterX = this.DecodeOperand();\n                this.SetZNFlags(this._indexRegisterX);\n                break;\n            case 160:\n            case 164:\n            case 180:\n            case 172:\n            case 188:\n                //LDY();\n                this._indexRegisterY = this.DecodeOperand();\n                this.SetZNFlags(this._indexRegisterY);\n                break;\n            case 74:\n            case 70:\n            case 86:\n            case 78:\n            case 94:\n                //LSR();\n                data = this.DecodeOperand();\n                //LSR shifts all bits right one position. 0 is shifted into bit 7 and the original bit 0 is shifted into the Carry. \n                this.SetFlag(this.SRMasks_CarryMask, (data & 1) === 1);\n                //target.SetFlag(CPUStatusBits.Carry, (rst & 1) == 1);\n                data = data >> 1 & 0xFF;\n                this.SetZNFlags(data);\n                if (this._currentInstruction_AddressingMode === ChiChiTypes_1.ChiChiCPPU_AddressingModes.Accumulator) {\n                    this._accumulator = data;\n                }\n                else {\n                    this.SetByte(this.DecodeAddress(), data);\n                }\n                break;\n            case 234:\n            case 26:\n            case 58:\n            case 90:\n            case 122:\n            case 218:\n            case 250:\n            case 137:\n                //case 0x04:\n                //case 0x14:\n                //case 0x34:\n                //case 0x44:\n                //case 0x64:\n                //case 0x80:\n                //case 0x82:\n                //case 0xc2:\n                //case 0xd4:\n                //case 0xe2:\n                //case 0xf4:\n                //case 0x0c:\n                //case 0x1c:\n                //case 0x3c:\n                //case 0x5c:\n                //case 0x7c:\n                //case 0xdc:\n                //case 0xfc:\n                //NOP();\n                if (this._currentInstruction_AddressingMode === ChiChiTypes_1.ChiChiCPPU_AddressingModes.AbsoluteX) {\n                    this.DecodeAddress();\n                }\n                break;\n            case 9:\n            case 5:\n            case 21:\n            case 13:\n            case 29:\n            case 25:\n            case 1:\n            case 17:\n                //ORA();\n                this._accumulator = (this._accumulator | this.DecodeOperand());\n                this.SetZNFlags(this._accumulator);\n                break;\n            case 72:\n                //PHA();\n                this.PushStack(this._accumulator);\n                break;\n            case 8:\n                //PHP();\n                data = this._statusRegister | 16 | 32;\n                this.PushStack(data);\n                break;\n            case 104:\n                //PLA();\n                this._accumulator = this.PopStack();\n                this.SetZNFlags(this._accumulator);\n                break;\n            case 40:\n                //PLP();\n                this._statusRegister = this.PopStack(); // | 0x20;\n                break;\n            case 42:\n            case 38:\n            case 54:\n            case 46:\n            case 62:\n                //ROL();\n                data = this.DecodeOperand();\n                // old carry bit shifted into bit 1\n                oldbit = (this._statusRegister & 1) === 1 ? 1 : 0;\n                this.SetFlag(this.SRMasks_CarryMask, (data & 128) === 128);\n                data = ((data << 1) | oldbit) & 0xFF;\n                //data = data & 0xFF;\n                //data = data | oldbit;\n                this.SetZNFlags(data);\n                if (this._currentInstruction_AddressingMode === ChiChiTypes_1.ChiChiCPPU_AddressingModes.Accumulator) {\n                    this._accumulator = data;\n                }\n                else {\n                    this.SetByte(this.DecodeAddress(), data);\n                }\n                break;\n            case 106:\n            case 102:\n            case 118:\n            case 110:\n            case 126:\n                //ROR();\n                data = this.DecodeOperand();\n                // old carry bit shifted into bit 7\n                oldbit = (this._statusRegister & 1) === 1 ? 128 : 0;\n                // original bit 0 shifted to carry\n                this.SetFlag(this.SRMasks_CarryMask, (data & 1) === 1);\n                data = (data >> 1) | oldbit;\n                this.SetZNFlags(data);\n                if (this._currentInstruction_AddressingMode === ChiChiTypes_1.ChiChiCPPU_AddressingModes.Accumulator) {\n                    this._accumulator = data;\n                }\n                else {\n                    this.SetByte(this.DecodeAddress(), data);\n                }\n                break;\n            case 64:\n                //RTI();\n                this._statusRegister = this.PopStack(); // | 0x20;\n                lowByte = this.PopStack();\n                highByte = this.PopStack();\n                this._programCounter = ((highByte << 8) | lowByte);\n                break;\n            case 96:\n                //RTS();\n                lowByte = (this.PopStack() + 1) & 0xFF;\n                highByte = this.PopStack();\n                this._programCounter = ((highByte << 8) | lowByte);\n                break;\n            case 235:\n            case 233:\n            case 229:\n            case 245:\n            case 237:\n            case 253:\n            case 249:\n            case 225:\n            case 241:// undocumented sbc immediate\n                //SBC();\n                // start the read process\n                data = this.DecodeOperand() & 4095;\n                carryFlag = ((this._statusRegister ^ 1) & 1);\n                result = (((this._accumulator - data) & 4095) - carryFlag) & 4095;\n                // set overflow flag if sign bit of accumulator changed\n                this.SetFlag(this.SRMasks_OverflowMask, ((this._accumulator ^ result) & 128) === 128 && ((this._accumulator ^ data) & 128) === 128);\n                this.SetFlag(this.SRMasks_CarryMask, (result < 256));\n                this._accumulator = (result) & 0xFF;\n                this.SetZNFlags(this._accumulator);\n                break;\n            case 56:\n                //SEC();\n                this.SetFlag(this.SRMasks_CarryMask, true);\n                break;\n            case 248:\n                //SED();\n                this.SetFlag(this.SRMasks_DecimalModeMask, true);\n                break;\n            case 120:\n                //SEI();\n                this.SetFlag(this.SRMasks_InterruptDisableMask, true);\n                break;\n            case 133:\n            case 149:\n            case 141:\n            case 157:\n            case 153:\n            case 129:\n            case 145:\n                //STA();\n                this.SetByte(this.DecodeAddress(), this._accumulator);\n                break;\n            case 134:\n            case 150:\n            case 142:\n                //STX();\n                this.SetByte(this.DecodeAddress(), this._indexRegisterX);\n                break;\n            case 132:\n            case 148:\n            case 140:\n                //STY();\n                this.SetByte(this.DecodeAddress(), this._indexRegisterY);\n                break;\n            case 170:\n                //TAX();\n                this._indexRegisterX = this._accumulator;\n                this.SetZNFlags(this._indexRegisterX);\n                break;\n            case 168:\n                //TAY();\n                this._indexRegisterY = this._accumulator;\n                this.SetZNFlags(this._indexRegisterY);\n                break;\n            case 186:\n                //TSX();\n                this._indexRegisterX = this._stackPointer;\n                this.SetZNFlags(this._indexRegisterX);\n                break;\n            case 138:\n                //TXA();\n                this._accumulator = this._indexRegisterX;\n                this.SetZNFlags(this._accumulator);\n                break;\n            case 154:\n                //TXS();\n                this._stackPointer = this._indexRegisterX;\n                break;\n            case 152:\n                //TYA();\n                this._accumulator = this._indexRegisterY;\n                this.SetZNFlags(this._accumulator);\n                break;\n            case 11:\n            case 43:\n                //AAC();\n                //AND byte with accumulator. If result is negative then carry is set.\n                //Status flags: N,Z,C\n                this._accumulator = this.DecodeOperand() & this._accumulator & 0xFF;\n                this.SetFlag(this.SRMasks_CarryMask, (this._accumulator & 128) === 128);\n                this.SetZNFlags(this._accumulator);\n                break;\n            case 75:\n                //AND byte with accumulator, then shift right one bit in accumu-lator.\n                //Status flags: N,Z,C\n                this._accumulator = this.DecodeOperand() & this._accumulator;\n                this.SetFlag(this.SRMasks_CarryMask, (this._accumulator & 1) === 1);\n                this._accumulator = this._accumulator >> 1;\n                this.SetZNFlags(this._accumulator);\n                break;\n            case 107:\n                //ARR();\n                //AND byte with accumulator, then rotate one bit right in accu - mulator and\n                //  check bit 5 and 6:\n                //If both bits are 1: set C, clear V. 0x30\n                //If both bits are 0: clear C and V.\n                //If only bit 5 is 1: set V, clear C.\n                //If only bit 6 is 1: set C and V.\n                //Status flags: N,V,Z,C\n                this._accumulator = this.DecodeOperand() & this._accumulator;\n                if ((this._statusRegister & 1) === 1) {\n                    this._accumulator = (this._accumulator >> 1) | 128;\n                }\n                else {\n                    this._accumulator = (this._accumulator >> 1);\n                }\n                // original bit 0 shifted to carry\n                //            target.SetFlag(CPUStatusBits.Carry, (); \n                this.SetFlag(this.SRMasks_CarryMask, (this._accumulator & 1) === 1);\n                switch (this._accumulator & 48) {\n                    case 48:\n                        this.SetFlag(this.SRMasks_CarryMask, true);\n                        this.SetFlag(this.SRMasks_InterruptDisableMask, false);\n                        break;\n                    case 0:\n                        this.SetFlag(this.SRMasks_CarryMask, false);\n                        this.SetFlag(this.SRMasks_InterruptDisableMask, false);\n                        break;\n                    case 16:\n                        this.SetFlag(this.SRMasks_CarryMask, false);\n                        this.SetFlag(this.SRMasks_InterruptDisableMask, true);\n                        break;\n                    case 32:\n                        this.SetFlag(this.SRMasks_CarryMask, true);\n                        this.SetFlag(this.SRMasks_InterruptDisableMask, true);\n                        break;\n                }\n                break;\n            case 171:\n                //ATX();\n                //AND byte with accumulator, then transfer accumulator to X register.\n                //Status flags: N,Z\n                this._indexRegisterX = (this._accumulator = this.DecodeOperand() & this._accumulator);\n                this.SetZNFlags(this._indexRegisterX);\n                break;\n        }\n    };\n    ChiChiCPPU.prototype.SetZNFlags = function (data) {\n        //zeroResult = (data & 0xFF) == 0;\n        //negativeResult = (data & 0x80) == 0x80;\n        if ((data & 255) === 0) {\n            this._statusRegister |= 2;\n        }\n        else {\n            this._statusRegister &= -3;\n        } // ((int)CPUStatusMasks.ZeroResultMask);\n        if ((data & 128) === 128) {\n            this._statusRegister |= 128;\n        }\n        else {\n            this._statusRegister &= -129;\n        } // ((int)CPUStatusMasks.NegativeResultMask);\n    };\n    ChiChiCPPU.prototype.Compare = function (data) {\n        this.SetFlag(this.SRMasks_CarryMask, data > 255);\n        this.SetZNFlags(data & 255);\n    };\n    ChiChiCPPU.prototype.Branch = function () {\n        this._currentInstruction_ExtraTiming = 1;\n        var addr = this._currentInstruction_Parameters0 & 255;\n        if ((addr & 128) === 128) {\n            addr = addr - 256;\n            this._programCounter += addr;\n        }\n        else {\n            this._programCounter += addr;\n        }\n        if ((this._programCounter & 255) < addr) {\n            this._currentInstruction_ExtraTiming = 2;\n        }\n    };\n    ChiChiCPPU.prototype.NMIHandler = function () {\n        this._handleNMI = true;\n    };\n    ChiChiCPPU.prototype.IRQUpdater = function () {\n        this._handleIRQ = this.SoundBopper.IRQAsserted || this.Cart.irqRaised;\n    };\n    ChiChiCPPU.prototype.LoadBytes = function (offset, bytes) {\n        throw new Error('Method not implemented.');\n    };\n    ChiChiCPPU.prototype.LoadBytes$1 = function (offset, bytes, length) {\n        throw new Error('Method not implemented.');\n    };\n    ChiChiCPPU.prototype.PushStack = function (data) {\n        this.Rams[this._stackPointer + 256] = data;\n        this._stackPointer--;\n        if (this._stackPointer < 0) {\n            this._stackPointer = 255;\n        }\n    };\n    ChiChiCPPU.prototype.PopStack = function () {\n        this._stackPointer++;\n        if (this._stackPointer > 255) {\n            this._stackPointer = 0;\n        }\n        return this.Rams[this._stackPointer + 256];\n    };\n    ChiChiCPPU.prototype.GetByte = function (address) {\n        var result = 0;\n        // check high byte, find appropriate handler\n        switch (address & 61440) {\n            case 0:\n            case 4096:\n                if (address < 2048) {\n                    result = this.Rams[address];\n                }\n                else {\n                    result = address >> 8;\n                }\n                break;\n            case 8192:\n            case 12288:\n                result = this.ppu.GetByte(this.clock, address);\n                break;\n            case 16384:\n                switch (address) {\n                    case 16406:\n                        result = this._padOne.GetByte(this.clock, address);\n                        break;\n                    case 16407:\n                        result = this._padTwo.GetByte(this.clock, address);\n                        break;\n                    case 16405:\n                        result = this.SoundBopper.GetByte(this.clock, address);\n                        break;\n                    default:\n                        // return open bus?\n                        result = address >> 8;\n                        break;\n                }\n                break;\n            case 20480:\n                // ??\n                result = address >> 8;\n                break;\n            case 24576:\n            case 28672:\n            case 32768:\n            case 36864:\n            case 40960:\n            case 45056:\n            case 49152:\n            case 53248:\n            case 57344:\n            case 61440:\n                // cart \n                result = this.Cart.GetByte(this.clock, address);\n                break;\n            default:\n                throw new Error(\"Bullshit!\");\n        }\n        //if (_cheating && memoryPatches.ContainsKey(address))\n        //{\n        //    return memoryPatches[address].Activated ? memoryPatches[address].GetData(result) & 0xFF : result & 0xFF;\n        //}\n        return result & 255;\n    };\n    ChiChiCPPU.prototype.PeekByte = function (address) {\n        var result = 0;\n        // check high byte, find appropriate handler\n        switch (address & 61440) {\n            case 0:\n            case 4096:\n                if (address < 2048) {\n                    result = this.Rams[address];\n                }\n                else {\n                    result = address >> 8;\n                }\n                break;\n            case 8192:\n            case 12288:\n                result = 0;\n                //result = this.PPU_GetByte(this.clock, address);\n                break;\n            case 16384:\n                switch (address) {\n                    case 16406:\n                        result = this._padOne.GetByte(this.clock, address);\n                        break;\n                    case 16407:\n                        result = this._padTwo.GetByte(this.clock, address);\n                        break;\n                    case 16405:\n                        result = this.SoundBopper.GetByte(this.clock, address);\n                        break;\n                    default:\n                        // return open bus?\n                        result = address >> 8;\n                        break;\n                }\n                break;\n            case 20480:\n                // ??\n                result = address >> 8;\n                break;\n            case 24576:\n            case 28672:\n            case 32768:\n            case 36864:\n            case 40960:\n            case 45056:\n            case 49152:\n            case 53248:\n            case 57344:\n            case 61440:\n                // cart \n                result = 0;\n                //result = this.Cart.GetByte(this.clock, address);\n                break;\n            default:\n                throw new Error(\"Bullshit!\");\n        }\n        //if (_cheating && memoryPatches.ContainsKey(address))\n        //{\n        //    return memoryPatches[address].Activated ? memoryPatches[address].GetData(result) & 0xFF : result & 0xFF;\n        //}\n        return result & 255;\n    };\n    ChiChiCPPU.prototype.PeekBytes = function (start, finish) {\n        var array = new Array();\n        for (var i = 0; i < finish; ++i) {\n            if (i < this.Rams.length)\n                array.push(this.Rams[i]);\n        }\n        return array;\n    };\n    ChiChiCPPU.prototype.SetByte = function (address, data) {\n        // check high byte, find appropriate handler\n        if (address < 2048) {\n            this.Rams[address & 2047] = data;\n            return;\n        }\n        switch (address & 61440) {\n            case 0:\n            case 4096:\n                // nes sram\n                this.Rams[address & 2047] = data;\n                break;\n            case 20480:\n                this.Cart.SetByte(this.clock, address, data);\n                break;\n            case 24576:\n            case 28672:\n            case 32768:\n            case 36864:\n            case 40960:\n            case 45056:\n            case 49152:\n            case 53248:\n            case 57344:\n            case 61440:\n                // cart rom banks\n                this.Cart.SetByte(this.clock, address, data);\n                break;\n            case 8192:\n            case 12288:\n                this.ppu.SetByte(this.clock, address, data);\n                break;\n            case 16384:\n                switch (address) {\n                    case 16384:\n                    case 16385:\n                    case 16386:\n                    case 16387:\n                    case 16388:\n                    case 16389:\n                    case 16390:\n                    case 16391:\n                    case 16392:\n                    case 16393:\n                    case 16394:\n                    case 16395:\n                    case 16396:\n                    case 16397:\n                    case 16398:\n                    case 16399:\n                    case 16405:\n                    case 16407:\n                        this.SoundBopper.SetByte(this.clock, address, data);\n                        break;\n                    case 16404:\n                        this.ppu.CopySprites(data * 256);\n                        this._currentInstruction_ExtraTiming = this._currentInstruction_ExtraTiming + 512;\n                        break;\n                    case 16406:\n                        this._padOne.SetByte(this.clock, address, data & 1);\n                        this._padTwo.SetByte(this.clock, address, data & 1);\n                        break;\n                }\n                break;\n        }\n    };\n    ChiChiCPPU.prototype.FindNextEvent = function () {\n        // it'll either be the ppu's NMI, or an irq from either the apu or the cart\n        this.nextEvent = this.clock + this.ppu.NextEventAt;\n    };\n    ChiChiCPPU.prototype.HandleNextEvent = function () {\n        this.ppu.HandleEvent(this.clock);\n        this.FindNextEvent();\n    };\n    ChiChiCPPU.prototype.ResetInstructionHistory = function () {\n        //_instructionHistory = new Instruction[0x100];\n        this.instructionHistoryPointer = 0xFF;\n    };\n    ChiChiCPPU.prototype.WriteInstructionHistoryAndUsage = function () {\n        var inst = new ChiChiTypes_1.ChiChiInstruction();\n        inst.time = this.systemClock;\n        inst.A = this._accumulator;\n        inst.X = this._indexRegisterX;\n        inst.Y = this._indexRegisterY;\n        inst.SR = this._statusRegister;\n        inst.SP = this._stackPointer;\n        inst.frame = this.clock;\n        inst.OpCode = this._currentInstruction_OpCode;\n        inst.Parameters0 = this._currentInstruction_Parameters0;\n        inst.Parameters1 = this._currentInstruction_Parameters1;\n        inst.Address = this._currentInstruction_Address;\n        inst.AddressingMode = this._currentInstruction_AddressingMode;\n        inst.ExtraTiming = this._currentInstruction_ExtraTiming;\n        this._instructionHistory[(this.instructionHistoryPointer--) & 255] = inst;\n        this.instructionUsage[this._currentInstruction_OpCode]++;\n        if ((this.instructionHistoryPointer & 255) === 255) {\n            this.FireDebugEvent(\"instructionHistoryFull\");\n        }\n    };\n    ChiChiCPPU.prototype.FireDebugEvent = function (s) {\n        for (var i = 0; i < this.debugEvents.length; ++i) {\n            this.debugEvents[i].call(this, s);\n        }\n        //throw new Error('Method not implemented.');\n    };\n    ChiChiCPPU.prototype.PeekInstruction = function (address) {\n        throw new Error('Method not implemented.');\n    };\n    ChiChiCPPU.prototype.GetStatus = function () {\n        return {\n            PC: this._programCounter,\n            A: this._accumulator,\n            X: this._indexRegisterX,\n            Y: this._indexRegisterY,\n            SP: this._stackPointer,\n            SR: this._statusRegister\n        };\n    };\n    // statics\n    ChiChiCPPU.cpuTiming = [7, 6, 0, 0, 3, 2, 5, 0, 3, 2, 2, 0, 6, 4, 6, 0, 2, 5, 0, 0, 3, 3, 6, 0, 2, 4, 2, 0, 6, 4, 7, 0, 6, 6, 0, 0, 3, 2, 5, 0, 3, 2, 2, 0, 4, 4, 6, 0, 2, 5, 0, 0, 3, 3, 6, 0, 2, 4, 2, 0, 6, 4, 7, 0, 6, 6, 0, 0, 3, 2, 5, 0, 3, 2, 2, 0, 3, 4, 6, 0, 2, 5, 0, 0, 0, 3, 6, 0, 2, 4, 2, 0, 6, 4, 6, 0, 6, 6, 0, 0, 3, 3, 5, 0, 3, 2, 2, 0, 5, 4, 6, 0, 2, 5, 0, 0, 0, 4, 6, 0, 2, 4, 2, 0, 6, 4, 7, 0, 3, 6, 3, 0, 3, 3, 3, 0, 2, 3, 2, 0, 4, 4, 4, 0, 2, 6, 0, 0, 4, 4, 4, 0, 2, 5, 2, 0, 0, 5, 0, 0, 2, 6, 2, 0, 3, 3, 3, 0, 2, 2, 2, 0, 4, 4, 4, 0, 2, 5, 0, 0, 4, 4, 4, 0, 2, 4, 2, 0, 4, 4, 4, 0, 2, 6, 3, 0, 3, 2, 5, 0, 2, 2, 2, 0, 4, 4, 6, 0, 2, 5, 0, 0, 3, 4, 6, 0, 2, 4, 2, 0, 6, 4, 7, 0, 2, 6, 3, 0, 3, 3, 5, 0, 2, 2, 2, 0, 4, 4, 6, 0, 2, 5, 0, 0, 3, 4, 6, 0, 2, 4, 2, 0, 6, 4, 7, 0];\n    ChiChiCPPU.addressModes = [1, 12, 1, 0, 0, 4, 4, 0, 1, 3, 2, 3, 8, 8, 8, 1, 7, 13, 14, 1, 4, 5, 5, 1, 1, 10, 1, 1, 8, 9, 9, 1, 8, 12, 1, 1, 4, 4, 4, 1, 1, 3, 2, 3, 8, 8, 8, 1, 7, 13, 14, 1, 5, 5, 5, 1, 1, 10, 1, 1, 9, 9, 9, 1, 1, 12, 1, 1, 1, 4, 4, 1, 1, 3, 2, 3, 8, 8, 8, 1, 7, 13, 14, 1, 1, 5, 5, 1, 1, 10, 1, 1, 1, 9, 9, 1, 1, 12, 1, 1, 4, 4, 4, 1, 1, 3, 2, 3, 11, 8, 8, 1, 7, 13, 14, 1, 5, 5, 5, 1, 1, 10, 1, 1, 15, 9, 9, 1, 7, 12, 3, 1, 4, 4, 4, 1, 1, 3, 1, 1, 8, 8, 8, 1, 7, 13, 14, 1, 5, 5, 6, 1, 1, 10, 1, 1, 8, 9, 9, 1, 3, 12, 3, 1, 4, 4, 4, 1, 1, 3, 1, 3, 8, 8, 8, 1, 7, 13, 14, 1, 5, 5, 6, 1, 1, 10, 1, 1, 9, 9, 10, 1, 3, 12, 3, 1, 4, 4, 4, 1, 1, 3, 1, 3, 8, 8, 8, 1, 7, 13, 14, 1, 1, 5, 5, 1, 1, 10, 1, 1, 1, 9, 9, 1, 3, 12, 3, 1, 4, 4, 4, 1, 1, 3, 1, 3, 8, 8, 8, 1, 7, 13, 14, 1, 1, 5, 5, 1, 1, 10, 1, 1, 1, 9, 9, 1];\n    return ChiChiCPPU;\n}());\nexports.ChiChiCPPU = ChiChiCPPU;\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar iNESFileHandler = /** @class */ (function () {\n    function iNESFileHandler() {\n    }\n    iNESFileHandler.LoadROM = function (cpu, thefile) {\n        var _cart = null;\n        var iNesHeader = thefile.slice(0, 16);\n        var bytesRead = 16;\n        /*\n        .NES file format\n        ---------------------------------------------------------------------------\n        0-3      String \"NES^Z\" used to recognize .NES files.\n        4        Number of 16kB ROM banks.\n        5        Number of 8kB VROM banks.\n        6        bit 0     1 for vertical mirroring, 0 for horizontal mirroring\n        bit 1     1 for battery-backed RAM at $6000-$7FFF\n        bit 2     1 for a 512-byte trainer at $7000-$71FF\n        bit 3     1 for a four-screen VRAM layout\n        bit 4-7   Four lower bits of ROM Mapper Type.\n        7        bit 0-3   Reserved, must be zeroes!\n        bit 4-7   Four higher bits of ROM Mapper Type.\n        8-15     Reserved, must be zeroes!\n        16-...   ROM banks, in ascending order. If a trainer is present, its\n        512 bytes precede the ROM bank contents.\n        ...-EOF  VROM banks, in ascending order.\n        ---------------------------------------------------------------------------\n        */\n        var mapperId = (iNesHeader[6] & 240);\n        mapperId = mapperId >> 4;\n        mapperId = (mapperId + iNesHeader[7]) | 0;\n        var prgRomCount = iNesHeader[4];\n        var chrRomCount = iNesHeader[5];\n        var prgRomLength = prgRomCount * 16384;\n        var chrRomLength = chrRomCount * 16384;\n        var theRom = new Uint8Array(prgRomLength); //System.Array.init(Bridge.Int.mul(prgRomCount, 16384), 0, System.Byte);\n        theRom.fill(0);\n        var chrRom = new Uint8Array(chrRomLength);\n        chrRom.fill(0);\n        //var chrRom = new Uint8Array(thefile.slice(16 + prgRomLength, 16 + prgRomLength + chrRomLength)); //System.Array.init(Bridge.Int.mul(chrRomCount, 16384), 0, System.Byte);\n        //chrRom.fill(0);\n        var chrOffset = 0;\n        //bytesRead = zipStream.Read(theRom, 0, theRom.Length);\n        BaseCart.arrayCopy(thefile, 16, theRom, 0, theRom.length);\n        chrOffset = (16 + theRom.length) | 0;\n        var len = chrRom.length;\n        if (((chrOffset + chrRom.length) | 0) > thefile.length) {\n            len = (thefile.length - chrOffset) | 0;\n        }\n        BaseCart.arrayCopy(thefile, chrOffset, chrRom, 0, len);\n        //zipStream.Read(chrRom, 0, chrRom.Length);\n        switch (mapperId) {\n            case 0:\n            case 2:\n            case 3:\n                _cart = new NesCart();\n                break;\n            case 7:\n                _cart = new AxROMCart();\n                break;\n            case 1:\n                _cart = new MMC1Cart();\n                break;\n            case 4:\n                _cart = new MMC3Cart();\n                break;\n        }\n        if (_cart != null) {\n            _cart.Whizzler = cpu.ppu;\n            _cart.CPU = cpu;\n            cpu.Cart = _cart;\n            cpu.ppu.ChrRomHandler = _cart;\n            _cart.ROMHashFunction = null; //Hashers.HashFunction;\n            _cart.LoadiNESCart(iNesHeader, prgRomCount, chrRomCount, theRom, chrRom, chrOffset);\n        }\n        return _cart;\n    };\n    iNESFileHandler.LoadNSF = function (cpu, thefile) {\n        var _cart = null;\n        var iNesHeader = thefile.slice(0, 0x80);\n        var bytesRead = 0x80;\n        var mapperId = (iNesHeader[6] & 240);\n        mapperId = mapperId >> 4;\n        mapperId = (mapperId + iNesHeader[7]) | 0;\n        var prgRomLength = thefile.length - 0x80;\n        var theRom = new Array(prgRomLength); //System.Array.init(Bridge.Int.mul(prgRomCount, 16384), 0, System.Byte);\n        theRom.fill(0);\n        var chrRom = new Array(0);\n        chrRom.fill(0);\n        //var chrRom = new Uint8Array(thefile.slice(16 + prgRomLength, 16 + prgRomLength + chrRomLength)); //System.Array.init(Bridge.Int.mul(chrRomCount, 16384), 0, System.Byte);\n        //chrRom.fill(0);\n        var chrOffset = 0;\n        //bytesRead = zipStream.Read(theRom, 0, theRom.Length);\n        BaseCart.arrayCopy(thefile, 0x80, theRom, 0, theRom.length);\n        //zipStream.Read(chrRom, 0, chrRom.Length);\n        _cart = new NsfCart();\n        if (_cart != null) {\n            _cart.Whizzler = cpu.ppu;\n            _cart.CPU = cpu;\n            cpu.Cart = _cart;\n            cpu.ppu.ChrRomHandler = _cart;\n            _cart.ROMHashFunction = null; //Hashers.HashFunction;\n            //_cart.LoadiNESCart(iNesHeader, prgRomCount, chrRomCount, theRom, chrRom, chrOffset);\n        }\n        return _cart;\n    };\n    return iNESFileHandler;\n}());\nexports.iNESFileHandler = iNESFileHandler;\nvar NameTableMirroring;\n(function (NameTableMirroring) {\n    NameTableMirroring[NameTableMirroring[\"OneScreen\"] = 0] = \"OneScreen\";\n    NameTableMirroring[NameTableMirroring[\"Vertical\"] = 1] = \"Vertical\";\n    NameTableMirroring[NameTableMirroring[\"Horizontal\"] = 2] = \"Horizontal\";\n    NameTableMirroring[NameTableMirroring[\"FourScreen\"] = 3] = \"FourScreen\";\n})(NameTableMirroring = exports.NameTableMirroring || (exports.NameTableMirroring = {}));\nvar BaseCart = /** @class */ (function () {\n    //ChrRamStart: number;\n    function BaseCart() {\n        var _this = this;\n        this.mapperName = 'base';\n        // shared components\n        this.prgRomBank6 = new Uint8Array(new SharedArrayBuffer(8192 * Uint8Array.BYTES_PER_ELEMENT));\n        this.ppuBankStarts = new Uint32Array(new SharedArrayBuffer(16 * Uint32Array.BYTES_PER_ELEMENT));\n        this.bankStartCache = new Uint32Array(new SharedArrayBuffer(4096 * Uint32Array.BYTES_PER_ELEMENT));\n        this.iNesHeader = new Uint8Array(16);\n        this.romControlBytes = new Uint8Array(2);\n        this.nesCart = null;\n        this.chrRom = null;\n        this.current8 = -1;\n        this.currentA = -1;\n        this.currentC = -1;\n        this.currentE = -1;\n        this.SRAMCanWrite = false;\n        this.SRAMEnabled = false;\n        this.SRAMCanSave = false;\n        this.prgRomCount = 0;\n        this.chrRomOffset = 0;\n        this.chrRamStart = 0;\n        this.chrRomCount = 0;\n        this.mapperId = 0;\n        this.bank8start = 0;\n        this.bankAstart = 0;\n        this.bankCstart = 0;\n        this.bankEstart = 0;\n        this._ROMHashfunction = null;\n        this.checkSum = null;\n        this.mirroring = -1;\n        this.updateIRQ = function () {\n            _this.NMIHandler();\n        };\n        this.bankSwitchesChanged = false;\n        this.oneScreenOffset = 0;\n        this.irqRaised = false;\n        this.DebugEvents = null;\n        //IRQAsserted: boolean;\n        //NextEventAt: number;\n        //PpuBankStarts: any;\n        //BankStartCache: any;\n        this.CurrentBank = 0;\n        //BankSwitchesChanged: boolean;\n        //OneScreenOffset: number;\n        this.UsesSRAM = false;\n        this.prgRomBank6.fill(0);\n        for (var i = 0; i < 16; i = (i + 1) | 0) {\n            this.ppuBankStarts[i] = i * 1024;\n        }\n    }\n    // compatible with .net array.copy method\n    BaseCart.arrayCopy = function (src, spos, dest, dpos, len) {\n        if (!dest) {\n            throw new Error(\"dest Value cannot be null\");\n        }\n        if (!src) {\n            throw new Error(\"src Value cannot be null\");\n        }\n        if (spos < 0 || dpos < 0 || len < 0) {\n            throw new Error(\"Number was less than the array's lower bound in the first dimension\");\n        }\n        if (len > (src.length - spos) || len > (dest.length - dpos)) {\n            throw new Error(\"Destination array was not long enough. Check destIndex and length, and the array's lower bounds\");\n        }\n        if (spos < dpos && src === dest) {\n            while (--len >= 0) {\n                dest[dpos + len] = src[spos + len];\n            }\n        }\n        else {\n            for (var i = 0; i < len; i++) {\n                dest[dpos + i] = src[spos + i];\n            }\n        }\n    };\n    Object.defineProperty(BaseCart.prototype, \"NumberOfPrgRoms\", {\n        // external api\n        get: function () {\n            return this.prgRomCount;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BaseCart.prototype, \"NumberOfChrRoms\", {\n        get: function () {\n            return this.chrRomCount;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BaseCart.prototype, \"MapperID\", {\n        get: function () {\n            return this.mapperId;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BaseCart.prototype, \"MapperName\", {\n        get: function () {\n            return this.mapperName;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    BaseCart.prototype.ClearDebugEvents = function () {\n        //this.DebugEvents.clear();\n    };\n    BaseCart.prototype.LoadiNESCart = function (header, prgRoms, chrRoms, prgRomData, chrRomData, chrRomOffset) {\n        this.romControlBytes[0] = header[6];\n        this.romControlBytes[1] = header[7];\n        this.mapperId = (this.romControlBytes[0] & 240) >> 4;\n        this.mapperId = (this.mapperId + (this.romControlBytes[1] & 240)) | 0;\n        this.chrRomOffset = chrRomOffset;\n        /*\n        .NES file format\n        ---------------------------------------------------------------------------\n        0-3      String \"NES^Z\" used to recognize .NES files.\n        4        Number of 16kB ROM banks.\n        5        Number of 8kB VROM banks.\n        6        bit 0     1 for vertical mirroring, 0 for horizontal mirroring\n                bit 1     1 for battery-backed RAM at $6000-$7FFF\n                bit 2     1 for a 512-byte trainer at $7000-$71FF\n                bit 3     1 for a four-screen VRAM layout\n                bit 4-7   Four lower bits of ROM Mapper Type.\n        7        bit 0-3   Reserved, must be zeroes!\n                bit 4-7   Four higher bits of ROM Mapper Type.\n        8-15     Reserved, must be zeroes!\n        16-...   ROM banks, in ascending order. If a trainer i6s present, its\n                512 bytes precede the ROM bank contents.\n        ...-EOF  VROM banks, in ascending order.\n        ---------------------------------------------------------------------------\n        */\n        this.iNesHeader = new Uint8Array(header.slice(0, 16));\n        //System.Array.copy(header, 0, this.iNesHeader, 0, header.length);\n        this.prgRomCount = prgRoms;\n        this.chrRomCount = chrRoms;\n        //  this.nesCart = System.Array.init(prgRomData.length, 0, System.Byte);\n        // System.Array.copy(prgRomData, 0, this.nesCart, 0, prgRomData.length);\n        this.nesCart = new Uint8Array(prgRomData.length);\n        BaseCart.arrayCopy(prgRomData, 0, this.nesCart, 0, prgRomData.length);\n        if (this.chrRomCount === 0) {\n            // chrRom is going to be RAM\n            chrRomData = new Array(32768); //System.Array.init(32768, 0, System.Byte);\n            chrRomData.fill(0);\n        }\n        var chrRomBuffer = new SharedArrayBuffer((chrRomData.length + 4096) * Uint8Array.BYTES_PER_ELEMENT);\n        this.chrRom = new Uint8Array(chrRomBuffer); //     System.Array.init(((chrRomData.length + 4096) | 0), 0, System.Int32);\n        this.chrRamStart = chrRomData.length;\n        BaseCart.arrayCopy(chrRomData, 0, this.chrRom, 0, chrRomData.length);\n        this.prgRomCount = this.iNesHeader[4];\n        this.chrRomCount = this.iNesHeader[5];\n        this.romControlBytes[0] = this.iNesHeader[6];\n        this.romControlBytes[1] = this.iNesHeader[7];\n        this.SRAMCanSave = (this.romControlBytes[0] & 2) === 2;\n        this.SRAMEnabled = true;\n        this.UsesSRAM = (this.romControlBytes[0] & 2) === 2;\n        // rom0.0=0 is horizontal mirroring, rom0.0=1 is vertical mirroring\n        // by default we have to call Mirror() at least once to set up the bank offsets\n        this.Mirror(0, 0);\n        if ((this.romControlBytes[0] & 1) === 1) {\n            this.Mirror(0, 1);\n        }\n        else {\n            this.Mirror(0, 2);\n        }\n        if ((this.romControlBytes[0] & 8) === 8) {\n            this.Mirror(0, 3);\n        }\n        this.checkSum = \"\"; //ROMHashFunction(nesCart, chrRom);\n        this.InitializeCart();\n    };\n    BaseCart.prototype.GetByte = function (clock, address) {\n        var bank = 0;\n        switch (address & 57344) {\n            case 24576:\n                return this.prgRomBank6[address & 8191];\n            case 32768:\n                bank = this.bank8start;\n                break;\n            case 40960:\n                bank = this.bankAstart;\n                break;\n            case 49152:\n                bank = this.bankCstart;\n                break;\n            case 57344:\n                bank = this.bankEstart;\n                break;\n        }\n        // if cart is half sized, adjust\n        if (((bank + (address & 8191)) | 0) > this.nesCart.length) {\n            throw new Error(\"THis is broken!\");\n        }\n        return this.nesCart[((bank + (address & 8191)) | 0)];\n    };\n    BaseCart.prototype.SetByte = function (clock, address, data) {\n        // throw new Error('Method not implemented.');\n    };\n    BaseCart.prototype.GetPPUByte = function (clock, address) {\n        var bank = address >> 10;\n        var newAddress = this.ppuBankStarts[bank] + (address & 1023);\n        //while (newAddress > chrRamStart)\n        //{\n        //    newAddress -= chrRamStart;\n        //}\n        return this.chrRom[newAddress];\n    };\n    BaseCart.prototype.SetPPUByte = function (clock, address, data) {\n        var bank = address >> 10; //, 1024)) | 0;\n        var newAddress = this.bankStartCache[(this.CurrentBank << 4) + bank] + (address & 1023); // ppuBankStarts[bank] + (address & 0x3FF);\n        this.chrRom[newAddress] = data;\n    };\n    BaseCart.prototype.SetupBankStarts = function (reg8, regA, regC, regE) {\n        reg8 = this.MaskBankAddress(reg8);\n        regA = this.MaskBankAddress(regA);\n        regC = this.MaskBankAddress(regC);\n        regE = this.MaskBankAddress(regE);\n        this.current8 = reg8;\n        this.currentA = regA;\n        this.currentC = regC;\n        this.currentE = regE;\n        this.bank8start = reg8 * 8192;\n        this.bankAstart = regA * 8192;\n        this.bankCstart = regC * 8192;\n        this.bankEstart = regE * 8192;\n    };\n    BaseCart.prototype.MaskBankAddress = function (bank) {\n        if (bank >= this.prgRomCount * 2) {\n            var i = 255;\n            while ((bank & i) >= this.prgRomCount * 2) {\n                i = i >> 1;\n            }\n            return (bank & i);\n        }\n        else {\n            return bank;\n        }\n    };\n    BaseCart.prototype.WriteState = function (state) {\n        // throw new Error('Method not implemented.');\n    };\n    BaseCart.prototype.ReadState = function (state) {\n        // throw new Error('Method not implemented.');\n    };\n    BaseCart.prototype.HandleEvent = function (Clock) {\n        //  throw new Error('Method not implemented.');\n    };\n    BaseCart.prototype.ResetClock = function (Clock) {\n        // throw new Error('Method not implemented.');\n    };\n    BaseCart.prototype.ResetBankStartCache = function () {\n        // if (currentBank > 0)\n        this.CurrentBank = 0;\n        // Array.Clear(bankStartCache, 0, 16 * 256 * 256);\n        //System.Array.copy(this.ppuBankStarts, 0, this.bankStartCache, 0, 16);\n        this.bankStartCache.fill(0);\n        for (var i = 0; i < 16; ++i) {\n            this.bankStartCache[i] = this.ppuBankStarts[i];\n        }\n        //Mirror(-1, this.mirroring);\n        //chrRamStart = ppuBankStarts[8];\n        //Array.Copy(ppuBankStarts, 0, bankStartCache[0], 0, 16 * 4);\n        //bankSwitchesChanged = false;\n    };\n    BaseCart.prototype.UpdateBankStartCache = function () {\n        this.CurrentBank = (this.CurrentBank + 1) | 0;\n        for (var i = 0; i < 16; ++i) {\n            this.bankStartCache[(this.CurrentBank * 16) + i] = this.ppuBankStarts[i];\n        }\n        //System.Array.copy(this.ppuBankStarts, 0, this.bankStartCache, this.CurrentBank * 16, 16);\n        this.Whizzler.UpdatePixelInfo();\n        return this.CurrentBank;\n    };\n    BaseCart.prototype.ActualChrRomOffset = function (address) {\n        var bank = address >> 10 | 0;\n        //int newAddress = ppuBankStarts[bank] + (address & 0x3FF);\n        var newAddress = (this.bankStartCache[(this.CurrentBank * 16) + bank] + (address & 1023));\n        return newAddress;\n    };\n    BaseCart.prototype.Mirror = function (clockNum, mirroring) {\n        //    //            A11 A10 Effect\n        //    //----------------------------------------------------------\n        //    // 0   0  All four screen buffers are mapped to the same\n        //    //        area of memory which repeats at $2000, $2400,\n        //    //        $2800, and $2C00.\n        //    // 0   x  \"Upper\" and \"lower\" screen buffers are mapped to\n        //    //        separate areas of memory at $2000, $2400 and\n        //    //        $2800, $2C00. ( horizontal mirroring)\n        //    // x   0  \"Left\" and \"right\" screen buffers are mapped to\n        //    //        separate areas of memory at $2000, $2800 and\n        //    //        $2400,$2C00.  (vertical mirroring)\n        //    // x   x  All four screen buffers are mapped to separate\n        //    //        areas of memory. In this case, the cartridge\n        //    //        must contain 2kB of additional VRAM (i got vram up the wazoo)\n        //    // 0xC00 = 110000000000\n        //    // 0x800 = 100000000000\n        //    // 0x400 = 010000000000\n        //    // 0x000 = 000000000000\n        //if (this.debugging) {\n        //    this.DebugEvents.add(($t = new ChiChiNES.CartDebugEvent(), $t.Clock = clockNum, $t.EventType = System.String.format(\"Mirror set to {0}\", mirroring), $t));\n        //}\n        //if (mirroring == this.mirroring) return;\n        this.mirroring = mirroring;\n        if (clockNum > -1) {\n            this.Whizzler.DrawTo(clockNum);\n        }\n        //Console.WriteLine(\"Mirroring set to {0}\", mirroring);\n        switch (mirroring) {\n            case 0:\n                this.ppuBankStarts[8] = (((this.chrRamStart + 0) | 0) + this.oneScreenOffset) | 0;\n                this.ppuBankStarts[9] = (((this.chrRamStart + 0) | 0) + this.oneScreenOffset) | 0;\n                this.ppuBankStarts[10] = (((this.chrRamStart + 0) | 0) + this.oneScreenOffset) | 0;\n                this.ppuBankStarts[11] = (((this.chrRamStart + 0) | 0) + this.oneScreenOffset) | 0;\n                break;\n            case 1:\n                this.ppuBankStarts[8] = (this.chrRamStart + 0) | 0;\n                this.ppuBankStarts[9] = (this.chrRamStart + 1024) | 0;\n                this.ppuBankStarts[10] = (this.chrRamStart + 0) | 0;\n                this.ppuBankStarts[11] = (this.chrRamStart + 1024) | 0;\n                break;\n            case 2:\n                this.ppuBankStarts[8] = (this.chrRamStart + 0) | 0;\n                this.ppuBankStarts[9] = (this.chrRamStart + 0) | 0;\n                this.ppuBankStarts[10] = (this.chrRamStart + 1024) | 0;\n                this.ppuBankStarts[11] = (this.chrRamStart + 1024) | 0;\n                break;\n            case 3:\n                this.ppuBankStarts[8] = (this.chrRamStart + 0) | 0;\n                this.ppuBankStarts[9] = (this.chrRamStart + 1024) | 0;\n                this.ppuBankStarts[10] = (this.chrRamStart + 2048) | 0;\n                this.ppuBankStarts[11] = (this.chrRamStart + 3072) | 0;\n                break;\n        }\n        this.UpdateBankStartCache();\n        this.Whizzler.UpdatePixelInfo();\n    };\n    BaseCart.prototype.InitializeCart = function () {\n        //throw new Error('Method not implemented.');\n    };\n    BaseCart.prototype.UpdateScanlineCounter = function () {\n        //throw new Error('Method not implemented.');\n    };\n    return BaseCart;\n}());\nexports.BaseCart = BaseCart;\nvar NesCart = /** @class */ (function (_super) {\n    __extends(NesCart, _super);\n    function NesCart() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    //PPUBankStarts: any;\n    NesCart.prototype.InitializeCart = function () {\n        //for (var i = 0; i < 8; i = (i + 1) | 0) {\n        //    this.prevBSSrc[i] = -1;\n        //}\n        //SRAMEnabled = SRAMCanSave;\n        switch (this.mapperId) {\n            case 0:\n                this.mapperName = 'NROM';\n                break;\n            case 1:\n                this.mapperName = 'MMC1';\n                break;\n            case 2:\n                this.mapperName = 'UxROM';\n                break;\n            case 3:\n                this.mapperName = 'CNROM';\n                break;\n        }\n        switch (this.mapperId) {\n            case 0:\n            case 1:\n            case 2:\n            case 3:\n                if (this.chrRomCount > 0) {\n                    this.CopyBanks(0, 0, 0, 1);\n                }\n                this.SetupBankStarts(0, 1, (this.prgRomCount * 2) - 2, (this.prgRomCount * 2) - 1);\n                break;\n            default:\n                throw new Error(\"Mapper \" + (this.mapperId.toString() || \"\") + \" not implemented.\");\n        }\n    };\n    NesCart.prototype.CopyBanks = function (clock, dest, src, numberOf8kBanks) {\n        if (dest >= this.chrRomCount) {\n            dest = (this.chrRomCount - 1) | 0;\n        }\n        var oneKsrc = src << 3;\n        var oneKdest = dest << 3;\n        //TODO: get whizzler reading ram from INesCart.GetPPUByte then be calling this\n        //  setup ppuBankStarts in 0x400 block chunks \n        for (var i = 0; i < (numberOf8kBanks << 3); i = (i + 1) | 0) {\n            this.ppuBankStarts[((oneKdest + i) | 0)] = (oneKsrc + i) * 1024;\n        }\n        this.UpdateBankStartCache();\n    };\n    NesCart.prototype.SetByte = function (clock, address, val) {\n        if (address >= 24576 && address <= 32767) {\n            if (this.SRAMEnabled) {\n                this.prgRomBank6[address & 8191] = val & 255;\n            }\n            return;\n        }\n        if (this.mapperId === 7) {\n            // val selects which bank to swap, 32k at a time\n            var newbank8 = 0;\n            newbank8 = (val & 15) << 2;\n            this.SetupBankStarts(newbank8, ((newbank8 + 1) | 0), ((newbank8 + 2) | 0), ((newbank8 + 3) | 0));\n            // whizzler.DrawTo(clock);\n            if ((val & 16) === 16) {\n                this.OneScreenOffset = 1024;\n            }\n            else {\n                this.OneScreenOffset = 0;\n            }\n            this.Mirror(clock, 0);\n        }\n        if (this.mapperId === 3 && address >= 32768) {\n            this.CopyBanks(clock, 0, val, 1);\n        }\n        if (this.mapperId === 2 && address >= 32768) {\n            var newbank81 = 0;\n            newbank81 = val * 2;\n            // keep two high banks, swap low banks\n            // SetupBanks(newbank8, newbank8 + 1, currentC, currentE);\n            this.SetupBankStarts(newbank81, ((newbank81 + 1) | 0), this.currentC, this.currentE);\n        }\n    };\n    return NesCart;\n}(BaseCart));\nexports.NesCart = NesCart;\n//  Mapper 7\nvar AxROMCart = /** @class */ (function (_super) {\n    __extends(AxROMCart, _super);\n    function AxROMCart() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    // PPUBankStarts: any;\n    AxROMCart.prototype.InitializeCart = function () {\n        this.mapperName = 'AxROM';\n        this.SetupBankStarts(0, 1, 2, 3);\n        this.Mirror(0, 0);\n    };\n    AxROMCart.prototype.CopyBanks = function (clock, dest, src, numberOf8kBanks) {\n        if (dest >= this.chrRomCount) {\n            dest = (this.chrRomCount - 1) | 0;\n        }\n        var oneKsrc = src << 3;\n        var oneKdest = dest << 3;\n        //TODO: get whizzler reading ram from INesCart.GetPPUByte then be calling this\n        //  setup ppuBankStarts in 0x400 block chunks \n        for (var i = 0; i < (numberOf8kBanks << 3); i = (i + 1) | 0) {\n            this.ppuBankStarts[((oneKdest + i) | 0)] = (oneKsrc + i) * 1024;\n        }\n        this.UpdateBankStartCache();\n    };\n    AxROMCart.prototype.SetByte = function (clock, address, val) {\n        if (address >= 24576 && address <= 32767) {\n            if (this.SRAMEnabled) {\n                this.prgRomBank6[address & 8191] = val & 255;\n            }\n            return;\n        }\n        // val selects which bank to swap, 32k at a time\n        var newbank8 = 0;\n        newbank8 = (val & 15) << 2;\n        // this.Whizzler.DrawTo(clock);\n        this.SetupBankStarts(newbank8, ((newbank8 + 1) | 0), ((newbank8 + 2) | 0), ((newbank8 + 3) | 0));\n        // whizzler.DrawTo(clock);\n        if ((val & 16) === 16) {\n            this.OneScreenOffset = 1024;\n        }\n        else {\n            this.OneScreenOffset = 0;\n        }\n        this.Mirror(clock, 0);\n    };\n    return AxROMCart;\n}(BaseCart));\nexports.AxROMCart = AxROMCart;\nvar NsfCart = /** @class */ (function (_super) {\n    __extends(NsfCart, _super);\n    function NsfCart() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.loadNsfAt = 0;\n        _this.bank_select = 0;\n        _this.rams = new Uint8Array(0xFFFFFFFF);\n        return _this;\n    }\n    NsfCart.prototype.InitializeCart = function () {\n        this.mapperName = 'NSF';\n    };\n    NsfCart.prototype.GetPPUByte = function (clock, address) {\n        return 0;\n    };\n    NsfCart.prototype.GetByte = function (clock, address) {\n        return this.rams[address];\n    };\n    NsfCart.prototype.__SetByte = function (address, data) {\n        var bank = 0;\n        this.rams[address] = data;\n    };\n    NsfCart.prototype.LoadNSFFile = function (header, prgRoms, chrRoms, prgRomData, chrRomData, chrRomOffset) {\n        this.mapperId = -1;\n        //        $000    5   STRING  'N', 'E', 'S', 'M', $1A(denotes an NES sound format file)\n        //        $005    1   BYTE    Version number (currently $01)\n        //        $006    1   BYTE    Total songs   (1 = 1 song, 2 = 2 songs, etc)\n        //        $007    1   BYTE    Starting song (1 = 1st song, 2 = 2nd song, etc)\n        //        $008    2   WORD    (lo, hi) load address of data ($8000 - FFFF)\n        //        $00A    2   WORD    (lo, hi) init address of data ($8000 - FFFF)\n        //        $00C    2   WORD    (lo, hi) play address of data ($8000 - FFFF)\n        //        $00E    32  STRING  The name of the song, null terminated\n        //        $02E    32  STRING  The artist, if known, null terminated\n        //        $04E    32  STRING  The copyright holder, null terminated\n        //        $06E    2   WORD    (lo, hi) Play speed, in 1 / 1000000th sec ticks, NTSC(see text)\n        //        $070    8   BYTE    Bankswitch init values (see text, and FDS section)\n        //        $078    2   WORD    (lo, hi) Play speed, in 1 / 1000000th sec ticks, PAL(see text)\n        //        $07A    1   BYTE    PAL/ NTSC bits\n        //        bit 0: if clear, this is an NTSC tune\n        //        bit 0: if set, this is a PAL tune\n        //        bit 1: if set, this is a dual PAL/ NTSC tune\n        //        bits 2- 7: not used.they * must * be 0\n        //        $07B    1   BYTE    Extra Sound Chip Support\n        //        bit 0: if set, this song uses VRC6 audio\n        //        bit 1: if set, this song uses VRC7 audio\n        //        bit 2: if set, this song uses FDS audio\n        //        bit 3: if set, this song uses MMC5 audio\n        //        bit 4: if set, this song uses Namco 163 audio\n        //        bit 5: if set, this song uses Sunsoft 5B audio\n        //        bits 6, 7: future expansion: they * must * be 0\n        //        $07C    1   BYTE    Extra Sound Chip Support (Cont.)\n        //        bits 0- 3: future expansion: they * must * be 0\n        //        bits 4- 7: unavailable(conflicts with NSF2 backwards compatibility)\n        //        $07D    3   ----    3 extra bytes for expansion (must be $00)\n        //        $080    nnn ----    The music program/ data follows until end of file\n        this.prgRomCount = prgRoms;\n        this.chrRomCount = chrRoms;\n        this.SetupBankStarts(0, 1, 3, 4);\n        this.songCount = header[0x06];\n        this.firstSong = header[0x07];\n        this.loadNsfAt = (header[0x09] << 8) + header[0x08];\n        this.initNsfAt = (header[0x0B] << 8) + header[0x0A];\n        this.runNsfAt = (header[0x0D] << 8) + header[0x0C];\n        this.songName = header.slice(0x0E, 0x0e + 32).map(function (v) { return String.fromCharCode(v); }).join('').trim();\n        this.artist = header.slice(0x02E, 0x0e + 32).map(function (v) { return String.fromCharCode(v); }).join('').trim();\n        this.copyright = header.slice(0x4E, 0x0e + 32).map(function (v) { return String.fromCharCode(v); }).join('').trim();\n        var address = this.loadNsfAt;\n        for (var i = 0; i < prgRomData.length - 0x80; ++i) {\n            this.__SetByte(address + i, prgRomData[0x80 + i]);\n        }\n        // set init code at reset spot\n        this.__SetByte(0xFFFC, header[0x0A]);\n        this.__SetByte(0xFFFD, header[0x0B]); // << 8)\n        this.prgRomCount = prgRomData.length / 1024;\n        this.chrRomCount = 0; //this.iNesHeader[5];\n        this.SRAMEnabled = true;\n        this.checkSum = \"\"; //ROMHashFunction(nesCart, chrRom);\n        this.InitializeCart();\n    };\n    return NsfCart;\n}(BaseCart));\nexports.NsfCart = NsfCart;\nvar MMC1Cart = /** @class */ (function (_super) {\n    __extends(MMC1Cart, _super);\n    function MMC1Cart() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.lastClock = 0;\n        _this.sequence = 0;\n        _this.accumulator = 0;\n        _this.bank_select = 0;\n        _this._registers = new Array(4);\n        _this.lastwriteAddress = 0;\n        return _this;\n    }\n    MMC1Cart.prototype.InitializeCart = function () {\n        this.mapperName = 'MMC1';\n        if (this.chrRomCount > 0) {\n            this.CopyBanks(0, 0, 4);\n        }\n        this._registers[0] = 12;\n        this._registers[1] = 0;\n        this._registers[2] = 0;\n        this._registers[3] = 0;\n        this.SetupBankStarts(0, 1, ((this.prgRomCount * 2 - 2) | 0), ((this.prgRomCount * 2 - 1) | 0));\n        this.sequence = 0;\n        this.accumulator = 0;\n    };\n    MMC1Cart.prototype.MaskBankAddress$1 = function (bank) {\n        if (bank >= (this.prgRomCount << 1)) {\n            var i;\n            i = 255;\n            while ((bank & i) >= this.prgRomCount * 2) {\n                i = (i >> 1) & 255;\n            }\n            return (bank & i);\n        }\n        else {\n            return bank;\n        }\n    };\n    MMC1Cart.prototype.CopyBanks = function (dest, src, numberOf4kBanks) {\n        if (this.chrRomCount > 0) {\n            var oneKdest = dest * 4;\n            var oneKsrc = src * 4;\n            //TODO: get whizzler reading ram from INesCart.GetPPUByte then be calling this\n            //  setup ppuBankStarts in 0x400 block chunks \n            for (var i = 0; i < (numberOf4kBanks << 2); i = (i + 1) | 0) {\n                this.ppuBankStarts[((oneKdest + i) | 0)] = (((oneKsrc + i) | 0)) << 10;\n            }\n            //Array.Copy(chrRom, src * 0x1000, whizzler.cartCopyVidRAM, dest * 0x1000, numberOf4kBanks * 0x1000);\n        }\n        this.UpdateBankStartCache();\n    };\n    MMC1Cart.prototype.SetByte = function (clock, address, val) {\n        // if write is to a different register, reset\n        this.lastClock = clock;\n        switch (address & 61440) {\n            case 24576:\n            case 28672:\n                this.prgRomBank6[address & 8191] = val & 255;\n                break;\n            default:\n                this.lastwriteAddress = address;\n                if ((val & 128) === 128) {\n                    this._registers[0] = this._registers[0] | 12;\n                    this.accumulator = 0; // _registers[(address / 0x2000) & 3];\n                    this.sequence = 0;\n                }\n                else {\n                    if ((val & 1) === 1) {\n                        this.accumulator = this.accumulator | (1 << this.sequence);\n                    }\n                    this.sequence = (this.sequence + 1) | 0;\n                }\n                if (this.sequence === 5) {\n                    var regnum = (address & 32767) >> 13;\n                    this._registers[(address & 32767) >> 13] = this.accumulator;\n                    this.sequence = 0;\n                    this.accumulator = 0;\n                    switch (regnum) {\n                        case 0:\n                            this.SetMMC1Mirroring(clock);\n                            break;\n                        case 1:\n                        case 2:\n                            this.SetMMC1ChrBanking(clock);\n                            break;\n                        case 3:\n                            this.SetMMC1PrgBanking();\n                            break;\n                    }\n                }\n                break;\n        }\n    };\n    MMC1Cart.prototype.SetMMC1ChrBanking = function (clock) {\n        //\tbit 4 - sets 8KB or 4KB CHRROM switching mode\n        // 0 = 8KB CHRROM banks, 1 = 4KB CHRROM banks\n        this.Whizzler.DrawTo(clock);\n        if ((this._registers[0] & 16) === 16) {\n            this.CopyBanks(0, this._registers[1], 1);\n            this.CopyBanks(1, this._registers[2], 1);\n        }\n        else {\n            //CopyBanks(0, _registers[1], 2);\n            this.CopyBanks(0, this._registers[1], 1);\n            this.CopyBanks(1, ((this._registers[1] + 1) | 0), 1);\n        }\n        this.bankSwitchesChanged = true;\n        this.Whizzler.UpdatePixelInfo();\n    };\n    MMC1Cart.prototype.SetMMC1PrgBanking = function () {\n        var reg = 0;\n        if (this.prgRomCount === 32) {\n            this.bank_select = (this._registers[1] & 16) << 1;\n        }\n        else {\n            this.bank_select = 0;\n        }\n        if ((this._registers[0] & 8) === 0) {\n            reg = (4 * ((this._registers[3] >> 1) & 15) + this.bank_select) | 0;\n            this.SetupBankStarts(reg, ((reg + 1) | 0), ((reg + 2) | 0), ((reg + 3) | 0));\n        }\n        else {\n            reg = (2 * (this._registers[3]) + this.bank_select) | 0;\n            //bit 2 - toggles between low PRGROM area switching and high\n            //PRGROM area switching\n            //0 = high PRGROM switching, 1 = low PRGROM switching\n            if ((this._registers[0] & 4) === 4) {\n                // select 16k bank in register 3 (setupbankstarts switches 8k banks)\n                this.SetupBankStarts(reg, ((reg + 1) | 0), (((this.prgRomCount << 1) - 2) | 0), (((this.prgRomCount << 1) - 1) | 0));\n                //SetupBanks(reg8, reg8 + 1, 0xFE, 0xFF);\n            }\n            else {\n                this.SetupBankStarts(0, 1, reg, ((reg + 1) | 0));\n            }\n        }\n    };\n    MMC1Cart.prototype.SetMMC1Mirroring = function (clock) {\n        //bit 1 - toggles between H/V and \"one-screen\" mirroring\n        //0 = one-screen mirroring, 1 = H/V mirroring\n        this.Whizzler.DrawTo(clock);\n        switch (this._registers[0] & 3) {\n            case 0:\n                this.oneScreenOffset = 0;\n                this.Mirror(clock, 0);\n                break;\n            case 1:\n                this.oneScreenOffset = 1024;\n                this.Mirror(clock, 0);\n                break;\n            case 2:\n                this.Mirror(clock, 1); // vertical\n                break;\n            case 3:\n                this.Mirror(clock, 2); // horizontal\n                break;\n        }\n        this.bankSwitchesChanged = true;\n        this.Whizzler.UpdatePixelInfo();\n    };\n    return MMC1Cart;\n}(BaseCart));\nexports.MMC1Cart = MMC1Cart;\nvar MMC2Cart = /** @class */ (function (_super) {\n    __extends(MMC2Cart, _super);\n    function MMC2Cart() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.lastClock = 0;\n        _this.sequence = 0;\n        _this.accumulator = 0;\n        _this.bank_select = 0;\n        _this._registers = new Array(4);\n        _this.lastwriteAddress = 0;\n        return _this;\n    }\n    MMC2Cart.prototype.InitializeCart = function () {\n        this.mapperName = 'MMC2';\n        if (this.chrRomCount > 0) {\n            this.CopyBanks(0, 0, 4);\n        }\n        this._registers[0] = 12;\n        this._registers[1] = 0;\n        this._registers[2] = 0;\n        this._registers[3] = 0;\n        this.SetupBankStarts(0, 1, ((this.prgRomCount * 2 - 2) | 0), ((this.prgRomCount * 2 - 1) | 0));\n        this.sequence = 0;\n        this.accumulator = 0;\n    };\n    MMC2Cart.prototype.MaskBankAddress$1 = function (bank) {\n        if (bank >= (this.prgRomCount << 1)) {\n            var i;\n            i = 255;\n            while ((bank & i) >= this.prgRomCount * 2) {\n                i = (i >> 1) & 255;\n            }\n            return (bank & i);\n        }\n        else {\n            return bank;\n        }\n    };\n    MMC2Cart.prototype.CopyBanks = function (dest, src, numberOf4kBanks) {\n        if (this.chrRomCount > 0) {\n            var oneKdest = dest * 4;\n            var oneKsrc = src * 4;\n            //TODO: get whizzler reading ram from INesCart.GetPPUByte then be calling this\n            //  setup ppuBankStarts in 0x400 block chunks \n            for (var i = 0; i < (numberOf4kBanks << 2); i = (i + 1) | 0) {\n                this.ppuBankStarts[((oneKdest + i) | 0)] = (((oneKsrc + i) | 0)) << 10;\n            }\n            //Array.Copy(chrRom, src * 0x1000, whizzler.cartCopyVidRAM, dest * 0x1000, numberOf4kBanks * 0x1000);\n        }\n        this.UpdateBankStartCache();\n    };\n    MMC2Cart.prototype.SetByte = function (clock, address, val) {\n        // if write is to a different register, reset\n        this.lastClock = clock;\n        switch (address & 61440) {\n            case 24576:\n            case 28672:\n                this.prgRomBank6[address & 8191] = val & 255;\n                break;\n            default:\n                this.lastwriteAddress = address;\n                if ((val & 128) === 128) {\n                    this._registers[0] = this._registers[0] | 12;\n                    this.accumulator = 0; // _registers[(address / 0x2000) & 3];\n                    this.sequence = 0;\n                }\n                else {\n                    if ((val & 1) === 1) {\n                        this.accumulator = this.accumulator | (1 << this.sequence);\n                    }\n                    this.sequence = (this.sequence + 1) | 0;\n                }\n                if (this.sequence === 5) {\n                    var regnum = (address & 32767) >> 13;\n                    this._registers[(address & 32767) >> 13] = this.accumulator;\n                    this.sequence = 0;\n                    this.accumulator = 0;\n                    switch (regnum) {\n                        case 0:\n                            this.SetMMC2Mirroring(clock);\n                            break;\n                        case 1:\n                        case 2:\n                            this.SetMMC2ChrBanking(clock);\n                            break;\n                        case 3:\n                            this.SetMMC2PrgBanking();\n                            break;\n                    }\n                }\n                break;\n        }\n    };\n    MMC2Cart.prototype.SetMMC2ChrBanking = function (clock) {\n        //\tbit 4 - sets 8KB or 4KB CHRROM switching mode\n        // 0 = 8KB CHRROM banks, 1 = 4KB CHRROM banks\n        this.Whizzler.DrawTo(clock);\n        if ((this._registers[0] & 16) === 16) {\n            this.CopyBanks(0, this._registers[1], 1);\n            this.CopyBanks(1, this._registers[2], 1);\n        }\n        else {\n            //CopyBanks(0, _registers[1], 2);\n            this.CopyBanks(0, this._registers[1], 1);\n            this.CopyBanks(1, ((this._registers[1] + 1) | 0), 1);\n        }\n        this.bankSwitchesChanged = true;\n        this.Whizzler.UpdatePixelInfo();\n    };\n    MMC2Cart.prototype.SetMMC2PrgBanking = function () {\n        var reg = 0;\n        if (this.prgRomCount === 32) {\n            this.bank_select = (this._registers[1] & 16) << 1;\n        }\n        else {\n            this.bank_select = 0;\n        }\n        if ((this._registers[0] & 8) === 0) {\n            reg = (4 * ((this._registers[3] >> 1) & 15) + this.bank_select) | 0;\n            this.SetupBankStarts(reg, ((reg + 1) | 0), ((reg + 2) | 0), ((reg + 3) | 0));\n        }\n        else {\n            reg = (2 * (this._registers[3]) + this.bank_select) | 0;\n            //bit 2 - toggles between low PRGROM area switching and high\n            //PRGROM area switching\n            //0 = high PRGROM switching, 1 = low PRGROM switching\n            if ((this._registers[0] & 4) === 4) {\n                // select 16k bank in register 3 (setupbankstarts switches 8k banks)\n                this.SetupBankStarts(reg, ((reg + 1) | 0), (((this.prgRomCount << 1) - 2) | 0), (((this.prgRomCount << 1) - 1) | 0));\n                //SetupBanks(reg8, reg8 + 1, 0xFE, 0xFF);\n            }\n            else {\n                this.SetupBankStarts(0, 1, reg, ((reg + 1) | 0));\n            }\n        }\n    };\n    MMC2Cart.prototype.SetMMC2Mirroring = function (clock) {\n        //bit 1 - toggles between H/V and \"one-screen\" mirroring\n        //0 = one-screen mirroring, 1 = H/V mirroring\n        this.Whizzler.DrawTo(clock);\n        switch (this._registers[0] & 3) {\n            case 0:\n                this.oneScreenOffset = 0;\n                this.Mirror(clock, 0);\n                break;\n            case 1:\n                this.oneScreenOffset = 1024;\n                this.Mirror(clock, 0);\n                break;\n            case 2:\n                this.Mirror(clock, 1); // vertical\n                break;\n            case 3:\n                this.Mirror(clock, 2); // horizontal\n                break;\n        }\n        this.bankSwitchesChanged = true;\n        this.Whizzler.UpdatePixelInfo();\n    };\n    return MMC2Cart;\n}(BaseCart));\nexports.MMC2Cart = MMC2Cart;\nvar MMC3Cart = /** @class */ (function (_super) {\n    __extends(MMC3Cart, _super);\n    function MMC3Cart() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this._registers = new Uint8Array(4);\n        _this.chr2kBank0 = 0;\n        _this.chr2kBank1 = 1;\n        _this.chr1kBank0 = 0;\n        _this.chr1kBank1 = 0;\n        _this.chr1kBank2 = 0;\n        _this.chr1kBank3 = 0;\n        _this.prgSwap = 0;\n        _this.prgSwitch1 = 0;\n        _this.prgSwitch2 = 0;\n        _this.prevBSSrc = new Uint8Array(8);\n        _this._mmc3Command = 0;\n        _this._mmc3ChrAddr = 0;\n        _this._mmc3IrqVal = 0;\n        _this._mmc3TmpVal = 0;\n        _this.scanlineCounter = 0;\n        _this._mmc3IrcOn = false;\n        _this.ppuBankSwap = false;\n        _this.PPUBanks = new Uint32Array(8);\n        return _this;\n    }\n    MMC3Cart.prototype.InitializeCart = function () {\n        this.mapperName = 'MMC3';\n        this._registers.fill(0);\n        this.PPUBanks.fill(0);\n        this.prevBSSrc.fill(0);\n        this.prgSwap = 1;\n        //SetupBanks(0, 1, 0xFE, 0xFF);\n        this.prgSwitch1 = 0;\n        this.prgSwitch2 = 1;\n        this.SwapPrgRomBanks();\n        this._mmc3IrqVal = 0;\n        this._mmc3IrcOn = false;\n        this._mmc3TmpVal = 0;\n        this.chr2kBank0 = 0;\n        this.chr2kBank1 = 0;\n        this.chr1kBank0 = 0;\n        this.chr1kBank1 = 0;\n        this.chr1kBank2 = 0;\n        this.chr1kBank3 = 0;\n        if (this.chrRomCount > 0) {\n            this.CopyBanks(0, 0, 8);\n        }\n    };\n    MMC3Cart.prototype.MaskBankAddress = function (bank) {\n        if (bank >= this.prgRomCount * 2) {\n            var i = 255;\n            while ((bank & i) >= this.prgRomCount * 2) {\n                i = i >> 1;\n            }\n            return (bank & i);\n        }\n        else {\n            return bank;\n        }\n    };\n    MMC3Cart.prototype.CopyBanks = function (dest, src, numberOf1kBanks) {\n        var $t;\n        if (this.chrRomCount > 0) {\n            for (var i = 0; i < numberOf1kBanks; i = (i + 1) | 0) {\n                this.ppuBankStarts[((dest + i) | 0)] = (src + i) * 1024;\n            }\n            this.bankSwitchesChanged = true;\n            //Array.Copy(chrRom, src * 0x400, whizzler.cartCopyVidRAM, dest * 0x400, numberOf1kBanks * 0x400);\n        }\n    };\n    MMC3Cart.prototype.SetByte = function (clock, address, val) {\n        if (address >= 24576 && address < 32768) {\n            if (this.SRAMEnabled && this.SRAMCanWrite) {\n                this.prgRomBank6[address & 8191] = val & 255;\n            }\n            return;\n        }\n        //Bank select ($8000-$9FFE, even)\n        //7  bit  0\n        //---- ----\n        //CPxx xRRR\n        //||    |||\n        //||    +++- Specify which bank register to update on next write to Bank Data register\n        //_mmc3Command\n        //||         0: Select 2 KB CHR bank at PPU $0000-$07FF (or $1000-$17FF);\n        //||         1: Select 2 KB CHR bank at PPU $0800-$0FFF (or $1800-$1FFF);\n        //||         2: Select 1 KB CHR bank at PPU $1000-$13FF (or $0000-$03FF);\n        //||         3: Select 1 KB CHR bank at PPU $1400-$17FF (or $0400-$07FF);\n        //||         4: Select 1 KB CHR bank at PPU $1800-$1BFF (or $0800-$0BFF);\n        //||         5: Select 1 KB CHR bank at PPU $1C00-$1FFF (or $0C00-$0FFF);\n        //||         6: Select 8 KB PRG bank at $8000-$9FFF (or $C000-$DFFF);\n        //||         7: Select 8 KB PRG bank at $A000-$BFFF\n        //|+-------- PRG ROM bank configuration (0: $8000-$9FFF swappable, $C000-$DFFF fixed to second-last bank;\n        //|                                      1: $C000-$DFFF swappable, $8000-$9FFF fixed to second-last bank)\n        //+--------- CHR ROM bank configuration (0: two 2 KB banks at $0000-$0FFF, four 1 KB banks at $1000-$1FFF;\n        //                                       1: four 1 KB banks at $0000-$0FFF, two 2 KB banks at $1000-$1FFF)\n        switch (address & 57345) {\n            case 32768:\n                this._mmc3Command = val & 7;\n                if ((val & 128) === 128) {\n                    this.ppuBankSwap = true;\n                    this._mmc3ChrAddr = 4096;\n                }\n                else {\n                    this.ppuBankSwap = false;\n                    this._mmc3ChrAddr = 0;\n                }\n                if ((val & 64) === 64) {\n                    this.prgSwap = 1;\n                }\n                else {\n                    this.prgSwap = 0;\n                }\n                this.SwapPrgRomBanks();\n                break;\n            case 32769:\n                switch (this._mmc3Command) {\n                    case 0:\n                        this.chr2kBank0 = val;\n                        this.SwapChrBanks();\n                        // CopyBanks(0, val, 1);\n                        // CopyBanks(1, val + 1, 1);\n                        break;\n                    case 1:\n                        this.chr2kBank1 = val;\n                        this.SwapChrBanks();\n                        // CopyBanks(2, val, 1);\n                        // CopyBanks(3, val + 1, 1);\n                        break;\n                    case 2:\n                        this.chr1kBank0 = val;\n                        this.SwapChrBanks();\n                        //CopyBanks(4, val, 1);\n                        break;\n                    case 3:\n                        this.chr1kBank1 = val;\n                        this.SwapChrBanks();\n                        //CopyBanks(5, val, 1);\n                        break;\n                    case 4:\n                        this.chr1kBank2 = val;\n                        this.SwapChrBanks();\n                        //CopyBanks(6, val, 1);\n                        break;\n                    case 5:\n                        this.chr1kBank3 = val;\n                        this.SwapChrBanks();\n                        //CopyBanks(7, val, 1);\n                        break;\n                    case 6:\n                        this.prgSwitch1 = val;\n                        this.SwapPrgRomBanks();\n                        break;\n                    case 7:\n                        this.prgSwitch2 = val;\n                        this.SwapPrgRomBanks();\n                        break;\n                }\n                break;\n            case 40960:\n                if ((val & 1) === 1) {\n                    this.Mirror(clock, 2);\n                }\n                else {\n                    this.Mirror(clock, 1);\n                }\n                break;\n            case 40961:\n                //PRG RAM protect ($A001-$BFFF, odd)\n                //7  bit  0\n                //---- ----\n                //RWxx xxxx\n                //||\n                //|+-------- Write protection (0: allow writes; 1: deny writes)\n                //+--------- Chip enable (0: disable chip; 1: enable chip)\n                this.SRAMCanWrite = ((val & 64) === 0);\n                this.SRAMEnabled = ((val & 128) === 128);\n                break;\n            case 49152:\n                this._mmc3IrqVal = val;\n                if (val === 0) {\n                    // special treatment for one-time irq handling\n                    this.scanlineCounter = 0;\n                }\n                break;\n            case 49153:\n                this._mmc3TmpVal = this._mmc3IrqVal;\n                break;\n            case 57344:\n                this._mmc3IrcOn = false;\n                this._mmc3IrqVal = this._mmc3TmpVal;\n                this.irqRaised = false;\n                if (this.updateIRQ) {\n                    this.updateIRQ();\n                }\n                break;\n            case 57345:\n                this._mmc3IrcOn = true;\n                break;\n        }\n    };\n    MMC3Cart.prototype.SwapChrBanks = function () {\n        if (this.ppuBankSwap) {\n            this.CopyBanks(0, this.chr1kBank0, 1);\n            this.CopyBanks(1, this.chr1kBank1, 1);\n            this.CopyBanks(2, this.chr1kBank2, 1);\n            this.CopyBanks(3, this.chr1kBank3, 1);\n            this.CopyBanks(4, this.chr2kBank0, 2);\n            this.CopyBanks(6, this.chr2kBank1, 2);\n        }\n        else {\n            this.CopyBanks(4, this.chr1kBank0, 1);\n            this.CopyBanks(5, this.chr1kBank1, 1);\n            this.CopyBanks(6, this.chr1kBank2, 1);\n            this.CopyBanks(7, this.chr1kBank3, 1);\n            this.CopyBanks(0, this.chr2kBank0, 2);\n            this.CopyBanks(2, this.chr2kBank1, 2);\n        }\n    };\n    MMC3Cart.prototype.SwapPrgRomBanks = function () {\n        //|+-------- PRG ROM bank configuration (0: $8000-$9FFF swappable, $C000-$DFFF fixed to second-last bank;\n        //|                                      1: $C000-$DFFF swappable, $8000-$9FFF fixed to second-last bank)\n        if (this.prgSwap === 1) {\n            this.SetupBankStarts(((this.prgRomCount * 2 - 2) | 0), this.prgSwitch2, this.prgSwitch1, ((this.prgRomCount * 2 - 1) | 0));\n        }\n        else {\n            this.SetupBankStarts(this.prgSwitch1, this.prgSwitch2, ((this.prgRomCount * 2 - 2) | 0), ((this.prgRomCount * 2 - 1) | 0));\n        }\n    };\n    MMC3Cart.prototype.UpdateScanlineCounter = function () {\n        //if (scanlineCounter == -1) return;\n        if (this.scanlineCounter === 0) {\n            this.scanlineCounter = this._mmc3IrqVal;\n            //Writing $00 to $C000 will result in a single IRQ being generated on the next rising edge of PPU A12. \n            //No more IRQs will be generated until $C000 is changed to a non-zero value, upon which the \n            // counter will start counting from the new value, generating an IRQ once it reaches zero. \n            if (this._mmc3IrqVal === 0) {\n                if (this._mmc3IrcOn) {\n                    this.irqRaised = true;\n                    this.updateIRQ();\n                }\n                this.scanlineCounter = -1;\n                return;\n            }\n        }\n        if (this._mmc3TmpVal !== 0) {\n            this.scanlineCounter = this._mmc3TmpVal;\n            this._mmc3TmpVal = 0;\n        }\n        else {\n            this.scanlineCounter = (((this.scanlineCounter - 1) | 0)) & 255;\n        }\n        if (this.scanlineCounter === 0) {\n            if (this._mmc3IrcOn) {\n                this.irqRaised = true;\n                if (this.updateIRQ) {\n                    this.updateIRQ();\n                }\n            }\n            if (this._mmc3IrqVal > 0) {\n                this.scanlineCounter = this._mmc3IrqVal;\n            }\n        }\n    };\n    return MMC3Cart;\n}(BaseCart));\nexports.MMC3Cart = MMC3Cart;\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ChiChiTypes_1 = __webpack_require__(0);\n// shared buffer to get sound out\nvar WavSharer = /** @class */ (function () {\n    function WavSharer() {\n        this.NES_BYTES_WRITTEN = 0;\n        this.WAVSHARER_BLOCKTHREAD = 1;\n        this.controlBuffer = new Int32Array(new SharedArrayBuffer(2 * Int32Array.BYTES_PER_ELEMENT));\n        this.sharedAudioBufferPos = 0;\n        this.SharedBufferLength = 8192;\n        this.SharedBuffer = new Float32Array(this.SharedBufferLength);\n    }\n    Object.defineProperty(WavSharer.prototype, \"audioBytesWritten\", {\n        get: function () {\n            return Atomics.load(this.controlBuffer, this.NES_BYTES_WRITTEN);\n        },\n        set: function (value) {\n            Atomics.store(this.controlBuffer, this.NES_BYTES_WRITTEN, value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    WavSharer.prototype.wakeSleepers = function () {\n        Atomics.wake(this.controlBuffer, this.NES_BYTES_WRITTEN, 99999);\n    };\n    WavSharer.prototype.synchronize = function () {\n        while (this.audioBytesWritten >= this.SharedBuffer.length >> 2) {\n            Atomics.wait(this.controlBuffer, this.NES_BYTES_WRITTEN, this.audioBytesWritten);\n        }\n    };\n    WavSharer.sample_size = 1;\n    return WavSharer;\n}());\nexports.WavSharer = WavSharer;\n//apu classes\nvar blip_buffer_t = /** @class */ (function () {\n    function blip_buffer_t(size) {\n        this.size = size;\n        this.factor = 0;\n        this.offset = 0;\n        this.avail = 0;\n        this.integrator = 0;\n        this.time_bits = 0;\n        this.arrayLength = 0;\n        this.samples = new Array(size);\n        this.samples.fill(0);\n    }\n    return blip_buffer_t;\n}());\nvar Blip = /** @class */ (function () {\n    // functions\n    function Blip(size) {\n        this.bass_shift = 8;\n        this.end_frame_extra = 2;\n        this.half_width = 8;\n        this.phase_bits = 5;\n        this.blip_new(size);\n    }\n    Blip.prototype.blip_new = function (size) {\n        this.BlipBuffer = new blip_buffer_t(size);\n        this.BlipBuffer.size = size;\n        this.BlipBuffer.factor = 0;\n        this.blip_clear();\n    };\n    Blip.prototype.blip_set_rates = function (clock_rate, sample_rate) {\n        this.BlipBuffer.factor = Blip.time_unit / clock_rate * sample_rate + (0.9999847412109375);\n    };\n    Blip.prototype.blip_clear = function () {\n        this.BlipBuffer.offset = 0;\n        this.BlipBuffer.avail = 0;\n        this.BlipBuffer.integrator = 0;\n        this.BlipBuffer.samples = new Array(this.BlipBuffer.size + Blip.buf_extra);\n        this.BlipBuffer.samples.fill(0);\n    };\n    Blip.prototype.blip_clocks_needed = function (samples) {\n        var needed = samples * Blip.time_unit - this.BlipBuffer.offset;\n        /* Fails if buffer can't hold that many more samples */\n        //assert( s->avail + samples <= s->size );\n        return ((needed + this.BlipBuffer.factor - 1) / this.BlipBuffer.factor) | 0;\n    };\n    Blip.prototype.blip_end_frame = function (t) {\n        var off = t * this.BlipBuffer.factor + this.BlipBuffer.offset;\n        this.BlipBuffer.avail += off >> Blip.time_bits;\n        this.BlipBuffer.offset = off & (Blip.time_unit - 1);\n    };\n    Blip.prototype.remove_samples = function (count) {\n        var remain = this.BlipBuffer.avail + Blip.buf_extra - count;\n        this.BlipBuffer.avail -= count;\n        this.BlipBuffer.samples.copyWithin(0, count, count + remain);\n        //for (let i = 0; i < remain; i++) {\n        //     this.BlipBuffer.samples[count + i] = this.BlipBuffer.samples[i];\n        // }\n        this.BlipBuffer.samples.fill(0, remain, remain + count);\n        //for (let i = 0;i < count; ++i) {\n        //    this.BlipBuffer.samples[i + remain] = 0;\n        //} \n        //        this.BlipBuffer.samples = this\n        //        System.Array.copy(this._blipBuffer.samples, count, this._blipBuffer.samples, 0, remain);\n        //        System.Array.fill(this._blipBuffer.samples, 0, remain, count);\n        this.BlipBuffer.arrayLength = count;\n    };\n    Blip.prototype.ReadBytes = function (outbuf, count, stereo) {\n        if (count > this.BlipBuffer.avail) {\n            count = this.BlipBuffer.avail;\n        }\n        if (count !== 0) {\n            var step = 1;\n            //int inPtr  = BLIP_SAMPLES( s );\n            //buf_t const* end = in + count;\n            var inPtr = 0, outPtr = 0;\n            var endPtr = inPtr + count;\n            var sum = this.BlipBuffer.integrator;\n            do {\n                var st = sum >> Blip.delta_bits; /* assumes right shift preserves sign */\n                sum = sum + this.BlipBuffer.samples[inPtr];\n                inPtr++;\n                if (st !== st) {\n                    st = (st >> 31) ^ 32767;\n                }\n                var f = st / 65536; // (st/0xFFFF) * 2 - 1;\n                //if (f < -1) {\n                //    f = -1;\n                //}\n                //if (f > 1) {\n                //    f = 1;\n                //}\n                outbuf[outPtr] = f;\n                // outbuf[outPtr+ 1] = (byte)(st >> 8);\n                outPtr += step;\n                sum = sum - (st << (7));\n            } while (inPtr !== endPtr);\n            this.BlipBuffer.integrator = sum;\n            this.remove_samples(count);\n        }\n        return count;\n    };\n    // reads 'count' elements into array 'outbuf', beginning at 'start' and looping at array boundary if needed\n    // returns number of elements written\n    Blip.prototype.ReadElementsLoop = function (wavSharer) {\n        var outbuf = wavSharer.SharedBuffer;\n        var start = wavSharer.sharedAudioBufferPos;\n        var count = this.BlipBuffer.avail;\n        var inPtr = 0, outPtr = start;\n        var end = count;\n        var sum = this.BlipBuffer.integrator;\n        if (count !== 0) {\n            var step = 1;\n            do {\n                var st = sum >> Blip.delta_bits; /* assumes right shift preserves sign */\n                sum = sum + this.BlipBuffer.samples[inPtr];\n                inPtr++;\n                if (st !== st) {\n                    st = (st >> 31) ^ 32767;\n                }\n                var f = st / 65536; // (st/0xFFFF) * 2 - 1;\n                outPtr += step;\n                if (outPtr >= outbuf.length) {\n                    outPtr = 0;\n                }\n                outbuf[outPtr] = f;\n                // outbuf[outPtr+ 1] = (byte)(st >> 8);\n                sum = sum - (st << (7));\n            } while (end-- > 0);\n            this.BlipBuffer.integrator = sum;\n            this.remove_samples(count);\n        }\n        wavSharer.sharedAudioBufferPos = outPtr;\n        wavSharer.audioBytesWritten += count;\n        wavSharer.synchronize();\n        return count;\n    };\n    Blip.prototype.blip_add_delta = function (time, delta) {\n        if (delta === 0) {\n            return;\n        }\n        var fixedTime = (time * this.BlipBuffer.factor + this.BlipBuffer.offset) | 0;\n        var outPtr = (this.BlipBuffer.avail + (fixedTime >> Blip.time_bits));\n        var phase_shift = 16;\n        //const phase = System.Int64.clip32(fixedTime.shr(phase_shift).and(System.Int64((Blip.phase_count - 1))));\n        var phase = (fixedTime >> phase_shift & (Blip.phase_count - 1)) >>> 0;\n        var inStep = phase; // bl_step[phase];\n        var rev = Blip.phase_count - phase; // bl_step[phase_count - phase];\n        var interp_bits = 15;\n        var interp = (fixedTime >> (phase_shift - interp_bits) & ((1 << interp_bits) - 1));\n        var delta2 = (delta * interp) >> interp_bits;\n        delta -= delta2;\n        /* Fails if buffer size was exceeded */\n        //assert( out <= &BLIP_SAMPLES( s ) [s->size] );\n        for (var i = 0; i < 8; ++i) {\n            this.BlipBuffer.samples[outPtr + i] += (Blip.bl_step[inStep][i] * delta) + (Blip.bl_step[inStep][i] * delta2);\n            this.BlipBuffer.samples[outPtr + (15 - i)] += (Blip.bl_step[rev][i] * delta) + (Blip.bl_step[rev - 1][i] * delta2);\n        }\n    };\n    Blip.prototype.blip_add_delta_fast = function (time, delta) {\n        var fixedTime = time * this.BlipBuffer.factor + this.BlipBuffer.offset;\n        var outPtr = this.BlipBuffer.avail + (fixedTime >> Blip.time_bits);\n        var delta_unit = 1 << Blip.delta_bits;\n        var phase_shift = Blip.time_bits - Blip.delta_bits;\n        var phase = fixedTime >> phase_shift & (delta_unit - 1);\n        var delta2 = delta * phase;\n        /* Fails if buffer size was exceeded */\n        //assert( out <= &BLIP_SAMPLES( s ) [s->size] );\n        this.BlipBuffer.samples[outPtr + 8] += delta * delta_unit - delta2;\n        this.BlipBuffer.samples[outPtr + 9] += delta2;\n        //out [8] += delta * delta_unit - delta2;\n        //out [9] += delta2;\n    };\n    Blip.time_unit = 2097152;\n    Blip.buf_extra = 18;\n    Blip.phase_count = 32;\n    Blip.time_bits = 21;\n    Blip.delta_bits = 15;\n    //sinc values\n    Blip.bl_step = [[43, -115,\n            350,\n            -488,\n            1136,\n            -914,\n            5861,\n            21022\n        ], [\n            44,\n            -118,\n            348,\n            -473,\n            1076,\n            -799,\n            5274,\n            21001\n        ], [\n            45,\n            -121,\n            344,\n            -454,\n            1011,\n            -677,\n            4706,\n            20936\n        ], [\n            46,\n            -122,\n            336,\n            -431,\n            942,\n            -549,\n            4156,\n            20829\n        ], [\n            47,\n            -123,\n            327,\n            -404,\n            868,\n            -418,\n            3629,\n            20679\n        ], [\n            47,\n            -122,\n            316,\n            -375,\n            792,\n            -285,\n            3124,\n            20488\n        ], [\n            47,\n            -120,\n            303,\n            -344,\n            714,\n            -151,\n            2644,\n            20256\n        ], [\n            46,\n            -117,\n            289,\n            -310,\n            634,\n            -17,\n            2188,\n            19985\n        ], [\n            46,\n            -114,\n            273,\n            -275,\n            553,\n            117,\n            1758,\n            19675\n        ], [\n            44,\n            -108,\n            255,\n            -237,\n            471,\n            247,\n            1356,\n            19327\n        ], [\n            43,\n            -103,\n            237,\n            -199,\n            390,\n            373,\n            981,\n            18944\n        ], [\n            42,\n            -98,\n            218,\n            -160,\n            310,\n            495,\n            633,\n            18527\n        ], [\n            40,\n            -91,\n            198,\n            -121,\n            231,\n            611,\n            314,\n            18078\n        ], [\n            38,\n            -84,\n            178,\n            -81,\n            153,\n            722,\n            22,\n            17599\n        ], [\n            36,\n            -76,\n            157,\n            -43,\n            80,\n            824,\n            -241,\n            17092\n        ], [\n            34,\n            -68,\n            135,\n            -3,\n            8,\n            919,\n            -476,\n            16558\n        ], [\n            32,\n            -61,\n            115,\n            34,\n            -60,\n            1006,\n            -683,\n            16001\n        ], [\n            29,\n            -52,\n            94,\n            70,\n            -123,\n            1083,\n            -862,\n            15422\n        ], [\n            27,\n            -44,\n            73,\n            106,\n            -184,\n            1152,\n            -1015,\n            14824\n        ], [\n            25,\n            -36,\n            53,\n            139,\n            -239,\n            1211,\n            -1142,\n            14210\n        ], [\n            22,\n            -27,\n            34,\n            170,\n            -290,\n            1261,\n            -1244,\n            13582\n        ], [\n            20,\n            -20,\n            16,\n            199,\n            -335,\n            1301,\n            -1322,\n            12942\n        ], [\n            18,\n            -12,\n            -3,\n            226,\n            -375,\n            1331,\n            -1376,\n            12293\n        ], [\n            15,\n            -4,\n            -19,\n            250,\n            -410,\n            1351,\n            -1408,\n            11638\n        ], [\n            13,\n            3,\n            -35,\n            272,\n            -439,\n            1361,\n            -1419,\n            10979\n        ], [\n            11,\n            9,\n            -49,\n            292,\n            -464,\n            1362,\n            -1410,\n            10319\n        ], [\n            9,\n            16,\n            -63,\n            309,\n            -483,\n            1354,\n            -1383,\n            9660\n        ], [\n            7,\n            22,\n            -75,\n            322,\n            -496,\n            1337,\n            -1339,\n            9005\n        ], [\n            6,\n            26,\n            -85,\n            333,\n            -504,\n            1312,\n            -1280,\n            8355\n        ], [\n            4,\n            31,\n            -94,\n            341,\n            -507,\n            1278,\n            -1205,\n            7713\n        ], [\n            3,\n            35,\n            -102,\n            347,\n            -506,\n            1238,\n            -1119,\n            7082\n        ], [\n            1,\n            40,\n            -110,\n            350,\n            -499,\n            1190,\n            -1021,\n            6464\n        ], [\n            0,\n            43,\n            -115,\n            350,\n            -488,\n            1136,\n            -914,\n            5861\n        ]];\n    return Blip;\n}());\nvar PortWriteEntry = /** @class */ (function () {\n    function PortWriteEntry(time, address, data) {\n        this.time = time;\n        this.address = address;\n        this.data = data;\n    }\n    return PortWriteEntry;\n}());\nvar QueuedPort = /** @class */ (function () {\n    function QueuedPort() {\n        this.array = new Array();\n    }\n    Object.defineProperty(QueuedPort.prototype, \"Count\", {\n        get: function () {\n            return this.array.length;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    QueuedPort.prototype.clear = function () {\n        this.array.length = 0;\n    };\n    QueuedPort.prototype.enqueue = function (item) {\n        this.array.push(item);\n    };\n    QueuedPort.prototype.dequeue = function () {\n        return this.array.pop();\n    };\n    return QueuedPort;\n}());\nvar DMCChannel = /** @class */ (function () {\n    function DMCChannel(bleeper, chan) {\n    }\n    DMCChannel.prototype.WriteRegister = function (register, data, time) {\n        //throw new Error('Method not implemented.');\n    };\n    DMCChannel.prototype.Run = function (end_time) {\n        //throw new Error('Method not implemented.');\n    };\n    DMCChannel.prototype.UpdateAmplitude = function (new_amp) {\n        // throw new Error('Method not implemented.');\n    };\n    DMCChannel.prototype.EndFrame = function (time) {\n        //  throw new Error('Method not implemented.');\n    };\n    DMCChannel.prototype.FrameClock = function (time, step) {\n        //  throw new Error('Method not implemented.');\n    };\n    return DMCChannel;\n}());\nvar NoiseChannel = /** @class */ (function () {\n    function NoiseChannel(bleeper, chan) {\n        this._bleeper = null;\n        this._chan = 0;\n        this.NoisePeriods = [4, 8, 16, 32, 64, 96, 128, 160, 202, 254, 380, 508, 762, 1016, 2034, 4068];\n        this.LengthCounts = [10, 254, 20, 2, 40, 4, 80, 6, 160, 8, 60, 10, 14, 12, 26, 14, 12, 16, 24, 18, 48, 20, 96, 22, 192, 24, 72, 26, 16, 28, 32, 30];\n        this._length = 0;\n        this._period = 0;\n        this._volume = 0;\n        this._time = 0;\n        this._envConstantVolume = false;\n        this._envVolume = 0;\n        this._looping = false;\n        this._enabled = false;\n        this.amplitude = 0;\n        this._phase = 0;\n        this.gain = 0;\n        this._envTimer = 0;\n        this._envStart = false;\n        this._bleeper = bleeper;\n        this._chan = chan;\n        this._enabled = true;\n        this._phase = 1;\n        this._envTimer = 15;\n    }\n    Object.defineProperty(NoiseChannel.prototype, \"Period\", {\n        get: function () {\n            return this._period;\n        },\n        set: function (value) {\n            this._period = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NoiseChannel.prototype, \"Volume\", {\n        get: function () {\n            return this._volume;\n        },\n        set: function (value) {\n            this._volume = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NoiseChannel.prototype, \"Time\", {\n        get: function () {\n            return this._time;\n        },\n        set: function (value) {\n            this._time = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NoiseChannel.prototype, \"Looping\", {\n        get: function () {\n            return this._looping;\n        },\n        set: function (value) {\n            this._looping = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NoiseChannel.prototype, \"Enabled\", {\n        get: function () {\n            return this._enabled;\n        },\n        set: function (value) {\n            this._enabled = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NoiseChannel.prototype, \"Gain\", {\n        get: function () {\n            return this.gain;\n        },\n        set: function (value) {\n            this.gain = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    NoiseChannel.prototype.WriteRegister = function (register, data, time) {\n        // Run(time);\n        switch (register) {\n            case 0:\n                this._envConstantVolume = (data & 16) === 16;\n                this._volume = data & 15;\n                this._looping = (data & 128) === 128;\n                break;\n            case 1:\n                break;\n            case 2:\n                this._period = this.NoisePeriods[data & 15];\n                // _period |= data;\n                break;\n            case 3:\n                // setup length\n                if (this._enabled) {\n                    this._length = this.LengthCounts[(data >> 3) & 31];\n                }\n                this._envStart = true;\n                break;\n            case 4:\n                this._enabled = (data !== 0);\n                if (!this._enabled) {\n                    this._length = 0;\n                }\n                break;\n        }\n    };\n    NoiseChannel.prototype.Run = function (end_time) {\n        var volume = this._envConstantVolume ? this._volume : this._envVolume;\n        if (this._length === 0) {\n            volume = 0;\n        }\n        if (this._period === 0) {\n            this._time = end_time;\n            this.UpdateAmplitude(0);\n            return;\n        }\n        if (this._phase === 0) {\n            this._phase = 1;\n        }\n        for (; this._time < end_time; this._time += this._period) {\n            var new15;\n            if (this._looping) {\n                new15 = ((this._phase & 1) ^ ((this._phase >> 6) & 1));\n            }\n            else {\n                new15 = ((this._phase & 1) ^ ((this._phase >> 1) & 1));\n            }\n            this.UpdateAmplitude(this._phase & 1 * volume);\n            this._phase = ((this._phase >> 1) | (new15 << 14)) & 65535;\n        }\n    };\n    NoiseChannel.prototype.UpdateAmplitude = function (amp) {\n        var delta = amp * this.gain - this.amplitude;\n        this.amplitude += delta;\n        this._bleeper.blip_add_delta(this._time, delta);\n    };\n    NoiseChannel.prototype.EndFrame = function (time) {\n        this.Run(time);\n        this._time = 0;\n    };\n    NoiseChannel.prototype.FrameClock = function (time, step) {\n        this.Run(time);\n        if (!this._envStart) {\n            this._envTimer--;\n            if (this._envTimer === 0) {\n                this._envTimer = this._volume + 1;\n                if (this._envVolume > 0) {\n                    this._envVolume--;\n                }\n                else {\n                    this._envVolume = this._looping ? 15 : 0;\n                }\n            }\n        }\n        else {\n            this._envStart = false;\n            this._envTimer = this._volume + 1;\n            this._envVolume = 15;\n        }\n        switch (step) {\n            case 1:\n            case 2:\n                if (!this._looping && this._length > 0) {\n                    this._length--;\n                }\n                break;\n        }\n    };\n    return NoiseChannel;\n}());\nvar TriangleChannel = /** @class */ (function () {\n    function TriangleChannel(bleeper, chan) {\n        this._chan = 0;\n        this.LengthCounts = new Uint8Array([\n            0x0A, 0xFE,\n            0x14, 0x02,\n            0x28, 0x04,\n            0x50, 0x06,\n            0xA0, 0x08,\n            0x3C, 0x0A,\n            0x0E, 0x0C,\n            0x1A, 0x0E,\n            0x0C, 0x10,\n            0x18, 0x12,\n            0x30, 0x14,\n            0x60, 0x16,\n            0xC0, 0x18,\n            0x48, 0x1A,\n            0x10, 0x1C,\n            0x20, 0x1E\n        ]);\n        this._length = 0;\n        this._period = 0;\n        this._time = 0;\n        this._envelope = 0;\n        this._looping = false;\n        this._enabled = false;\n        this._amplitude = 0;\n        this._gain = 0;\n        this._linCtr = 0;\n        this._phase = 0;\n        this._linVal = 0;\n        this._linStart = false;\n        this._bleeper = bleeper;\n        this._chan = chan;\n        this._enabled = true;\n    }\n    Object.defineProperty(TriangleChannel.prototype, \"Period\", {\n        get: function () {\n            return this._period;\n        },\n        set: function (value) {\n            this._period = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(TriangleChannel.prototype, \"Time\", {\n        get: function () {\n            return this._time;\n        },\n        set: function (value) {\n            this._time = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(TriangleChannel.prototype, \"Envelope\", {\n        get: function () {\n            return this._envelope;\n        },\n        set: function (value) {\n            this._envelope = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(TriangleChannel.prototype, \"Looping\", {\n        get: function () {\n            return this._looping;\n        },\n        set: function (value) {\n            this._looping = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(TriangleChannel.prototype, \"Enabled\", {\n        get: function () {\n            return this._enabled;\n        },\n        set: function (value) {\n            this._enabled = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(TriangleChannel.prototype, \"Gain\", {\n        get: function () {\n            return this._gain;\n        },\n        set: function (value) {\n            this._gain = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(TriangleChannel.prototype, \"Amplitude\", {\n        get: function () {\n            return this._amplitude;\n        },\n        set: function (value) {\n            this._amplitude = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(TriangleChannel.prototype, \"Length\", {\n        get: function () {\n            return this._length;\n        },\n        set: function (value) {\n            this._length = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    TriangleChannel.prototype.WriteRegister = function (register, data, time) {\n        //Run(time);\n        switch (register) {\n            case 0:\n                this._looping = (data & 0x80) === 0x80;\n                this._linVal = data & 0x7F;\n                break;\n            case 1:\n                break;\n            case 2:\n                this._period &= 0x700;\n                this._period |= data;\n                break;\n            case 3:\n                this._period &= 0xFF;\n                this._period |= (data & 7) << 8;\n                // setup lengthhave\n                if (this._enabled) {\n                    this._length = this.LengthCounts[(data >> 3) & 0x1f];\n                }\n                this._linStart = true;\n                break;\n            case 4:\n                this._enabled = (data !== 0);\n                if (!this._enabled) {\n                    this._length = 0;\n                }\n                break;\n        }\n    };\n    TriangleChannel.prototype.Run = function (end_time) {\n        var period = this._period + 1;\n        if (this._linCtr === 0 || this._length === 0 || this._period < 4) {\n            // leave it at it's current phase\n            this._time = end_time;\n            return;\n        }\n        for (; this._time < end_time; this._time += period, this._phase = (this._phase + 1) % 32) {\n            this.UpdateAmplitude(this._phase < 16 ? this._phase : 31 - this._phase);\n        }\n    };\n    TriangleChannel.prototype.UpdateAmplitude = function (new_amp) {\n        var delta = new_amp * this._gain - this._amplitude;\n        this._amplitude += delta;\n        this._bleeper.blip_add_delta(this._time, delta);\n    };\n    TriangleChannel.prototype.EndFrame = function (time) {\n        this.Run(time);\n        this._time = 0;\n    };\n    TriangleChannel.prototype.FrameClock = function (time, step) {\n        this.Run(time);\n        if (this._linStart) {\n            this._linCtr = this._linVal;\n        }\n        else {\n            if (this._linCtr > 0) {\n                this._linCtr--;\n            }\n        }\n        if (!this._looping) {\n            this._linStart = false;\n        }\n        switch (step) {\n            case 1:\n            case 3:\n                if (this._length > 0 && !this._looping) {\n                    this._length--;\n                }\n                break;\n        }\n    };\n    return TriangleChannel;\n}());\nvar SquareChannel = /** @class */ (function () {\n    function SquareChannel(bleeper, chan) {\n        this._chan = 0;\n        this._bleeper = null;\n        this.LengthCounts = new Uint8Array([\n            0x0A, 0xFE,\n            0x14, 0x02,\n            0x28, 0x04,\n            0x50, 0x06,\n            0xA0, 0x08,\n            0x3C, 0x0A,\n            0x0E, 0x0C,\n            0x1A, 0x0E,\n            0x0C, 0x10,\n            0x18, 0x12,\n            0x30, 0x14,\n            0x60, 0x16,\n            0xC0, 0x18,\n            0x48, 0x1A,\n            0x10, 0x1C,\n            0x20, 0x1E\n        ]);\n        this._dutyCycle = 0;\n        this._length = 0;\n        this._timer = 0;\n        this._rawTimer = 0;\n        this._volume = 0;\n        this._time = 0;\n        this._envelope = 0;\n        this._looping = false;\n        this._enabled = false;\n        this._amplitude = 0;\n        this.doodies = [2, 6, 30, 249];\n        this._sweepShift = 0;\n        this._sweepCounter = 0;\n        this._sweepDivider = 0;\n        this._sweepNegateFlag = false;\n        this._sweepEnabled = false;\n        this._startSweep = false;\n        this._sweepInvalid = false;\n        this._phase = 0;\n        this._gain = 0;\n        this._envTimer = 0;\n        this._envStart = false;\n        this._envConstantVolume = false;\n        this._envVolume = 0;\n        this._sweepComplement = false;\n        this._bleeper = bleeper;\n        this._chan = chan;\n        this._enabled = true;\n        this._sweepDivider = 1;\n        this._envTimer = 15;\n    }\n    Object.defineProperty(SquareChannel.prototype, \"DutyCycle\", {\n        // properties\n        get: function () {\n            return this._dutyCycle;\n        },\n        set: function (value) {\n            this._dutyCycle = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SquareChannel.prototype, \"Period\", {\n        get: function () {\n            return this._timer;\n        },\n        set: function (value) {\n            this._timer = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SquareChannel.prototype, \"Volume\", {\n        get: function () {\n            return this._volume;\n        },\n        set: function (value) {\n            this._volume = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SquareChannel.prototype, \"Time\", {\n        get: function () {\n            return this._time;\n        },\n        set: function (value) {\n            this._time = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SquareChannel.prototype, \"Envelope\", {\n        get: function () {\n            return this._envelope;\n        },\n        set: function (value) {\n            this._envelope = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SquareChannel.prototype, \"Looping\", {\n        get: function () {\n            return this._looping;\n        },\n        set: function (value) {\n            this._looping = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SquareChannel.prototype, \"Enabled\", {\n        get: function () {\n            return this._enabled;\n        },\n        set: function (value) {\n            this._enabled = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SquareChannel.prototype, \"Gain\", {\n        get: function () {\n            return this._gain;\n        },\n        set: function (value) {\n            this._gain = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SquareChannel.prototype, \"SweepComplement\", {\n        get: function () {\n            return this._sweepComplement;\n        },\n        set: function (value) {\n            this._sweepComplement = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    // functions\n    SquareChannel.prototype.WriteRegister = function (register, data, time) {\n        switch (register) {\n            case 0:\n                this._envConstantVolume = (data & 0x10) === 0x10;\n                this._volume = data & 15;\n                this._dutyCycle = this.doodies[(data >> 6) & 0x3];\n                this._looping = (data & 0x20) === 0x20;\n                this._sweepInvalid = false;\n                break;\n            case 1:\n                this._sweepShift = data & 7;\n                this._sweepNegateFlag = (data & 8) === 8;\n                this._sweepDivider = (data >> 4) & 7;\n                this._sweepEnabled = (data & 0x80) === 0x80;\n                this._startSweep = true;\n                this._sweepInvalid = false;\n                break;\n            case 2:\n                this._timer &= 0x700;\n                this._timer |= data;\n                this._rawTimer = this._timer;\n                break;\n            case 3:\n                this._timer &= 0xFF;\n                this._timer |= (data & 7) << 8;\n                this._rawTimer = this._timer;\n                this._phase = 0;\n                // setup length\n                if (this._enabled) {\n                    this._length = this.LengthCounts[(data >> 3) & 0x1f];\n                }\n                this._envStart = true;\n                break;\n            case 4:\n                this._enabled = (data !== 0);\n                if (!this._enabled) {\n                    this._length = 0;\n                }\n                break;\n        }\n    };\n    SquareChannel.prototype.Run = function (end_time) {\n        var period = this._sweepEnabled ? ((this._timer + 1) & 0x7FF) << 1 : ((this._rawTimer + 1) & 0x7FF) << 1;\n        if (period === 0) {\n            this._time = end_time;\n            this.UpdateAmplitude(0);\n            return;\n        }\n        var volume = this._envConstantVolume ? this._volume : this._envVolume;\n        if (this._length === 0 || volume === 0 || this._sweepInvalid) {\n            this._phase += ((end_time - this._time) / period) & 7;\n            this._time = end_time;\n            this.UpdateAmplitude(0);\n            return;\n        }\n        for (; this._time < end_time; this._time += period, this._phase++) {\n            this.UpdateAmplitude((this._dutyCycle >> (this._phase & 7) & 1) * volume);\n        }\n        this._phase &= 7;\n    };\n    SquareChannel.prototype.UpdateAmplitude = function (new_amp) {\n        var delta = new_amp * this._gain - this._amplitude;\n        this._amplitude += delta;\n        this._bleeper.blip_add_delta(this._time, delta);\n    };\n    SquareChannel.prototype.EndFrame = function (time) {\n        this.Run(time);\n        this._time = 0;\n    };\n    SquareChannel.prototype.FrameClock = function (time, step) {\n        this.Run(time);\n        if (!this._envStart) {\n            this._envTimer--;\n            if (this._envTimer === 0) {\n                this._envTimer = this._volume + 1;\n                if (this._envVolume > 0) {\n                    this._envVolume--;\n                }\n                else {\n                    this._envVolume = this._looping ? 15 : 0;\n                }\n            }\n        }\n        else {\n            this._envStart = false;\n            this._envTimer = this._volume + 1;\n            this._envVolume = 15;\n        }\n        switch (step) {\n            case 1:\n            case 3:\n                --this._sweepCounter;\n                if (this._sweepCounter === 0) {\n                    this._sweepCounter = this._sweepDivider + 1;\n                    if (this._sweepEnabled && this._sweepShift > 0) {\n                        var sweep = this._timer >> this._sweepShift;\n                        if (this._sweepComplement) {\n                            this._timer += this._sweepNegateFlag ? ~sweep : sweep;\n                        }\n                        else {\n                            this._timer += this._sweepNegateFlag ? ~sweep + 1 : sweep;\n                        }\n                        this._sweepInvalid = (this._rawTimer < 8 || (this._timer & 2048) === 2048);\n                        //if (_sweepInvalid)\n                        //{\n                        //    _sweepInvalid = true;\n                        //}\n                    }\n                }\n                if (this._startSweep) {\n                    this._startSweep = false;\n                    this._sweepCounter = this._sweepDivider + 1;\n                }\n                if (!this._looping && this._length > 0) {\n                    this._length--;\n                }\n                break;\n        }\n    };\n    return SquareChannel;\n}());\nvar ChiChiBopper = /** @class */ (function () {\n    function ChiChiBopper(writer) {\n        this.writer = writer;\n        this.throwingIRQs = false;\n        this.reg15 = 0;\n        this.master_vol = 4369;\n        this.registers = new QueuedPort();\n        this._sampleRate = 44100;\n        this.square0Gain = 873;\n        this.square1Gain = 873;\n        this.triangleGain = 1004;\n        this.noiseGain = 567;\n        this.muted = false;\n        this.lastFrameHit = 0;\n        this.RebuildSound();\n    }\n    Object.defineProperty(ChiChiBopper.prototype, \"audioSettings\", {\n        get: function () {\n            var settings = new ChiChiTypes_1.AudioSettings();\n            settings.sampleRate = this._sampleRate;\n            settings.enableNoise = this.EnableNoise;\n            settings.enableSquare0 = this.EnableSquare0;\n            settings.enableSquare1 = this.EnableSquare1;\n            settings.enableTriangle = this.enableTriangle;\n            return settings;\n        },\n        set: function (value) {\n            this.EnableNoise = value.enableNoise;\n            this.EnableSquare0 = value.enableSquare0;\n            this.EnableSquare1 = value.enableSquare1;\n            this.enableTriangle = value.enableTriangle;\n            if (value.sampleRate != this._sampleRate) {\n                this._sampleRate = value.sampleRate;\n                this.RebuildSound();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ChiChiBopper.prototype, \"SampleRate\", {\n        get: function () {\n            return this._sampleRate;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ChiChiBopper.prototype, \"sampleRate\", {\n        set: function (value) {\n            this._sampleRate = value;\n            this.RebuildSound();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ChiChiBopper.prototype, \"EnableSquare0\", {\n        get: function () {\n            return this.square0.Gain > 0;\n        },\n        set: function (value) {\n            this.square0.Gain = value ? this.square0Gain : 0;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ChiChiBopper.prototype, \"EnableSquare1\", {\n        get: function () {\n            return this.square1.Gain > 0;\n        },\n        set: function (value) {\n            this.square1.Gain = value ? this.square1Gain : 0;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ChiChiBopper.prototype, \"enableTriangle\", {\n        get: function () {\n            return this.triangle.Gain > 0;\n        },\n        set: function (value) {\n            this.triangle.Gain = value ? this.triangleGain : 0;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ChiChiBopper.prototype, \"EnableNoise\", {\n        get: function () {\n            return this.noise.Gain > 0;\n        },\n        set: function (value) {\n            this.noise.Gain = value ? this.noiseGain : 0;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ChiChiBopper.prototype.RebuildSound = function () {\n        this.myBlipper = new Blip(this._sampleRate / 5);\n        this.myBlipper.blip_set_rates(ChiChiBopper.clock_rate, this._sampleRate);\n        //this.writer = new ChiChiNES.BeepsBoops.WavSharer();\n        //this.writer.\n        this.registers.clear();\n        this.InterruptRaised = false;\n        this.square0Gain = 873;\n        this.square1Gain = 873;\n        this.triangleGain = 1004;\n        this.noiseGain = 567;\n        this.square0 = new SquareChannel(this.myBlipper, 0);\n        this.square0.Gain = this.square0Gain;\n        this.square0.Period = 10;\n        this.square0.SweepComplement = true;\n        this.square1 = new SquareChannel(this.myBlipper, 0);\n        this.square1.Gain = this.square1Gain;\n        this.square1.Period = 10;\n        this.square1.SweepComplement = false;\n        this.triangle = new TriangleChannel(this.myBlipper, 2);\n        this.triangle.Gain = this.triangleGain;\n        this.triangle.Period = 0;\n        this.noise = new NoiseChannel(this.myBlipper, 3);\n        this.noise.Gain = this.noiseGain;\n        this.noise.Period = 0;\n        this.dmc = new DMCChannel(this.myBlipper, 4);\n        this.dmc.Gain = 873;\n        this.dmc.Period = 10;\n    };\n    ChiChiBopper.prototype.GetByte = function (Clock, address) {\n        if (address === 16384) {\n            this.InterruptRaised = false;\n        }\n        if (address === 16405) {\n            return this.ReadStatus();\n        }\n        else {\n            return 66;\n        }\n    };\n    ChiChiBopper.prototype.ReadStatus = function () {\n        return ((this.square0.Length > 0) ? 1 : 0) | ((this.square1.Length > 0) ? 2 : 0) | ((this.triangle.Length > 0) ? 4 : 0) | ((this.square0.Length > 0) ? 8 : 0) | (this.InterruptRaised ? 64 : 0);\n    };\n    ChiChiBopper.prototype.SetByte = function (Clock, address, data) {\n        if (address === 16384) {\n            this.InterruptRaised = false;\n        }\n        this.DoSetByte(Clock, address, data);\n        this.registers.enqueue(new PortWriteEntry(Clock, address, data));\n    };\n    ChiChiBopper.prototype.DoSetByte = function (Clock, address, data) {\n        switch (address) {\n            case 16384:\n            case 16385:\n            case 16386:\n            case 16387:\n                this.square0.WriteRegister(address - 16384, data, Clock);\n                break;\n            case 16388:\n            case 16389:\n            case 16390:\n            case 16391:\n                this.square1.WriteRegister(address - 16388, data, Clock);\n                break;\n            case 16392:\n            case 16393:\n            case 16394:\n            case 16395:\n                this.triangle.WriteRegister(address - 16392, data, Clock);\n                break;\n            case 16396:\n            case 16397:\n            case 16398:\n            case 16399:\n                this.noise.WriteRegister(address - 16396, data, Clock);\n                break;\n            case 16400:\n            case 16401:\n            case 16402:\n            case 16403:\n                // dmc.WriteRegister(address - 0x40010, data, Clock);\n                break;\n            case 16405:\n                this.reg15 = data;\n                this.square0.WriteRegister(4, data & 1, Clock);\n                this.square1.WriteRegister(4, data & 2, Clock);\n                this.triangle.WriteRegister(4, data & 4, Clock);\n                this.noise.WriteRegister(4, data & 8, Clock);\n                break;\n            case 16407:\n                this.throwingIRQs = ((data & 64) !== 64);\n                this.lastFrameHit = 0;\n                break;\n        }\n    };\n    ChiChiBopper.prototype.UpdateFrame = function (time) {\n        if (this.muted) {\n            return;\n        }\n        this.RunFrameEvents(time, this.lastFrameHit);\n        if (this.lastFrameHit === 3) {\n            if (this.throwingIRQs) {\n                this.InterruptRaised = true;\n            }\n            this.lastFrameHit = 0;\n            //EndFrame(time);\n        }\n        else {\n            this.lastFrameHit++;\n        }\n    };\n    ChiChiBopper.prototype.RunFrameEvents = function (time, step) {\n        this.triangle.FrameClock(time, step);\n        this.noise.FrameClock(time, step);\n        this.square0.FrameClock(time, step);\n        this.square1.FrameClock(time, step);\n    };\n    ChiChiBopper.prototype.EndFrame = function (time) {\n        this.square0.EndFrame(time);\n        this.square1.EndFrame(time);\n        this.triangle.EndFrame(time);\n        this.noise.EndFrame(time);\n        if (!this.muted) {\n            this.myBlipper.blip_end_frame(time);\n        }\n        //var count = this.myBlipper.ReadBytes(this.writer.SharedBuffer, this.writer.SharedBuffer.length / 2, 0);\n        // const startPos = this.writer.sharedAudioBufferPos;\n        this.myBlipper.ReadElementsLoop(this.writer);\n        //this.writer.audioBytesWritten += count;\n        //this.writer.sharedAudioBufferPos += count;\n        //this.writer.WavesWritten(count);\n    };\n    ChiChiBopper.prototype.FlushFrame = function (time) {\n        var currentClock = 0;\n        var frameClocker = 0;\n        var currentEntry;\n        while (this.registers.Count > 0) {\n            currentEntry = this.registers.dequeue();\n            if (frameClocker > 7445) {\n                frameClocker -= 7445;\n                this.UpdateFrame(7445);\n            }\n            this.DoSetByte(currentEntry.time, currentEntry.address, currentEntry.data);\n            currentClock = currentEntry.time;\n            frameClocker = currentEntry.time;\n        }\n        // hit the latest frame boundary, maybe too much math for too little reward\n        var clockDelta = currentClock % 7445;\n        if (this.lastFrameHit === 0) {\n            this.UpdateFrame(7445);\n        }\n        while (this.lastFrameHit > 0) {\n            this.UpdateFrame(7445 * (this.lastFrameHit + 1));\n        }\n    };\n    ChiChiBopper.prototype.HandleEvent = function (Clock) {\n        this.UpdateFrame(Clock);\n        this.lastClock = Clock;\n        if (Clock > 29780) {\n            this.writer;\n            {\n                this.EndFrame(Clock);\n            }\n        }\n    };\n    ChiChiBopper.prototype.ResetClock = function (Clock) {\n        this.lastClock = Clock;\n    };\n    ChiChiBopper.clock_rate = 1789772.727;\n    return ChiChiBopper;\n}());\nexports.ChiChiBopper = ChiChiBopper;\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//input classes\nvar ChiChiInputHandler = /** @class */ (function () {\n    function ChiChiInputHandler() {\n        this.ControlPad = new ChiChiControlPad();\n    }\n    ChiChiInputHandler.prototype.controlPad_NextControlByteSet = function (sender, e) {\n        // throw new Error(\"Method not implemented.\");\n    };\n    ChiChiInputHandler.prototype.GetByte = function (clock, address) {\n        return this.ControlPad.getByte(clock);\n    };\n    ChiChiInputHandler.prototype.SetByte = function (clock, address, data) {\n        return this.ControlPad.setByte(clock, data);\n    };\n    ChiChiInputHandler.prototype.SetNextControlByte = function (data) {\n    };\n    ChiChiInputHandler.prototype.HandleEvent = function (Clock) {\n    };\n    ChiChiInputHandler.prototype.ResetClock = function (Clock) {\n    };\n    return ChiChiInputHandler;\n}());\nexports.ChiChiInputHandler = ChiChiInputHandler;\nvar ChiChiControlPad = /** @class */ (function () {\n    function ChiChiControlPad() {\n        this.currentByte = 0;\n        this.readNumber = 0;\n        this.padOneState = 0;\n        this.CurrentByte = 0;\n    }\n    ChiChiControlPad.prototype.refresh = function () {\n    };\n    ChiChiControlPad.prototype.getByte = function (clock) {\n        var result = (this.currentByte >> this.readNumber) & 0x01;\n        this.readNumber = (this.readNumber + 1) & 7;\n        return (result | 0x40) & 0xFF;\n    };\n    ChiChiControlPad.prototype.setByte = function (clock, data) {\n        if ((data & 1) == 1) {\n            this.currentByte = this.padOneState;\n            // if im pushing up, i cant be pushing down\n            if ((this.currentByte & 16) == 16)\n                this.currentByte = this.currentByte & ~32;\n            // if im pushign left, i cant be pushing right.. seriously, the nes will glitch\n            if ((this.currentByte & 64) == 64)\n                this.currentByte = this.currentByte & ~128;\n            this.readNumber = 0;\n        }\n    };\n    return ChiChiControlPad;\n}());\nexports.ChiChiControlPad = ChiChiControlPad;\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ChiChiMachine_1 = __webpack_require__(2);\nexports.ChiChiCPPU = ChiChiMachine_1.ChiChiCPPU;\nexports.ChiChiMachine = ChiChiMachine_1.ChiChiMachine;\nvar ChiChiNsfMachine_1 = __webpack_require__(7);\nexports.ChiChiNsfCPPU = ChiChiNsfMachine_1.ChiChiNsfCPPU;\nexports.ChiChiNsfMachine = ChiChiNsfMachine_1.ChiChiNsfMachine;\nvar ChiChiCarts_1 = __webpack_require__(3);\nexports.BaseCart = ChiChiCarts_1.BaseCart;\nexports.NesCart = ChiChiCarts_1.NesCart;\nexports.AxROMCart = ChiChiCarts_1.AxROMCart;\nexports.NsfCart = ChiChiCarts_1.NsfCart;\nexports.MMC1Cart = ChiChiCarts_1.MMC1Cart;\nexports.MMC3Cart = ChiChiCarts_1.MMC3Cart;\nexports.iNESFileHandler = ChiChiCarts_1.iNESFileHandler;\nvar ChiChiControl_1 = __webpack_require__(5);\nexports.ChiChiInputHandler = ChiChiControl_1.ChiChiInputHandler;\nvar ChiChiAudio_1 = __webpack_require__(4);\nexports.WavSharer = ChiChiAudio_1.WavSharer;\nexports.ChiChiBopper = ChiChiAudio_1.ChiChiBopper;\nvar ChiChiPPU_1 = __webpack_require__(1);\nexports.ChiChiPPU = ChiChiPPU_1.ChiChiPPU;\nvar ChiChiTypes_1 = __webpack_require__(0);\nexports.RunningStatuses = ChiChiTypes_1.RunningStatuses;\nexports.ChiChiCPPU_AddressingModes = ChiChiTypes_1.ChiChiCPPU_AddressingModes;\nexports.CpuStatus = ChiChiTypes_1.CpuStatus;\nexports.PpuStatus = ChiChiTypes_1.PpuStatus;\nexports.ChiChiInstruction = ChiChiTypes_1.ChiChiInstruction;\nexports.ChiChiSprite = ChiChiTypes_1.ChiChiSprite;\nexports.AudioSettings = ChiChiTypes_1.AudioSettings;\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ChiChiMachine_1 = __webpack_require__(2);\nvar ChiChiPPU_1 = __webpack_require__(1);\nvar ChiChiNsfMachine = /** @class */ (function (_super) {\n    __extends(ChiChiNsfMachine, _super);\n    function ChiChiNsfMachine() {\n        var _this = _super.call(this) || this;\n        _this.ppu = new ChiChiPPU_1.ChiChiPPU();\n        _this.Cpu = new ChiChiNsfCPPU(_this.SoundBopper, _this.ppu);\n        _this.Cpu.ppu = _this.ppu;\n        _this.Cpu.frameFinished = function () { _this.FrameFinished(); };\n        return _this;\n    }\n    ChiChiNsfMachine.prototype.LoadNsf = function (rom) {\n        this.Cpu.LoadNsf(rom);\n    };\n    return ChiChiNsfMachine;\n}(ChiChiMachine_1.ChiChiMachine));\nexports.ChiChiNsfMachine = ChiChiNsfMachine;\nvar ChiChiNsfCPPU = /** @class */ (function (_super) {\n    __extends(ChiChiNsfCPPU, _super);\n    function ChiChiNsfCPPU() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.runNsfAt = 0;\n        _this.loadNsfAt = 0;\n        _this.initNsfAt = 0;\n        _this.firstSong = 0;\n        _this.songCount = 0;\n        return _this;\n    }\n    ChiChiNsfCPPU.prototype.__SetByte = function (address, data) {\n        var bank = 0;\n        this.Rams[address] = data;\n    };\n    ChiChiNsfCPPU.prototype.GetByte = function (address) {\n        return this.Rams[address];\n    };\n    ChiChiNsfCPPU.prototype.LoadNsf = function (nsfFile) {\n        var header = nsfFile.slice(0, 16);\n        var ramsBuffer = new SharedArrayBuffer(0x10000 * Uint8Array.BYTES_PER_ELEMENT);\n        this.Rams = new Uint8Array(ramsBuffer); // System.Array.init(vv, 0, System.Int32);\n        this.Rams.fill(0);\n        //        $000    5   STRING  'N', 'E', 'S', 'M', $1A(denotes an NES sound format file)\n        //        $005    1   BYTE    Version number (currently $01)\n        //        $006    1   BYTE    Total songs   (1 = 1 song, 2 = 2 songs, etc)\n        //        $007    1   BYTE    Starting song (1 = 1st song, 2 = 2nd song, etc)\n        //        $008    2   WORD    (lo, hi) load address of data ($8000 - FFFF)\n        //        $00A    2   WORD    (lo, hi) init address of data ($8000 - FFFF)\n        //        $00C    2   WORD    (lo, hi) play address of data ($8000 - FFFF)\n        //        $00E    32  STRING  The name of the song, null terminated\n        //        $02E    32  STRING  The artist, if known, null terminated\n        //        $04E    32  STRING  The copyright holder, null terminated\n        //        $06E    2   WORD    (lo, hi) Play speed, in 1 / 1000000th sec ticks, NTSC(see text)\n        //        $070    8   BYTE    Bankswitch init values (see text, and FDS section)\n        //        $078    2   WORD    (lo, hi) Play speed, in 1 / 1000000th sec ticks, PAL(see text)\n        //        $07A    1   BYTE    PAL/ NTSC bits\n        //        bit 0: if clear, this is an NTSC tune\n        //        bit 0: if set, this is a PAL tune\n        //        bit 1: if set, this is a dual PAL/ NTSC tune\n        //        bits 2- 7: not used.they * must * be 0\n        //        $07B    1   BYTE    Extra Sound Chip Support\n        //        bit 0: if set, this song uses VRC6 audio\n        //        bit 1: if set, this song uses VRC7 audio\n        //        bit 2: if set, this song uses FDS audio\n        //        bit 3: if set, this song uses MMC5 audio\n        //        bit 4: if set, this song uses Namco 163 audio\n        //        bit 5: if set, this song uses Sunsoft 5B audio\n        //        bits 6, 7: future expansion: they * must * be 0\n        //        $07C    1   BYTE    Extra Sound Chip Support (Cont.)\n        //        bits 0- 3: future expansion: they * must * be 0\n        //        bits 4- 7: unavailable(conflicts with NSF2 backwards compatibility)\n        //        $07D    3   ----    3 extra bytes for expansion (must be $00)\n        //        $080    nnn ----    The music program/ data follows until end of file\n        this.songCount = header[0x06];\n        this.firstSong = header[0x07];\n        this.loadNsfAt = (header[0x09] << 8) + header[0x08];\n        this.initNsfAt = (header[0x0B] << 8) + header[0x0A];\n        this.runNsfAt = (header[0x0D] << 8) + header[0x0C];\n        this.songName = header.slice(0x0E, 0x0e + 32).map(function (v) { return String.fromCharCode(v); }).join('').trim();\n        this.artist = header.slice(0x02E, 0x0e + 32).map(function (v) { return String.fromCharCode(v); }).join('').trim();\n        this.copyright = header.slice(0x4E, 0x0e + 32).map(function (v) { return String.fromCharCode(v); }).join('').trim();\n        var address = this.loadNsfAt;\n        nsfFile = nsfFile.slice(16, nsfFile.length);\n        for (var i = 0; i < nsfFile.length - 0x80; ++i) {\n            this.__SetByte(address + i, nsfFile[0x80 + i]);\n        }\n        this.InitNsf();\n    };\n    ChiChiNsfCPPU.prototype.InitNsf = function () {\n        this.SetByte(0x4017, 0x40);\n        this._accumulator = this.firstSong;\n        this._indexRegisterX = 0;\n        this._programCounter = this.initNsfAt;\n        debugger;\n        while (this._programCounter != this.runNsfAt) {\n            this.Step();\n        }\n        console.log(\"ready to play\");\n    };\n    return ChiChiNsfCPPU;\n}(ChiChiMachine_1.ChiChiCPPU));\nexports.ChiChiNsfCPPU = ChiChiNsfCPPU;\n\n\n/***/ })\n/******/ ]);\n\n\n//////////////////\n// WEBPACK FOOTER\n// /home/jhartrick/projects/cc/chichines/chichilib/chichi.js\n// module id = 1\n// module chunks = 0"],"sourceRoot":""}