import { ChiChiCPPU_AddressingModes, ChiChiInstruction } from "./ChiChiTypes";
import { ChiChiInputHandler } from "./ChiChiControl";
import { ChiChiPPU } from "./ChiChiPPU";
import { ChiChiAPU } from "./ChiChiAudio";
import { BaseCart } from '../chichicarts/BaseCart';
import { MemoryPatch } from "./ChiChiCheats";
import { MemoryMap } from "./MemoryMaps/ChiChiMemoryMap";
import { StateBuffer } from "./StateBuffer";
export declare class ChiChiCPPU {
    clock: number;
    private advanceClock(value);
    borrowedCycles: number;
    cpuStatus16: Uint16Array;
    programCounter: number;
    addressBus: number;
    handleNMI: boolean;
    cpuStatus: Uint8Array;
    stackPointer: number;
    statusRegister: number;
    accumulator: number;
    indexRegisterX: number;
    indexRegisterY: number;
    dataBus: number;
    _operationCounter: number;
    _currentInstruction_AddressingMode: ChiChiCPPU_AddressingModes;
    _currentInstruction_Address: number;
    _currentInstruction_OpCode: number;
    _currentInstruction_Parameters0: number;
    _currentInstruction_Parameters1: number;
    _currentInstruction_ExtraTiming: number;
    systemClock: number;
    private instructionUsage;
    private debugging;
    cheating: boolean;
    genieCodes: MemoryPatch[];
    cheat(address: number, result: number): number;
    instructionHistoryPointer: number;
    _instructionHistory: ChiChiInstruction[];
    readonly InstructionHistory: Array<any>;
    readonly InstructionHistoryPointer: number;
    PadOne: ChiChiInputHandler;
    PadTwo: ChiChiInputHandler;
    ppu: ChiChiPPU;
    SoundBopper: ChiChiAPU;
    Cart: BaseCart;
    constructor(bopper: ChiChiAPU, ppu: ChiChiPPU);
    memoryMap: MemoryMap;
    Clock: number;
    setFlag(Flag: number, value: boolean): void;
    GetFlag(flag: number): boolean;
    interruptRequest(): void;
    nonMaskableInterrupt(): void;
    step(): void;
    fetchInstructionParameters(): any;
    ResetCPU(): void;
    PowerOn(): void;
    decodeAddress(): number;
    handleBadOperation(): void;
    handleBreakpoint(): void;
    decodeOperand(): number;
    execute(): void;
    setZNFlags(data: number): void;
    compare(data: number): void;
    branch(): void;
    nmiHandler(): void;
    private pushStack(data);
    private popStack();
    getByte(address: number): number;
    setByte(address: number, data: number): void;
    HandleNextEvent(): void;
    ResetInstructionHistory(): void;
    setupStateBuffer: (sb: StateBuffer) => StateBuffer;
}
